xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Sep 15, 2022 21:39 (UTC+01) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: BaseX.ebnf -xquery -ll 2 -backtrack -name XQuery :)

(:~
 : The parser that was generated for the XQuery grammar.
 :)
module namespace p="XQuery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 11;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 12;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  70, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 40, 41,
  42, 43, 44, 45, 46, 47, 48, 49, 30, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 38,
  38
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 355, 371,
  387, 423, 423, 423, 415, 339, 331, 339, 331, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 440, 440, 440, 440, 440, 440, 440, 324, 339, 339, 339, 339, 339, 339, 339, 339, 401, 423, 423, 424, 422,
  423, 423, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 338, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 70, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 38, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
  30, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  38, 38, 38, 30, 30, 38, 38, 38, 38, 38, 38, 38, 69, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 38, 30, 38, 30, 30, 38
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 94212, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
  207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
  230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 18176, 18192, 18216, 18216, 18216, 18214, 18216, 18216, 18216, 18218, 18234, 18216, 18216, 18198, 18216, 18245,
  18261, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548,
  24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458,
  20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537,
  18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824,
  21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786,
  20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161,
  19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300,
  19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430,
  19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 31431, 19711, 19725, 19826,
  19773, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 26234, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521,
  19548, 18744, 42147, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434,
  18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465,
  18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120,
  18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521,
  19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989,
  19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316,
  19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514,
  19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19668, 19802, 19826, 19826, 19826, 19823, 19826, 19826, 19843, 19863, 19690, 19825, 19826, 19826,
  28289, 19879, 42027, 19826, 19826, 19807, 19826, 19826, 31277, 19908, 42553, 18563, 19826, 19826, 19826, 18557, 25371,
  18521, 19548, 24485, 19554, 19925, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407,
  18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005,
  42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760,
  21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983,
  18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136,
  32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295,
  19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498,
  19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19941, 20490, 19826, 19826, 19826, 19979, 19826, 19826, 20491, 41231, 19690, 20000, 20035,
  20049, 20070, 20089, 36165, 19826, 19826, 19807, 20118, 19826, 31277, 20135, 42553, 18563, 19826, 19826, 19826, 18557,
  25371, 18521, 19548, 24485, 19554, 20153, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371,
  18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747,
  22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 20169, 18682, 18702, 18722, 42520, 18741, 18663,
  18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961,
  18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639,
  19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551,
  19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494,
  19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19668, 20812, 19826, 19826, 19826, 20185, 19826, 19826, 20813, 42493, 19690, 19826,
  24696, 20209, 20228, 20242, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826,
  18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355,
  18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826,
  34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741,
  18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939,
  18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100,
  18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536,
  18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401,
  19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826, 20284, 19826, 19826, 19826, 20290, 20306,
  24825, 19826, 19826, 32128, 20327, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826,
  19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339,
  18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826,
  19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520,
  18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917,
  18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082,
  19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272,
  30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476,
  19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 21871,
  30821, 19826, 19826, 19826, 19826, 38269, 41888, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826,
  19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582,
  18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 20365, 20380, 18504, 23628, 18520, 18663, 29470, 19826,
  19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722,
  42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989,
  18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116,
  19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661,
  19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478,
  19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 20396, 19826, 19826, 19826, 20417, 19826, 19826, 23546,
  20436, 19690, 20419, 19826, 19826, 33845, 20452, 40206, 19826, 19826, 19807, 19826, 19826, 31277, 20507, 42553, 18563,
  19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 24134, 18295, 18314, 26681, 19826, 19826, 42581, 19826,
  39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470,
  19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702,
  18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967,
  18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637,
  19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145,
  31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462,
  19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 20528, 20572, 20572, 20572, 20555, 20572, 20572,
  20539, 20588, 20567, 20610, 20604, 20626, 20666, 20680, 36165, 19826, 19826, 39227, 19826, 19826, 31277, 19826, 42553,
  18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26847, 19826, 19826, 42581,
  19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663,
  29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682,
  18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945,
  18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098,
  18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224,
  19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446,
  19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 21199, 19826, 19826, 19826, 20709, 19826,
  19826, 21011, 41231, 20721, 20755, 20765, 20771, 20742, 20787, 36165, 19826, 19826, 20311, 19826, 19826, 31277, 19826,
  42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 25357, 19826, 19826,
  42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520,
  18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655,
  18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923,
  18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080,
  19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256,
  19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484,
  19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618,
  19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 42610, 19826, 19826, 19826, 25369,
  19826, 19826, 19826, 41231, 19690, 20829, 20833, 20849, 20895, 20909, 36165, 19826, 19826, 19807, 19826, 19826, 31277,
  19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826,
  19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 23613, 20380, 18504, 23628,
  18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521,
  18655, 20938, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442,
  18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303,
  19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240,
  19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417,
  18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602,
  19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826,
  25369, 19826, 19826, 19826, 41231, 19690, 33486, 33491, 20954, 39401, 20989, 36165, 19826, 19826, 19807, 19826, 19826,
  31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681,
  19826, 19826, 19195, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504,
  23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706,
  18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370,
  18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064,
  23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219,
  19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424,
  19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518,
  19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 40272, 19826, 19826,
  19826, 21027, 21068, 19826, 40275, 41231, 21086, 21136, 21140, 21040, 19826, 21156, 36165, 19826, 19826, 19807, 19826,
  19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314,
  26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380,
  18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686,
  18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871,
  42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470,
  19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251,
  19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387,
  19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586,
  19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21191, 19826, 19826,
  19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 33775, 33780, 21215, 40902, 21243, 36165, 19826, 19826, 19807,
  19826, 19826, 31277, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826,
  21337, 18666, 22901, 21354, 19195, 25825, 30576, 21395, 29999, 19826, 19826, 26253, 40006, 29622, 29622, 29622, 29289,
  22052, 22052, 27453, 21373, 34343, 19826, 19826, 19826, 19826, 39118, 41508, 29003, 21394, 29998, 19826, 30578, 27490,
  29622, 29622, 29622, 26744, 22051, 22052, 22052, 22053, 34641, 21657, 33181, 19826, 19826, 19826, 19826, 19826, 21391,
  29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826, 38460,
  26255, 32290, 30579, 29619, 21431, 29622, 25491, 33297, 22052, 22052, 28686, 19826, 19826, 40233, 22270, 30000, 21457,
  29622, 41791, 28092, 22052, 28783, 25411, 19826, 19826, 21451, 29088, 29621, 21435, 22052, 38559, 19826, 39599, 21473,
  39640, 21498, 21516, 40865, 19826, 25146, 21541, 40801, 32457, 21613, 21648, 21580, 21673, 40013, 21676, 31252, 26925,
  21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 19826,
  19826, 19826, 19826, 25369, 19826, 19826, 19826, 21692, 19690, 19826, 19826, 19826, 25879, 21708, 36165, 19826, 19826,
  19807, 19826, 19826, 42306, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21767, 28004,
  19826, 19826, 18666, 19826, 19826, 42581, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 40006, 29622, 29622, 29622,
  29289, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 39118, 19826, 19826, 21394, 29998, 19826, 30578,
  27490, 29622, 29622, 29622, 26744, 22051, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826,
  26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826,
  19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000,
  21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826,
  30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047,
  26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668,
  21818, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 34846, 21794, 21808, 22972, 21840, 36165, 19826,
  19826, 19807, 19826, 19826, 31277, 41603, 42553, 18563, 21869, 19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554,
  23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500,
  23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595,
  23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088,
  19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892,
  19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553,
  19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100,
  19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527,
  19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19668, 21887, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 21175, 19690, 21906, 19826, 19826, 23346, 21927, 24512,
  19826, 19826, 19807, 19826, 19826, 21169, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275,
  21986, 28004, 19826, 19826, 18666, 19826, 19826, 29688, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 40006, 29622,
  29622, 29622, 29289, 22052, 22052, 26274, 21373, 29326, 19826, 19826, 19826, 19826, 24026, 22021, 19826, 21394, 29998,
  19826, 30578, 27490, 29622, 29622, 29622, 26744, 22051, 22052, 22052, 22053, 34641, 34736, 19826, 19826, 19826, 19826,
  27605, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 37465, 22048, 22052, 22052, 22052, 21412, 22069, 19826,
  19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 32321, 22051, 22052, 22052, 28686, 19826, 19826, 19826,
  22270, 30000, 21457, 29622, 29622, 22088, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789,
  19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013,
  21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19668, 38442, 19826, 19826, 19826, 22109, 22127, 19826, 42471, 41231, 22148, 31284, 22185, 22199, 19826, 22234,
  32978, 19826, 19826, 41860, 22269, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 20137, 23024, 22885,
  22936, 22287, 22424, 18295, 18314, 23796, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 22314,
  22754, 22356, 23073, 22329, 22594, 22386, 23245, 22412, 22898, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537,
  18579, 18595, 23380, 22440, 23029, 22471, 23024, 23292, 22502, 22542, 22932, 22396, 22518, 22898, 18760, 21120, 18824,
  21114, 35088, 19826, 18855, 18871, 42370, 23312, 22567, 23002, 22610, 22370, 22626, 22530, 22822, 22655, 22720, 19786,
  20801, 19892, 19005, 19026, 41470, 19064, 23303, 22743, 22770, 23082, 22786, 22298, 22807, 22551, 22847, 32989, 19161,
  19048, 42553, 19182, 42342, 22486, 22872, 22917, 22639, 23060, 22856, 31661, 19272, 30536, 18551, 42352, 22582, 22670,
  22952, 21100, 19337, 19371, 22988, 23018, 23045, 22831, 19446, 23098, 22455, 23114, 23130, 23166, 22685, 23182, 22727,
  23185, 22892, 23201, 22340, 23217, 23233, 23261, 23277, 23328, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19668, 39780, 19826, 19826, 19826, 23362, 23373, 19826, 19826, 41231, 23396, 42588, 23437, 23443, 19826,
  23459, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521,
  19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434,
  18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 23494, 42465,
  18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 23536, 18760, 21120,
  18824, 21114, 42193, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521,
  23566, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 23582, 19082, 19100, 18639, 19136, 32989,
  19161, 19048, 42553, 19182, 42137, 19251, 19219, 23598, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316,
  19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514,
  19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 19826, 23644, 35874, 35879, 23665,
  26344, 23700, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 23735, 19826, 19826, 18557, 25371,
  18521, 19548, 24485, 23754, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407,
  18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005,
  42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760,
  21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983,
  18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136,
  32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295,
  19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498,
  19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 23782, 19826, 23837, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 35512, 23812,
  23826, 19826, 23854, 37493, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 23889, 19826, 19826, 18557,
  25371, 18521, 19548, 24485, 23910, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371,
  18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747,
  22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663,
  18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961,
  18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639,
  19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551,
  19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494,
  19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 23938, 36558, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 37848,
  37853, 23989, 19826, 24005, 36774, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 24021, 19826, 19826,
  18557, 25371, 18521, 19548, 24485, 19554, 23766, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355,
  18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826,
  34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741,
  18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939,
  18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100,
  18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536,
  18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401,
  19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 24042, 19826, 19826, 19826, 19826, 24058, 19826, 19826, 19826, 41231, 19690,
  41491, 38836, 19826, 18391, 24093, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 41839, 42553, 18563, 19826, 19826,
  19826, 18557, 25371, 18521, 19548, 42218, 24122, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339,
  18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826,
  19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520,
  18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917,
  18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082,
  19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272,
  30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476,
  19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231,
  19690, 19826, 19826, 19826, 33189, 24150, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826,
  19826, 19826, 18557, 25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582,
  18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826,
  19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722,
  42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989,
  18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116,
  19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661,
  19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478,
  19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826,
  41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395,
  19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826,
  30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826,
  19826, 19826, 19826, 19826, 25656, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052,
  22052, 22053, 34641, 30525, 19826, 19826, 19826, 19826, 27605, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622,
  38316, 28094, 22052, 22052, 22052, 21412, 22069, 19826, 19826, 19826, 24228, 26255, 32290, 30579, 29619, 29622, 29622,
  25199, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 22088, 22052, 26763, 34343,
  19826, 23150, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146,
  21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369, 19826, 19826,
  19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270,
  21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826,
  19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343,
  19826, 19826, 19826, 19826, 19826, 25656, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622, 27416, 27372,
  22052, 22052, 22053, 34641, 30525, 19826, 19826, 19826, 19826, 27605, 19826, 26256, 29999, 22270, 33011, 29622, 29622,
  29622, 38316, 28094, 22052, 22052, 22052, 21412, 22069, 19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622,
  29622, 25199, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 22088, 22052, 26763,
  34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826,
  25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369, 19826,
  19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826,
  22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826,
  19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373,
  34343, 19826, 19826, 19826, 19826, 19826, 25656, 24249, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622, 27416,
  27372, 22052, 22052, 22053, 34641, 30525, 19826, 19826, 19826, 19826, 27605, 19826, 26256, 29999, 22270, 33011, 29622,
  29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 22069, 19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619,
  29622, 29622, 25199, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 22088, 22052,
  26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865,
  19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697,
  32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369,
  19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826, 19826, 19826,
  19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826, 18666, 19826,
  19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274,
  21373, 34343, 19826, 19826, 19826, 19826, 19826, 25656, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622,
  27416, 27372, 22052, 22052, 22053, 34641, 30525, 19826, 19826, 19826, 19826, 27605, 24266, 26256, 29999, 22270, 33011,
  29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 22069, 19826, 19826, 19826, 19826, 26255, 32290, 30579,
  29619, 29622, 29622, 25199, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 22088,
  22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765,
  40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703,
  36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826,
  25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826, 19826,
  29463, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826, 18666,
  19826, 19826, 29463, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052,
  26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 25656, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622,
  29622, 27416, 27372, 22052, 22052, 22053, 34641, 30525, 19826, 19826, 19826, 19826, 27605, 19826, 26256, 29999, 22270,
  33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 22069, 19826, 19826, 19826, 19826, 26255, 32290,
  30579, 29619, 29622, 29622, 25199, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622,
  22088, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622,
  35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703,
  25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826,
  19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826,
  19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826,
  18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052,
  22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 30578, 27490, 29622,
  29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 26256, 29999,
  22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826, 19826, 26255,
  32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622,
  29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144,
  29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415,
  25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826,
  19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807,
  19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 21998, 19826,
  19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590,
  22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 30578, 27490,
  29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 26256,
  29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826, 19826,
  26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457,
  29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580,
  26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925,
  21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826,
  19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 28124, 21571, 19826, 19826,
  19807, 19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004,
  19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622,
  29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 30578,
  27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826,
  26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826,
  19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000,
  21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826,
  30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047,
  26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185,
  19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24286, 32293, 22271, 40632, 21375, 36985, 21571, 19826,
  19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300,
  28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 24321, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622,
  29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826,
  30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826,
  19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826,
  19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270,
  30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826,
  19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676,
  26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  24185, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 36564, 24342, 24356, 21571,
  19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275,
  21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622,
  29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998,
  19826, 30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826,
  19826, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826,
  19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826,
  22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789,
  19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013,
  21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 24185, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985,
  21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626,
  26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974,
  29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394,
  29998, 19826, 30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826,
  19826, 19826, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826,
  19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826,
  37995, 22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052,
  28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814,
  40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 24391, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375,
  36985, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622,
  21626, 26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253,
  41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826,
  19826, 19826, 19826, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412,
  19826, 19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826,
  19826, 19826, 22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435,
  22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010,
  41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 39098, 24413, 24427,
  29792, 24448, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371,
  18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 23719, 39582, 18339, 18355, 18371, 18407,
  18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 24483, 18663, 29470, 19826, 19826, 19826, 34747, 22005,
  42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760,
  21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983,
  18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136,
  32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295,
  19316, 19300, 19321, 21100, 24501, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498,
  19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 19826, 19826,
  19826, 19826, 38269, 36165, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557,
  25371, 18521, 19548, 24485, 19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371,
  18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747,
  22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663,
  18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961,
  18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639,
  19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551,
  19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494,
  19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 24537, 24572, 19826, 19826, 19826, 24590, 19826, 19826, 19826, 41231, 24604, 19279,
  24625, 24631, 42083, 24647, 24687, 19826, 19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826,
  18557, 25371, 18521, 19548, 24485, 19554, 24712, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355,
  18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826,
  34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741,
  18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939,
  18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100,
  18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536,
  18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401,
  19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 24728, 24750, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690,
  19826, 19826, 19826, 32029, 24768, 24816, 19826, 19826, 19807, 19826, 19826, 31277, 41330, 42553, 18563, 19826, 19826,
  19826, 18557, 25371, 18521, 19548, 18725, 19554, 24841, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339,
  18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826,
  19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520,
  18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917,
  18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082,
  19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272,
  30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476,
  19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 24857, 19826, 19826, 24876, 24910, 19826, 28472, 24944,
  24960, 24974, 24984, 25000, 25016, 25030, 34397, 25068, 35124, 19807, 21952, 21002, 25087, 25111, 25134, 25174, 35115,
  21853, 21940, 25215, 25257, 25280, 25316, 25343, 25387, 25427, 19826, 27321, 18666, 23649, 19826, 25462, 37260, 30576,
  21395, 41966, 24432, 24860, 41926, 25479, 29622, 29622, 36845, 29590, 22052, 22052, 25511, 21373, 34343, 23677, 37505,
  33508, 25898, 19826, 25656, 19826, 30630, 39176, 32238, 25550, 25566, 21597, 29622, 38622, 25595, 38347, 22052, 29297,
  21284, 25611, 30525, 25627, 30172, 19826, 19826, 25647, 19826, 24792, 25677, 38373, 25693, 25727, 32539, 26810, 38316,
  37978, 35589, 28573, 22052, 25778, 25806, 30428, 19826, 41387, 29651, 26255, 32290, 30579, 29619, 29622, 37192, 25841,
  22051, 22052, 41364, 28686, 25870, 32820, 25895, 25914, 30000, 25934, 29622, 25960, 22088, 36956, 32671, 25978, 19826,
  19826, 30577, 29088, 31013, 39847, 39732, 25994, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433,
  22052, 32457, 25154, 38406, 26020, 25711, 26043, 30909, 26063, 41821, 21415, 25703, 25703, 36697, 32449, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 26098, 19826, 19826, 25369, 19826, 19826, 19826,
  26120, 26136, 28507, 26160, 26175, 21375, 26203, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395,
  19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826,
  30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826,
  19826, 19826, 19826, 26232, 25052, 19826, 21394, 37877, 19826, 26250, 27490, 29622, 29622, 30928, 27416, 27372, 22052,
  22052, 26272, 34641, 30525, 19826, 19826, 19826, 19826, 27605, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622,
  38316, 28094, 22052, 22052, 22052, 21412, 22069, 19826, 19826, 30967, 19826, 27058, 40224, 30579, 26291, 29622, 29622,
  25199, 26314, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 22088, 22052, 26763, 34343,
  19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146,
  21433, 22052, 32457, 25154, 30906, 40010, 41814, 19652, 26335, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 27173, 19826, 19826, 25369, 19674, 19826,
  19826, 41231, 26360, 26374, 26387, 26403, 26419, 26433, 21571, 19826, 24270, 20054, 19826, 26552, 19826, 19826, 22270,
  21395, 19826, 19826, 24574, 26254, 22253, 27530, 21626, 30871, 26462, 26490, 23478, 19826, 18666, 27952, 23738, 19826,
  19826, 26513, 39169, 29999, 26551, 26568, 26589, 27210, 26607, 29622, 29622, 34322, 26644, 22052, 26274, 21373, 28695,
  19826, 19826, 24549, 19826, 24369, 25656, 26667, 26697, 29998, 19826, 30578, 27490, 38080, 38310, 38944, 27416, 34086,
  34494, 40829, 22053, 34641, 30525, 19826, 19826, 26721, 19826, 25043, 19826, 26256, 29999, 22270, 33011, 29622, 29622,
  36935, 38316, 28094, 22052, 22052, 28568, 21412, 22069, 19826, 19826, 19826, 18382, 26255, 32290, 30579, 29619, 29622,
  26739, 25199, 22051, 22052, 26760, 28686, 19826, 19826, 26779, 22270, 38024, 26799, 36035, 29622, 22088, 18799, 30153,
  26833, 19826, 19826, 30577, 26863, 29621, 26886, 32593, 28789, 19826, 29039, 30580, 26144, 39865, 35765, 32226, 19826,
  25146, 21433, 22052, 32457, 25154, 30906, 40010, 35740, 20340, 26921, 26047, 26925, 21415, 25703, 25703, 33733, 32449,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 18298, 19826, 19826, 25369, 25118,
  19826, 26941, 41231, 26965, 26979, 26989, 27005, 27021, 27035, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826,
  22270, 38051, 27084, 19826, 27081, 20019, 23838, 34698, 25579, 26275, 27100, 28004, 27277, 23409, 21052, 27116, 37742,
  19826, 19826, 41213, 39467, 27134, 39142, 27162, 27189, 27226, 21589, 37200, 31871, 35160, 30902, 40379, 31512, 21373,
  34343, 19826, 19826, 27255, 19826, 27276, 25656, 19826, 21394, 29998, 19826, 30578, 28419, 29622, 29622, 29622, 27416,
  27372, 22052, 22052, 22053, 40328, 27293, 27320, 19826, 39945, 34455, 27605, 19826, 26256, 29999, 22270, 34217, 27337,
  29622, 29622, 27357, 18789, 22052, 22052, 29598, 21412, 22069, 19826, 19826, 19826, 19826, 27389, 32290, 30579, 27411,
  29622, 27432, 25199, 27450, 34414, 22052, 28686, 35552, 19826, 27469, 38663, 27486, 21457, 27506, 27527, 27546, 40112,
  26763, 34343, 27562, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 27582, 30580, 26144, 33797, 35765, 31782,
  19826, 25146, 21433, 22052, 32457, 25154, 30906, 25264, 30755, 40973, 34337, 26047, 26925, 21415, 25703, 25703, 36697,
  32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19827, 27602, 19826, 25369,
  29521, 27621, 23684, 27304, 27639, 27653, 27663, 27679, 27695, 27709, 21571, 32617, 27749, 27784, 20922, 27821, 32261,
  20512, 32792, 27858, 28913, 27894, 27937, 27908, 27974, 28027, 32700, 28080, 28110, 28159, 28206, 28182, 23520, 34180,
  28202, 23507, 34252, 30576, 21395, 30033, 24609, 19826, 18279, 41974, 34688, 35412, 26298, 29590, 28222, 28244, 31331,
  21373, 33898, 39365, 28281, 35914, 28305, 37727, 28356, 28377, 28393, 28500, 28448, 28488, 28523, 28539, 28589, 28605,
  28634, 28672, 28711, 35484, 28755, 28805, 28821, 24660, 19826, 40605, 31944, 27605, 28848, 28884, 41118, 24781, 36687,
  34114, 29622, 28929, 36305, 35238, 28950, 34660, 38537, 28970, 22069, 29000, 40487, 29019, 29055, 26255, 29083, 29108,
  32177, 41408, 29124, 29140, 22093, 35169, 29169, 33889, 19826, 36608, 29196, 22270, 25241, 29219, 29246, 39814, 29313,
  18808, 29351, 34343, 29153, 29373, 34036, 29403, 30302, 27733, 30254, 29439, 29486, 29507, 29537, 20650, 36855, 29562,
  40865, 29335, 25146, 41178, 28954, 28064, 39974, 25402, 29614, 29639, 20465, 29677, 29704, 29742, 21415, 34985, 25703,
  36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 29763, 19826,
  29783, 20073, 29808, 19847, 29827, 29843, 29857, 29867, 29883, 29899, 29913, 21571, 19826, 28906, 19807, 19826, 19826,
  24928, 19826, 22270, 21395, 19826, 26572, 26573, 19749, 23838, 32361, 29962, 26275, 29978, 28004, 22026, 19826, 18666,
  22032, 19826, 34892, 19826, 24071, 29994, 29999, 19826, 22031, 30016, 41974, 30049, 29622, 29622, 27989, 22052, 22052,
  26274, 30068, 34343, 19826, 19826, 19826, 19826, 19826, 25656, 19826, 21394, 29998, 19826, 38590, 27490, 29622, 29622,
  38985, 27416, 27372, 22052, 32005, 22053, 34641, 30525, 19826, 19826, 33837, 19826, 27605, 19826, 26256, 29999, 22270,
  30124, 29622, 38100, 29622, 38316, 28094, 22052, 30150, 22052, 21412, 22069, 19826, 30169, 19826, 19826, 26255, 30188,
  40130, 29619, 29622, 29230, 25199, 22051, 22052, 36127, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622,
  22088, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 30224, 19826, 30580, 26144, 29622,
  35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 30243,
  25703, 30289, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826,
  19826, 25369, 19826, 30318, 19826, 41231, 30338, 30352, 30362, 30378, 30394, 30408, 21571, 19826, 19826, 19807, 19826,
  19826, 19826, 35451, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28726, 19826, 19826,
  18666, 19826, 19826, 19826, 19826, 30444, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052,
  22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 30467, 21394, 29998, 19826, 30578, 29546, 29622,
  29622, 29622, 27511, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 41656, 19826, 34158, 19826, 19826, 26256, 29999,
  37057, 30486, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 30512, 19826, 19826, 19826, 19826, 19826, 26255,
  32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 30552, 30573, 30000, 21457, 29622,
  29622, 28092, 22052, 26763, 30764, 30596, 29452, 30620, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30653, 36633,
  30678, 30703, 40865, 19826, 30719, 30743, 30780, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415,
  25703, 34922, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826,
  19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 30807,
  19826, 19826, 19826, 21890, 22270, 21396, 19826, 19826, 37749, 18901, 28166, 30842, 30860, 39438, 30887, 29719, 19826,
  27118, 18666, 30322, 27470, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 30925, 29590,
  22052, 33241, 26274, 21373, 34343, 19826, 19826, 30944, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 36587, 35057,
  29622, 29622, 29622, 34577, 27372, 22052, 22052, 38518, 34641, 34343, 30964, 19826, 19826, 19826, 19826, 19826, 26256,
  29999, 22270, 35975, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 42256, 19826, 19826,
  26255, 32290, 30579, 29619, 29622, 37331, 25491, 22051, 22052, 40389, 28686, 19826, 19826, 19826, 22270, 30000, 21457,
  29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 30983, 30580,
  31004, 29622, 35765, 21321, 19826, 31174, 41157, 35627, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925,
  21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826,
  19826, 27798, 19826, 25369, 30208, 27835, 30202, 31029, 31045, 31059, 31085, 31069, 31101, 31115, 21571, 19826, 19826,
  42172, 34870, 19826, 19826, 19826, 31162, 31202, 23338, 29203, 36784, 31222, 31238, 31300, 31319, 32419, 31347, 31375,
  19826, 19826, 36794, 19826, 23894, 31398, 19826, 30576, 34016, 27065, 31418, 19826, 26253, 25187, 31447, 31464, 34372,
  28770, 36097, 22052, 31481, 21373, 34343, 24163, 31528, 31634, 31547, 35356, 19826, 32250, 21394, 21742, 33067, 23421,
  27490, 29622, 30844, 33034, 39983, 27372, 22052, 31563, 25300, 34641, 34343, 19826, 19826, 30988, 41585, 27761, 19826,
  26256, 29999, 22270, 33011, 31607, 29622, 29622, 38316, 39431, 22052, 22052, 22052, 21412, 19826, 28317, 31624, 29067,
  25854, 31677, 19757, 28329, 31697, 32857, 29622, 25491, 22051, 39327, 22052, 33155, 31899, 26216, 19826, 36244, 31716,
  22704, 39250, 31756, 33114, 39296, 35301, 41209, 19826, 36264, 31798, 29088, 33341, 31814, 40093, 28789, 40650, 19826,
  29926, 26144, 29622, 35765, 39562, 31848, 25146, 21433, 22052, 32457, 31867, 30906, 29747, 31887, 40013, 21676, 26047,
  26925, 31922, 25703, 25703, 36697, 31960, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185,
  19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 19826,
  19826, 19807, 19826, 19826, 31984, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300,
  28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622,
  29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826,
  30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826,
  19826, 26256, 29999, 22270, 33011, 29622, 37618, 29622, 38316, 28094, 22052, 32004, 22052, 21412, 19826, 19826, 19826,
  19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270,
  30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826,
  19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676,
  26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  24185, 19826, 19826, 38209, 19826, 25369, 19826, 32021, 32459, 28832, 32045, 32059, 32069, 32085, 32101, 32115, 21571,
  24397, 19826, 19807, 19826, 30826, 24375, 35451, 22270, 29418, 19826, 24250, 20401, 32144, 32165, 32193, 32213, 26275,
  21300, 25790, 22247, 19826, 27842, 24886, 23472, 25661, 21911, 23550, 21395, 32287, 19826, 22247, 41012, 37297, 32309,
  27341, 32337, 32384, 41761, 33223, 26905, 32435, 32475, 32494, 19826, 19826, 19826, 32511, 19826, 19826, 35795, 29998,
  19826, 30578, 27490, 32531, 32555, 25754, 27511, 32575, 26074, 31832, 22053, 34641, 34343, 33915, 32609, 19826, 19826,
  32633, 32650, 26256, 27870, 22270, 33011, 29622, 31700, 38499, 38316, 28094, 22052, 36093, 32668, 21412, 30470, 19826,
  19826, 42278, 19826, 28656, 32290, 30579, 32687, 29622, 29622, 25491, 21632, 22052, 22052, 28686, 32716, 19826, 35609,
  32736, 32781, 26870, 29622, 29622, 25524, 22052, 26763, 34343, 34245, 19826, 34948, 29088, 29621, 21435, 22052, 28789,
  19826, 34605, 30580, 26144, 41096, 35765, 32808, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013,
  21676, 33746, 32843, 40040, 25703, 21272, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 24185, 19826, 19826, 30604, 19826, 32879, 19826, 38260, 19826, 24671, 32895, 32909, 32919, 32935, 32951, 32965,
  21571, 22790, 19826, 19807, 19826, 24752, 19826, 19826, 22270, 33565, 19826, 25463, 22790, 33005, 22791, 33027, 28618,
  26275, 33050, 28004, 19826, 20966, 18666, 19826, 30948, 19826, 33066, 30576, 21395, 29999, 19826, 36323, 24106, 41974,
  33083, 26817, 36728, 28042, 22052, 35250, 33101, 33141, 33171, 32271, 20973, 19826, 19826, 35907, 19826, 19826, 21394,
  29998, 19826, 30578, 27490, 38694, 32559, 29622, 27416, 33205, 33239, 33257, 22053, 34641, 34343, 36174, 36183, 19826,
  19826, 33274, 42036, 26256, 29999, 22270, 33011, 36365, 29622, 32351, 32863, 33294, 33313, 39539, 22052, 21412, 19826,
  19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826,
  19826, 22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 21562, 19826, 19826, 30577, 29088, 29621, 21435, 22052,
  28789, 19826, 19826, 30580, 33332, 38479, 35765, 29184, 19826, 25146, 21433, 22052, 31968, 30727, 30273, 40010, 41814,
  40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 24185, 19826, 19826, 32827, 19826, 33357, 19826, 20255, 33377, 33387, 33403, 33417, 33427, 33443, 33459,
  33473, 21571, 34346, 33507, 19807, 18886, 19347, 19826, 19826, 33524, 33550, 21721, 33586, 33602, 33618, 36657, 33655,
  33671, 29276, 33687, 28004, 20861, 19826, 24467, 33703, 27768, 35453, 33719, 22697, 21395, 29423, 32495, 33762, 21227,
  41974, 25158, 29622, 33796, 29590, 33214, 39923, 26274, 33813, 33861, 19826, 32515, 33914, 19826, 19826, 22218, 19826,
  24299, 29998, 24461, 30578, 33931, 34570, 29622, 29622, 33960, 39691, 22052, 22052, 40858, 34641, 34343, 19826, 19826,
  19826, 33991, 19826, 37004, 34011, 38058, 34032, 24305, 29622, 29622, 34052, 34071, 23967, 22052, 31503, 35208, 21412,
  40153, 34130, 34154, 34174, 19826, 34196, 34233, 34268, 34307, 34362, 38708, 25491, 21778, 30265, 39919, 34936, 42392,
  34388, 26446, 27048, 33639, 27722, 37459, 29622, 28092, 34413, 41427, 34430, 34450, 19826, 19203, 26535, 34471, 34510,
  25534, 29357, 34540, 19826, 18418, 40251, 34560, 26897, 34593, 31851, 25146, 34628, 40769, 32457, 40299, 26474, 34676,
  21553, 34721, 28256, 26047, 26925, 21415, 33875, 25703, 36697, 28056, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 24185, 19826, 19826, 19010, 19826, 25369, 20420, 20212, 19826, 41231, 34763, 34777, 34787, 34803,
  34819, 34833, 20870, 34862, 34886, 34908, 34971, 35001, 19826, 20879, 35022, 35043, 37031, 21258, 35104, 18839, 35145,
  35185, 33944, 35224, 35272, 35349, 19826, 19826, 35384, 19826, 24920, 35372, 22211, 28649, 30637, 29999, 19826, 19826,
  26253, 35400, 25962, 31448, 36204, 29590, 39888, 35256, 25327, 21373, 34343, 27260, 19826, 23873, 19826, 35428, 35444,
  18323, 21394, 36345, 29946, 35027, 27490, 29622, 39822, 29622, 39207, 27372, 39737, 22052, 37236, 35469, 37411, 19826,
  35528, 35548, 19826, 19826, 19826, 26256, 29999, 38184, 33011, 29622, 35568, 29622, 38316, 28094, 40820, 22052, 22052,
  21412, 19826, 19826, 25819, 35532, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 26187, 35587, 22052, 22052, 28686,
  19826, 35605, 19826, 22270, 27395, 35953, 41735, 36419, 32412, 41684, 36137, 38360, 19826, 19826, 25918, 29088, 32759,
  21435, 35625, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 35643, 38385, 40696, 22052, 35660, 35683, 35707,
  38217, 20478, 40013, 21676, 26047, 26925, 21415, 35732, 35756, 36697, 33827, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369, 19826, 21824, 21338, 20268, 35782, 37111, 35816,
  35831, 35847, 35861, 21571, 19826, 30090, 18775, 19826, 19826, 19826, 19826, 20641, 21395, 19826, 35895, 19826, 24077,
  23838, 29623, 21626, 40398, 21300, 28004, 27805, 19826, 18666, 19826, 27623, 31402, 35930, 35946, 35969, 29999, 19826,
  35991, 26253, 41974, 36009, 36032, 36051, 28554, 36078, 36224, 39702, 36113, 31934, 19826, 28011, 19826, 31726, 31652,
  23713, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 31265,
  29811, 19826, 19826, 37429, 19826, 36153, 41137, 35800, 22270, 33011, 29622, 36199, 29622, 38714, 36220, 40339, 22052,
  22052, 21412, 19826, 36240, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 37385, 29622, 31186, 22051, 40774, 22052,
  28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 36260, 30577, 21751,
  29621, 21435, 22052, 21525, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 36280, 25154,
  30906, 36296, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293,
  22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 36321, 22270, 33633, 30098, 30104, 30107,
  36339, 30108, 36361, 36381, 28228, 21300, 35499, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999,
  19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622, 28934, 27372, 22052, 22052, 22053, 34641,
  34343, 19826, 19826, 19826, 19826, 19826, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052,
  22052, 22052, 21412, 19826, 19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052,
  22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577,
  29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 36416, 40461, 40865, 19826, 25146, 21433, 22052, 32457,
  25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19909, 36435, 36452, 19166, 19826, 36458, 41231, 36475,
  36489, 36499, 36515, 36531, 36545, 21571, 19826, 19355, 19807, 26104, 36580, 36603, 40611, 36624, 27921, 26723, 19737,
  36649, 36673, 36713, 37167, 27239, 29577, 36749, 36810, 19826, 19826, 29767, 22160, 37089, 28463, 23867, 37663, 30025,
  29999, 19826, 35129, 24326, 36833, 36733, 27434, 29622, 34486, 34652, 38166, 33316, 36879, 36895, 19826, 18270, 28137,
  33278, 19826, 37367, 19826, 21394, 41532, 19826, 18276, 30662, 36915, 36933, 31303, 39501, 36951, 31826, 22052, 36972,
  34641, 34343, 19826, 40429, 38737, 37020, 37047, 37081, 26256, 37105, 37127, 37143, 29622, 26618, 37183, 37916, 28094,
  26319, 40350, 33258, 37216, 41897, 19826, 38235, 37252, 36436, 26255, 32290, 37276, 37313, 29622, 29622, 25491, 21311,
  22052, 22052, 31577, 36459, 37347, 37365, 22270, 30000, 21457, 29622, 31608, 28092, 22052, 26082, 34343, 28868, 19826,
  30577, 34291, 37383, 35691, 22052, 37401, 19826, 37427, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052,
  37535, 37445, 37481, 40010, 41814, 37521, 37557, 26047, 26925, 21415, 30496, 37573, 37598, 32449, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 37634, 37655, 37679, 37696, 37712, 29387,
  37765, 37779, 37789, 37805, 37821, 37835, 22169, 19826, 19826, 20693, 19826, 19826, 24894, 19826, 22072, 37869, 24169,
  27586, 37893, 21732, 34138, 37909, 37932, 39331, 37948, 28004, 37964, 19826, 18666, 31382, 37994, 19826, 19826, 24233,
  38011, 33570, 28863, 33975, 38040, 27878, 38074, 38096, 29622, 29261, 38116, 22052, 26274, 38132, 34343, 38182, 25071,
  29491, 38200, 19826, 19826, 19826, 21394, 29998, 31988, 30578, 27490, 29622, 29622, 29622, 27416, 27372, 22052, 22052,
  22053, 34641, 34343, 19826, 38233, 38251, 31643, 32652, 30227, 26256, 37289, 38285, 38913, 29622, 36917, 25762, 38332,
  38401, 22052, 34524, 37227, 38422, 38438, 38458, 35006, 19826, 19826, 26591, 24800, 30579, 38476, 41554, 38495, 25491,
  22051, 40811, 38515, 28686, 19826, 41713, 19826, 40242, 30000, 21457, 39805, 37612, 25294, 38534, 38553, 34343, 19826,
  24521, 30577, 25228, 29621, 21435, 22052, 30791, 19037, 40920, 38575, 38612, 38629, 35765, 38645, 25095, 32748, 21433,
  22052, 38661, 38298, 36762, 40010, 41814, 28739, 21676, 25944, 38679, 20349, 25703, 25703, 36697, 32449, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19954, 25369, 19826, 19826, 38730,
  19963, 38753, 38767, 38777, 38793, 38809, 38823, 28265, 22111, 38852, 19807, 19826, 27958, 38868, 27566, 22270, 28406,
  29726, 24734, 38884, 38900, 38929, 38966, 39001, 39017, 39046, 39062, 23145, 39085, 22132, 39114, 19826, 31906, 39134,
  21962, 31206, 26527, 29034, 29661, 39158, 39192, 29622, 39243, 39266, 31771, 35766, 39282, 23973, 39312, 26004, 39347,
  28361, 37349, 40739, 19826, 19826, 33361, 41955, 39381, 39417, 39454, 39488, 39517, 32368, 33085, 27416, 39533, 35287,
  22052, 39555, 40949, 39578, 39396, 40436, 27146, 39598, 39615, 39069, 21970, 28895, 39631, 28340, 30687, 39656, 34055,
  39676, 39718, 39753, 22052, 38147, 21412, 39357, 39779, 34544, 41906, 19826, 33534, 26705, 30579, 39796, 39838, 39863,
  25491, 39881, 39904, 22052, 28686, 39939, 42414, 19826, 39961, 39999, 40029, 40056, 29622, 40079, 40109, 36400, 34343,
  20193, 19826, 40128, 29088, 37156, 40063, 35327, 40726, 40146, 19826, 29092, 40169, 36062, 37582, 40194, 40267, 40291,
  40315, 40366, 32457, 25154, 30906, 40010, 41814, 40013, 26651, 26027, 34101, 40414, 40452, 25703, 30134, 40477, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 26497, 25369, 19826, 21357,
  19826, 40503, 40519, 40533, 40546, 40562, 40578, 40592, 21571, 19826, 19826, 19984, 19826, 25631, 19826, 19826, 22270,
  21395, 19826, 41336, 19826, 26254, 40627, 38980, 28432, 26275, 21300, 28004, 40648, 19826, 18666, 19826, 19826, 19826,
  40666, 25495, 21395, 29999, 19826, 40672, 37065, 41974, 40694, 29622, 29622, 40712, 22052, 22052, 41639, 40755, 35716,
  32634, 36998, 19826, 28143, 19826, 30557, 35667, 32149, 27201, 34612, 30578, 21482, 32197, 26628, 36863, 27416, 27372,
  40790, 40845, 22053, 34641, 34343, 36817, 19826, 19826, 19826, 19826, 25440, 34955, 29999, 22270, 33011, 36016, 29622,
  29622, 38950, 40881, 22052, 22052, 22052, 21412, 40897, 34434, 19826, 19826, 19826, 26255, 32290, 40215, 29619, 29622,
  29622, 25491, 22051, 22052, 22052, 28984, 19826, 19826, 37639, 22270, 30000, 30451, 29622, 29622, 31494, 22052, 26763,
  34343, 40918, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826,
  25146, 40936, 36394, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 40178, 40965, 21415, 25703, 31591, 36697, 32449,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19826, 25369, 21070,
  19120, 19826, 40989, 41005, 29936, 22271, 41028, 41044, 41058, 21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826,
  22270, 21395, 19826, 19826, 19826, 26254, 23838, 41092, 35070, 26275, 21300, 28004, 19826, 23953, 18666, 19826, 19826,
  19826, 19826, 30576, 41112, 39472, 19826, 19826, 41134, 41974, 41153, 41173, 29622, 39030, 27373, 22052, 26274, 41194,
  34343, 19826, 19826, 19826, 19826, 37541, 19826, 19826, 31681, 29998, 41229, 30578, 27490, 29622, 25745, 29622, 27416,
  27372, 41690, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 26256, 29999, 22270, 33011, 29622,
  29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619,
  29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 37680, 19826, 22270, 30000, 21457, 29622, 29622, 28092, 22052,
  26763, 34343, 31531, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865,
  30421, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697,
  32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826, 19695, 25369,
  19826, 24556, 20119, 20102, 41247, 41261, 41271, 41287, 41303, 41317, 21571, 19826, 19826, 19807, 19826, 19826, 19826,
  19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 30052, 21626, 33125, 41352, 41380, 19826, 19826, 18666, 19826,
  19826, 19826, 35993, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590, 22052, 22052, 26274,
  21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622, 29622,
  27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 40678, 19826, 26256, 29999, 22270, 33011,
  29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 35644, 19826, 19826, 19826, 26255, 32290, 30579,
  29619, 41403, 35571, 25491, 22051, 41424, 35333, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622, 28092,
  22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622, 35765,
  40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703, 25703,
  36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24391, 19826, 19826, 19826, 19826,
  25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 24191, 41443, 41457, 21571, 19826, 19826, 19807, 41486, 19826,
  41507, 19826, 20010, 34211, 31734, 31740, 28186, 41524, 20726, 41548, 35314, 26275, 21300, 28004, 19826, 19826, 41570,
  19826, 41601, 41619, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 25736, 29590, 22052, 22052,
  32399, 21373, 30081, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 30578, 27490, 29622, 29622,
  29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 26256, 29999, 22270,
  33011, 29622, 29622, 29622, 32765, 41635, 22052, 22052, 22052, 21412, 25446, 19826, 19826, 19826, 19826, 26255, 32290,
  30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457, 29622, 29622,
  28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144, 29622,
  35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415, 25703,
  25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826, 19826,
  19826, 25369, 19826, 19826, 19826, 41231, 24207, 32293, 22271, 40632, 21375, 36985, 21571, 41655, 19826, 19807, 19826,
  19826, 26783, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 19642, 21500, 21626, 39763, 41672, 41706, 19826, 19826,
  18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 34705, 35200, 22052,
  22052, 31359, 21373, 34343, 39222, 19826, 32720, 19826, 19826, 19826, 19826, 21394, 34282, 19826, 30578, 27490, 37325,
  29622, 41729, 27416, 41751, 22052, 32587, 22053, 34641, 34343, 33995, 19826, 19826, 19826, 19826, 19826, 38596, 29999,
  22270, 33011, 31465, 41785, 29622, 38316, 28094, 38159, 22052, 22052, 41807, 19826, 19826, 41837, 19826, 19826, 26255,
  32290, 24212, 29619, 39660, 29622, 41855, 22051, 41769, 22052, 41876, 19826, 19826, 26949, 22270, 30000, 21457, 29622,
  29622, 28092, 22052, 26763, 35083, 19826, 19826, 41922, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580, 26144,
  29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925, 21415,
  25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 24185, 19826, 19826,
  19826, 19826, 25369, 19826, 19826, 19826, 41231, 41942, 32293, 22271, 40632, 21375, 36985, 21571, 19826, 19826, 19807,
  19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626, 26275, 21300, 28004, 19826,
  19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 41974, 29622, 29622, 29622, 29590,
  22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394, 29998, 19826, 30578, 27490,
  29622, 29622, 29622, 27416, 27372, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 26256,
  29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826, 19826, 19826, 19826, 19826,
  26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826, 19826, 22270, 30000, 21457,
  29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052, 28789, 19826, 19826, 30580,
  26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814, 40013, 21676, 26047, 26925,
  21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668, 19826,
  19826, 19826, 19826, 41990, 42059, 42081, 42015, 41999, 42052, 42079, 42108, 42063, 42099, 42124, 42163, 19826, 19826,
  19807, 19826, 19826, 31277, 42188, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 42209, 24485, 19554, 42234,
  18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500, 23624,
  18473, 20380, 18504, 23628, 18520, 42250, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595, 23380,
  18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088, 19826,
  18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892, 19005,
  19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553, 19182,
  42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100, 19337,
  19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527, 19534,
  19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19668,
  19826, 19826, 19826, 19826, 25369, 19826, 19826, 42272, 41231, 19690, 41071, 41076, 42294, 19826, 42329, 36165, 19826,
  19826, 19807, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 42368, 19826, 18557, 25371, 18521, 19548, 24485, 19554,
  23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376, 18500,
  23624, 18626, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579, 18595,
  23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114, 35088,
  19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801, 19892,
  19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048, 42553,
  19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321, 21100,
  19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517, 42527,
  19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19668, 19826, 19826, 19826, 19826, 25369, 42386, 19826, 19826, 32478, 42408, 42313, 42430, 42436, 19826, 42452, 36165,
  19826, 19826, 19807, 19826, 19826, 31277, 42487, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521, 19548, 24485,
  19554, 23922, 18295, 18314, 26681, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434, 18458, 20376,
  18500, 23624, 42509, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465, 18537, 18579,
  18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120, 18824, 21114,
  35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521, 19786, 20801,
  19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989, 19161, 19048,
  42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316, 19300, 19321,
  21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514, 19430, 19517,
  42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19668, 19826, 19826, 19826, 19826, 25369, 19826, 19826, 19826, 41231, 19690, 19826, 19826, 19826, 19826, 31128,
  21571, 19826, 19826, 19807, 19826, 19826, 19826, 19826, 22270, 21395, 19826, 19826, 19826, 26254, 23838, 29622, 21626,
  26275, 21300, 28004, 19826, 19826, 18666, 19826, 19826, 19826, 19826, 30576, 21395, 29999, 19826, 19826, 26253, 40006,
  29622, 29622, 29622, 29289, 22052, 22052, 26274, 21373, 34343, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 21394,
  29998, 19826, 30578, 27490, 29622, 29622, 29622, 26744, 22051, 22052, 22052, 22053, 34641, 34343, 19826, 19826, 19826,
  19826, 19826, 19826, 26256, 29999, 22270, 33011, 29622, 29622, 29622, 38316, 28094, 22052, 22052, 22052, 21412, 19826,
  19826, 19826, 19826, 19826, 26255, 32290, 30579, 29619, 29622, 29622, 25491, 22051, 22052, 22052, 28686, 19826, 19826,
  19826, 22270, 30000, 21457, 29622, 29622, 28092, 22052, 26763, 34343, 19826, 19826, 30577, 29088, 29621, 21435, 22052,
  28789, 19826, 19826, 30580, 26144, 29622, 35765, 40865, 19826, 25146, 21433, 22052, 32457, 25154, 30906, 40010, 41814,
  40013, 21676, 26047, 26925, 21415, 25703, 25703, 36697, 32449, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 42548, 19826, 42552, 31141, 31146, 42569, 36899,
  42604, 31277, 19826, 19826, 19826, 19826, 19826, 31277, 19826, 42553, 18563, 19826, 19826, 19826, 18557, 25371, 18521,
  19548, 24485, 19554, 42532, 18295, 18314, 22966, 19826, 19826, 42581, 19826, 39582, 18339, 18355, 18371, 18407, 18434,
  18458, 20376, 18500, 23624, 18473, 20380, 18504, 23628, 18520, 18663, 29470, 19826, 19826, 19826, 34747, 22005, 42465,
  18537, 18579, 18595, 23380, 18611, 18686, 18706, 18521, 18655, 18682, 18702, 18722, 42520, 18741, 18663, 18760, 21120,
  18824, 21114, 35088, 19826, 18855, 18871, 42370, 18442, 18923, 18945, 18967, 18989, 18917, 18939, 18961, 18983, 18521,
  19786, 20801, 19892, 19005, 19026, 41470, 19064, 23303, 19080, 19098, 18637, 19116, 19082, 19100, 18639, 19136, 32989,
  19161, 19048, 42553, 19182, 42137, 19251, 19219, 19240, 19256, 19224, 19145, 31661, 19272, 30536, 18551, 19295, 19316,
  19300, 19321, 21100, 19337, 19371, 19387, 19424, 19417, 18484, 19446, 19462, 19478, 19476, 19401, 19494, 19498, 19514,
  19430, 19517, 42527, 19534, 19570, 19586, 19518, 19602, 19618, 19632, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826, 19826,
  19826, 19826, 19826, 0, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 73986, 73986, 73986, 73986, 0, 0, 78085, 78085, 73986,
  73986, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 0, 78085, 0, 73986, 78085, 73986, 78085,
  316, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085,
  45056, 49152, 78085, 78085, 78085, 78085, 40960, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085,
  78085, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 73986, 0, 0, 78085, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 1322,
  0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 1082, 0, 0, 2469888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 281, 282, 0, 0, 2719744, 0, 0, 0, 0, 0, 0, 2871296, 0, 0, 0, 0, 0, 0, 0, 0, 1387, 0, 0, 0, 0, 0, 1394, 0, 2158592,
  2158592, 2158592, 2158592, 2158592, 2621440, 2158592, 2158592, 2686976, 2158592, 2703360, 2158592, 2158592, 2756608,
  2777088, 2797568, 2158592, 2834432, 2158592, 2883584, 2158592, 2158592, 2158592, 3067904, 2158592, 2158592, 2158592,
  0, 0, 0, 0, 2621440, 0, 2686976, 2703360, 0, 0, 2756608, 2777088, 2797568, 0, 2834432, 2883584, 0, 0, 0, 0, 0, 0, 0,
  1907, 1908, 0, 0, 0, 0, 0, 0, 0, 0, 270336, 270336, 270336, 270336, 270336, 270336, 270336, 270336, 0, 0, 2883584,
  2441216, 0, 0, 0, 0, 2777088, 0, 2883584, 0, 0, 0, 0, 0, 0, 0, 2307, 400, 400, 2309, 2310, 400, 400, 400, 0, 0,
  2719744, 0, 0, 2883584, 0, 0, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  3158016, 2158592, 0, 0, 0, 0, 2162688, 2162688, 2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2162688,
  2441216, 2449408, 2162688, 0, 0, 0, 0, 0, 0, 0, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 3121152, 2162688, 2162688, 2162688, 2162688, 0, 2494464, 0, 0, 2162688, 2711552, 2162688,
  2162688, 2756608, 2162688, 2777088, 2797568, 2162688, 2162688, 2834432, 2162688, 2162688, 2883584, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 2428928, 2158592, 2158592, 2158592,
  2158592, 2158592, 2158592, 2580480, 2158592, 2158592, 2613248, 2158592, 2658304, 2158592, 2158592, 2158592, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2785280, 2809856, 2158592, 2158592, 2158592, 2158592,
  2158592, 2158592, 2158592, 2158592, 2428928, 0, 0, 2580480, 0, 0, 0, 0, 2809856, 0, 0, 0, 0, 2809856, 0, 0, 0, 0, 0,
  2809856, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 2162688, 2162688, 2428928, 2162688,
  0, 0, 0, 853, 0, 0, 856, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 3026944, 2162688, 2162688, 3076096, 2162688, 3096576, 2162688, 2162688, 2162688, 2162688, 2162688,
  3080192, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 316, 316, 0, 0, 2162688, 2428928, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2580480, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2613248,
  2162688, 2162688, 2162688, 2658304, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2785280,
  2809856, 2162688, 2162688, 2785280, 2809856, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 913, 2801664, 2162688, 2801664, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 912, 0, 0, 2473984,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 2596864, 0, 0, 2760704, 0, 0, 0, 0, 615, 0, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 0, 0, 520,
  520, 520, 520, 520, 1798, 520, 520, 520, 520, 520, 520, 520, 520, 2155, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  2156, 520, 520, 520, 520, 520, 520, 3141632, 0, 0, 3158016, 0, 0, 0, 0, 0, 0, 0, 0, 2875392, 0, 2768896, 0, 0, 0, 0,
  621, 600, 400, 400, 778, 400, 780, 400, 400, 728, 400, 787, 0, 0, 0, 0, 2158592, 2473984, 2478080, 2158592, 2158592,
  2158592, 2158592, 2596864, 2158592, 2158592, 2158592, 2707456, 2158592, 2158592, 2875392, 2158592, 2158592, 2158592,
  2158592, 2158592, 2158592, 2158592, 2158592, 2478080, 0, 0, 2707456, 0, 0, 0, 0, 629, 0, 0, 632, 0, 0, 0, 0, 637, 0,
  639, 0, 0, 0, 0, 682, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400, 731, 0, 0, 0, 0, 2162688, 2162688, 2162688,
  2473984, 2478080, 2162688, 2162688, 2162688, 2519040, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2596864, 2162688, 2162688, 2162688, 2162688, 2162688, 2596864, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2707456, 2162688, 2162688, 2162688, 2162688, 2162688, 2760704, 2162688, 2162688, 2162688, 2854912, 2162688, 2760704,
  2162688, 2162688, 2162688, 2854912, 2875392, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2994176, 3018752, 2162688, 2162688, 2162688, 3051520, 2994176, 3018752, 2162688, 2162688, 2162688, 3051520,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3158016, 2162688, 0, 0, 0, 0, 0, 2121728, 0,
  0, 0, 0, 3043328, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 296, 297, 298, 0, 2527232, 2695168, 0, 3145728, 0, 0, 0, 0, 0,
  0, 2572288, 0, 0, 0, 0, 0, 0, 0, 962560, 1052672, 0, 2292, 0, 0, 0, 0, 0, 0, 0, 2715648, 0, 0, 3039232, 0, 0, 0,
  3022848, 0, 2887680, 2158592, 2158592, 2158592, 3026944, 3076096, 3096576, 3145728, 0, 0, 0, 0, 0, 0, 3076096,
  3096576, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2490368, 2162688, 2162688, 2527232, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2600960, 2162688, 2600960, 2625536, 2162688, 2162688, 2162688, 2695168, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2887680, 2162688, 2162688, 2162688, 2162688, 3145728, 2162688,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 3145728, 2162688, 2437120, 2437120, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 0, 2514944, 0, 0, 2543616, 2592768, 0, 0, 0, 0, 0, 0, 3153920,
  0, 2813952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 299, 0, 0, 0, 0, 2158592, 2158592, 2158592, 2158592, 2633728, 2158592,
  2158592, 2961408, 2158592, 3022848, 0, 0, 2633728, 0, 0, 0, 0, 0, 0, 2109440, 1020, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2215,
  0, 2217, 400, 400, 400, 400, 2818048, 2162688, 2162688, 2908160, 2162688, 2162688, 2953216, 2162688, 2961408, 2162688,
  2162688, 3022848, 3047424, 2162688, 2162688, 2162688, 2162688, 3174400, 2162688, 2162688, 2162688, 2162688, 3174400,
  0, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2547712, 2162688, 2162688,
  2162688, 2162688, 2633728, 2162688, 2162688, 2715648, 2736128, 2162688, 2162688, 2813952, 2818048, 2162688, 2162688,
  2908160, 2162688, 2891776, 0, 0, 0, 3014656, 0, 2539520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290816, 290816, 290816, 290816,
  290816, 290816, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2498560, 2539520, 2543616, 2162688, 2162688, 2592768,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2891776, 2162688, 2162688, 2162688, 2162688, 2891776, 2162688,
  2162688, 2957312, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2457600, 0, 0, 0, 0, 2936832, 0, 0, 3084288, 0, 2940928, 3129344, 2416640, 0, 0, 0, 0, 0, 0, 0, 648, 0, 0, 0,
  0, 0, 0, 0, 0, 603, 604, 0, 0, 0, 0, 0, 0, 0, 2723840, 0, 0, 0, 0, 0, 0, 2158592, 2482176, 2158592, 2158592, 2740224,
  2158592, 2158592, 2482176, 2740224, 0, 0, 0, 0, 0, 2158592, 2158592, 2158592, 0, 2420736, 2162688, 2162688, 2482176,
  2162688, 2162688, 0, 0, 0, 0, 0, 2846720, 0, 0, 0, 0, 0, 0, 2805760, 0, 3121152, 2420736, 2162688, 2162688, 2482176,
  2162688, 2162688, 2162688, 2584576, 2162688, 2162688, 2682880, 2740224, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 2502656, 0, 0, 0, 2826240, 0, 2973696, 0, 0, 0,
  3100672, 0, 0, 0, 0, 0, 0, 0, 2916352, 0, 2445312, 0, 2445312, 2494464, 2158592, 2744320, 2973696, 2744320, 0,
  2158592, 0, 2162688, 2445312, 2453504, 2494464, 2162688, 2162688, 2162688, 2162688, 2650112, 2744320, 2826240,
  2928640, 2162688, 2973696, 2162688, 2162688, 2162688, 3100672, 2162688, 2445312, 3178496, 2560000, 2560000, 0,
  2162688, 2551808, 2560000, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3092480, 0, 0, 0,
  0, 0, 2850816, 0, 0, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 0, 2162688, 2162688, 2588672, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2588672, 2162688, 2162688, 2162688, 0, 0, 2162688, 0, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2465792, 0, 2531328, 2985984, 0, 0, 0, 0, 2162688, 2162688, 2605056, 2162688, 2830336,
  2162688, 2162688, 2162688, 2985984, 2162688, 2162688, 2605056, 2162688, 2830336, 2162688, 2162688, 2162688, 2985984,
  2523136, 0, 0, 0, 0, 2424832, 2162688, 2162688, 2162688, 2162688, 2981888, 2424832, 2162688, 2162688, 2162688,
  2162688, 2981888, 2535424, 0, 0, 2912256, 2162688, 2654208, 2932736, 2162688, 2162688, 2654208, 2932736, 2162688,
  2637824, 2699264, 2555904, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2945024, 2945024, 0, 0, 0,
  0, 0, 0, 0, 669, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 2470, 496, 2472, 496, 2474, 496, 520, 0, 2, 3, 94212, 5, 6,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 274, 0, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 311, 312, 313,
  314, 315, 111009, 111009, 111009, 111009, 111009, 111009, 417, 417, 111009, 111009, 111009, 111009, 111009, 417,
  111009, 111009, 111009, 417, 111009, 417, 417, 417, 417, 417, 0, 417, 0, 0, 0, 0, 0, 0, 747, 0, 0, 0, 0, 755, 0, 0, 0,
  0, 0, 0, 776, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 1932, 0, 0, 0, 0, 0, 0, 0, 0, 111009, 111009, 111009, 0,
  0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2486272, 0, 0, 0, 0, 0, 0, 0, 0, 2600960, 118784, 0, 0, 264, 118784, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 0, 316, 264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0,
  0, 0, 264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 264, 264, 0, 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 264, 119153,
  49152, 264, 264, 0, 0, 264, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2646016, 0, 2781184, 0, 0, 0, 0, 0, 0,
  3125248, 32768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 299, 2162688, 2162688, 2162688, 2162688, 0, 2, 6, 0, 0,
  0, 264, 0, 0, 0, 2441216, 2449408, 0, 2, 2183418, 94212, 5, 6, 254, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 305, 306, 307,
  308, 0, 0, 0, 0, 0, 0, 0, 365, 307, 0, 0, 0, 0, 0, 45056, 49152, 0, 316, 0, 122880, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 316, 316, 316, 0, 625, 0, 122880, 0, 122880, 0, 122880, 122880, 122880, 122880, 122880, 0, 0, 0, 0, 0, 0, 0,
  692, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 716, 400, 400, 400, 400, 400, 400, 122880, 0, 0, 122880, 0, 0, 0, 0, 122880,
  122880, 122880, 122880, 122880, 0, 122880, 122880, 122880, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 316,
  624, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 320, 0, 0, 0, 0, 122880, 122880, 0, 0, 0, 2, 2, 2183418,
  94212, 5, 6, 0, 0, 0, 0, 0, 311, 0, 0, 312, 0, 311, 0, 0, 0, 45056, 49152, 147456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 311, 0, 672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2163484, 2162688, 2162688, 2162688, 2162688, 0, 2,
  6, 0, 0, 0, 0, 933, 937, 0, 2441216, 2449408, 2162688, 2162688, 3080192, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 0, 1516, 0, 0, 1521, 0, 316, 0, 0, 0, 131072, 131072, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2190, 0, 0, 2192, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 0, 131072, 0, 0,
  131072, 0, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 0, 0, 2, 2, 3, 94212, 5, 6,
  0, 0, 0, 0, 0, 334, 0, 0, 0, 338, 339, 341, 294, 0, 0, 0, 0, 0, 357, 0, 0, 0, 0, 357, 0, 0, 0, 45056, 49152, 0, 316,
  0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 45056, 49152, 0, 135168, 0, 0, 40960, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 316, 316, 204800, 0, 0, 135168, 135168, 0, 0, 135168, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0,
  496, 496, 496, 2469, 496, 496, 496, 496, 496, 496, 520, 2524, 520, 520, 520, 520, 520, 520, 520, 0, 2162688, 0, 0, 0,
  1197, 0, 0, 1200, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2621440, 2162688, 2162688, 2162688, 2162688, 2686976, 2162688, 2703360, 2162688, 2711552, 2162688, 2162688, 139264, 0,
  0, 265, 139264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 668, 590, 0, 0, 0, 0, 316, 265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 328, 265, 265, 0, 0, 0, 0, 0, 0, 0, 265, 0, 0, 0, 265, 45056, 139637, 265, 265, 0, 0, 265, 0, 0, 2, 2, 3,
  94212, 5, 6, 0, 0, 0, 0, 0, 496, 496, 2468, 496, 496, 496, 496, 496, 496, 496, 520, 2449, 520, 520, 520, 2453, 520,
  520, 520, 520, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 680, 0, 0, 0, 0, 0, 0, 262, 262, 0, 0, 262, 262, 143622, 262, 262, 262, 262, 262, 262, 262, 143622, 262, 143622,
  262, 262, 262, 262, 262, 262, 262, 262, 262, 317, 262, 143622, 262, 262, 262, 262, 262, 143622, 321, 262, 262, 262,
  262, 262, 40960, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 143681, 262,
  262, 262, 262, 262, 262, 262, 143681, 262, 143622, 262, 143681, 45056, 49152, 262, 143622, 262, 143622, 143622,
  143622, 262, 262, 143622, 143622, 143622, 143622, 143622, 143622, 143622, 143622, 262, 262, 262, 262, 262, 262,
  143622, 143622, 143622, 262, 143622, 262, 262, 262, 262, 262, 0, 262, 0, 0, 262, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 400, 400, 400, 0, 496, 496, 2319, 496, 496, 496, 262, 262, 262, 143622, 262, 143622, 143622, 143622, 143622,
  143622, 143622, 143681, 143681, 143681, 143681, 143681, 143622, 143622, 143622, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0,
  0, 0, 616, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 0, 316, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 40960,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 793, 0, 0, 0, 496, 0, 0, 0, 0, 155648, 0, 0, 155648, 0, 0, 0, 0, 0, 155648, 0, 0, 0,
  155648, 0, 0, 0, 0, 0, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648,
  155648, 155648, 155648, 155648, 0, 155648, 0, 0, 0, 0, 0, 0, 155648, 155648, 155648, 0, 0, 2, 2, 0, 94212, 5, 6,
  126976, 0, 0, 0, 0, 0, 2887680, 0, 0, 0, 0, 3026944, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  159744, 0, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744,
  159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 0, 159744, 0,
  0, 0, 0, 0, 0, 946, 947, 948, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0, 0, 0, 0, 578, 676, 677, 678, 0, 0, 0, 0, 0, 684,
  90631, 0, 0, 0, 159744, 0, 0, 0, 0, 90631, 90631, 90631, 90631, 90631, 90631, 90631, 159744, 159744, 90631, 0, 0, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 630, 631, 0, 0, 0, 0, 636, 0, 0, 0, 640, 90112, 2162688, 2428928, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2580480, 163840, 163840,
  163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 0, 163840, 0, 0, 0, 0, 0, 0, 961, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1323, 0, 0, 0, 0, 0, 0, 163840, 163840, 163840, 163840, 163840, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 646,
  0, 0, 649, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 0,
  167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 0, 167936, 0, 0, 0, 0, 0, 0, 975, 0,
  0, 0, 0, 0, 0, 316, 316, 0, 167936, 167936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 327, 0, 167936, 0, 0, 0, 40960,
  167936, 167936, 0, 0, 167936, 0, 167936, 0, 167936, 0, 0, 0, 0, 0, 2895872, 0, 0, 0, 2682880, 0, 2641920, 2609152,
  2691072, 0, 0, 0, 0, 0, 2838528, 0, 0, 2854912, 0, 0, 0, 0, 0, 0, 0, 0, 3051520, 3055616, 0, 0, 0, 0, 0, 0, 0, 167936,
  167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 0, 0, 167936, 167936, 167936, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 663, 359, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 45056, 49152, 0, 2, 3, 251, 5, 6, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 0, 172032,
  172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 0, 172032, 0, 0, 0, 0, 0, 0, 979, 400, 400,
  1117, 400, 400, 400, 1121, 400, 400, 172032, 172032, 172032, 172032, 172032, 53494, 53494, 2, 2, 3, 0, 5, 6, 0, 568,
  0, 0, 0, 0, 751, 752, 0, 0, 754, 0, 0, 0, 0, 758, 0, 0, 0, 0, 496, 2549, 496, 496, 496, 496, 520, 2553, 520, 520, 520,
  520, 520, 1576, 520, 520, 520, 520, 1580, 520, 520, 520, 520, 1585, 0, 520, 520, 496, 496, 496, 496, 496, 496, 496,
  496, 0, 520, 520, 520, 520, 520, 520, 520, 520, 1997, 520, 520, 520, 520, 520, 520, 520, 520, 2353, 496, 2354, 520, 0,
  0, 0, 0, 956, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 357, 0, 0, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  344, 0, 0, 0, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 0, 1683, 0, 0, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 731, 496, 520, 496, 496, 496, 496, 496,
  496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 496, 1960, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 520, 520, 520, 520, 2207, 0, 0, 0, 0, 2212, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496,
  496, 496, 496, 2301, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 1453, 0, 0, 1133, 496, 496, 496,
  496, 2323, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 843, 496, 496, 2335, 520, 520, 520,
  520, 520, 520, 2341, 520, 520, 520, 520, 520, 520, 520, 496, 2281, 496, 520, 2283, 520, 0, 0, 0, 496, 496, 496, 496,
  2378, 496, 2379, 2380, 496, 496, 496, 496, 496, 496, 520, 520, 520, 2451, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 0,
  2178, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 2438, 496, 496, 496, 496, 496, 496, 496, 1153, 496, 496,
  496, 496, 496, 496, 496, 496, 1466, 496, 496, 496, 496, 496, 496, 496, 0, 0, 400, 0, 496, 2410, 496, 496, 496, 496,
  496, 496, 2416, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1998, 520, 520, 520, 520,
  520, 520, 2420, 520, 520, 520, 520, 520, 520, 2426, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1605, 496, 496,
  2448, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  45056, 49152, 180769, 180769, 0, 0, 180769, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 732, 0, 0, 0, 0, 741,
  0, 0, 0, 0, 0, 0, 702, 400, 400, 718, 400, 400, 400, 400, 400, 400, 400, 1414, 400, 400, 400, 400, 0, 0, 0, 0, 0,
  2228, 0, 0, 0, 400, 2231, 400, 400, 184320, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496, 0, 520, 520, 520, 520,
  520, 520, 1996, 520, 520, 520, 520, 2000, 520, 2002, 520, 188834, 188834, 188834, 188834, 188834, 188834, 0, 0,
  188834, 188834, 188834, 188834, 188834, 0, 188834, 188834, 188834, 0, 188834, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 340, 0, 0, 0, 345, 340, 188834, 188834, 188834, 188834, 0, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0,
  0, 0, 0, 733, 0, 0, 733, 0, 0, 0, 0, 757, 0, 0, 0, 192512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 370, 0, 0,
  263, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 0, 263, 0, 263, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 945, 0, 0,
  0, 0, 359, 359, 0, 0, 359, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 764, 627, 0, 0, 0, 768, 0, 0, 0, 627, 0,
  0, 0, 0, 0, 0, 634, 0, 0, 0, 0, 0, 0, 0, 1053, 0, 0, 0, 0, 400, 400, 400, 400, 1689, 400, 400, 400, 400, 400, 400,
  400, 663, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496, 0, 520, 520, 520, 520, 246, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 2658304, 0, 2785280, 0, 0, 0, 0, 0, 0, 1028, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 951, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1788, 0, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 1601, 0,
  1603, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 699, 0, 400, 496, 496, 1987, 0, 1989, 0, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1999, 520, 2001, 520, 520, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593, 0, 0, 0, 268,
  268, 268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 980, 0, 316, 316, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 268, 0, 0, 0, 0,
  0, 0, 988, 0, 990, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0, 575, 0, 0, 0, 200704, 200704, 200971, 200704, 200971,
  200704, 200972, 200704, 200704, 200971, 200704, 200704, 200704, 200972, 200704, 200704, 200704, 200704, 200704,
  200704, 200704, 200704, 200704, 200704, 0, 200704, 0, 0, 0, 0, 0, 0, 1036, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1376, 0, 0, 0,
  0, 0, 0, 0, 0, 200704, 200971, 200704, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 945, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  792, 0, 0, 0, 0, 496, 151552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 0, 0, 2163543, 2163543, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 0, 2163543, 2163543, 2163543, 2163543, 2491223,
  2163543, 2163543, 2528087, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2601815, 2158592, 2158592, 2158592,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 2163484, 2442012, 2450204, 2163484, 0, 0, 0, 853, 0, 0, 856, 2163543, 2442071, 2450263,
  2163543, 2163543, 2163543, 2163543, 2163543, 2465792, 0, 2531328, 2985984, 0, 0, 0, 0, 2163484, 2163484, 2605852,
  2163484, 2712348, 2163484, 2163484, 2757404, 2163484, 2777884, 2798364, 2163484, 2163484, 2835228, 2163484, 2163484,
  2884380, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 3158812, 2163484, 0, 0, 0, 0, 0,
  2121728, 2757463, 2163543, 2777943, 2798423, 2163543, 2163543, 2835287, 2163543, 2163543, 2884439, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 3081047, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163484, 0, 2163543, 2163543, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543,
  2163543, 2163543, 2163543, 2163543, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408, 2158592, 2158592, 2158592,
  2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 2162688, 2163484, 2429724, 2163484, 2163484, 2163484, 2163484, 2650908,
  2745116, 2827036, 2929436, 2163484, 2974492, 2163484, 2163484, 2163484, 3101468, 2163543, 2446167, 2614044, 2163484,
  2163484, 2163484, 2659100, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2786076, 2810652,
  2163484, 2163484, 2163484, 2548508, 2163484, 2163484, 2163484, 2163484, 2634524, 2163484, 2163484, 2716444, 2736924,
  2163484, 2163484, 2814748, 0, 2163543, 2429783, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163543, 2581335, 2802460, 2163543, 2802519, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 2163543, 2163543, 2597719, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2708311, 2163543, 2163543, 2163543, 2163543, 2614103, 2163543, 2163543, 2163543, 2659159,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 3027799, 2163543, 2163543, 3076951, 2163543, 3097431,
  2163543, 2163543, 2163543, 2163484, 2474780, 2478876, 2163484, 2163484, 2163484, 2519836, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2597660, 2163484, 2163484, 2892572, 2163484, 2163484, 2958108, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 2163543, 2622295, 2163543, 2163543, 2163543, 2163543,
  2687831, 2163543, 2704215, 2163543, 2712407, 2163543, 2163543, 2876188, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2994972, 3019548, 2163484, 2163484, 2163484, 3052316, 0, 0, 0, 0, 2163543,
  2163543, 2163543, 2474839, 2478935, 2163543, 2163543, 2163543, 2519895, 2163543, 2163543, 2163543, 2634583, 2163543,
  2163543, 2716503, 2736983, 2163543, 2163543, 2814807, 2818903, 2163543, 2163543, 2909015, 2163543, 2995031, 3019607,
  2163543, 2163543, 2163543, 3052375, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 3158871,
  2163543, 2499415, 2540375, 2544471, 2163543, 2163543, 2593623, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2892631, 2163543, 2163543, 2552663, 2560855, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  3093335, 0, 0, 0, 0, 0, 0, 1052, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 2115, 496, 496, 2118, 2163484,
  2163543, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163543, 0, 2502656, 0, 0, 0, 0, 0, 2163484, 2163484, 2163484, 2163484, 2491164,
  2163484, 2163484, 2528028, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2622236, 2163484,
  2163484, 2163484, 2163484, 2687772, 2163484, 2704156, 2163484, 2601756, 2626332, 2163484, 2163484, 2163484, 2695964,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2888476, 2163484, 2163484, 3146524, 2163484,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 591, 0, 0, 0, 496, 2626391, 2163543, 2163543, 2163543, 2696023, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2888535, 2163543, 2163543, 2761559, 2163543, 2163543, 2163543,
  2855767, 2876247, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 3122007, 2163484,
  2163484, 2163543, 2163543, 0, 2494464, 0, 0, 3146583, 2163543, 2437916, 2437975, 2163484, 2163484, 2163484, 2163484,
  2163543, 2163543, 2163543, 2163543, 0, 0, 0, 0, 2514944, 0, 0, 2543616, 2592768, 0, 0, 0, 0, 2818844, 2163484,
  2163484, 2908956, 2163484, 2163484, 2954012, 2163484, 2962204, 2163484, 2163484, 3023644, 3048220, 2163484, 2163484,
  2163484, 0, 0, 2163484, 854, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 995, 0, 0, 2163484, 3175196, 0, 0, 0, 0, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2548567, 2163543, 2786135, 2810711, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163484, 2163484, 0, 0, 2958167, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 2457600, 0, 0, 0, 0, 0,
  3067904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188834, 188834, 188834, 188834, 188834, 188834, 2740224, 0, 0, 0, 0, 0,
  2158592, 2158592, 2158592, 0, 2421532, 2163484, 2163484, 2482972, 2163484, 2163484, 2163484, 2163484, 2163484,
  2708252, 2163484, 2163484, 2163484, 2163484, 2163484, 2761500, 2163484, 2163484, 2163484, 2855708, 2163484, 2585372,
  2163484, 2163484, 2683676, 2741020, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2581276, 2163484, 2163484, 2163484, 2163484, 3121948,
  2421591, 2163543, 2163543, 2483031, 2163543, 2163543, 2163543, 2585431, 2163543, 2163543, 2683735, 2741079, 2163543,
  2163543, 2163543, 2954071, 2163543, 2962263, 2163543, 2163543, 3023703, 3048279, 2163543, 2163543, 2163543, 2163543,
  3175255, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 3068700, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 3027740, 2163484, 2163484, 3076892, 2163484, 3097372, 2163484,
  0, 2445312, 0, 2445312, 2494464, 2158592, 2744320, 2973696, 2744320, 0, 2158592, 0, 2163484, 2446108, 2454300,
  2495260, 2454359, 2495319, 2163543, 2163543, 2163543, 2163543, 2650967, 2745175, 2827095, 2929495, 2163543, 2974551,
  2163543, 2163543, 2163543, 3101527, 2163484, 2163543, 0, 0, 0, 0, 0, 2846720, 0, 0, 0, 0, 0, 0, 2805760, 0, 0, 0, 0,
  944, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2203, 0, 0, 0, 0, 3178496, 2560000, 2560000, 0, 2163484, 2552604, 2560796,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 3093276, 0, 2850816, 0, 0, 0, 0, 0, 0,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543, 0, 2163484,
  2163484, 2589468, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2589527, 2163543,
  2163543, 2163484, 2831132, 2163484, 2163484, 2163484, 2986780, 2163543, 2163543, 2605911, 2163543, 2831191, 2163543,
  2163543, 2163543, 2986839, 2523136, 0, 0, 0, 0, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163543, 3068759, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163484, 2163484, 0, 0, 0, 0, 0, 2425628, 2163484, 2163484, 2163484, 2163484, 2982684, 2425687, 2163543,
  2163543, 2163543, 2163543, 2982743, 2535424, 0, 0, 2912256, 2163484, 2655004, 2933532, 2163484, 2163543, 2655063,
  2933591, 2163543, 2637824, 2699264, 2556700, 2163484, 2163484, 3080988, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 0, 0, 0, 0, 0, 0, 0, 2887680, 0, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  2158592, 2158592, 3158016, 2158592, 0, 0, 0, 0, 2163484, 2163484, 2556759, 2163543, 2163484, 2163543, 2163484,
  2163543, 2163484, 2163543, 2945820, 2945879, 0, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 0, 0, 0, 0, 359, 359, 359, 359,
  359, 359, 359, 359, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217088, 0, 0, 217088, 217088, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 2158592, 2158592, 2158592, 2158592, 2809856, 2158592, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 217088, 0, 0, 0, 0,
  0, 960, 0, 962, 0, 0, 964, 965, 0, 0, 0, 0, 0, 0, 1437, 0, 0, 0, 400, 400, 400, 400, 1443, 400, 217088, 217088,
  217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 0,
  217088, 0, 0, 0, 0, 0, 0, 217088, 217088, 217088, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1003, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 950, 0, 0, 0, 0, 0, 0, 0, 0, 57344, 0, 0, 0, 28672, 0, 0, 2658304, 0, 2785280, 0, 0, 0, 0, 0, 1019, 664,
  0, 0, 0, 0, 0, 0, 970, 0, 0, 973, 974, 0, 0, 0, 977, 0, 0, 0, 0, 316, 316, 0, 2162688, 2162688, 2162688, 264, 0, 0, 0,
  264, 0, 265, 0, 0, 0, 265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 1061, 264, 0, 265, 0, 0, 0, 2486272, 0,
  0, 0, 0, 0, 0, 0, 0, 2600960, 2162688, 2162688, 3145728, 2162688, 0, 853, 0, 0, 0, 853, 0, 856, 0, 0, 0, 856, 2162688,
  3174400, 853, 0, 856, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2547712, 2162688, 0,
  0, 0, 853, 0, 90112, 856, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 3067904, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0,
  0, 0, 221567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 993, 0, 0, 0, 0, 221603, 221603, 221603, 221603, 221603, 221603,
  221603, 221603, 221603, 221603, 0, 221603, 0, 0, 0, 0, 0, 0, 1306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 324, 324, 353, 0,
  0, 0, 221727, 221727, 221603, 221603, 221740, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1032, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1041, 0, 0, 0, 0, 0, 0, 0, 237568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1011, 0, 0, 0, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 237568, 2162688, 2162688, 2162688, 2162688, 0,
  2, 0, 176128, 294912, 0, 0, 0, 0, 0, 2441216, 2449408, 0, 2, 3, 94212, 5, 6, 0, 0, 249856, 0, 0, 0, 0, 249856, 0, 0,
  0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 0, 2179695, 0, 250276, 250276, 250276, 250276, 250276, 250276, 249856, 249856,
  250276, 250276, 250276, 250276, 250276, 249856, 250276, 250276, 250276, 249856, 250276, 249856, 249856, 249856,
  249856, 249856, 0, 249856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 0, 250276, 250276, 250276, 0, 0, 2, 2,
  3, 94212, 5, 6, 0, 0, 0, 0, 0, 1035, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 0, 0, 0, 0, 0, 114688, 0, 241664, 0, 262144,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1009, 0, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 241664, 2162688, 2162688, 2162688, 2162688, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408,
  0, 2, 3, 94212, 5, 6, 0, 0, 0, 258048, 0, 0, 0, 0, 258048, 0, 0, 0, 0, 959, 0, 0, 0, 0, 0, 0, 0, 0, 967, 0, 0, 0, 0,
  520, 1795, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1262, 520, 496, 496, 0, 258469, 258469, 258469,
  258469, 258469, 258469, 258469, 258469, 258469, 258469, 0, 258469, 0, 0, 0, 258048, 0, 0, 258469, 258469, 258469, 0,
  0, 2, 2, 3, 94212, 0, 6, 0, 0, 274432, 0, 0, 0, 253952, 266240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1021, 1021, 0, 0, 0,
  0, 2, 3, 94212, 2195708, 6, 0, 0, 0, 0, 256, 0, 0, 0, 0, 256, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270336, 0, 0, 0,
  0, 0, 1051, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 785, 400, 270336, 270336, 0, 0, 270336, 0, 0, 2,
  2, 3, 94212, 2195708, 6, 0, 0, 0, 0, 0, 1113, 0, 400, 400, 400, 400, 400, 400, 400, 1122, 400, 0, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 245760, 2162688, 2162688, 2162688, 2162688, 0,
  2, 6, 0, 0, 0, 0, 0, 0, 265, 2441216, 2449408, 278528, 278528, 0, 0, 278528, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0,
  0, 1305, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 742, 0, 0, 0, 0, 0, 53494, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  515, 0, 515, 515, 515, 515, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 1943, 400, 400, 400, 400, 0, 0, 0,
  0, 1904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1057, 400, 400, 1060, 400, 1380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 590, 0, 0, 0, 1669, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 607, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 390,
  0, 400, 400, 400, 400, 1401, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 1733, 1046, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1120, 400, 400, 400, 521, 518, 518, 518, 518, 518, 518, 518, 518,
  521, 521, 521, 521, 521, 521, 521, 518, 518, 521, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1365, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 668, 0, 0, 0, 0, 668, 53495, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 590, 0, 0, 0, 0,
  286720, 286720, 286720, 286720, 286720, 286720, 0, 0, 286720, 286720, 286720, 286720, 286720, 0, 286720, 286720,
  286720, 0, 286720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1094, 0, 0, 0, 0, 286720, 286720, 286720, 286720, 286720, 0, 0, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 316, 316, 0, 303104, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 0, 0, 0, 0, 2936832, 0, 0, 3084288, 0, 2940928, 3129344, 2416640, 229376, 0, 0, 0, 0, 0, 0, 263, 264, 265, 0,
  0, 0, 0, 0, 0, 0, 0, 2200, 0, 0, 0, 0, 0, 2205, 2206, 0, 248, 3, 94212, 5, 253, 0, 0, 0, 0, 0, 257, 0, 0, 0, 0, 0, 0,
  1335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 311, 0, 0, 0, 0, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 624, 0, 0,
  316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290816, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1095, 0, 0, 0, 0,
  290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816,
  290816, 290816, 0, 290816, 0, 0, 0, 0, 0, 0, 290816, 290816, 290816, 0, 0, 248, 248, 3, 94212, 5, 4297271, 0, 0, 0, 0,
  0, 1610, 1611, 0, 0, 0, 1615, 0, 0, 0, 0, 0, 0, 337, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 569, 0, 0, 0, 0, 0, 2105344,
  264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 131072, 2162688, 2162688, 2162688, 2162688, 0, 248,
  4297271, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408, 0, 249, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593, 0, 0, 0, 0,
  0, 0, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655, 0, 544, 544, 0, 0, 544, 0, 0, 4264502, 249, 3, 94212, 5, 6,
  0, 0, 0, 0, 0, 1611, 0, 0, 1716, 0, 1717, 0, 0, 0, 0, 400, 400, 1687, 1688, 400, 400, 400, 400, 400, 400, 400, 400, 0,
  0, 0, 0, 1935, 0, 0, 0, 0, 0, 570, 0, 0, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 135168, 0, 0, 0, 0, 0,
  0, 2162688, 2162688, 2162688, 2162688, 0, 932, 6, 0, 0, 299008, 0, 0, 0, 0, 2441216, 2449408, 0, 269, 270, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1107, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 0, 989, 0, 0, 0, 0, 0, 0,
  0, 0, 575, 0, 0, 0, 0, 0, 0, 575, 0, 0, 0, 269, 0, 270, 0, 269, 269, 270, 0, 0, 0, 0, 0, 0, 0, 1005, 0, 0, 0, 0, 0, 0,
  0, 0, 666, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 361, 363, 270, 0, 0, 0, 0, 270, 0, 368, 0, 45056, 49152, 0, 0, 0, 0, 40960,
  0, 0, 0, 0, 0, 0, 269, 0, 398, 401, 401, 401, 401, 401, 422, 422, 422, 422, 422, 445, 445, 445, 445, 445, 445, 460,
  464, 445, 445, 445, 445, 445, 460, 471, 445, 445, 445, 445, 464, 445, 464, 464, 464, 464, 464, 497, 516, 497, 497,
  497, 497, 522, 497, 497, 497, 497, 541, 541, 541, 541, 546, 546, 546, 546, 546, 546, 546, 548, 548, 557, 53494, 53494,
  2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1660, 0, 0, 0, 0, 0, 0, 0, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 1378, 0, 0, 0, 580, 581,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1326, 0, 0, 0, 0, 659, 0, 0, 0, 0, 665, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466944, 0,
  2365, 2366, 0, 0, 0, 0, 673, 0, 0, 0, 0, 577, 0, 0, 0, 0, 0, 0, 0, 0, 0, 282, 282, 0, 326, 0, 0, 0, 0, 0, 686, 0, 0,
  689, 0, 0, 0, 0, 0, 696, 0, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1158, 496, 496, 496, 400, 703, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 726, 400, 400, 400, 0,
  0, 0, 1129, 0, 0, 0, 0, 1133, 496, 496, 496, 496, 0, 0, 1987, 0, 0, 0, 0, 0, 1989, 0, 0, 0, 0, 0, 0, 774, 0, 0, 400,
  400, 703, 400, 400, 781, 726, 400, 400, 400, 0, 409600, 0, 0, 0, 0, 0, 0, 0, 410000, 400, 400, 400, 400, 400, 400,
  2098, 400, 400, 400, 0, 0, 0, 0, 2103, 0, 0, 627, 0, 0, 0, 659, 627, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 2440, 496, 496,
  496, 496, 496, 496, 800, 496, 496, 496, 496, 496, 496, 496, 826, 496, 831, 496, 834, 496, 496, 0, 1786, 0, 1792, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1581, 520, 520, 520, 496, 846, 496, 496, 0, 764, 496, 0, 520, 520,
  520, 860, 520, 520, 520, 520, 520, 520, 520, 1258, 520, 520, 520, 520, 520, 496, 496, 0, 520, 520, 886, 520, 891, 520,
  894, 520, 520, 906, 520, 520, 496, 911, 0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 2162688, 0, 520, 915, 496, 496, 800, 496, 920, 834, 496, 496, 0, 520, 520, 860, 520, 520, 520, 520,
  2422, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 2179, 0, 0, 0, 0, 0, 0, 928, 894, 520, 520, 53494, 2, 6, 0,
  0, 0, 0, 934, 938, 0, 0, 0, 0, 0, 1671, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1858, 0, 0, 0, 0, 0, 1014, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 591, 400, 400, 400, 1127, 0, 1107, 0, 0, 1014, 0, 0, 1133, 496, 496, 496, 496, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 1062, 520, 1250, 520, 520, 520, 1253, 520, 520, 520, 520, 520, 520, 520, 496, 496,
  0, 0, 0, 0, 520, 520, 520, 2144, 520, 520, 520, 520, 520, 520, 520, 520, 2267, 2268, 520, 520, 520, 520, 2272, 520,
  1432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1444, 400, 400, 400, 1448, 400, 400, 0, 0, 0, 0, 0, 1454,
  1133, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 520, 520, 520, 877, 496, 1506, 496, 496, 496, 496, 1510,
  496, 496, 496, 496, 1515, 1517, 1520, 91311, 1522, 496, 1586, 520, 496, 496, 496, 496, 1590, 496, 496, 496, 520, 520,
  520, 520, 1597, 0, 0, 0, 1608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 653, 0, 0, 0, 0, 1656, 0, 0, 0, 0, 0, 1662, 0, 0,
  0, 0, 0, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1025, 0, 0, 0, 0, 1695, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 1705, 1706, 0, 0, 1708, 400, 1723, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 496,
  496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 2460, 496, 496, 1735, 496, 1737, 496, 496, 496, 1740,
  496, 496, 496, 496, 496, 496, 496, 1184, 496, 496, 496, 496, 496, 496, 496, 496, 1478, 496, 496, 496, 496, 496, 496,
  496, 496, 1495, 496, 496, 496, 496, 496, 496, 496, 496, 1767, 496, 496, 496, 496, 496, 496, 496, 496, 520, 496, 496,
  1846, 496, 496, 496, 496, 520, 520, 1850, 520, 520, 520, 520, 246, 2, 6, 0, 0, 0, 0, 935, 939, 0, 0, 0, 1601, 0, 1603,
  0, 0, 1854, 0, 0, 0, 0, 0, 0, 1860, 0, 0, 0, 0, 0, 1881, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1040, 0, 0, 0, 0, 0, 496, 1985,
  496, 496, 0, 0, 1987, 0, 0, 0, 0, 0, 1989, 0, 0, 0, 0, 0, 1905, 0, 0, 0, 0, 0, 0, 1911, 1912, 0, 0, 0, 0, 2041, 0, 0,
  0, 0, 0, 2046, 0, 0, 0, 0, 0, 0, 0, 0, 180582, 180769, 180769, 180769, 180769, 180769, 180769, 180769, 0, 0, 2067, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1357, 0, 0, 0, 0, 2079, 2080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 2219,
  400, 400, 2105, 0, 0, 0, 0, 400, 400, 2110, 400, 400, 0, 496, 496, 496, 496, 496, 496, 496, 2500, 496, 496, 520, 520,
  520, 520, 520, 496, 2130, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1159, 496, 520, 2172,
  520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2183, 520, 520, 2275, 520, 520, 520, 520, 496, 496, 496, 520, 520, 520, 0, 0,
  0, 1288, 0, 0, 0, 1294, 0, 0, 0, 0, 0, 0, 0, 0, 2434, 0, 0, 2437, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  2502, 520, 520, 520, 520, 520, 0, 0, 2463, 2464, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520,
  520, 520, 2493, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 1545, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 2166, 520, 520, 496, 496, 496, 0, 0, 0, 271, 272, 273, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 635, 0, 0, 0, 0, 0, 0, 0, 0, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0, 375, 0, 40960, 0, 0, 375, 0,
  0, 0, 0, 0, 0, 400, 400, 400, 0, 496, 496, 496, 496, 496, 496, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362,
  362, 362, 362, 472, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 496, 362, 496, 496, 496, 496, 0, 0, 0, 0, 1988,
  0, 1518, 0, 0, 0, 1990, 0, 520, 520, 549, 549, 558, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2054, 0, 0, 0,
  0, 0, 0, 2061, 2062, 0, 0, 0, 1361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 683, 0, 0, 0, 1378, 0, 0, 0, 0, 0, 0, 0,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 520, 1571, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 496, 496, 0, 0, 0, 0, 0, 496, 496, 1950, 1951, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1186,
  496, 496, 496, 496, 1193, 496, 0, 520, 520, 1993, 1994, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  1814, 1815, 520, 1817, 520, 520, 520, 2480, 520, 2482, 520, 2484, 520, 0, 0, 0, 0, 0, 0, 0, 0, 221727, 221727, 221727,
  221727, 221727, 221727, 221727, 221727, 0, 279, 376, 377, 40960, 377, 384, 376, 377, 384, 274, 384, 0, 384, 402, 402,
  402, 402, 402, 423, 423, 423, 438, 441, 446, 446, 459, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446,
  446, 446, 473, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 498, 446, 498, 498, 498, 498, 523, 498, 498,
  498, 498, 498, 498, 498, 498, 523, 523, 523, 523, 523, 523, 523, 550, 550, 559, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0,
  0, 0, 0, 0, 2070, 0, 0, 0, 0, 0, 0, 0, 2075, 0, 0, 0, 520, 520, 496, 496, 496, 496, 496, 835, 496, 496, 0, 520, 520,
  520, 520, 520, 520, 2424, 520, 520, 520, 520, 520, 0, 2430, 0, 0, 520, 895, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 309, 310, 0, 0, 0, 0, 0, 0, 1047, 0, 0, 0, 0, 0, 0, 0, 0, 1056, 0, 400, 1059, 400, 400, 400, 400, 1079, 1080,
  400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 2230, 0, 400, 400, 400, 400, 1089, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 656, 0, 0, 0, 1056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 666, 0, 0, 0, 666, 1089, 0, 0, 0, 0, 0, 0, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 1927, 496, 496, 1144, 496, 1149, 496, 496, 496, 496, 496, 1155, 496, 496, 496,
  496, 496, 496, 1752, 1753, 496, 1755, 496, 496, 496, 496, 496, 496, 1477, 496, 496, 496, 496, 496, 496, 496, 1486,
  496, 1217, 520, 520, 520, 520, 520, 1223, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 2488, 2489, 0, 0, 0, 0,
  1381, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1393, 0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 316, 316, 0, 1396, 400, 400,
  400, 400, 400, 400, 1403, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 1933, 0, 0, 0, 0, 0, 0, 1631, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 747, 748, 496, 496, 496, 496, 1976, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  0, 0, 0, 91311, 0, 520, 520, 2019, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 496, 0,
  0, 0, 2068, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 669, 0, 0, 0, 0, 2106, 0, 2108, 0, 400, 400, 400, 2111, 400, 0, 496,
  496, 496, 496, 496, 496, 1765, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1168, 496, 496, 496, 496, 496, 496, 520,
  520, 2173, 0, 0, 0, 2177, 0, 0, 0, 0, 0, 0, 2181, 0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 2179694, 2179694, 0,
  400, 2222, 400, 0, 0, 0, 2226, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496, 496, 2117, 496, 2247, 2248, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 2338, 2339, 2340, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1260, 520, 520, 520, 496, 496, 0, 520, 520, 2479, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 496,
  496, 496, 0, 0, 0, 282, 350, 0, 0, 282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 0, 0, 0, 326, 0, 40960, 0,
  0, 326, 0, 0, 386, 0, 391, 399, 403, 403, 403, 403, 403, 424, 424, 424, 424, 442, 447, 447, 447, 447, 447, 447, 447,
  465, 447, 447, 447, 447, 447, 447, 403, 447, 447, 447, 447, 465, 447, 465, 465, 465, 465, 465, 499, 465, 499, 499,
  499, 499, 524, 499, 499, 499, 499, 499, 499, 499, 499, 524, 524, 524, 524, 524, 524, 524, 499, 499, 524, 53494, 53494,
  2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2082, 2083, 0, 0, 2086, 0, 0, 0, 0, 0, 400, 1921, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 1083, 400, 0, 0, 0, 0, 0, 0, 740, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 740, 0, 0, 0, 0, 0, 0, 520, 520,
  496, 496, 496, 817, 496, 496, 496, 496, 0, 520, 520, 520, 877, 0, 984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 968,
  0, 1076, 400, 400, 1078, 400, 400, 400, 400, 400, 400, 400, 1085, 0, 0, 0, 0, 0, 0, 1633, 0, 0, 0, 0, 0, 0, 1639, 0,
  1640, 1100, 0, 965, 0, 0, 0, 0, 0, 0, 1104, 964, 0, 0, 0, 0, 0, 0, 274, 275, 276, 277, 278, 279, 280, 0, 0, 0, 0, 0,
  0, 955, 1112, 0, 0, 400, 400, 400, 400, 1119, 400, 400, 400, 400, 400, 400, 1413, 400, 400, 400, 400, 400, 0, 0, 0, 0,
  1130, 1089, 0, 0, 1133, 1134, 1136, 496, 496, 1124, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 1133, 1135, 496, 496, 496, 0, 0,
  496, 0, 520, 520, 520, 520, 520, 520, 520, 875, 520, 0, 1330, 1331, 0, 1333, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1310,
  651264, 0, 0, 0, 1360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 955, 520, 520, 1600, 0, 1601, 0, 0, 0, 0, 0, 1603,
  0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 1606, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 969, 496,
  496, 496, 1736, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1170, 496, 496, 496, 496, 496, 496, 496,
  1776, 496, 1778, 496, 496, 496, 0, 0, 0, 0, 0, 1520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1232, 0, 0, 1917, 1918, 0, 1920, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 2104, 0,
  0, 0, 496, 1949, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 1520, 91311, 0, 496, 1973, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1172, 496, 0, 520, 1992, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 496, 496, 1040, 2065, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1013, 400, 400,
  400, 2096, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 496, 496, 496, 496, 2122, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 1518, 1520, 91311, 1523, 496, 496, 2131, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 835, 496, 496, 496, 496, 1987, 0, 1989, 0, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 2149, 0, 0, 0, 2185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 681, 0, 0, 0, 0, 0, 0, 2296, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 756, 0, 0, 0, 284, 285, 286, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1374, 0, 0, 286, 324, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1012, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 286, 285, 0, 0, 392, 285, 404, 404, 404, 404, 404, 425,
  435, 425, 425, 425, 448, 448, 448, 448, 448, 448, 461, 466, 448, 448, 448, 448, 448, 461, 404, 448, 448, 448, 448,
  466, 448, 466, 466, 492, 466, 492, 500, 466, 500, 500, 500, 500, 525, 500, 500, 500, 500, 500, 500, 500, 500, 525,
  525, 525, 525, 525, 525, 525, 500, 500, 525, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2109, 400, 400, 400,
  400, 0, 496, 496, 496, 496, 496, 496, 2251, 2253, 496, 496, 2256, 2257, 520, 520, 520, 2261, 0, 0, 597, 0, 0, 0, 0, 0,
  0, 0, 605, 606, 0, 0, 0, 0, 0, 0, 1661, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1007, 0, 0, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 316, 316, 316, 0, 0, 0, 0, 288, 289, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 949, 0, 0, 0, 0, 954, 0, 0, 642, 0, 0,
  0, 0, 0, 0, 0, 650, 0, 0, 0, 654, 0, 0, 0, 0, 288, 333, 335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 978, 0, 0, 0, 316, 316, 0,
  400, 400, 705, 400, 400, 713, 400, 719, 400, 722, 400, 725, 400, 400, 400, 400, 400, 400, 1700, 400, 400, 400, 400, 0,
  0, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 1138, 0, 0, 0, 746, 0, 0, 0, 0, 0, 630, 0, 0, 0, 0, 759, 0, 0, 765, 0, 746,
  400, 777, 400, 400, 400, 400, 782, 400, 400, 400, 400, 400, 714, 400, 400, 400, 400, 724, 400, 400, 729, 400, 400,
  738, 0, 761, 0, 0, 0, 765, 0, 0, 0, 0, 0, 0, 0, 765, 0, 0, 0, 0, 987, 950, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 651, 0, 0, 0,
  0, 0, 746, 765, 0, 0, 746, 761, 765, 0, 0, 791, 0, 0, 0, 791, 795, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520,
  520, 520, 520, 1213, 520, 520, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 937984, 0, 0, 0, 0, 0, 496, 496,
  803, 496, 496, 814, 496, 823, 496, 827, 496, 496, 833, 836, 840, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520,
  520, 520, 1209, 520, 520, 496, 520, 496, 520, 2569, 2570, 496, 520, 0, 0, 0, 0, 0, 0, 634880, 2402, 0, 0, 2405, 2406,
  0, 0, 883, 520, 887, 520, 520, 893, 896, 900, 520, 520, 520, 520, 496, 496, 0, 0, 0, 0, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 0, 520, 520, 496, 917, 496, 496, 496, 921, 840, 496, 0, 520, 925, 520, 520, 496, 496,
  520, 53494, 53813, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1354, 0, 0, 0, 0, 0, 520,
  929, 900, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 682, 0, 496, 0, 0, 0, 958, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 769, 0, 0, 0, 0, 0, 0, 1001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 952, 0, 0, 0, 520, 1218, 520, 520,
  520, 1222, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 909, 496, 496, 0, 0, 520, 1233, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 1241, 520, 520, 520, 520, 520, 520, 2483, 520, 2485, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0,
  0, 576, 0, 0, 1314, 1315, 0, 1317, 1318, 0, 0, 1321, 0, 0, 0, 0, 0, 0, 0, 0, 264, 264, 264, 264, 264, 264, 264, 264,
  0, 1346, 0, 1348, 0, 0, 0, 0, 0, 1353, 0, 1355, 0, 0, 0, 0, 0, 0, 1867, 0, 1869, 0, 0, 1871, 0, 1873, 0, 0, 0, 0, 0,
  0, 0, 400, 1942, 400, 400, 400, 400, 400, 400, 400, 1728, 400, 400, 0, 0, 0, 1731, 496, 496, 0, 1372, 0, 0, 1374, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1324, 0, 0, 0, 0, 0, 0, 0, 1383, 1384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1395, 0, 400, 1397,
  1398, 400, 400, 400, 400, 400, 1404, 400, 400, 1406, 400, 400, 400, 400, 400, 715, 400, 720, 400, 400, 400, 400, 727,
  400, 400, 400, 400, 400, 1450, 0, 0, 0, 0, 1070389, 0, 1133, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520,
  520, 873, 520, 520, 1422, 0, 0, 1425, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1298, 1425, 0, 0, 0, 0, 1018, 0, 0, 0, 1022, 0, 0, 0,
  0, 0, 0, 0, 270, 269, 0, 269, 269, 270, 270, 0, 0, 0, 0, 0, 1434, 0, 0, 0, 1438, 872448, 0, 1440, 400, 400, 1410, 400,
  400, 400, 1412, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 375, 362, 362, 362, 362, 362, 362, 400, 1446, 400, 400, 400,
  400, 0, 0, 0, 0, 0, 0, 1133, 1455, 496, 1456, 496, 1458, 496, 496, 496, 496, 496, 496, 496, 1467, 496, 496, 496, 496,
  1471, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 1210, 520, 520, 520, 520, 1833, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 1827, 520, 520, 520, 496, 496, 1474, 496, 496, 496, 496, 496, 496, 1480,
  1482, 496, 496, 496, 496, 1487, 1488, 496, 1490, 1491, 496, 496, 496, 496, 496, 496, 1498, 496, 1500, 496, 496, 496,
  0, 0, 496, 0, 520, 520, 520, 520, 520, 867, 520, 520, 879, 496, 496, 496, 1507, 496, 496, 496, 496, 496, 496, 1514, 0,
  0, 1520, 91311, 0, 0, 0, 0, 1050, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 1923, 400, 400, 400, 400, 400, 400, 1520,
  1525, 520, 1526, 520, 1528, 520, 520, 520, 520, 520, 520, 520, 1537, 520, 520, 496, 520, 496, 496, 496, 496, 520, 520,
  520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1299, 520, 520, 1541, 520, 520, 520, 1544, 520, 520, 520, 520, 520, 520,
  1550, 1552, 520, 520, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 935, 939, 0, 0, 0, 0, 0, 2466, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 2476, 1570, 520, 520, 520, 520, 520, 520, 1577, 520, 520, 520, 520, 520, 520, 1584, 496, 0, 0, 0, 853,
  91311, 1133, 856, 520, 520, 520, 520, 1207, 520, 520, 520, 520, 520, 2163, 520, 520, 520, 520, 520, 520, 520, 496,
  496, 496, 520, 520, 520, 0, 0, 0, 496, 520, 520, 1587, 496, 496, 1482, 1491, 496, 1592, 496, 1594, 520, 520, 1552,
  1561, 520, 1599, 520, 0, 1601, 0, 0, 0, 0, 0, 1603, 0, 0, 0, 0, 0, 0, 332, 355, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0,
  1668, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1680, 0, 0, 0, 0, 1091, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2191, 0, 0, 0, 0,
  1682, 0, 0, 1685, 400, 400, 400, 400, 400, 400, 1691, 400, 400, 400, 400, 400, 400, 400, 1701, 1702, 400, 400, 0, 0,
  0, 0, 0, 0, 601, 0, 0, 0, 0, 0, 0, 0, 0, 0, 738, 0, 743, 0, 746, 0, 0, 496, 496, 496, 1762, 1763, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 0, 1519, 1520, 91311, 1524, 520, 1805, 520, 1807, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 2395, 520, 520, 496, 520, 496, 496, 496, 496, 1848, 496, 496, 520, 520, 520, 520,
  1852, 520, 520, 496, 520, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 0, 2039, 0, 0, 1864, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1392, 0, 0, 1889, 1890, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 364544, 0, 0, 0, 0, 1092, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 2298, 0, 0, 0, 0, 0, 0, 1903, 0, 0, 0, 0, 0, 0, 0, 0, 1910, 0, 0, 0, 0, 0, 0, 1894, 0, 0, 0, 0, 0, 0,
  0, 0, 1902, 400, 400, 400, 1930, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 2311, 400, 0,
  1007616, 1007616, 0, 0, 0, 0, 520192, 1889, 0, 364944, 400, 400, 400, 400, 400, 1008016, 496, 496, 496, 1975, 496,
  496, 496, 496, 1980, 496, 496, 496, 496, 496, 496, 1984, 1008112, 496, 496, 496, 827392, 0, 1987, 0, 0, 0, 0, 0, 1989,
  0, 0, 0, 0, 0, 2187, 0, 0, 0, 0, 0, 0, 0, 0, 2194, 2195, 520, 2018, 520, 520, 520, 520, 2023, 520, 520, 520, 520, 520,
  520, 2027, 1008136, 520, 520, 520, 520, 975368, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 0, 2071, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 735, 0, 0, 0, 2107, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496, 496, 496, 496, 496,
  1978, 496, 496, 496, 496, 1982, 496, 496, 496, 496, 496, 2120, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 2129, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 1206, 520, 520, 1215, 520, 520, 520, 889, 520, 520,
  520, 520, 904, 520, 520, 520, 797, 496, 0, 0, 0, 853, 0, 0, 856, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  1564, 520, 520, 520, 520, 520, 496, 496, 1987, 0, 1989, 0, 520, 520, 520, 520, 520, 520, 2147, 520, 520, 520, 0, 1284,
  0, 0, 0, 1290, 0, 0, 0, 0, 0, 0, 0, 0, 2363, 0, 2364, 0, 0, 0, 2368, 0, 520, 520, 2161, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 496, 496, 496, 520, 520, 520, 0, 0, 2286, 0, 2196, 0, 905216, 0, 0, 0, 2199, 0, 2201, 0, 0, 0,
  667648, 0, 0, 0, 0, 319, 0, 302, 364, 366, 0, 0, 0, 319, 0, 45056, 49152, 2221, 400, 2223, 2224, 0, 2225, 0, 0, 0,
  2229, 0, 479232, 400, 400, 2232, 400, 400, 400, 707, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0,
  1087, 0, 0, 520, 2274, 2276, 520, 520, 2279, 2280, 496, 496, 2282, 520, 520, 2284, 0, 0, 0, 0, 0, 2198, 0, 0, 0, 0,
  2202, 0, 0, 0, 0, 0, 0, 664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2613248, 0, 0, 0, 0, 0, 0, 2288, 0, 0, 2290, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1340, 0, 1342, 0, 0, 901120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 696320, 1015808, 0, 0, 0, 0, 324, 0,
  325, 0, 0, 0, 0, 0, 0, 283, 325, 286, 0, 0, 0, 0, 2304, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 0, 0, 1452, 0, 0,
  0, 1133, 496, 496, 496, 496, 520, 520, 2337, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2345, 520, 520, 520,
  890, 892, 520, 520, 902, 520, 520, 520, 520, 910, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1838, 520, 1840, 520, 520, 520, 0, 0, 2433, 0, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 845, 496, 2447, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2457, 0, 0, 0, 0,
  0, 0, 1906, 0, 0, 1909, 0, 0, 0, 0, 0, 0, 0, 1103, 1037, 0, 0, 0, 0, 0, 0, 944, 520, 2478, 520, 520, 520, 520, 520,
  520, 520, 2486, 2487, 0, 0, 0, 0, 0, 0, 663, 1021, 0, 0, 0, 0, 0, 0, 0, 1028, 0, 2494, 496, 496, 2496, 496, 2498, 496,
  496, 496, 496, 2503, 520, 520, 2505, 520, 520, 520, 907, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 739, 0, 744, 0, 0, 0,
  0, 2507, 520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 2442, 496, 2444, 2445, 0, 0, 0, 287, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 981, 316, 316, 0, 0, 316, 0, 0, 0, 0, 0, 0, 320, 0, 0, 0, 0, 0, 0, 0, 0, 286720, 286720,
  286720, 286720, 286720, 286720, 286720, 286720, 0, 0, 329, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1617, 0, 0, 0, 0,
  320, 0, 0, 0, 0, 0, 0, 367, 0, 320, 0, 367, 45056, 49152, 0, 320, 0, 378, 40960, 378, 378, 287, 378, 378, 0, 378, 0,
  378, 405, 405, 405, 405, 405, 0, 0, 0, 320, 443, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378,
  405, 378, 378, 378, 378, 484, 378, 484, 484, 493, 484, 493, 501, 484, 501, 501, 501, 501, 526, 501, 501, 501, 501,
  501, 501, 501, 501, 526, 526, 526, 526, 526, 526, 526, 501, 501, 526, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0,
  0, 2305, 0, 0, 400, 400, 400, 400, 400, 400, 400, 0, 327, 0, 360, 360, 0, 0, 0, 0, 0, 0, 0, 1428, 0, 0, 0, 0, 0, 0,
  651264, 0, 496, 496, 496, 666, 0, 496, 0, 520, 520, 520, 520, 520, 520, 520, 520, 878, 0, 520, 520, 916, 496, 496,
  818, 496, 496, 496, 496, 0, 924, 520, 520, 878, 1063, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 1109, 0, 0, 0, 0, 400, 1116, 400, 400, 400, 400, 400, 400, 400, 1070, 400, 400, 400,
  400, 400, 400, 400, 400, 1082, 400, 1084, 0, 0, 0, 0, 0, 496, 496, 1145, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 839, 496, 496, 0, 520, 520, 496, 1269, 496, 496, 496, 496, 496, 496, 520, 1277, 520, 520, 520, 0,
  1285, 0, 0, 0, 1291, 0, 0, 0, 0, 0, 0, 0, 602, 0, 0, 0, 0, 0, 0, 0, 0, 736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 736,
  0, 0, 0, 496, 400, 400, 1724, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 520, 520, 520, 520,
  0, 0, 496, 2563, 520, 520, 1819, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 2170, 0,
  0, 1878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1629, 0, 0, 400, 400, 1929, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0,
  1936, 0, 0, 0, 0, 351, 0, 0, 0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1679, 0, 0, 0, 0, 0, 0, 2533, 496, 496, 496, 496, 496, 2539, 520, 520, 520, 520, 520, 520, 520, 2266, 520,
  520, 2269, 520, 520, 520, 520, 520, 520, 520, 2009, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2428, 520, 0, 0,
  0, 2432, 0, 0, 0, 0, 2559, 496, 496, 496, 2561, 520, 520, 520, 0, 0, 496, 496, 496, 2238, 496, 496, 496, 496, 496,
  496, 496, 2243, 496, 496, 2246, 0, 0, 0, 331, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 994, 0, 0, 0, 0, 0, 0, 379, 40960,
  379, 379, 0, 379, 379, 0, 379, 393, 379, 406, 406, 406, 406, 406, 426, 426, 426, 426, 426, 449, 449, 449, 449, 449,
  449, 449, 449, 449, 449, 449, 449, 449, 449, 406, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 502, 449,
  502, 502, 502, 502, 527, 502, 502, 502, 502, 502, 502, 502, 502, 527, 527, 527, 527, 527, 527, 527, 502, 502, 527,
  53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2361, 2362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1870, 0, 0, 0, 0, 1874, 0,
  0, 0, 1048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496, 2116, 496, 496, 0, 0, 1382, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1861, 0, 0, 400, 400, 400, 1725, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496,
  496, 2537, 496, 520, 520, 520, 520, 2543, 520, 496, 520, 496, 496, 496, 1847, 496, 496, 496, 520, 520, 520, 1851, 520,
  520, 520, 0, 1601, 0, 0, 0, 0, 0, 1603, 0, 0, 0, 0, 0, 0, 0, 2920448, 0, 0, 0, 2158592, 2158592, 2158592, 2543616,
  2158592, 0, 0, 0, 0, 2069, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1377, 0, 0, 0, 0, 0, 2078, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 0, 933888, 0, 1011712, 0, 0, 0, 0, 2189, 0, 0, 0, 0, 0, 0, 0, 0, 292, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 2209, 0, 0, 0, 0, 0, 2214, 0, 0, 400, 400, 400, 400, 400, 1402, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 1071, 400, 400, 400, 400, 400, 400, 0, 0, 2302, 0, 0, 0, 2306, 0, 2308, 400, 400, 400, 400, 400, 400,
  0, 581632, 0, 0, 0, 0, 1133, 496, 496, 496, 496, 496, 496, 2325, 496, 496, 496, 496, 2328, 496, 496, 496, 496, 496,
  496, 496, 1739, 496, 496, 1742, 496, 496, 496, 496, 496, 496, 520, 2336, 520, 520, 520, 520, 520, 520, 520, 2343, 520,
  520, 520, 520, 2346, 0, 0, 2370, 400, 400, 2371, 400, 400, 0, 0, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 2418, 496, 496, 2375, 496, 496, 496, 496, 496, 496, 2381, 496, 496, 496, 496, 496, 520, 520, 2450, 520, 520, 520,
  520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2182, 0, 520, 520, 520, 2387, 520, 520, 520, 520, 520, 520, 2393,
  520, 520, 520, 520, 520, 520, 520, 410096, 496, 496, 410120, 520, 520, 0, 0, 0, 0, 612, 613, 0, 0, 0, 617, 0, 0, 0, 0,
  316, 316, 316, 0, 0, 0, 0, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 652, 0, 0, 0, 0, 496, 801, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1485, 496, 496, 847, 496, 0, 852, 496, 0, 520, 520, 520, 861, 520, 520,
  520, 520, 520, 520, 895, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 520, 520, 496, 496, 801, 496, 496, 496, 496, 847,
  0, 520, 520, 861, 520, 520, 520, 1221, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 2490,
  0, 0, 496, 496, 1179, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1501, 496, 496, 0, 0, 0, 1332,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1010, 0, 0, 0, 0, 0, 1607, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1901, 0, 0, 0,
  0, 0, 0, 802816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1638, 0, 0, 0, 0, 0, 0, 0, 2314, 0, 0, 2315, 400, 400, 0, 496, 496,
  496, 496, 496, 496, 496, 496, 2240, 496, 496, 496, 496, 496, 496, 0, 0, 0, 289, 288, 0, 0, 0, 0, 0, 0, 0, 288, 0,
  45056, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 394, 0, 407, 407, 407, 407, 407, 427, 427, 427, 427, 427, 450,
  450, 450, 450, 450, 450, 450, 450, 450, 450, 503, 450, 503, 503, 503, 503, 450, 450, 450, 450, 450, 450, 462, 450,
  450, 450, 450, 450, 450, 462, 474, 450, 528, 503, 503, 503, 503, 503, 503, 503, 503, 528, 528, 528, 528, 528, 528,
  528, 551, 551, 560, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0,
  0, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496,
  106496, 106496, 0, 685, 0, 0, 0, 0, 691, 0, 0, 0, 695, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 2372, 496, 496,
  496, 496, 0, 0, 0, 1786, 0, 0, 0, 0, 0, 1792, 0, 0, 400, 400, 706, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 1074, 400, 1075, 400, 771, 0, 0, 0, 775, 0, 400, 400, 400, 400, 400, 400, 400, 783, 400, 786, 0, 0,
  767, 0, 0, 0, 0, 767, 0, 775, 0, 0, 0, 775, 0, 496, 2495, 496, 496, 496, 496, 496, 496, 496, 496, 520, 2504, 520, 520,
  520, 0, 0, 1288, 0, 0, 0, 0, 0, 1294, 0, 0, 0, 0, 0, 0, 2105344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200704, 200704, 200704,
  200704, 200704, 200704, 496, 496, 804, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1502, 496,
  496, 496, 848, 496, 0, 0, 496, 0, 520, 520, 520, 520, 864, 520, 520, 520, 520, 520, 1254, 520, 520, 520, 520, 1261,
  520, 520, 496, 496, 0, 0, 520, 520, 496, 496, 496, 496, 496, 496, 922, 848, 0, 520, 520, 520, 520, 520, 1255, 520,
  520, 520, 520, 520, 520, 520, 496, 496, 0, 520, 520, 930, 908, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 0, 0, 0,
  0, 996, 0, 0, 0, 0, 1017, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1026, 0, 0, 0, 0, 0, 0, 1090, 0, 0, 0, 0, 0, 0, 0, 0,
  1096, 0, 0, 0, 0, 0, 111009, 111009, 111009, 111009, 111009, 417, 417, 417, 417, 417, 111009, 1139, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1174, 1160, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 1746, 520, 520, 1251, 520, 520, 520, 520, 1257, 520, 520, 520, 520, 520, 496, 496, 0, 0,
  0, 0, 520, 520, 2143, 520, 520, 520, 520, 520, 520, 520, 520, 1823, 520, 520, 520, 520, 520, 520, 520, 520, 1259, 520,
  520, 520, 520, 496, 496, 0, 0, 0, 1316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2193, 0, 0, 0, 0, 1347, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1359, 520, 520, 1555, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1567, 520, 520, 496, 520,
  496, 496, 2031, 496, 520, 520, 2034, 520, 2036, 2037, 0, 0, 0, 0, 496, 496, 496, 496, 2552, 496, 520, 520, 520, 520,
  2556, 520, 1734, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2139, 1876, 0, 0, 0, 1880,
  0, 0, 0, 0, 1883, 0, 0, 0, 0, 0, 0, 0, 1336, 1337, 0, 0, 0, 0, 0, 0, 0, 0, 761856, 0, 0, 0, 0, 0, 0, 0, 0, 913408, 0,
  0, 0, 0, 0, 0, 0, 0, 3133440, 0, 2727936, 0, 0, 0, 0, 0, 1915, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 1408, 0, 0, 1947, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1758,
  496, 496, 400, 2094, 400, 400, 400, 400, 400, 400, 2099, 400, 0, 0, 0, 0, 0, 0, 0, 1351, 0, 0, 0, 0, 0, 0, 0, 0, 737,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 496, 496, 496, 496, 2132, 496, 496, 496, 496, 2135, 496, 496, 496, 496, 2138,
  496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 1205, 520, 520, 520, 520, 520, 520, 2352, 520, 496, 496, 520, 520, 0,
  0, 0, 0, 0, 0, 0, 0, 2211, 0, 0, 0, 0, 0, 2216, 400, 400, 400, 400, 2220, 496, 496, 496, 496, 2250, 496, 496, 496,
  496, 496, 496, 496, 520, 520, 520, 520, 520, 1543, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1565, 520,
  520, 520, 520, 0, 0, 2359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2367, 0, 0, 0, 0, 400, 2408, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 1191, 496, 496, 496, 2446, 496, 520, 520, 520, 520, 2452, 520, 2454, 2455,
  2456, 520, 0, 0, 0, 0, 0, 0, 2045, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1023, 0, 0, 0, 0, 0, 0, 2519, 496, 2520, 496, 496, 496,
  520, 520, 520, 2525, 520, 2526, 520, 520, 520, 0, 0, 1287, 0, 0, 0, 1293, 0, 0, 0, 0, 0, 0, 0, 1647, 0, 1648, 0, 0, 0,
  1652, 0, 0, 520, 520, 2565, 2566, 496, 520, 496, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 0, 2403, 0, 0, 0, 0, 0, 0, 0, 0,
  660, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1301, 0, 0, 0, 1818, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1569, 0, 0, 330, 332, 0, 0, 0, 332, 0, 0, 0, 0, 0, 0, 0, 0, 544, 544, 544, 544, 544, 544, 544,
  544, 0, 0, 0, 380, 40960, 380, 380, 0, 380, 380, 387, 380, 0, 380, 408, 408, 408, 408, 408, 428, 428, 428, 428, 428,
  451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 408, 451, 451, 451, 451, 451, 486, 451, 451,
  451, 451, 451, 504, 451, 504, 504, 504, 504, 529, 504, 504, 504, 504, 504, 504, 504, 504, 529, 529, 529, 529, 529,
  529, 529, 504, 504, 529, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 135168, 135168, 135168, 135168, 135168,
  135168, 135168, 135168, 135168, 135168, 135168, 0, 590, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 1407, 400, 0, 652, 0, 0, 0, 0, 0, 0, 0, 0, 0, 590, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 1956, 496, 1958, 496, 496, 496, 806, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1469, 496,
  496, 496, 496, 496, 496, 850, 0, 496, 0, 520, 520, 520, 520, 520, 866, 520, 520, 520, 520, 520, 2351, 520, 520, 496,
  496, 520, 520, 0, 0, 0, 0, 0, 0, 1427, 0, 1429, 0, 0, 1431, 0, 0, 0, 0, 0, 0, 1385, 1386, 0, 0, 1389, 0, 0, 0, 0, 0,
  0, 664, 0, 0, 667, 0, 0, 0, 0, 0, 0, 0, 1307, 0, 0, 0, 0, 0, 1311, 0, 0, 400, 400, 1077, 400, 400, 400, 400, 400, 400,
  400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 1140, 1146, 496, 496, 496, 496, 496, 496, 496, 496, 1156, 496, 496,
  496, 496, 0, 1782, 1987, 0, 0, 0, 0, 1788, 1989, 0, 0, 0, 496, 496, 496, 1180, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 1192, 496, 496, 496, 496, 496, 1764, 496, 496, 496, 1768, 496, 496, 496, 496, 496, 496, 818, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1481, 496, 496, 496, 496, 496, 496, 496, 315392, 0, 0, 853, 91311, 1133, 856, 520, 520, 520,
  520, 520, 1208, 1214, 520, 520, 520, 1252, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 0, 2141,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 908, 520, 496, 496, 0, 0, 0, 520, 520, 496, 496, 1140, 496, 496,
  1180, 496, 496, 520, 520, 1208, 520, 520, 496, 520, 496, 520, 496, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 355, 0, 1248, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1101824, 372, 372, 1300, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1099, 0, 0, 1362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1325, 0, 0, 1328, 496, 496, 1460, 1461,
  496, 496, 496, 1465, 496, 496, 496, 496, 496, 496, 496, 496, 1754, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1475, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1484, 496, 496, 496, 1520, 520, 520, 520, 520, 520,
  1530, 1531, 520, 520, 520, 1535, 520, 520, 520, 520, 520, 1559, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  2270, 2271, 520, 520, 520, 1619, 0, 0, 0, 0, 0, 0, 1625, 0, 0, 0, 0, 0, 0, 0, 0, 587, 588, 0, 0, 0, 0, 0, 0, 1655, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1313, 0, 1667, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1032, 0, 520, 520,
  1831, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 2169, 496, 0, 0, 0, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1955, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 863, 520, 520, 874, 520, 0, 0, 0,
  2042, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 0, 0, 0, 2081, 0, 0, 0, 0, 0, 2087, 0, 0, 0, 0, 400, 400,
  400, 400, 400, 0, 806912, 807312, 0, 496, 496, 496, 496, 2239, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0,
  1783, 0, 0, 0, 1520, 2093, 400, 400, 400, 400, 400, 400, 400, 400, 400, 2100, 0, 0, 0, 0, 0, 0, 690, 0, 0, 0, 0, 697,
  698, 0, 700, 400, 520, 520, 520, 2350, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 0, 2055, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 293, 294, 0, 0, 0, 0, 0, 520, 2508, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 2517, 496, 496, 496, 496, 496,
  1963, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 1784, 0, 0, 1520, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 322, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 395, 0, 409, 409, 409, 409, 409, 429, 429, 437, 429, 429, 452,
  452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 475, 452, 452, 452, 452, 452, 452, 452, 452, 452,
  452, 452, 505, 452, 505, 505, 505, 505, 530, 505, 505, 505, 505, 542, 542, 542, 542, 547, 547, 547, 547, 547, 547,
  547, 505, 505, 547, 53494, 53813, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 151552, 2105344, 264, 265, 0, 208896, 0, 0, 0,
  0, 0, 0, 0, 2818048, 0, 2879488, 0, 2961408, 0, 2977792, 0, 0, 0, 591, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 496, 807, 496, 496, 819, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1497, 496, 496, 496, 496, 496, 496, 0, 520, 520, 496, 496, 496, 819, 496, 496, 496, 496, 0, 520, 520, 520, 879, 1030,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1336, 496, 1141, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1503, 1504, 1249, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 0,
  520, 2142, 520, 520, 2145, 520, 520, 520, 520, 520, 520, 899, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 520, 520,
  496, 496, 1141, 496, 496, 496, 1274, 496, 520, 520, 1209, 520, 520, 496, 520, 496, 2030, 496, 496, 520, 2033, 520,
  520, 0, 0, 2038, 0, 520, 1282, 520, 0, 0, 1286, 0, 0, 0, 1292, 0, 0, 0, 0, 0, 0, 0, 1612, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  278528, 278528, 278528, 278528, 278528, 278528, 278528, 1520, 520, 520, 520, 520, 520, 520, 520, 1532, 520, 520, 520,
  520, 520, 520, 520, 520, 1226, 520, 520, 520, 520, 520, 520, 520, 520, 1238, 520, 520, 520, 520, 520, 520, 1248, 520,
  1540, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1247, 520, 1554, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1842, 0, 0, 0, 1658, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1356, 0, 0,
  0, 0, 1790, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2003, 520, 520, 1806, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1264, 496, 0, 0, 0, 974848, 0, 0, 0, 400, 400, 975248, 0,
  496, 496, 496, 496, 496, 496, 496, 496, 2241, 496, 496, 496, 496, 496, 496, 0, 316, 293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1391, 0, 0, 0, 0, 0, 0, 293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 0, 0, 0, 0, 338, 0, 0, 0, 45056, 49152, 0,
  0, 0, 0, 40960, 0, 0, 293, 0, 0, 388, 0, 0, 0, 410, 410, 410, 410, 410, 430, 436, 436, 436, 430, 436, 436, 436, 436,
  436, 436, 436, 436, 436, 436, 470, 436, 436, 436, 410, 436, 481, 470, 436, 485, 436, 485, 485, 485, 485, 485, 506,
  485, 506, 506, 506, 506, 531, 506, 506, 506, 506, 506, 506, 506, 506, 531, 531, 531, 531, 531, 531, 531, 506, 506,
  531, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 163840, 163840, 163840, 163840, 163840, 163840, 163840,
  163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 595, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1344, 632, 0, 0, 0, 0, 0, 0, 0, 0, 694, 0, 0, 0, 0, 0, 400, 400, 1922, 400, 400, 400, 400, 1925, 400, 400, 400,
  701, 400, 400, 709, 400, 400, 717, 400, 400, 400, 723, 400, 400, 400, 730, 400, 400, 400, 708, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 0, 1086, 0, 0, 0, 749, 0, 629, 0, 0, 0, 0, 749, 0, 0, 0, 0, 732, 0, 0, 592, 0,
  760, 0, 0, 632, 0, 0, 0, 749, 0, 0, 732, 592, 770, 0, 732, 0, 772, 632, 0, 0, 0, 701, 400, 400, 779, 400, 400, 400,
  400, 730, 400, 400, 400, 710, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 2101, 0, 0, 0, 0, 797,
  496, 496, 808, 496, 496, 820, 496, 496, 496, 829, 496, 496, 496, 496, 844, 496, 496, 496, 851, 0, 496, 0, 520, 520,
  857, 520, 520, 868, 520, 520, 880, 0, 857, 520, 797, 496, 496, 919, 496, 496, 496, 496, 0, 857, 520, 520, 927, 983, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 997, 0, 0, 0, 946, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1043, 0, 0, 0, 0, 496, 496, 496,
  2560, 520, 520, 520, 2562, 0, 0, 496, 496, 496, 496, 2497, 496, 2499, 496, 496, 496, 520, 520, 520, 520, 2506, 0,
  1101, 0, 0, 0, 1087, 0, 0, 0, 0, 0, 0, 1106, 0, 0, 0, 0, 0, 172032, 172032, 172032, 172032, 172032, 172032, 172032,
  172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 1175, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 2334, 0, 520, 520, 496, 496, 1270, 496, 496, 1273, 496, 496, 520, 520, 1278, 520,
  520, 496, 520, 2567, 2568, 496, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 1634, 0, 0, 0, 0, 0, 0, 0, 0, 265, 265, 265, 265,
  265, 265, 265, 265, 1281, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1297, 0, 0, 0, 0, 496, 496, 2535, 2536, 496, 496,
  520, 520, 2541, 2542, 520, 520, 496, 520, 365040, 496, 496, 496, 365064, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1296, 0, 1298, 0, 1329, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1618, 400, 400, 1447, 400, 400, 400, 1451, 0, 0,
  0, 0, 0, 1133, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 862, 865, 520, 872, 520, 520, 1505, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 0, 0, 1520, 91311, 0, 0, 0, 0, 1102, 0, 1057, 1091, 0, 0, 0, 0, 0, 0, 0, 1102, 0, 0,
  1643, 1644, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1616, 0, 0, 0, 0, 0, 1684, 0, 1686, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 1072, 400, 400, 400, 400, 0, 0, 0, 1712, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 2218, 400, 400,
  400, 496, 496, 1761, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1770, 496, 496, 496, 496, 496,
  1775, 496, 496, 496, 496, 496, 496, 0, 0, 0, 0, 0, 1520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 1538, 520, 520, 520, 520, 2511, 0, 0, 0, 0, 2513, 0, 0, 2516, 496, 496, 496, 496, 496, 1738, 496, 496, 496, 496,
  496, 1743, 496, 1745, 496, 496, 0, 0, 0, 0, 1866, 0, 0, 1868, 0, 0, 0, 0, 0, 0, 0, 0, 616, 0, 0, 0, 0, 0, 0, 496, 0,
  0, 0, 1879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1651, 0, 0, 0, 0, 0, 0, 1892, 0, 1893, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  992, 0, 0, 0, 0, 0, 0, 1916, 0, 0, 1919, 400, 400, 400, 400, 400, 1924, 400, 400, 400, 1926, 400, 400, 400, 711, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 573440, 0, 0, 0, 496, 496, 400, 1928, 400, 400, 400, 400, 400,
  400, 0, 0, 0, 1934, 0, 0, 0, 0, 0, 0, 2188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1039, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1938, 0, 1940,
  0, 0, 0, 400, 400, 400, 400, 1945, 400, 400, 400, 400, 1411, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 2227, 0,
  0, 0, 0, 400, 400, 400, 2233, 0, 0, 0, 496, 496, 496, 496, 496, 496, 1953, 496, 496, 496, 496, 1957, 496, 0, 0, 0,
  853, 91311, 1133, 856, 1202, 1204, 520, 520, 520, 520, 1212, 520, 520, 520, 520, 2481, 520, 520, 520, 520, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 592, 0, 594, 1959, 496, 496, 496, 496, 496, 496, 496, 496, 1966, 496, 496, 496, 496, 496,
  496, 1183, 496, 496, 496, 496, 1189, 496, 496, 496, 496, 2051, 0, 0, 0, 0, 0, 0, 2056, 2057, 0, 0, 0, 0, 0, 0, 0, 264,
  265, 0, 0, 0, 0, 0, 577, 0, 2150, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2016,
  2171, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1872, 0, 0, 0, 0, 0, 0, 0, 2186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1650, 0, 0, 0, 0, 2234, 496, 2236, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2244, 2245, 496, 0, 0, 1196,
  853, 91311, 1133, 856, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1546, 520, 520, 520, 520, 520, 520, 496, 496, 496,
  2249, 496, 496, 496, 496, 496, 496, 496, 496, 520, 2259, 520, 520, 520, 520, 1821, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1829, 520, 0, 0, 0, 569344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1886, 0, 0, 0, 2322, 496, 496, 496, 496,
  496, 496, 496, 496, 2329, 496, 496, 496, 496, 496, 496, 1464, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1513, 496,
  0, 0, 1520, 91311, 0, 2347, 520, 520, 520, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 0, 2297, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1313, 0, 0, 0, 0, 0, 0, 496, 496, 2376, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520,
  520, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 1225, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 1824, 1825, 520, 520, 520, 520, 520, 868352, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 2441, 496, 496, 496,
  496, 496, 1150, 496, 496, 496, 1154, 496, 496, 496, 496, 496, 496, 817, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1187, 496, 496, 496, 496, 496, 496, 2461, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 2473, 496, 2475, 520, 520,
  520, 1284, 1601, 0, 0, 0, 0, 1290, 1603, 0, 0, 0, 0, 0, 0, 0, 2772992, 0, 0, 0, 0, 2113536, 0, 0, 0, 0, 296, 298, 297,
  40960, 297, 297, 298, 385, 297, 296, 297, 0, 297, 411, 411, 411, 411, 411, 431, 431, 431, 439, 444, 453, 453, 453,
  453, 453, 453, 453, 467, 453, 453, 453, 453, 453, 453, 411, 453, 453, 453, 453, 467, 453, 467, 491, 467, 491, 467,
  507, 491, 507, 507, 507, 507, 532, 507, 507, 507, 507, 507, 507, 507, 507, 532, 532, 532, 532, 532, 532, 532, 507,
  507, 532, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 188834, 188834, 188834, 188834, 188834, 0, 0, 0, 0, 0,
  188834, 0, 0, 0, 582, 583, 584, 585, 586, 0, 0, 0, 0, 0, 0, 0, 0, 633, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 598, 0, 600, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0, 0, 0, 614, 0, 0, 0, 0, 0, 0, 621, 316, 316, 316, 0, 0, 0, 0, 496,
  496, 2550, 2551, 496, 496, 520, 520, 2554, 2555, 520, 520, 496, 520, 496, 496, 496, 2032, 520, 520, 520, 2035, 0, 0,
  0, 0, 0, 0, 2213, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1690, 400, 400, 400, 400, 400, 400, 0, 626, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 638, 0, 0, 0, 0, 496, 2534, 496, 496, 496, 2538, 520, 2540, 520, 520, 520, 2544, 641, 0, 643, 0, 645,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1885, 0, 0, 0, 0, 0, 0, 687, 745472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 1441, 400,
  651664, 400, 400, 400, 704, 400, 400, 712, 400, 400, 400, 721, 400, 400, 400, 400, 728, 400, 400, 400, 400, 1449, 400,
  0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 870, 520, 520, 520, 0, 2175, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 3088384, 0, 0, 0, 0, 0, 0, 0, 762, 0, 0, 0, 614, 0, 621, 758, 0, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0,
  0, 0, 599, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1105, 0, 0, 0, 0, 645, 0, 614, 678, 789, 0, 0, 614, 0, 621, 0, 0, 678,
  794, 0, 496, 0, 1085, 0, 853, 91311, 1133, 856, 1203, 520, 520, 520, 520, 520, 520, 520, 520, 520, 655880, 520, 2012,
  520, 2014, 520, 520, 496, 802, 805, 496, 812, 496, 496, 496, 825, 828, 496, 496, 496, 837, 841, 496, 0, 335872, 0,
  853, 91311, 1133, 856, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1837, 520, 520, 520, 520, 520, 520, 520, 885, 888,
  520, 520, 520, 897, 901, 520, 520, 520, 520, 496, 825, 0, 0, 0, 0, 520, 520, 520, 520, 520, 520, 520, 1800, 520, 520,
  520, 520, 520, 1236, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1242, 520, 520, 520, 520, 0, 520, 885,
  496, 496, 918, 496, 496, 837, 841, 923, 0, 520, 520, 926, 520, 520, 520, 1542, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 1551, 520, 520, 520, 520, 2162, 520, 520, 520, 520, 2165, 520, 520, 520, 496, 496, 496, 0, 0, 496, 0, 520, 520,
  520, 520, 520, 871, 520, 520, 520, 520, 520, 2265, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2026, 520,
  520, 520, 520, 520, 897, 901, 931, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1366, 0, 0, 0, 1368, 0, 0, 0, 1015, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 982, 400, 400, 400, 1128, 0, 0, 0, 0, 0, 0,
  0, 1133, 496, 496, 496, 496, 496, 1165, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1173, 0, 0, 0, 1363, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1370, 1371, 0, 1373, 0, 0, 0, 1375, 0, 674, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1027, 0,
  496, 520, 520, 496, 1588, 496, 651760, 496, 496, 496, 496, 520, 1595, 520, 651784, 520, 520, 520, 1557, 1558, 520,
  1560, 1561, 520, 520, 520, 520, 520, 520, 1568, 520, 520, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 936, 940, 0, 0, 0, 0, 0,
  250276, 250276, 250276, 250276, 250276, 249856, 249856, 249856, 249856, 250276, 250276, 0, 0, 0, 1621, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1900, 0, 0, 0, 0, 0, 1632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2048, 0, 0, 0, 496, 496, 1749,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1983, 496, 496, 1523, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 1816, 520, 0, 0, 0, 2053, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2074, 0, 0,
  0, 2262, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2396, 520, 2358, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1875, 496, 520, 0, 2398, 0, 0, 2401, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1388, 0, 1390, 0, 0, 0, 0,
  0, 0, 400, 0, 496, 496, 496, 2411, 496, 496, 496, 496, 496, 496, 496, 496, 2254, 496, 496, 496, 2258, 520, 520, 520,
  520, 520, 520, 2421, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 1289, 0, 0, 0, 1295, 0, 0, 0, 0, 2529, 0, 0,
  2532, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2458, 0, 2459, 0, 0, 2546, 2547,
  0, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1231, 0,
  0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 396, 0, 400, 400, 400, 1400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 0, 0, 1707, 0, 0, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 476, 454, 454, 454, 454,
  454, 454, 454, 454, 454, 454, 508, 517, 508, 508, 508, 508, 533, 508, 508, 508, 508, 508, 508, 508, 508, 533, 533,
  533, 533, 533, 533, 533, 552, 552, 561, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 221603, 221603, 221603,
  221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 750, 0, 0, 0,
  0, 0, 602, 753, 0, 0, 0, 602, 0, 0, 0, 0, 0, 0, 565248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1338, 0, 0, 0, 0, 0, 0, 1031, 0, 0,
  949, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1045, 0, 0, 0, 1049, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 2112, 2113,
  2114, 496, 496, 496, 496, 400, 400, 400, 1067, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 1729, 0,
  0, 496, 496, 0, 949, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1044, 0, 496, 1142, 496, 496, 496, 496, 1152, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 1741, 496, 496, 496, 496, 496, 496, 496, 496, 1161, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 2128, 496, 496, 1176, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1188, 496, 496,
  496, 496, 496, 496, 2326, 496, 496, 496, 496, 2331, 496, 496, 496, 496, 520, 520, 1220, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 1229, 520, 520, 520, 1820, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1228,
  520, 520, 520, 0, 520, 1267, 496, 496, 1142, 496, 496, 496, 496, 496, 520, 520, 1210, 520, 520, 520, 520, 2021, 520,
  520, 520, 520, 2025, 520, 520, 520, 520, 520, 520, 520, 520, 2164, 520, 520, 520, 520, 496, 496, 496, 1666, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1677, 0, 0, 0, 0, 0, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 1613, 0, 0, 0, 0, 0, 0, 0, 0,
  1626, 0, 1628, 0, 0, 0, 0, 0, 496, 1748, 496, 496, 1751, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1190,
  496, 496, 496, 496, 0, 1791, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1244, 520, 520, 520, 0,
  0, 0, 1865, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2089, 2090, 0, 2092, 0, 0, 2197, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 2204, 0, 0, 0, 496, 520, 2397, 0, 2399, 0, 0, 0, 0, 0, 0, 2404, 0, 0, 0, 2407, 0, 0, 0, 0, 2435, 2436, 0, 851968,
  496, 496, 496, 496, 496, 496, 496, 496, 1779, 496, 496, 0, 0, 0, 0, 0, 1520, 0, 675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1108, 0, 0, 736, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1418, 400, 0, 0, 0, 0, 496,
  496, 496, 809, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1744, 496, 496, 496, 496, 496, 849, 0, 0,
  496, 0, 520, 520, 520, 520, 520, 869, 520, 520, 520, 520, 520, 2389, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 2167, 520, 496, 496, 496, 496, 496, 2324, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2137,
  496, 496, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1914, 0, 316, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 2050, 0, 0, 300, 299, 40960, 299, 299, 300, 299, 299, 0, 299, 0, 299, 412, 412, 412, 412, 412, 0, 0,
  0, 0, 300, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 412, 299, 299, 299, 299, 299, 299,
  299, 299, 299, 299, 495, 509, 299, 509, 509, 509, 509, 534, 509, 509, 509, 509, 509, 509, 509, 509, 534, 534, 534,
  534, 534, 534, 534, 509, 509, 534, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 258048, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 496, 0, 518, 518, 518, 496, 0, 0, 0, 644, 0, 0, 647, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1439, 400, 400, 400, 400, 400,
  400, 0, 658, 0, 0, 662, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2060, 0, 0, 0, 0, 603, 0, 0, 0, 0, 0, 0, 0, 693, 0, 0, 0, 0,
  0, 0, 400, 400, 400, 0, 496, 2318, 496, 496, 496, 496, 679, 0, 0, 0, 763, 0, 0, 748, 0, 0, 0, 0, 0, 0, 0, 0, 749, 0,
  632, 772, 0, 0, 0, 496, 0, 0, 773, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 784, 400, 400, 400, 400, 1726, 400,
  400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 496, 496, 0, 0, 748, 0, 0, 0, 0, 748, 0,
  0, 773, 0, 658, 0, 0, 496, 496, 496, 496, 1181, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1157, 496, 496,
  496, 496, 0, 914, 520, 496, 496, 496, 496, 832, 496, 842, 496, 0, 914, 520, 520, 520, 520, 520, 2423, 520, 2425, 520,
  520, 520, 520, 0, 0, 0, 0, 0, 0, 2105344, 264, 265, 196608, 0, 0, 0, 0, 0, 0, 0, 767, 0, 620, 0, 0, 0, 0, 0, 0, 0,
  976, 0, 0, 0, 0, 0, 316, 316, 0, 892, 520, 902, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1614, 0, 0, 0, 0, 0, 0,
  400, 400, 1126, 0, 0, 1018, 0, 0, 0, 1131, 0, 1133, 496, 496, 496, 496, 496, 1182, 496, 496, 496, 1185, 496, 496, 496,
  496, 496, 496, 496, 2327, 496, 496, 496, 496, 496, 496, 496, 496, 1496, 496, 496, 496, 496, 496, 496, 496, 0, 1266,
  520, 496, 496, 496, 496, 1272, 496, 496, 1275, 520, 520, 520, 520, 1280, 520, 520, 1283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 106496, 0, 0, 0, 1457, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1759, 496,
  496, 1473, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1771, 496, 1520, 520, 520, 520, 1527,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2157, 520, 520, 520, 520, 1572, 520, 520, 520, 520, 520,
  520, 520, 1579, 520, 520, 1582, 520, 520, 496, 496, 520, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1319, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1676, 0, 1678, 0, 0, 0, 0, 1642, 0, 0, 0, 0, 1646, 0, 0, 0, 1649, 0, 0, 0, 0, 0, 0, 734, 0,
  0, 0, 0, 0, 745, 0, 0, 614, 0, 0, 1657, 0, 0, 0, 0, 0, 311296, 1663, 0, 0, 0, 0, 0, 0, 0, 1715, 0, 0, 0, 0, 0, 0, 0,
  400, 400, 1062, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 1670, 0, 1672, 1673, 0, 0, 0, 0, 0, 0, 0, 0, 1006, 0, 1008,
  0, 0, 0, 0, 0, 400, 1696, 400, 1697, 1698, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 454, 454, 454, 454, 454, 454,
  1709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1719, 1720, 0, 311696, 1722, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0,
  1730, 0, 496, 496, 2237, 496, 496, 496, 496, 496, 496, 2242, 496, 496, 496, 496, 496, 815, 496, 496, 496, 496, 830,
  832, 496, 496, 842, 496, 496, 1760, 496, 496, 496, 496, 496, 1766, 496, 496, 496, 496, 496, 496, 496, 496, 1979, 496,
  496, 496, 496, 496, 496, 496, 496, 1167, 496, 496, 1169, 496, 1171, 496, 496, 496, 520, 311792, 1845, 496, 496, 496,
  496, 496, 311816, 1849, 520, 520, 520, 520, 520, 520, 1834, 520, 1836, 520, 520, 520, 520, 520, 520, 520, 520, 1578,
  520, 520, 520, 520, 520, 520, 496, 0, 0, 1891, 0, 0, 0, 0, 1895, 0, 0, 0, 0, 0, 0, 0, 0, 1038, 0, 0, 0, 1042, 0, 0, 0,
  0, 0, 1937, 0, 1939, 0, 0, 0, 0, 400, 400, 400, 1944, 400, 400, 400, 400, 400, 1699, 400, 400, 400, 400, 400, 0, 0, 0,
  0, 0, 0, 0, 1132, 1133, 496, 496, 496, 496, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496, 1954, 496, 496, 496, 496,
  496, 1463, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1981, 496, 496, 496, 496, 496, 0, 2052, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1343, 0, 0, 2066, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1379, 0, 0, 2235, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1970, 496, 520, 520, 520, 2277, 520, 520, 520, 496, 496, 496,
  520, 520, 520, 0, 0, 0, 1602, 0, 935, 0, 0, 0, 1604, 0, 939, 0, 0, 2295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1653, 0, 0, 0, 400, 0, 2409, 496, 496, 496, 496, 496, 496, 496, 496, 2417, 496, 496, 496, 496, 496, 2123, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 0, 1782, 0, 0, 0, 1520, 2419, 520, 520, 520, 520, 520, 520, 520, 520, 2427,
  520, 520, 0, 0, 0, 0, 0, 0, 2105344, 264, 265, 0, 0, 212992, 0, 0, 0, 0, 0, 0, 1320, 0, 0, 0, 0, 0, 0, 0, 1327, 0, 0,
  2462, 0, 0, 2465, 496, 2467, 496, 496, 496, 496, 496, 496, 496, 496, 520, 0, 0, 0, 2400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1367, 0, 0, 0, 0, 0, 2477, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 0, 2491, 2492, 2545, 0, 0, 2548, 496,
  496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2344, 520, 520, 0, 2557, 2558, 0,
  496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 496, 496, 496, 496, 496, 2133, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 1756, 496, 496, 496, 496, 496, 0, 301, 302, 303, 304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2073, 0, 0, 0, 0, 0,
  316, 0, 0, 0, 0, 0, 319, 0, 0, 0, 0, 0, 0, 0, 0, 1054, 1055, 0, 0, 400, 400, 400, 400, 323, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 2064, 302, 0, 0, 0, 319, 0, 336, 0, 301, 0, 0, 0, 0, 0, 346, 347, 0, 348, 0, 0, 0, 0, 348, 0, 0,
  352, 0, 0, 0, 319, 356, 0, 0, 0, 0, 1364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1369, 0, 0, 0, 0, 1002, 0, 1004, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 682, 0, 0, 0, 0, 0, 0, 0, 0, 0, 381, 40960, 381, 381, 0, 381, 381, 366, 381, 0, 381, 413, 413, 413, 413,
  413, 0, 0, 301, 0, 0, 455, 455, 455, 455, 455, 455, 463, 468, 455, 455, 455, 455, 455, 463, 477, 463, 455, 455, 482,
  468, 487, 468, 468, 468, 468, 468, 510, 468, 510, 510, 510, 510, 535, 510, 510, 510, 510, 510, 510, 510, 510, 535,
  535, 535, 535, 535, 535, 535, 553, 553, 562, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 258469, 258469,
  258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 702,
  400, 400, 400, 400, 400, 718, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1415, 400, 400, 400, 0, 0, 0, 0, 0, 742, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 756, 0, 742, 0, 756, 798, 496, 496, 496, 496, 496, 821, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 1780, 0, 0, 0, 0, 0, 1520, 496, 496, 496, 756, 0, 496, 0, 520, 520, 858, 520, 520, 520, 520, 520, 881, 0,
  858, 520, 798, 496, 496, 821, 496, 496, 496, 496, 0, 858, 520, 520, 881, 941, 0, 0, 943, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  953, 0, 0, 0, 0, 520, 520, 520, 520, 1797, 520, 1799, 520, 520, 520, 1802, 520, 998, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 2076, 1064, 400, 1066, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1073, 400, 400, 400, 400, 400, 2097,
  400, 400, 400, 400, 0, 0, 0, 2102, 0, 0, 0, 1091, 1110, 0, 0, 0, 0, 400, 400, 400, 1073, 400, 400, 400, 400, 400, 400,
  716, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1703, 400, 0, 0, 0, 0, 0, 496, 496, 1147, 496, 496, 1151, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 1468, 496, 496, 496, 496, 496, 496, 496, 496, 1162, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 1757, 496, 496, 496, 520, 1219, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 1230, 0, 520, 520, 496, 496, 496, 1162, 496, 496, 496, 496, 520, 520, 520, 1230, 520, 520, 520, 1832,
  520, 520, 520, 1835, 520, 520, 520, 1839, 520, 520, 520, 520, 520, 1808, 1809, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1240, 520, 520, 520, 520, 520, 0, 1301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1721, 400, 1345, 0, 0, 0,
  1349, 0, 0, 0, 1352, 0, 0, 0, 0, 0, 0, 0, 291, 0, 0, 0, 0, 0, 0, 0, 0, 496, 2439, 496, 496, 496, 2443, 496, 496, 0,
  1620, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1888, 0, 0, 0, 0, 0, 1073152, 0, 0, 0, 1635, 0, 0, 0, 0, 0, 0, 0, 337,
  292, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 1710, 0, 0, 0, 0, 0, 0, 0, 966656, 0, 0, 0, 0, 0, 400, 0,
  496, 496, 496, 496, 496, 2413, 496, 2415, 496, 496, 496, 496, 496, 1476, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 0, 0, 0, 0, 0, 1520, 1772, 496, 1774, 496, 496, 496, 496, 496, 496, 496, 1781, 0, 0, 0, 0, 1520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 1536, 520, 520, 520, 0, 0, 2176, 0, 0, 0, 0, 0, 0, 2180, 0, 0, 0, 0, 0, 1706,
  0, 0, 0, 0, 0, 1718, 0, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 0, 2373, 496, 496, 496, 0, 0, 0, 0, 1794, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2429, 0, 2431, 0, 496, 520, 496, 496, 496, 496, 496, 967152,
  1073648, 520, 520, 520, 520, 520, 967176, 1073672, 0, 1288, 0, 1294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200704, 267,
  268, 0, 0, 692224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1913, 0, 0, 770048, 0, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 975344, 496, 496, 496, 496, 1974, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 1769, 496, 496, 496, 2017, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1583,
  520, 496, 520, 520, 2152, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1841, 520, 520, 2160, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 496, 520, 520, 520, 0, 2285, 0, 0, 0, 0, 2303, 0, 0,
  0, 0, 400, 400, 400, 400, 400, 400, 2312, 0, 0, 0, 0, 1435, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400,
  1692, 400, 400, 400, 0, 0, 0, 0, 909312, 0, 400, 909712, 400, 2316, 496, 496, 496, 496, 496, 496, 1494, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 2330, 496, 496, 496, 496, 496, 520, 2348, 520, 520, 520, 520, 520, 520, 496,
  909808, 520, 909832, 2355, 0, 0, 2357, 807408, 807432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2091, 400, 520, 520,
  2509, 520, 520, 0, 2512, 0, 0, 0, 0, 0, 0, 496, 2518, 496, 496, 496, 496, 1462, 496, 496, 496, 496, 496, 496, 496,
  496, 1470, 496, 496, 496, 496, 496, 1977, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 1785, 0, 0, 1520, 0,
  349, 0, 0, 0, 0, 349, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1636, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 307, 0, 0,
  0, 414, 414, 414, 414, 414, 432, 432, 432, 432, 432, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456,
  456, 478, 456, 456, 456, 483, 456, 488, 456, 456, 456, 456, 456, 511, 456, 511, 511, 511, 511, 536, 511, 511, 511,
  511, 511, 511, 511, 511, 536, 536, 536, 536, 536, 536, 536, 554, 554, 563, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0,
  0, 0, 0, 270336, 270336, 0, 0, 0, 0, 0, 0, 270336, 0, 0, 0, 596, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 608, 609, 610, 0, 0,
  0, 661, 0, 0, 0, 0, 0, 0, 576, 661, 0, 670, 671, 576, 739, 0, 744, 0, 0, 0, 766, 0, 0, 0, 0, 576, 0, 0, 766, 576, 0,
  0, 0, 766, 0, 0, 400, 400, 400, 400, 400, 400, 727, 400, 400, 400, 400, 400, 967056, 1727, 400, 400, 1073552, 0, 0, 0,
  0, 1732, 496, 0, 766, 0, 788, 0, 744, 790, 0, 0, 0, 0, 0, 788, 0, 0, 496, 496, 496, 496, 1492, 1493, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 0, 0, 0, 0, 1787, 1520, 799, 496, 496, 496, 496, 816, 822, 824, 496, 496, 496, 496,
  496, 838, 496, 496, 496, 496, 813, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1499, 496, 496, 496, 496,
  496, 496, 496, 576, 0, 496, 0, 520, 520, 859, 520, 520, 520, 520, 876, 882, 884, 520, 520, 520, 520, 520, 898, 520,
  520, 520, 520, 520, 799, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 520, 520, 1216, 0, 859, 520,
  799, 496, 496, 822, 496, 838, 496, 496, 0, 859, 520, 520, 882, 520, 898, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1675, 0, 0, 0, 0, 0, 0, 0, 0, 957, 0, 0, 0, 0, 0, 0, 963, 0, 0, 966, 0, 0, 0, 0, 0, 286720, 286720, 286720,
  286720, 286720, 0, 0, 0, 0, 0, 286720, 0, 0, 985, 986, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2113536, 0, 0, 0, 0, 1032,
  0, 0, 0, 0, 0, 1037, 0, 0, 0, 0, 0, 0, 0, 0, 1093, 0, 0, 0, 0, 1097, 1098, 0, 986, 1103, 0, 1111, 0, 985, 1114, 1115,
  400, 400, 1118, 400, 400, 400, 400, 400, 400, 1069, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1417, 400, 400, 0, 0,
  0, 0, 400, 1125, 400, 0, 765952, 0, 0, 0, 0, 0, 966, 1133, 496, 496, 1137, 496, 496, 496, 496, 1508, 496, 496, 496,
  496, 496, 496, 0, 0, 1520, 91311, 0, 0, 0, 0, 1304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2179694, 2179694, 2179694, 0, 0,
  496, 496, 496, 1163, 496, 496, 1166, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2126, 496, 496, 496, 496, 496, 496,
  1177, 1178, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1194, 520, 520, 1234, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 1245, 1246, 520, 520, 520, 520, 2153, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2159,
  0, 520, 520, 1268, 496, 496, 1271, 496, 496, 496, 496, 1276, 520, 520, 1279, 520, 520, 520, 2006, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 798, 496, 0, 0, 0, 0, 1302, 1303, 0, 0, 0, 0, 0, 1309, 0, 0, 0, 0, 0, 0, 0,
  1855, 0, 0, 0, 0, 0, 0, 0, 0, 1308, 0, 0, 0, 0, 0, 1312, 0, 1409, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 0, 1420, 1421, 0, 0, 0, 0, 1609, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163840, 163840, 163840, 163840, 163840, 0, 0,
  1424, 0, 0, 0, 0, 0, 0, 0, 1430, 0, 1430, 1420, 0, 0, 0, 0, 520, 520, 1796, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 907, 520, 496, 496, 0, 0, 0, 1433, 0, 0, 0, 1436, 0, 0, 0, 0, 400, 400, 1442, 400, 400, 400, 400, 1068, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 1088, 0, 1445, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0,
  1133, 496, 496, 496, 496, 496, 1509, 496, 496, 1512, 496, 496, 0, 0, 1520, 91311, 0, 496, 1459, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1472, 1520, 520, 520, 520, 520, 1529, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1826, 520, 520, 520, 1830, 520, 520, 1573, 1574, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 496, 496, 520, 520, 0, 0, 2356, 0, 1598, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2158592, 2441216,
  2158592, 2158592, 1641, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2300, 0, 0, 0, 0, 1659, 0, 0, 0, 0, 0, 0, 0,
  577536, 0, 0, 1665, 0, 0, 1711, 0, 1713, 0, 1714, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 0, 2317, 496, 496, 496, 496,
  496, 496, 496, 496, 1750, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1968, 496, 496, 496, 496, 1773,
  496, 496, 496, 1777, 496, 496, 496, 496, 0, 0, 0, 1786, 0, 1520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1534,
  520, 520, 520, 520, 520, 520, 1256, 520, 520, 520, 520, 520, 520, 496, 1265, 0, 0, 0, 1792, 0, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 1801, 520, 520, 520, 520, 2263, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  1549, 520, 520, 1553, 1804, 520, 520, 520, 520, 520, 520, 520, 520, 1812, 520, 520, 520, 520, 520, 520, 520, 903, 520,
  520, 520, 520, 496, 496, 0, 0, 1863, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217088, 1040384, 0, 0, 1948, 496,
  496, 496, 496, 1952, 496, 496, 496, 496, 496, 496, 496, 2125, 496, 496, 496, 496, 496, 496, 496, 496, 2134, 496, 496,
  496, 496, 496, 496, 496, 496, 1479, 496, 496, 1483, 496, 496, 496, 496, 496, 496, 496, 1961, 496, 496, 496, 1964,
  1965, 496, 496, 496, 496, 496, 496, 496, 2252, 496, 496, 496, 496, 520, 520, 520, 520, 1972, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2333, 496, 0, 1991, 520, 520, 520, 520, 1995, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 1227, 520, 520, 520, 520, 520, 520, 2004, 520, 520, 520, 2007, 2008, 520, 520, 520, 520,
  520, 520, 520, 2015, 520, 520, 520, 2020, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1243, 520, 520,
  520, 413696, 2040, 0, 0, 2043, 2044, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1637, 0, 0, 0, 0, 0, 2077, 0, 0, 0, 0, 0, 0, 2084,
  0, 0, 0, 2088, 0, 0, 0, 400, 0, 496, 496, 496, 496, 2412, 496, 496, 496, 496, 496, 496, 496, 1511, 496, 496, 496, 0,
  0, 1520, 91311, 0, 400, 400, 2095, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 520, 0, 0, 0, 0, 1064960, 400, 400, 400, 400, 400, 0, 496, 496, 496, 496, 496, 496,
  2523, 520, 520, 520, 520, 520, 520, 520, 520, 0, 2119, 496, 2121, 496, 496, 496, 2124, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 2255, 496, 496, 520, 520, 2260, 520, 2140, 496, 0, 0, 0, 0, 520, 520, 520, 520, 520, 2146, 520, 2148,
  520, 520, 520, 520, 2264, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2273, 520, 2151, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 2158, 520, 520, 0, 2208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400,
  400, 1946, 400, 2287, 0, 0, 0, 0, 0, 2291, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1857, 0, 1859, 0, 0, 1862, 0, 0, 2313, 0, 0, 0,
  471040, 400, 400, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 2501, 496, 520, 520, 520, 520, 520, 520, 520, 2349,
  520, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 0, 2105344, 264, 21054, 0, 0, 0, 0, 0, 0, 0, 0, 1941, 400,
  400, 400, 400, 400, 400, 400, 400, 1931, 0, 0, 0, 0, 0, 0, 0, 0, 2072, 0, 0, 0, 0, 0, 0, 0, 0, 2085, 0, 0, 0, 0, 0, 0,
  400, 400, 400, 0, 496, 496, 496, 496, 2320, 2321, 0, 0, 0, 0, 2360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 0, 0, 0,
  0, 0, 0, 0, 2369, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 0, 496, 496, 496, 496, 496, 496, 2414, 496, 496, 496, 496,
  496, 2374, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2382, 496, 496, 496, 520, 520, 496, 496, 496, 496, 496, 496,
  496, 1593, 520, 520, 520, 520, 520, 520, 520, 1810, 520, 520, 1813, 520, 520, 520, 520, 520, 520, 520, 1822, 520, 520,
  520, 520, 520, 1828, 520, 520, 520, 520, 2386, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2394, 520, 520, 520, 520,
  1235, 520, 520, 1237, 520, 1239, 520, 520, 520, 520, 520, 520, 520, 520, 2024, 520, 520, 520, 520, 520, 520, 520, 520,
  905, 520, 520, 520, 496, 496, 0, 0, 496, 496, 496, 2521, 2522, 496, 520, 520, 520, 520, 520, 520, 2527, 2528, 520, 0,
  0, 0, 0, 1622, 1623, 1624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1627, 0, 0, 0, 0, 1630, 0, 0, 2530, 2531, 0, 496, 496, 496, 496,
  496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 2342, 520, 520, 520, 520, 520, 520, 520, 2564, 496, 520, 496, 520,
  496, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 1882, 0, 0, 0, 0, 0, 1887, 0, 0, 0, 0, 309, 0, 0, 0, 0, 0, 0, 0, 0, 309, 0,
  0, 45056, 49152, 0, 309, 0, 0, 40960, 0, 0, 0, 0, 0, 389, 0, 0, 0, 415, 415, 415, 415, 415, 433, 433, 433, 440, 440,
  457, 457, 457, 433, 433, 433, 433, 433, 433, 457, 457, 433, 433, 433, 440, 433, 457, 479, 433, 433, 433, 433, 457,
  433, 489, 489, 489, 489, 489, 512, 489, 512, 512, 512, 512, 537, 512, 512, 512, 512, 512, 512, 512, 512, 537, 537,
  537, 537, 537, 537, 537, 512, 512, 537, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 892928, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 679, 0, 0, 0, 0, 0, 0, 0, 653, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 496, 496, 496, 496, 0, 942, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2293, 2294, 0, 0, 1033, 0, 1034, 0, 0, 0, 0, 0, 0, 1034, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1664, 0, 0, 0, 0, 0, 496, 1143, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2385,
  520, 1195, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 1211, 520, 520, 520, 520, 2278, 520, 520, 496,
  496, 496, 520, 520, 520, 0, 0, 0, 0, 0, 724992, 1350, 0, 0, 0, 0, 0, 0, 0, 1358, 0, 0, 520, 520, 496, 496, 1143, 496,
  496, 496, 496, 496, 520, 520, 1211, 520, 520, 520, 520, 2388, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 2013, 520, 520, 520, 1539, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1547, 520, 520, 520, 520, 520, 520, 2390,
  520, 2391, 2392, 520, 520, 520, 520, 520, 520, 520, 520, 2010, 520, 520, 520, 520, 520, 520, 520, 520, 1811, 520, 520,
  520, 520, 520, 520, 520, 520, 1562, 1563, 520, 520, 520, 520, 520, 520, 520, 520, 1556, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 1566, 520, 520, 520, 520, 1575, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 520, 520,
  0, 0, 0, 0, 0, 0, 0, 1793, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1803, 0, 0, 0, 0, 1853, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 172032, 172032, 172032, 172032, 172032, 0, 2184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2299,
  0, 496, 496, 496, 2377, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 496, 496, 1589, 496, 496, 1591,
  496, 496, 520, 520, 1596, 520, 520, 520, 520, 520, 2510, 520, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 496, 2471,
  496, 496, 496, 496, 520, 0, 0, 360, 0, 0, 0, 0, 0, 0, 0, 0, 360, 0, 0, 45056, 49152, 0, 360, 0, 0, 40960, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 400, 400, 1061, 400, 400, 400, 400, 400, 400, 0, 342, 0, 0, 0, 0, 0, 0, 0, 0, 513, 0, 513, 513, 513,
  513, 538, 513, 513, 513, 513, 513, 513, 513, 513, 538, 538, 538, 538, 538, 538, 538, 513, 513, 538, 53494, 53494, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066,
  1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 496, 496, 496, 810, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 2332, 496, 496, 496, 400, 1065, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 1704, 0, 0, 0, 0, 0, 0, 0, 1088, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1693, 1694, 400,
  496, 496, 496, 1148, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2384, 496, 520, 520, 496, 496, 496,
  1164, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2383, 496, 496, 520, 520, 0, 520, 520, 496, 496,
  496, 1164, 496, 496, 496, 496, 520, 520, 520, 1232, 520, 520, 520, 2174, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1058,
  400, 400, 400, 0, 1423, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0, 0, 382, 40960, 382, 382, 0, 382,
  382, 312, 382, 0, 382, 416, 416, 416, 416, 416, 0, 0, 0, 0, 0, 458, 458, 458, 458, 458, 458, 458, 469, 458, 458, 458,
  458, 458, 458, 480, 458, 458, 458, 458, 469, 458, 490, 490, 490, 494, 490, 514, 490, 514, 514, 514, 514, 539, 514,
  514, 514, 514, 514, 514, 514, 514, 539, 539, 539, 539, 539, 539, 539, 555, 555, 564, 53494, 53494, 2, 2, 3, 94212, 5,
  6, 0, 0, 0, 0, 0, 1105920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 625, 0, 0, 0, 0, 0, 0, 520, 520, 496, 496, 496, 496, 496,
  839, 496, 496, 0, 520, 520, 520, 520, 520, 2022, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2028, 520, 899, 520,
  520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1897, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 1962, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 655856, 496, 1969, 496, 1971, 520, 520, 2005, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 2168, 496, 496, 540, 515, 515, 515, 515, 515, 515, 515, 515, 540, 540, 540, 540, 540,
  540, 540, 515, 515, 540, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2158592, 2158592, 2158592, 2527232,
  2158592, 2158592, 2600960, 2158592, 2695168, 2158592, 2158592, 0, 0, 0, 628, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  270336, 0, 0, 0, 0, 657, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 225280, 0, 737, 0, 0, 0, 0, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 1416, 400, 400, 1419, 0, 0, 0, 0, 496, 496, 496, 811, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1967, 496, 496, 496, 496, 496, 0, 0, 972, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 0, 0, 0, 0,
  1645, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1654, 0, 999, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233472, 0, 0, 0, 1016, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1029, 1789, 0, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  1263, 496, 496, 0, 579, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1019904, 0, 520, 520, 496, 496, 496, 496, 496,
  496, 843, 496, 0, 520, 520, 520, 520, 520, 2154, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1548, 520,
  520, 520, 520, 520, 520, 903, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2058, 0, 0, 0, 0, 2063, 0, 496, 1489, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2127, 496, 496, 496, 496, 496, 1520, 520, 520, 520,
  520, 520, 520, 520, 520, 1533, 520, 520, 520, 520, 520, 520, 520, 1224, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 2011, 520, 520, 520, 520, 520, 1747, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  2136, 496, 496, 496, 496, 496, 1843, 1844, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 0, 0, 0, 0, 0, 2514, 2515, 0, 496, 496, 496, 0, 1877, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245760, 0,
  496, 496, 496, 1986, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2179695, 151552, 2179695, 0, 0, 520, 2029, 496, 520, 496,
  496, 496, 496, 520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 2105344, 572, 573, 0, 0, 0, 0, 0, 0, 0, 0, 1856, 0, 0, 0, 0, 0,
  0, 0, 0, 1896, 0, 0, 1899, 0, 0, 0, 0, 0, 0, 0, 2210, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400,
  1123, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 397, 0, 400, 400, 1399, 400, 400, 400, 400, 400, 400, 1405, 400, 400,
  400, 400, 400, 400, 1081, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 496, 1085440, 316, 0, 0,
  1085440, 0, 0, 0, 0, 0, 1085440, 0, 0, 0, 0, 0, 1085440, 0, 1085440, 0, 0, 0, 1085440, 1085811, 1085811, 0, 0,
  1085440, 0, 0, 1085440, 0, 0, 0, 0, 0, 1085440, 0, 0, 0, 0, 0, 0, 2105344, 21051, 265, 0, 0, 0, 0, 0, 0, 0, 0, 1674,
  0, 0, 0, 0, 0, 0, 1681, 0, 0, 0, 0, 1085811, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1085440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1085440, 0, 1085440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290816, 0, 0, 1085440, 1085440, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1085440, 0, 0, 0, 0, 0, 1085440, 1085440, 1085440, 0, 0, 0, 1085440, 1085440, 0, 0, 0, 2, 4263936, 3,
  94212, 5, 6, 0, 0, 0, 0, 0, 2158592, 2813952, 2158592, 2158592, 2158592, 0, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 912, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 307200, 0, 0,
  2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 618, 619, 620, 0, 316, 316, 316, 0, 0, 0, 0, 1089536, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 3088384, 0, 57344, 0, 0, 2162688, 2162688, 2162688, 0, 0, 2163541, 0, 2162688, 2163544, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  245760, 0, 2162688, 2162688, 2162688, 2162688, 0, 4263936, 6, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408, 2162688, 2162688,
  2162688, 4263936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1884, 0, 0, 0, 0, 0, 1093632, 0, 1093632, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1898, 0, 0, 0, 0, 0, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066,
  1094066, 1094066, 0, 1094066, 0, 0, 0, 0, 0, 0, 2106007, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1102198, 1102198, 1102198,
  1102198, 1102198, 1102198, 0, 0, 1094066, 1094066, 1094066, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2158592,
  2813952, 2158592, 2158592, 2158592, 0, 2163484, 2163484, 2163484, 2163484, 2163484, 2499356, 2540316, 2544412,
  2163484, 2163484, 2593564, 2163484, 2163484, 2163484, 2163484, 0, 1097728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  3158016, 2158592, 0, 1101824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2047, 0, 0, 0, 2049, 0, 1102198, 0, 0, 0, 372,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2059, 0, 0, 0, 0, 0, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198,
  1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 0, 1102198, 0, 0, 0, 0, 1101824, 374,
  1102198, 1102198, 1102198, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2379776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 268, 0,
  0, 0, 0, 0, 0, 0, 0, 1110016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 45056, 49152, 2162688, 0, 0, 0,
  1198, 0, 0, 1201, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3080192, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2441216,
  2449408, 0, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2158592, 106496, 106496, 106496, 106496,
  106496, 106496, 106496, 106496, 106496, 106496, 0, 106496, 0, 0, 0, 0, 0, 0, 2109440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  217088, 217088, 217088, 217088, 217088, 217088, 0, 0, 106496, 106496, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159744,
  0, 0, 0, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  91, 107, 123, 181, 197, 213, 229, 245, 431, 261, 277, 293, 461, 148, 310, 158, 1328, 1320, 137, 312, 740, 328, 372,
  388, 343, 417, 447, 504, 489, 534, 473, 550, 566, 582, 928, 1390, 1375, 1209, 598, 614, 629, 645, 661, 677, 693, 1179,
  865, 709, 725, 756, 772, 788, 804, 835, 851, 881, 897, 913, 959, 1022, 1252, 975, 991, 819, 1007, 1164, 1038, 1133,
  943, 1054, 1070, 1086, 1102, 1118, 1149, 1404, 1282, 1195, 1225, 1241, 165, 1268, 1298, 1344, 518, 401, 356, 1360,
  1420, 1310, 304, 1436, 1440, 1442, 1442, 1442, 1446, 1442, 1442, 1450, 1454, 1458, 1462, 1466, 1470, 1474, 1478, 1482,
  2078, 2078, 2814, 2078, 2078, 1653, 1489, 1835, 3545, 1496, 2078, 2078, 3526, 2530, 1633, 1501, 1553, 1511, 1560,
  2078, 2078, 2734, 2078, 2078, 1519, 1529, 3641, 3545, 1534, 2078, 2078, 1569, 2078, 2078, 2078, 2078, 2078, 2078,
  2078, 2830, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2879, 2078, 2078, 2078, 2078, 2078, 2078, 1567,
  2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2837, 3556, 3568, 3575, 3580, 3592, 3596, 1969, 1544, 1633,
  1633, 1633, 1551, 1574, 1574, 1593, 1557, 1564, 2078, 2078, 2078, 2078, 2616, 1522, 2078, 3544, 3546, 2078, 3525,
  1606, 1633, 1633, 1633, 2213, 1573, 1574, 1574, 1575, 1579, 1586, 2078, 2078, 2078, 2078, 1497, 2078, 1538, 1534,
  1835, 1540, 1633, 1633, 1633, 1646, 1616, 1574, 1574, 1574, 1590, 1566, 2078, 2078, 2078, 2078, 3543, 3547, 3542,
  1546, 1633, 1633, 1613, 1573, 1574, 1574, 1597, 2078, 2078, 2078, 1835, 1605, 1610, 1633, 1633, 1621, 1574, 1617,
  1627, 1642, 1547, 1574, 1661, 1644, 1623, 2211, 1650, 2373, 1514, 2374, 1515, 2399, 2398, 2398, 2387, 1659, 1667,
  1671, 1683, 1683, 1674, 1678, 1682, 1684, 1688, 1692, 1696, 1700, 1704, 1708, 1712, 3519, 3235, 2078, 2078, 1716,
  2078, 2078, 2078, 1791, 2078, 1836, 2078, 2078, 2078, 2078, 2078, 1491, 2078, 3224, 2078, 2078, 2078, 2078, 2078,
  2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 1758, 1767, 1773, 2078, 2078, 2078, 2078, 2432,
  1780, 3623, 1789, 2996, 1763, 1795, 1799, 2078, 1872, 3623, 1857, 2078, 1864, 1869, 2078, 3659, 2078, 2078, 2078,
  3658, 2078, 2078, 2078, 2284, 2078, 2078, 2078, 2027, 1785, 2078, 2079, 2078, 2078, 2078, 2421, 2078, 2240, 1803,
  2078, 1807, 1816, 3212, 2078, 2078, 2078, 2078, 1915, 2078, 1820, 1826, 2042, 2431, 3703, 1831, 2078, 2260, 2078,
  2078, 2257, 3393, 2078, 2078, 1840, 1834, 1852, 2078, 2078, 2078, 2036, 3237, 3239, 2078, 2078, 2518, 2078, 2078,
  2078, 3675, 2078, 3333, 2520, 1879, 1834, 1883, 2078, 2078, 2078, 2140, 2078, 1822, 1525, 2078, 1833, 1889, 2078,
  2078, 2078, 1968, 1536, 1632, 1634, 1574, 1582, 2078, 2078, 3642, 1638, 1633, 1592, 1504, 2078, 2788, 2078, 2078,
  2078, 1485, 2230, 2078, 2078, 2078, 1895, 3583, 2293, 2525, 2303, 2078, 2078, 2242, 1783, 2917, 2078, 2078, 2078,
  2078, 2078, 2078, 3706, 2078, 2078, 2078, 2078, 1810, 2555, 2078, 2078, 3205, 2078, 1984, 3021, 1991, 1995, 1998,
  2002, 2017, 2078, 2832, 1943, 2409, 1933, 2078, 1942, 2078, 1947, 1827, 2850, 2410, 1952, 1933, 2078, 1900, 2078,
  2078, 2511, 1914, 2078, 2078, 2139, 1919, 2808, 1928, 2078, 2411, 2078, 2078, 2518, 2078, 2078, 2078, 1948, 2078,
  2078, 2078, 3428, 3663, 2078, 2078, 2078, 2037, 2019, 3562, 1961, 1966, 2098, 1974, 1975, 1973, 1938, 1979, 3375,
  1980, 3376, 1937, 2593, 2593, 2005, 2009, 2078, 2014, 2078, 2078, 2026, 2872, 2078, 2504, 2965, 2035, 2994, 2032,
  2267, 1761, 2066, 2041, 2380, 2078, 2085, 2078, 2046, 2078, 2078, 2026, 2872, 2078, 2050, 2178, 2059, 1910, 2010,
  2064, 2070, 1662, 2076, 2078, 2078, 1663, 2077, 2078, 2078, 2083, 2918, 1812, 2078, 3354, 3073, 2234, 2201, 2246,
  2250, 2727, 2254, 2079, 2265, 3696, 2271, 2764, 1903, 2278, 1496, 2282, 2314, 3082, 2288, 2313, 2292, 2297, 2301,
  2307, 2311, 2318, 2322, 2327, 2323, 2328, 3501, 2332, 3089, 2078, 2078, 2078, 2497, 2078, 2078, 2336, 2220, 3158,
  2340, 2348, 2352, 2356, 2360, 2364, 2366, 2078, 2078, 2370, 2078, 2185, 2378, 2384, 1860, 1909, 2391, 2078, 2395,
  2403, 3559, 2415, 2426, 2078, 3683, 2770, 2762, 2078, 2115, 2078, 3617, 2378, 2384, 1906, 2444, 2491, 2430, 2861,
  3240, 1769, 2436, 2450, 2455, 2078, 2078, 3106, 2456, 2078, 3394, 2153, 2078, 2053, 1853, 2460, 3116, 1859, 2468,
  2474, 3202, 3588, 2479, 2485, 2078, 3101, 2490, 2078, 2078, 3100, 2489, 2560, 2078, 2078, 3671, 2739, 2078, 2197,
  2100, 2565, 2569, 2599, 3517, 2078, 2574, 2078, 2470, 2598, 2078, 2550, 2580, 2570, 2582, 2078, 2962, 2078, 2586,
  2481, 2591, 2445, 2991, 2576, 2078, 2274, 1724, 2827, 2078, 2078, 2797, 1730, 2078, 3064, 1734, 1738, 1742, 1746,
  1750, 1754, 2597, 2716, 2603, 3149, 3163, 2078, 3071, 1956, 1628, 2022, 1775, 2607, 1776, 2608, 2612, 2620, 2418,
  2439, 2442, 2078, 2078, 2078, 1848, 2078, 2723, 2624, 2629, 2543, 2633, 3290, 2637, 2640, 2644, 2648, 2651, 2078,
  2078, 2658, 2078, 2667, 2671, 2677, 1953, 1922, 3011, 2695, 2748, 2683, 2689, 2699, 3039, 2078, 2703, 2707, 2715,
  2078, 2720, 2078, 2667, 2671, 2677, 1957, 2731, 3636, 2983, 2475, 2095, 2988, 2786, 2078, 3339, 2901, 2078, 2078,
  3340, 2078, 3000, 2078, 3636, 2738, 2745, 2752, 1492, 2759, 2078, 1600, 2078, 2078, 2078, 1601, 2078, 2768, 2078,
  2802, 2774, 1875, 2780, 3623, 1948, 3189, 2078, 2792, 2107, 2801, 2692, 2078, 1962, 2807, 2078, 2078, 2078, 2918,
  2534, 2078, 2078, 2078, 2549, 2663, 2462, 2542, 2446, 2547, 2554, 2078, 2919, 2806, 2078, 2812, 2078, 2078, 2818,
  1875, 2824, 2078, 3170, 2078, 3148, 2078, 1987, 2078, 2984, 2836, 2078, 2078, 2078, 2841, 2078, 2078, 2078, 2848,
  2854, 2078, 3188, 2733, 2078, 1874, 2694, 3676, 2796, 2078, 2078, 2422, 2078, 2078, 3195, 2188, 2831, 2865, 2078,
  1986, 2078, 2870, 2078, 2769, 3080, 2089, 2104, 2131, 2055, 2119, 2078, 2126, 2078, 2078, 2078, 2125, 2130, 2078,
  2146, 3142, 2679, 3120, 3153, 1720, 3132, 1896, 3162, 2072, 3167, 3174, 3178, 3183, 3193, 2422, 2078, 2060, 2878,
  2343, 2866, 2078, 2078, 2877, 2740, 2078, 2209, 2857, 2732, 2078, 2776, 2935, 2939, 2941, 2945, 2078, 2078, 2950,
  1891, 3382, 3053, 1873, 3026, 3586, 2237, 2078, 3478, 2955, 3411, 2959, 2783, 2969, 2974, 2979, 2078, 2078, 3215,
  1885, 3382, 3053, 2139, 2078, 3255, 3004, 3009, 3015, 2514, 2078, 3360, 2078, 3025, 2975, 3031, 3374, 2078, 3058,
  3044, 3037, 2078, 2796, 2883, 2078, 2794, 2741, 3257, 2887, 2888, 2892, 3155, 3005, 2899, 2888, 2900, 2895, 3094,
  3062, 2859, 2078, 2078, 3068, 2078, 3145, 2078, 3468, 3480, 3077, 3179, 1865, 2946, 3086, 3199, 3112, 3209, 3263,
  3222, 3114, 3228, 3232, 3244, 3245, 3249, 3261, 3267, 3272, 3268, 3273, 3252, 1843, 1843, 3277, 3281, 2078, 2078,
  2078, 2155, 2819, 2078, 3287, 3294, 3298, 3302, 3306, 3310, 3314, 3318, 3320, 2078, 2078, 2078, 3324, 3353, 3433,
  3328, 3332, 3371, 2078, 3337, 3344, 2587, 3693, 3348, 3352, 3358, 3531, 2261, 3018, 2078, 2078, 2844, 3353, 3433,
  3364, 3368, 1569, 2078, 3536, 3393, 3380, 3386, 2406, 2078, 2078, 3685, 3392, 2078, 2078, 3686, 2536, 2873, 2078,
  2970, 3093, 3099, 2078, 3095, 3105, 3110, 3475, 3120, 3124, 1719, 3130, 3186, 1929, 3136, 2172, 3398, 2202, 3404,
  3669, 3408, 2078, 2561, 3415, 3419, 2538, 2078, 2078, 2078, 2711, 2078, 3043, 2078, 3048, 2078, 2078, 2951, 3009,
  3052, 3057, 1655, 3636, 2983, 3033, 1935, 2078, 2820, 2479, 2078, 2916, 1853, 2460, 3126, 1924, 2495, 2501, 2508,
  2078, 2524, 3400, 2529, 3492, 2078, 3552, 3498, 2078, 2078, 3628, 3505, 2078, 3510, 3655, 3514, 2802, 2110, 2078,
  2078, 3422, 2078, 2078, 2192, 2196, 2201, 2207, 2249, 2217, 2224, 2228, 2078, 3388, 1496, 3523, 2078, 2556, 3530,
  3571, 3666, 1569, 1827, 2138, 2463, 3530, 2673, 2203, 3283, 3535, 3564, 2078, 3540, 2464, 2625, 2078, 2078, 3551,
  2661, 2078, 3156, 3157, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 3466, 2078, 2905, 2894, 2909, 2913, 2923, 2927,
  2931, 3600, 3603, 3607, 3611, 3615, 2078, 2078, 2078, 2685, 2078, 2078, 2078, 3621, 2020, 2078, 2078, 3450, 2078,
  2078, 2078, 3454, 3458, 3464, 2078, 3472, 3484, 3488, 2078, 3494, 2113, 3627, 1726, 3632, 3648, 2078, 3640, 2028,
  3708, 3635, 2078, 2078, 2516, 2078, 2078, 2078, 2078, 2078, 2614, 2078, 2078, 2078, 2614, 2078, 2078, 2078, 2078,
  2078, 2078, 2078, 1568, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 2078, 1530, 2078, 2078, 2078, 2078, 2078, 2078,
  2078, 1954, 2078, 2078, 2078, 2078, 3646, 3652, 2078, 2078, 2469, 1524, 2078, 2078, 2344, 3237, 3239, 2653, 2078,
  2078, 2078, 1846, 2078, 2078, 2078, 3680, 2078, 3690, 2078, 2020, 2078, 2654, 2078, 3138, 2171, 2078, 2078, 2121,
  3218, 2078, 2273, 3460, 2176, 2092, 2163, 2182, 1507, 2078, 2162, 2078, 2135, 2078, 3354, 2871, 2451, 2144, 2150,
  2725, 2159, 2078, 2167, 2078, 2078, 2710, 3506, 2873, 2078, 2469, 3426, 3432, 3437, 3441, 2078, 3576, 2755, 2537,
  3445, 2078, 3680, 2078, 3446, 2078, 3700, 2078, 2021, 2078, 2078, 2078, 2078, 2078, 3027, 2078, 1955, 5282, 3712,
  4529, 3719, 3726, 3730, 3760, 3760, 3760, 3760, 3736, 3732, 3760, 3760, 3761, 3740, 3760, 3760, 3749, 3760, 4435,
  3755, 3759, 3765, 3760, 3767, 3771, 3775, 3789, 3791, 3781, 3795, 3787, 3784, 3777, 3790, 3797, 3801, 3805, 3809,
  3813, 3819, 3815, 3823, 5283, 3713, 4527, 4438, 5703, 4529, 3751, 4529, 5663, 3842, 4621, 4529, 4529, 3844, 4529,
  5210, 4725, 4529, 4529, 4529, 3896, 4333, 3849, 3857, 3852, 3852, 3891, 4529, 3827, 4646, 4650, 3862, 4332, 4333,
  3852, 3852, 3928, 4529, 4331, 4529, 5049, 4529, 4150, 5125, 5556, 4529, 4529, 4529, 5713, 5126, 4529, 4529, 4529,
  3954, 5697, 5697, 5698, 4529, 4529, 5697, 5697, 5697, 5699, 4330, 5698, 4529, 4669, 4332, 4332, 4332, 3891, 4672,
  3876, 3852, 3852, 3852, 4334, 3887, 4332, 3890, 3852, 3867, 4678, 3952, 3909, 3950, 3950, 4529, 4529, 4529, 3955,
  4529, 4529, 3882, 3852, 3852, 3852, 3852, 3883, 3892, 4332, 3890, 3852, 3883, 3891, 3928, 3853, 3950, 3950, 3951,
  3902, 4332, 3908, 3852, 3852, 3852, 3903, 3863, 4332, 3852, 4529, 3827, 5216, 5202, 4529, 5697, 5697, 5699, 4529,
  4332, 4529, 5696, 5622, 4332, 3913, 3915, 3879, 3852, 3852, 3852, 3889, 3919, 3881, 3852, 3852, 3852, 4529, 3858,
  4529, 4529, 4529, 4013, 4331, 4332, 4332, 4332, 4332, 3852, 4529, 5695, 5623, 4332, 4224, 5697, 4225, 4332, 4332,
  4332, 3904, 3914, 3891, 3852, 3852, 4529, 3832, 4529, 4529, 3837, 4621, 3863, 3925, 3927, 4529, 4529, 4529, 4085,
  4541, 4705, 5549, 4359, 4050, 3973, 3935, 3945, 3950, 3950, 4441, 3939, 4006, 4425, 3992, 3943, 3949, 3950, 3950,
  3950, 3950, 3972, 3967, 3971, 3985, 3984, 3985, 3977, 3981, 3989, 3995, 3999, 4003, 4017, 4020, 4030, 4024, 4034,
  4042, 4038, 4037, 4027, 4030, 4216, 4048, 4054, 4057, 4061, 4065, 4044, 4529, 5132, 3745, 4529, 3838, 4529, 4529,
  5172, 4626, 5064, 4529, 4529, 3963, 4529, 4116, 4825, 4127, 5602, 4518, 5342, 4136, 5172, 4149, 3898, 5347, 4991,
  4158, 4160, 4164, 4167, 4171, 4180, 4174, 4180, 4178, 4181, 4185, 4187, 4191, 4191, 4194, 4198, 4200, 4204, 4208,
  4529, 4078, 4529, 4529, 4239, 4234, 4626, 5071, 4529, 4529, 4009, 4529, 4553, 4276, 4529, 4529, 4011, 4529, 4364,
  3872, 4529, 5348, 4529, 4096, 4529, 4529, 3960, 3957, 4879, 4222, 4529, 4529, 4076, 4529, 4246, 4529, 4529, 4072,
  5212, 4529, 4588, 4223, 4529, 5160, 4529, 4255, 4260, 4265, 4270, 4529, 4098, 4102, 4106, 4617, 4529, 4269, 4529,
  4529, 5642, 4529, 5703, 4529, 4878, 4934, 4529, 4280, 4529, 4529, 4529, 4152, 4071, 4529, 5175, 4668, 4529, 4529,
  4529, 4224, 4082, 5253, 4305, 4668, 5175, 5429, 5293, 5553, 4529, 4529, 4529, 5782, 5194, 4312, 4529, 4529, 4529,
  4225, 4877, 5590, 4529, 4529, 4122, 4529, 4529, 4233, 4529, 4529, 4529, 4250, 4317, 4529, 4529, 5662, 4153, 4529,
  4529, 4529, 4226, 5719, 5251, 4338, 4668, 5175, 4132, 4313, 4529, 4529, 4143, 5172, 5023, 4662, 4529, 4529, 4144,
  5172, 5337, 4529, 4529, 4529, 4285, 4529, 5024, 4083, 4529, 4119, 4733, 4529, 4122, 4529, 5459, 4529, 4529, 4673,
  4468, 5020, 4529, 4529, 4529, 4307, 4350, 4617, 4529, 5719, 5130, 4529, 4091, 4528, 4529, 4893, 4529, 4529, 4529,
  4319, 4529, 5024, 4617, 4529, 4671, 4529, 4670, 4529, 4529, 4371, 4529, 4529, 4529, 4350, 5019, 4529, 4529, 4529,
  4363, 4894, 4529, 4529, 4529, 4364, 4529, 4529, 4364, 4626, 4346, 4529, 4529, 4529, 4461, 4344, 5187, 4529, 4529,
  4224, 5697, 5697, 5021, 4529, 4529, 4672, 4529, 4529, 5021, 4529, 4671, 4529, 4669, 4378, 4984, 4529, 4529, 4227,
  4529, 5390, 4382, 4388, 3722, 4392, 4393, 4397, 4405, 4405, 4403, 4405, 4405, 4401, 4409, 4413, 4415, 4415, 4415,
  4415, 4419, 4529, 4529, 4529, 4474, 4099, 4103, 4591, 4529, 4132, 5021, 4529, 4529, 4529, 4365, 4529, 4363, 5006,
  4529, 4529, 4529, 4485, 4529, 4472, 5447, 4077, 4459, 4529, 4529, 4529, 4486, 4529, 4492, 4529, 4529, 4529, 4497,
  5704, 4101, 4105, 5398, 4429, 4529, 4503, 4607, 3714, 4529, 4529, 4585, 4529, 4592, 4529, 4529, 4529, 4525, 4077,
  4524, 4529, 4529, 4283, 4085, 4535, 4077, 4529, 4529, 4286, 5412, 4541, 4545, 4529, 4529, 4529, 4529, 3827, 4092,
  4529, 4092, 4529, 4529, 4496, 4529, 5574, 4529, 4498, 4242, 4654, 4529, 4138, 4617, 4529, 4144, 4529, 4529, 4224,
  5701, 4241, 4557, 5398, 4529, 4151, 5255, 4529, 4152, 4529, 4150, 5667, 4529, 4529, 5614, 4529, 4481, 3714, 4674,
  4529, 4675, 4529, 4529, 5234, 4646, 4596, 4560, 4560, 4529, 4529, 4529, 4572, 4099, 4103, 4107, 4529, 4152, 4529,
  4529, 4529, 4308, 4526, 5572, 4529, 4529, 4320, 5407, 4119, 4242, 4632, 4529, 4218, 4529, 4529, 4576, 4580, 5557,
  4529, 4639, 4673, 4529, 4673, 4529, 4529, 3827, 4645, 4649, 4600, 4598, 4529, 4529, 4529, 4574, 4525, 4607, 4997,
  4529, 4119, 4515, 4481, 3714, 4676, 4529, 4224, 4677, 4529, 4225, 4529, 5186, 4673, 4673, 4529, 4100, 4104, 4529,
  4529, 4529, 4608, 4529, 5551, 4529, 4529, 4529, 4609, 4529, 5178, 4529, 4526, 4529, 4529, 4332, 4332, 4333, 3921,
  3825, 4529, 4675, 4529, 4226, 4750, 4759, 4693, 4529, 4529, 5438, 4648, 4724, 4529, 4529, 4357, 4529, 5704, 4701,
  4709, 4529, 4248, 5174, 4529, 4256, 4529, 4529, 4089, 4529, 4529, 5178, 4526, 4608, 4529, 4529, 3826, 3825, 5704,
  5440, 4723, 4529, 4294, 4529, 4290, 4084, 4529, 4529, 4367, 5441, 4724, 4529, 4529, 4478, 4635, 4606, 4529, 5550,
  4529, 4529, 4529, 4602, 5251, 4529, 4529, 5675, 5704, 5676, 4529, 4529, 4487, 4529, 4731, 4529, 4529, 5674, 4738,
  4529, 4529, 4529, 4617, 4603, 4529, 4609, 4497, 4753, 4739, 4529, 5022, 4372, 4529, 4739, 4529, 4626, 4605, 4609,
  4669, 4740, 4529, 4529, 5704, 4604, 4938, 4529, 4626, 4703, 4529, 4939, 4529, 4937, 4725, 4725, 4529, 4703, 4529,
  4746, 4669, 4529, 4671, 4608, 4227, 4529, 4529, 3953, 4678, 4769, 4297, 3956, 4529, 4529, 4626, 5556, 4123, 5262,
  4776, 4778, 4782, 4786, 4788, 4792, 4796, 4798, 4798, 4803, 4798, 4804, 4799, 4808, 4810, 4814, 4814, 4814, 4816,
  4820, 4529, 5612, 3714, 4529, 4331, 4332, 3890, 3852, 4904, 4909, 4529, 4529, 4491, 4529, 4529, 5185, 4915, 4529,
  4332, 3852, 4330, 4697, 4529, 4626, 4830, 4843, 4529, 4627, 4529, 4332, 3891, 3852, 3858, 4327, 4626, 4850, 4529,
  4341, 4154, 4617, 5718, 4529, 4529, 5023, 4894, 4864, 4529, 4881, 4529, 4365, 4012, 4363, 4529, 4529, 4529, 5774,
  4726, 4876, 4228, 4886, 5242, 4234, 4529, 4529, 4529, 4213, 5766, 4529, 4209, 4529, 4365, 4012, 4364, 4013, 4529,
  4529, 4673, 4697, 4529, 4529, 4898, 4529, 4529, 4529, 4620, 5522, 5241, 4839, 4529, 4529, 5702, 4903, 4908, 4529,
  4529, 4529, 4711, 5689, 5458, 4529, 4529, 4529, 4626, 5511, 4696, 4529, 4529, 4529, 4627, 4529, 5042, 4529, 4529,
  4607, 4529, 4529, 5043, 4529, 4765, 4919, 4927, 4529, 4529, 4529, 4656, 4011, 4668, 4529, 4529, 4607, 5615, 4529,
  4931, 4616, 4529, 4429, 4529, 4445, 4529, 4943, 4617, 4529, 4432, 4668, 4668, 4641, 4529, 4529, 5142, 3960, 4529,
  4529, 5145, 4529, 5176, 4529, 4529, 4529, 4667, 4975, 4529, 4529, 4529, 4669, 4948, 4973, 4084, 4529, 4529, 5175,
  5290, 5719, 4952, 4529, 4527, 4529, 4529, 4529, 4960, 4529, 4529, 4610, 4529, 5011, 4852, 4617, 4529, 4529, 4529,
  4463, 4974, 4529, 4529, 4529, 4727, 4979, 5250, 4529, 5184, 4360, 4529, 4529, 4695, 4529, 5510, 4988, 4529, 4529,
  4611, 4615, 4979, 5250, 4529, 4529, 4616, 5003, 4614, 4529, 4529, 4529, 4868, 5010, 4499, 4529, 4529, 4672, 4670,
  4612, 4616, 4529, 4529, 4529, 4854, 4673, 5254, 4529, 5719, 4364, 4529, 4362, 4529, 4529, 4011, 4529, 4365, 4529,
  4529, 4529, 4673, 4676, 4364, 4529, 4012, 4363, 4226, 4529, 4529, 4529, 4879, 5720, 5015, 5029, 5033, 5047, 4877,
  5053, 4880, 5082, 5083, 5087, 5095, 5095, 5095, 5094, 5091, 5099, 5103, 5107, 5109, 5110, 5115, 5115, 5111, 4529,
  4529, 4676, 4529, 4529, 4998, 5783, 5195, 4529, 4483, 4529, 4529, 5700, 4511, 4224, 4529, 5119, 4719, 5589, 4923,
  4529, 4529, 4712, 5021, 4529, 5703, 4529, 4529, 4771, 4529, 5704, 5153, 4529, 5704, 5144, 4529, 4529, 5155, 5704,
  5211, 4529, 5389, 4529, 4529, 4529, 5149, 4833, 4846, 4529, 5159, 5164, 5169, 4529, 4455, 4529, 5183, 4625, 4529,
  4520, 5619, 5627, 5631, 4624, 4529, 4529, 4529, 4910, 4529, 5781, 5193, 4529, 4528, 4529, 4529, 4674, 4529, 4716,
  4529, 4606, 4529, 4091, 4529, 4529, 4529, 4995, 5199, 4083, 4529, 4529, 4529, 4822, 4529, 4529, 5704, 5206, 4084,
  4129, 3871, 3870, 4131, 4084, 5431, 4084, 4150, 5596, 4764, 4529, 5360, 5391, 4529, 4530, 4529, 4529, 4527, 4610,
  5178, 5178, 4529, 4529, 4529, 4531, 5783, 3714, 4529, 4529, 4823, 4529, 4718, 5588, 4922, 4529, 4537, 5353, 4529,
  4548, 4529, 4529, 5025, 4664, 4529, 5231, 4529, 4529, 4824, 4529, 4529, 4529, 5173, 5210, 4529, 4529, 4529, 4998,
  4461, 5218, 4529, 4529, 4529, 5022, 5176, 5178, 4529, 4529, 4825, 4996, 5782, 3713, 4529, 4529, 4529, 5042, 4718,
  4348, 4923, 4529, 4552, 4275, 4529, 3956, 4529, 4529, 4529, 4151, 5219, 4529, 4529, 4529, 5143, 4998, 5246, 4617,
  4529, 4575, 4579, 5580, 4618, 5269, 4529, 4529, 4878, 4353, 4224, 4529, 5554, 5259, 4529, 4529, 5189, 4529, 4529,
  4890, 4234, 4626, 4606, 4122, 4529, 4529, 5773, 4529, 4529, 4529, 5175, 4529, 4529, 4821, 4529, 4529, 4529, 5186,
  4529, 4525, 5185, 3956, 4121, 4091, 4529, 4529, 5254, 4529, 4132, 4529, 4529, 5251, 4529, 4529, 5254, 4529, 5252,
  4529, 4529, 4529, 5188, 4506, 4529, 4529, 5174, 4981, 5273, 5279, 3743, 3844, 4667, 5287, 4529, 4609, 4529, 4529,
  4529, 4098, 4970, 4509, 4151, 5021, 4563, 4568, 4566, 5525, 5527, 5300, 5306, 5312, 5312, 5314, 5312, 5318, 5308,
  5322, 5325, 5329, 5329, 5329, 5331, 5335, 4529, 4529, 4529, 5225, 4529, 5584, 5187, 4529, 4529, 4140, 4529, 5039,
  5576, 5036, 4623, 4548, 4529, 4613, 4617, 4529, 4454, 4529, 4734, 5346, 4529, 4529, 4622, 5405, 5352, 4529, 4529,
  4529, 5227, 4235, 5358, 4529, 5357, 4251, 4529, 4529, 4529, 5239, 5367, 4529, 5227, 4529, 4616, 4616, 4529, 4467,
  4529, 4529, 4232, 4529, 3929, 5382, 3929, 5382, 5585, 4529, 4529, 4529, 5254, 4145, 5174, 4529, 4529, 5136, 5170,
  4725, 5263, 4955, 4084, 4366, 5570, 4529, 4617, 4529, 3957, 4249, 4529, 4529, 4529, 5341, 4529, 4622, 4880, 4677,
  4617, 4624, 4677, 4529, 5188, 4529, 4529, 5165, 5170, 5400, 5406, 5395, 4529, 4529, 3929, 4617, 3929, 4617, 4741,
  5264, 4956, 5336, 5759, 4151, 4529, 4529, 4529, 5400, 5407, 5378, 4529, 4529, 5171, 4994, 4622, 5405, 4448, 5250,
  4013, 4529, 4529, 4673, 4674, 3845, 4667, 4153, 4529, 4618, 4529, 4525, 4610, 4529, 4622, 4529, 5227, 4670, 4670,
  4529, 4966, 4448, 4529, 4529, 4529, 5401, 5407, 4606, 4529, 4529, 4529, 5508, 4919, 4450, 4529, 4529, 4529, 5522,
  5225, 5225, 4529, 4529, 5179, 5425, 4529, 4529, 5184, 4914, 5173, 4529, 4982, 4954, 4084, 4710, 4529, 4529, 5185,
  4361, 5251, 5174, 4529, 5227, 5226, 4672, 5406, 4449, 4529, 4529, 5235, 4647, 4450, 4529, 5225, 5226, 4529, 5227,
  4529, 4617, 4529, 4529, 5535, 4665, 4153, 4529, 4529, 5253, 4529, 4529, 4529, 5187, 5411, 4529, 4529, 4529, 5533,
  4529, 5418, 4617, 4529, 4626, 4606, 4121, 4772, 5172, 4529, 4983, 5122, 4529, 4529, 5553, 5642, 4365, 4529, 5172,
  4677, 4964, 4529, 4529, 5223, 4529, 4090, 5419, 4671, 4529, 4529, 5268, 4529, 4529, 5424, 4668, 4529, 4658, 4616,
  4529, 4376, 5275, 4962, 4529, 5416, 4529, 4551, 4274, 3714, 4529, 4098, 5586, 4529, 4099, 4103, 5249, 5171, 4679,
  4529, 4529, 5302, 4529, 4529, 5423, 5296, 3952, 4826, 4666, 5553, 4669, 4069, 4529, 4529, 3958, 4529, 4529, 4529,
  5765, 4529, 5175, 5295, 4529, 5139, 5369, 4529, 5292, 5296, 5175, 5295, 5553, 5388, 4529, 4529, 5017, 4529, 4529,
  5294, 4529, 4668, 3837, 4529, 5556, 5175, 5295, 4529, 5293, 5293, 4668, 4668, 5556, 5292, 5292, 5292, 4224, 5696,
  5697, 5699, 4529, 4529, 5363, 5390, 4529, 5435, 4529, 5759, 5059, 5068, 5075, 4836, 4117, 4529, 4120, 4529, 5445,
  4301, 5451, 4300, 5383, 5465, 5466, 5463, 5470, 5471, 5475, 5487, 5479, 5479, 5488, 5484, 5480, 5492, 5495, 5499,
  5501, 5501, 5501, 5505, 4529, 4626, 4577, 4581, 3714, 4118, 4529, 3959, 5391, 5515, 4529, 4529, 4529, 5537, 4860,
  4870, 4529, 4529, 5373, 5377, 4529, 4529, 5519, 4529, 5531, 4866, 5542, 5548, 5561, 3715, 4529, 4529, 4529, 5552,
  4529, 4366, 5566, 4529, 4529, 5387, 4529, 4118, 4529, 3958, 5390, 4422, 4529, 4529, 4999, 4529, 3954, 4529, 4669,
  4529, 4529, 4145, 4529, 5600, 4762, 4529, 4529, 5389, 4121, 4726, 5178, 4529, 4529, 5439, 4649, 5606, 4084, 4529,
  4529, 4529, 4218, 4578, 5580, 4529, 4529, 5509, 4660, 5362, 4117, 4529, 3957, 4998, 4084, 3954, 4529, 4677, 4142,
  3835, 4870, 4529, 4150, 5596, 4763, 4529, 5610, 4529, 4683, 4648, 4687, 5636, 5580, 4529, 4529, 5538, 4529, 5551,
  4529, 4529, 5359, 4879, 4879, 4118, 3957, 5391, 4527, 4998, 4084, 3955, 5720, 4529, 4529, 4529, 5556, 5142, 5619,
  5628, 5632, 4529, 5704, 5640, 5683, 5630, 4529, 4529, 5177, 4529, 4619, 4529, 5178, 4529, 4529, 5583, 5587, 4529,
  5172, 5650, 4529, 5549, 4529, 4689, 5587, 4529, 4626, 4529, 4529, 4983, 4954, 4529, 5361, 5554, 4120, 5655, 4529,
  5660, 3954, 4529, 5671, 4529, 4529, 5645, 4870, 5682, 5629, 4084, 4529, 4745, 4529, 5061, 5684, 5631, 4529, 4529,
  5175, 4529, 5651, 4529, 5550, 5656, 4361, 3955, 4529, 4854, 4529, 4529, 4610, 4677, 4462, 5688, 4529, 4529, 5695,
  5697, 5697, 5689, 4529, 4529, 4529, 5565, 4132, 4529, 4529, 4529, 5594, 4150, 5688, 4529, 4529, 5696, 5697, 5697,
  5697, 5697, 4529, 4529, 4481, 4529, 4529, 4529, 5644, 4621, 4621, 4619, 4529, 4858, 4628, 4529, 4350, 4529, 4529,
  4153, 4151, 4090, 4529, 4621, 4529, 4872, 5187, 5550, 4620, 4529, 4529, 4529, 5646, 5063, 4620, 4618, 4529, 4877,
  4352, 4529, 4112, 4529, 4529, 4944, 4529, 4620, 4618, 5693, 5709, 5717, 5712, 5705, 5457, 4384, 5724, 5726, 5728,
  5736, 5728, 5733, 5729, 5738, 5742, 5749, 5746, 5749, 5749, 5750, 5754, 5758, 4529, 4529, 5700, 4529, 4261, 4152,
  4529, 4529, 5702, 4529, 5177, 4529, 4529, 4529, 5680, 4529, 5764, 4529, 3961, 4529, 4529, 4529, 5704, 4486, 4529,
  4529, 4529, 5697, 5698, 4529, 5055, 4529, 4529, 5763, 5770, 5778, 4529, 3931, 4529, 4877, 4497, 4529, 4755, 4324,
  4529, 4529, 4529, 5145, 3930, 4529, 4877, 4497, 5389, 4525, 4529, 4529, 5509, 4972, 4364, 4529, 4529, 4529, 5772,
  5555, 4529, 4529, 4529, 4885, 4529, 4529, 4520, 5078, 5606, 3828, 4529, 4529, 4529, 4898, 5544, 4529, 4675, 4676,
  5454, 5704, 4529, 4529, 4529, 4899, 4223, 4529, 4111, 4529, 4529, 3962, 4529, 8388608, 16777216, 1073741824, 0, 0, 0,
  -1610612736, 1073872896, 131072, 131072, 131072, 257, 525312, 67174657, 268435456, 0, 262146, 262160, 268566528,
  131072, 537133056, -2147221504, -2147221504, -2147221504, 262144, 524288, 262160, 537133056, 33816576, 537133056,
  -2147221504, 262144, -2147483648, 0, 0, 24, 0, 262174, 262160, 262144, 262144, 2048, 16777216, 262144, 262160,
  268444864, 10560, 33816576, 262144, 262144, 262144, 262144, 262160, 8768, 262144, 262144, 262144, 278528, 278528,
  278544, 537149440, 278530, 537149440, 278530, 772014080, 772014080, 772014080, -1375469568, 168034304, 772014080,
  235143168, 235143168, 772014080, 168034304, 772030464, -1375469568, 772014080, 772014080, 772014080, 168034304,
  168034304, 168034304, 235143168, 235143168, 235143168, 168034304, 168034304, 32768, 168034304, 32800, 163872, 294944,
  163840, 2392096, 294944, 537165856, -2147188704, 294944, 294944, -2147188704, 294944, -2147188674, -2145091522,
  -2145091522, -2145091522, 772046880, 772046880, -2111537090, -2145091522, -2145091522, -2145091522, -1910210498, 4096,
  4096, 65536, 0, 0, 1, 2, 0, 0, 12, 14, 0, -1608515584, 0, 0, 64, 128, 256, 128, 8256, 0, 0, -2147483648, 0, 0, 0,
  32800, 2097152, 2129920, 2129920, 2129920, 2129920, 16, 2129952, 2129920, 2129920, 2129920, 0, 12, 2129920, 2129920,
  32768, 2129920, 4096, 65536, 16777216, 0, -1073741824, 0, 0, 0, 2629632, 32, 2097152, 2129920, 2097184, 2097184,
  2097184, 2097184, 2129920, 2129920, 2129920, 32768, 0, 2129920, 2129920, 32768, 32768, 32768, 2129920, 2129920, 32768,
  0, 8192, 64, 0, 41943040, 0, 32768, 2129920, 32768, 32768, 0, 32, 32768, 2129920, 2129920, 2129920, 65536, 0, 32, 32,
  32, 32, 2097184, 32768, 32768, 32, 32, 2097152, 2097184, 32768, 2129920, 32768, 2129920, 0, 0, 0, 48, 0, 0, 80, 272,
  65552, 262160, 16, 20, 16, 48, 1572880, 524304, 524304, 1048592, 268435472, 16, 1048592, 16, 16, 16, 16, 0, 0,
  8388608, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 16, 20, 304, 48, 524304, 16, 16, 16, 20, 48, 16, 21, 16, 28, 0, 2, 304, 17,
  16, 16, 16, 28, 16, 16, 165675008, 272, 272, 272, 272, 16, 16, 272, 16, 524560, 1048592, 272, 16, 16, 48, 16, 16, 17,
  20, 1887436800, 0, 0, 8, 262144, 0, 0, 84, 20, 372, -165649452, -165649452, -165649451, -165649451, -164559888,
  -164535312, -164535312, -164535308, -701430800, -164535308, -701430800, -701430800, -701430800, -701430800,
  -164273168, -164535308, -164273164, -164535308, -164535308, -164535308, -164535308, -700906508, -700906512,
  -701430800, -164535308, -164273164, -26141771, 0, 16, 1073774592, 16, 16, 2, 1073774592, 16, 20, 112, 21, 53,
  140511253, 140515349, 140539925, 140540573, 140540573, 140540605, 140540573, 140540573, 140540573, 140540573, 262144,
  524288, 0, 0, 0, 2013265920, 3745792, 163577856, 0, 0, 0, 265, 0, 100663296, 536870912, -2147483648, 0, 0, 0, 323,
  138412032, 0, 4096, 0, 0, 0, 331, 0, 239075328, 0, 0, 1, 4, 16, 32, 128, 512, 4096, 16777216, 33554432, 67108864, 0,
  12582912, 0, 0, 0, 448, 2, 0, 64, 0, 65536, 0, 0, 0, 4096, 0, 16384, 0, 2097152, 0, 524288, 40960, 0, 0, 0, 8388608,
  2105344, 2097152, 0, 0, 1, 16, 538968064, 0, 0, 0, 33554432, 0, 0, 2629632, 0, 0, 0, 8192, 0, 0, 0, 38, 16, 1048576,
  941162496, 941162496, 941162496, 941162496, 941162496, 805371937, 805371937, 805371937, 847314977, 957941825,
  957941827, 2031683649, 957941825, 957941825, 957941857, 957941859, 960047171, 960038977, 957941857, 960047171,
  957941857, 957941857, 957941857, 957941857, 960038977, 957941857, 960038977, 960038977, 960038977, -1199980544,
  960174145, -1199980544, -1199980544, -1199980544, -1199980544, -1199718400, -1199718400, -1199718400, -1199717854,
  -1199717846, -1199717846, -1199717846, -1199717782, -1199717846, -1199717846, -1199717846, -1183201183, -1183201183,
  -1182938517, 0, 0, 0, 10240, 526336, 16777216, 2105344, 0, -701430800, 0, 0, -134217728, 0, 1638400, 939524096, 0, 0,
  0, 16384, 0, 0, 0, 5, 1, 65536, 805306368, 0, 0, 0, 19504, 0, 805306368, 0, 0, 1, 256, 4096, 1640448, 939524096, 0, 0,
  1, 262144, 2097152, 0, 0, 0, 7979008, -1207959552, 0, 0, 8241152, 0, 0, 512, 16384, 0, 8241152, 0, 7981056, 8243200,
  16777216, -1207959552, 0, 0, 8388608, 33554432, 67108864, 134217728, 1073741824, 0, 65536, 1572864, 939524096, 0,
  -436207616, 0, 0, 2, 3072, 16384, 114688, 1572864, 6291456, 939524096, 0, 4096, 196608, 0, 0, 16384, 1073741824,
  138412032, 0, 0, 1073741824, 512, 262144, 0, 2048, 16777216, 8192, 0, 8388608, 33554432, 134217728, 1073741824, 0, 0,
  939524096, 0, 0, 2, 32, 3072, 4194304, 939524096, -2147483648, 0, 0, 17408, 0, 0, 32768, 32768, 32768, 32768, 0, 0, 0,
  262144, 0, 2048, 24576, 2097152, 0, 0, 32768, 1048576, 4194304, 0, 0, 1048576, 0, 1048576, 536870912, 0, 0, 8388608,
  33554432, 1073741824, 0, 2, 0, 0, 0, 128, 0, 0, 0, 135, 325888, 49152, 1048576, 4194304, 536870912, -2147483648,
  268435456, 0, 0, 4096, 2048, 0, 4740, 256, 0, 256, 0, 256, 257, 4740, 536871168, 67109121, -1507782399, -1507782399,
  -1507782399, -1507782399, -2145386488, -1876951032, -2145386488, -2145386456, -2145381716, -1507782391, -432729847,
  -1507782391, -432729847, -1507782391, -1507782391, -1507782391, -1507782391, -432729847, -432729847, -432729847,
  -432729847, -1344145085, -432729847, -1344145085, -1344145085, -1344145085, -1344145085, -1344145077, -1344145077,
  -1344145077, 0, 0, 131072, 24, 304, 48, 1048848, 0, 132, 256, 0, 0, 262144, 262144, 262160, -2147221504, 262144, 0, 2,
  16, 16, 16, 131088, 0, 257, 0, 131072, 262144, 2097152, 25165824, 0, 0, 525312, 0, 0, 0, 59392, 2166784, -1509949440,
  0, 0, 2, 128, 8192, 262144, 8, 2097152, -2147483648, 0, 0, -1879048192, 0, 0, 40, 0, 172, 265, 0, -1509949440, 0, 0,
  262144, 1048576, 0, 0, 4, 64, 0, 0, 323, 14809088, -1358954496, 0, 0, 331, 0, 0, 0, 65536, 0, 67108864, 0, 257,
  131072, 0, 0, 262144, 33554432, 8192, 0, 0, 32, 65536, 0, 257, 69632, 2097152, 2097152, 0, 0, 1, 6, 69632, 0, 0, 0,
  131072, 0, 0, 0, 0, -126877696, 0, 3407872, 1610612736, 0, 0, 3, 19488, 129024, 2097152, 12582912, 50331648,
  201326592, 536870912, -2147483648, 0, 0, 294912, 0, 0, 524288, 2097152, 8388608, 33554432, 4096, 65536, 2097152,
  33554432, 201326592, 536870912, 0, 0, 524292, 262145, 262145, 0, 262145, 262145, 524292, 8, 2097152, 0, 0, 4, 8, 16,
  256, 512, 1024, 4096, 4194304, 16777216, 40, 0, 44, 0, 0, 1640448, 16777216, 33554432, 67108864, 536870912,
  -2147483648, 114688, 2097152, 12582912, 16777216, 33554432, 201326592, 0, 0, 4, 128, 512, 0, 0, 0, 1024, 0, 0, 0, 192,
  16384, 268435456, 536870912, 0, 0, 0, 256, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 65536, 33554432, 67108864, 0, 0, 3477504,
  -436207616, 262144, 1048576, 1073741824, 0, 8192, 0, 64, 256, 2048, 4096, 8192, 114688, 12582912, 16777216, 201326592,
  65536, 67108864, 0, 0, 4, 256, 131072, 1048576, 4194304, 134217728, 805306368, -2147483648, 0, 0, 16777216, 0, 0, 0,
  32768, 0, 0, 0, 8, 0, 0, 0, 16, 16, 32768, 1, 2, 256, 2048, 16777216, 201326592, 0, 0, 4, 262144, 262144, 1048576, 0,
  8, 262144, 16777216, 0, 0, 4, 32, 128, 512, 0, 1024, 268435456, 1073741824, 4096, 16777216, 0, 0, 8192, 262144,
  1048576, 262144, 1048576, 8, 0, 64, 0, 4194304, 12582912, 16777216, 134217728, 0, 0, 0, 6, 16384, 65536, 0, 1, 65536,
  0, 0, 257, 49152, 65536, 8388608, 134217728, 0, 0, 4096, 0, 32768, 134217728, 0, 0, 0, 16, 32, 65536, 0, 0, 49152,
  65536, 1048576, 8388608, 33554432, 67108864, 0, 0, 6291456, 0, 0, 2048, 8192, 514, 8388608, 0, 0, 4, 524288, 0, 0,
  16384, 0, 131328, 131328, 1024, 131328, 131328, 0, 131328, 17039368, 131328, 807043332, 807043332, 807043332,
  807043332, 807043332, 806912004, 806912004, 806912004, 806928388, 806929412, 1880785156, 1880785156, 1880785156,
  1880785156, 1880795396, 1880785156, 1880785156, 1889173780, 1880785156, 1880785156, 1880785156, 1880795396,
  1880795396, 1880795910, -1199914555, 1880795396, -1199914555, -1199914555, -1199914555, -1199914555, -126172731,
  -126172731, -126172731, 0, 0, 0, 393216, 0, 0, 0, 524288, 0, 256, 688128, 806354944, 0, 0, 50855936, 0, 0, 67108864,
  1048576, 2097152, 4194304, -1207959552, 4, 557056, 806354944, 0, 0, 67633152, 1200, 688128, 1880096768, 0, 0, 4,
  268435456, 536870912, 0, 20, 1888485376, 0, 0, 6, 20480, 0, 1880096768, 0, 0, 6, 30720, 524288, -2147483648, 0, 0, 8,
  1024, 11008, 0, 0, 0, 1048576, 0, 0, 0, 10496, 5, 16832, 688128, -1200619520, 0, 4, 32768, 524288, 1048576, 4194304,
  536870912, 0, 0, 6, 0, 0, 0, 1572864, 0, 32, 0, 65536, 0, 0, 33554432, 0, 67108864, 0, 0, 0, 2, 512, 0, 0, 256, 16384,
  131072, 1048576, 8388608, 0, 50331648, 0, 4194304, 402653184, 536870912, -2147483648, 0, 4, 131072, 1048576,
  134217728, 805306368, 0, 0, 32768, 8388608, 134217728, 0, 0, 4, 1048576, 268435456, 536870912, 192, 16384, 131072,
  1048576, 4194304, 0, 2, 0, 8, 268435456, 0, -2147483648, 4, 131072, 268435456, 536870912, 536870912, 0, 32768, 0,
  32768, 0, 192, 16384, 131072, 4194304, 134217728, 268435456, 536870912, -2147483648, 0, 0, 65536, 33554432, 0,
  134217728, 0, 4096, 0, 16777216, 134217728, 268435456, 536870912, 0, 0, 134217728, 524288, 0, 524288, 524288, 0, 0, 0,
  2, -2147483648, 0, 268435456, 536870912, 0, 0, 268435456, 4608, 0, 16384, 0, 16, 0, 8, 64, 0, 4194304, 0, 8388608,
  33554432, 0, 0, 0, 49152, 1048576, 4194304, 134217728, 0, 65600, 32768, 1048576, 8388608, 50331648, 16777216, 0, 0,
  538968064, 0, 0, 572522496, 0, 0, 1610612736, 0, 0, 16, 1048576, 0, 0, 12, 8, 65600, 16, 0, 0, 14, 0, 0, 128, 0, 128,
  1024, 0, 1280, 0, 0, 128, 131072, 536871040, 128, 0, 256, 1024, 1075839492, 128, 4096, 128, 256, 4096, 57344,
  -1610079071, -1610079071, -1610079071, -1610079071, -2146819039, -2146950111, -2146917343, -1073208287, -1073077215,
  -1610062687, -1610062687, -1559731039, -1593285471, -1610062687, -1610062687, -1610062687, -1610062687, -1610062687,
  -1542953823, -1610062671, -1542953823, -1408736095, -1542953823, -1408736095, -1542953823, -1592859485, -1408736095,
  -1592859485, -1592859485, -1592859485, -1592859485, -1592857437, 0, -1592857437, -1592857437, -1592857437,
  -1592857437, 0, 536870912, 0, 8, 0, 16777216, 8192, 64, 64, 64, 0, 516, 2097152, 0, 0, 16, 131072, 1, 1184, 8192,
  524288, 0, 16777216, 0, 1, 2, 4, 32, 0, 0, 1, 1056, 8192, 655360, 1184, 24576, -1610612736, 0, 0, 17301504,
  -1476395008, 0, 0, 0, 3872768, 0, 3, 1184, 57344, 17694720, 17694720, -1610612736, 0, 0, 0, 2097152, 0, 0, 0, 2048, 0,
  0, 0, 3072, 59392, 0, 0, 0, 4194304, 0, 0, 0, 512, 0, 131072, 16777216, 268435456, 1073741824, 0, 0, 160, 1024, 8192,
  524288, 16777216, 536870912, -2147483648, 32, 1024, 8192, 524288, 0, 24576, 0, 0, 0, 3737600, 160, 1024, 57344,
  393216, 16777216, 536870912, 0, 4, 512, 0, 0, 16, 536870912, 0, 0, 128, 8192, 536870912, 0, 1, 2, 64, 256, 0, 2,
  16384, 32768, 131072, 524288, 1048576, 16384, 32768, 393216, 16777216, 67108864, 0, 0, 0, 262144, 0, 0, 0, 40960,
  4194304, 0, 0, 8388608, 4096, 0, 0, 2, 0, 0, 32768, 131072, 1073741824, 0, 4194304, 0, 4096, 0, 4608, 16777216, 0, 2,
  268435464, 4096, 65536, 1048576, 4194304, 8388608, 0, 33554432, 1073741824, 8192, 2097152, 0, 0, 2048, 16384, 8388608,
  16777216, 0, 0, 2359297, 0, 0, 4194304, 8388608, 0, 0, 524292, 539230225, 539230225, -1608253423, 540278803,
  539230225, 539230225, 539230225, 539230225, 572784657, 540278803, 539230225, 572784657, 539230225, 572784657,
  539230225, 540278803, 540278803, 540278803, 540311571, 94850083, 540279315, 94850083, 94850083, 94850083, 94850083,
  631721011, 631721011, 631721011, 0, 0, 0, 16777216, 8192, 1, 0, 0, 0, 17303552, 528, 0, 0, 0, 41943040, 0, 19488,
  458752, 94371840, 0, 0, 19504, 631242752, 0, 0, 0, 67108864, 0, 1048576, 0, 65536, 3, 3145728, 0, 0, 64, 32768, 0, 3,
  32, 19456, 458752, 2097152, 25165824, 67108864, 0, 603979776, 0, 0, 0, 138412032, 64, 384, 0, 0, 0, 134217728, 0, 0,
  262144, 2097152, 25165824, 67108864, 536870912, 0, 0, 3, 32, 3072, 32, 3072, 16384, 65536, 131072, 262144, 16384,
  131072, 2097152, 25165824, 0, 16, 536870912, 16, 536870912, 0, 16, 536870912, 0, 3072, 16384, 2097152, 8388608,
  16777216, 16384, 8388608, 0, 0, 160, 24576, 268435456, 0, 4, 0, 1, 2, 2048, 4096, 114688, 12582912, 32, 1073741824, 0,
  0, 172, 2101760, 4, 131104, 1048, 0, 1, 4, 128, 0, 0, 256, 131072, 0, 8389656, -2147483646, 0, -2147483646, 0,
  -2147483646, -2147483646, -2146938874, -2146938874, -2146938874, -2146938874, 2650112, 271085568, 2650112, 141062144,
  141062144, -2144831482, -2144831482, -2144831482, -2144831482, -2077722618, -2144831482, -2140637178, -2144831482,
  -2146928634, -2146928634, -2146928634, -2144831482, -2144831482, -2144765946, -2146928634, -2144700378, -1593280506,
  -1593280506, -1593280506, -1593280506, -2109935225, -1593280506, -2109935225, -2109935225, -2109935225, -2109935225,
  -2109933177, -2109933177, -2109933177, 0, 1, 4, 192, 16384, 4194304, 134217728, 0, 32, 131072, 24, 0, 28672, 2621440,
  0, 1, 4, 448, 262145, 2359297, 2359297, 2359297, 2359297, 0, 6815744, 0, 0, 192, 536870912, 0, 0, 12, 0, 0, 2621440,
  -2147483648, 0, 6, -2147483648, 0, 96256, 0, 0, 0, 268435456, 0, 0, 0, 64, 0, 0, 0, 40, 38, 161792, 17301504,
  -1610612736, 135, 323840, 3670016, 33554432, -2147483648, 325888, -2147483648, 0, 0, 1024, 524288, 0, 0, 3, 540016640,
  4194304, 16777216, 1073741824, 0, 1, 4, 262144, 524288, 4194304, 0, 0, 65536, 1048576, 939524096, 6, 4096, 16384,
  524288, 2097152, 0, 0, 24576, 524288, 2097152, 134217728, 134217728, 262144, 1572864, 2097152, 33554432, 6, 2048, 0,
  0, 1024, 8388608, 1073741824, 0, 0, 128, 256, 8192, 16384, 16384, 0, 32768, 32768, 32768, 262144, 524288, 1048576,
  2097152, 33554432, -2147483648, 0, 0, 8, 256, 512, 1024, 2, 4, 128, 256, 0, 0, 2, 4, 16384, 524288, 4, 8, 1024,
  4194304, 0, 0, 32, 0, 134217728, 0, 2, -2147483648, 0, 0, 2048, 16777216, 0, 16384, 524288, 2097152, 6291456, 8192,
  2097152, 536870912, 0, 1, 49152, 65536, 12582912, 134217728, 2, 4, 128, 8192, 16384, 262144, 524288, 1048576, 262144,
  1048576, 33554432, 0, 0, 1, 256, 0, 0, 16384, 16384, 16384, 16384, 0, 0, 16, 0, 0, 0, 1, 0, 0, 4352, 17152, 17152, 0,
  0, 0, 805306368, 12288, 0, 0, 0, 536870912, 0, 0, 0, 3072, 3072, 3072, 15396, 15396, 15396, 15396, 15406, 15652,
  15652, 15652, 15396, 15396, 15652, 15406, 15406, 15406, 15422, 15406, 68, 15406, 68, 324, 324, 68, 68, 68, 68, 324,
  4164, 8260, 15716, 15716, 15460, 0, 0, 0, 1073741824, 0, 46, 0, 0, 0, 1879048192, 0, 0, 62, 0, 0, 16384, 32768,
  393216, 0, 0, 4, 32, 0, 2, 256, 32768, 131072, 16777216
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "StringConstructorChars",
  "S",
  "S",
  "CommentContents",
  "PragmaContents",
  "Wildcard",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "EOF",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'=>'",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "']``'",
  "'``['",
  "'`{'",
  "'after'",
  "'all'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'any'",
  "'array'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'contains'",
  "'content'",
  "'context'",
  "'copy'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'diacritics'",
  "'different'",
  "'digit'",
  "'distance'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'entire'",
  "'eq'",
  "'every'",
  "'exactly'",
  "'except'",
  "'exponent-separator'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'from'",
  "'ft-option'",
  "'ftand'",
  "'ftnot'",
  "'ftor'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'insensitive'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'invoke'",
  "'is'",
  "'item'",
  "'language'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'levels'",
  "'lowercase'",
  "'lt'",
  "'map'",
  "'minus-sign'",
  "'mod'",
  "'modify'",
  "'module'",
  "'most'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'not'",
  "'occurs'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'paragraph'",
  "'paragraphs'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'phrase'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'relationship'",
  "'rename'",
  "'replace'",
  "'return'",
  "'revalidation'",
  "'same'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'score'",
  "'self'",
  "'sensitive'",
  "'sentence'",
  "'sentences'",
  "'skip'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'stemming'",
  "'stop'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'thesaurus'",
  "'times'",
  "'to'",
  "'transform'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'update'",
  "'updating'",
  "'uppercase'",
  "'using'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'weight'",
  "'when'",
  "'where'",
  "'wildcards'",
  "'window'",
  "'with'",
  "'without'",
  "'word'",
  "'words'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}`'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 4096,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 4096
    let $end := $end - $result idiv 512
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 512 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 4096 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 4095) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 4096, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 8
    let $i0 := $t * 2570 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 16 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(81, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 19) then                 (: CommentContents :)
            let $state := p:consume(19, $input, $state)     (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(36, $input, $state)               (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consume(49, $input, $state)               (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: S^WS :)
      let $state := p:consume(18, $input, $state)           (: S^WS :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  return $state
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(190, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionBody($input, $state)
      return $state
    else
      let $state := p:consume(132, $input, $state)          (: 'external' :)
      return $state
  return $state
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(251, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(132, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(98, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse CompatibilityAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompatibilityAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(246, $input, $state)              (: 'updating' :)
  return $state
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 32                               (: '%' :)
      and $state[$p:l1] != 246) then                        (: 'updating' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 246) then                (: 'updating' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-CompatibilityAnnotation($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Annotation($input, $state)
            return $state
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 251) then                      (: 'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:consume(57, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(64, $input, $state)           (: '>>' :)
      return $state
  return $state
};

(:~
 : Try parsing NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:consume(57, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(64, $input, $state)           (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:consume(27, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:consume(53, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:consume(58, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(63, $input, $state)           (: '>=' :)
      return $state
  return $state
};

(:~
 : Try parsing GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:consume(27, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:consume(53, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:consume(58, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(63, $input, $state)           (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
  return $state
};

(:~
 : Try parsing ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(259, $input, $state)              (: 'without' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:consume(100, $input, $state)              (: 'content' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  return $state
};

(:~
 : Try parsing FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(259, $input, $state)              (: 'without' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:consume(100, $input, $state)              (: 'content' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnionExpr($input, $state)
  return $state
};

(:~
 : Parse FTContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(112, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 226) then                  (: 'start' :)
          let $state := p:consume(226, $input, $state)      (: 'start' :)
          return $state
        else
          let $state := p:consume(125, $input, $state)      (: 'end' :)
          return $state
      return $state
    else
      let $state := p:consume(126, $input, $state)          (: 'entire' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:consume(100, $input, $state)          (: 'content' :)
      return $state
  return $state
};

(:~
 : Try parsing FTContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(112, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 226) then                  (: 'start' :)
          let $state := p:consume(226, $input, $state)      (: 'start' :)
          return $state
        else
          let $state := p:consume(125, $input, $state)      (: 'end' :)
          return $state
      return $state
    else
      let $state := p:consume(126, $input, $state)          (: 'entire' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:consume(100, $input, $state)          (: 'content' :)
      return $state
  return $state
};

(:~
 : Parse FTBigUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 220) then                      (: 'sentence' :)
      let $state := p:consume(220, $input, $state)          (: 'sentence' :)
      return $state
    else
      let $state := p:consume(195, $input, $state)          (: 'paragraph' :)
      return $state
  return $state
};

(:~
 : Try parsing FTBigUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 220) then                      (: 'sentence' :)
      let $state := p:consume(220, $input, $state)          (: 'sentence' :)
      return $state
    else
      let $state := p:consume(195, $input, $state)          (: 'paragraph' :)
      return $state
  return $state
};

(:~
 : Parse FTScope.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: 'same' :)
      let $state := p:consume(212, $input, $state)          (: 'same' :)
      return $state
    else
      let $state := p:consume(114, $input, $state)          (: 'different' :)
      return $state
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTBigUnit($input, $state)
  return $state
};

(:~
 : Try parsing FTScope.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: 'same' :)
      let $state := p:consume(212, $input, $state)          (: 'same' :)
      return $state
    else
      let $state := p:consume(114, $input, $state)          (: 'different' :)
      return $state
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTBigUnit($input, $state)
  return $state
};

(:~
 : Parse FTDistance.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(116, $input, $state)              (: 'distance' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTRange($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnit($input, $state)
  return $state
};

(:~
 : Try parsing FTDistance.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(116, $input, $state)              (: 'distance' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTRange($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 261) then                      (: 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'sentences' :)
      let $state := p:consume(221, $input, $state)          (: 'sentences' :)
      return $state
    else
      let $state := p:consume(196, $input, $state)          (: 'paragraphs' :)
      return $state
  return $state
};

(:~
 : Try parsing FTUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 261) then                      (: 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'sentences' :)
      let $state := p:consume(221, $input, $state)          (: 'sentences' :)
      return $state
    else
      let $state := p:consume(196, $input, $state)          (: 'paragraphs' :)
      return $state
  return $state
};

(:~
 : Parse FTWindow.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnit($input, $state)
  return $state
};

(:~
 : Try parsing FTWindow.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTOrder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  return $state
};

(:~
 : Try parsing FTOrder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  return $state
};

(:~
 : Parse FTPosFilter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 257) then                      (: 'window' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'distance' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 114                            (: 'different' :)
          or $state[$p:l1] = 212) then                      (: 'same' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScope($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FTPosFilter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 257) then                      (: 'window' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'distance' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 114                            (: 'different' :)
          or $state[$p:l1] = 212) then                      (: 'same' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTScope($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTWeight.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(253, $input, $state)              (: 'weight' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing FTWeight.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(253, $input, $state)              (: 'weight' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-FTExtensionSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTExtensionSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-FTExtensionSelection-1($input, $state)
};

(:~
 : Parse FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FTExtensionSelection-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(157, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTExtensionSelection-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(157, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse FTRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FTRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTTimes.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(187, $input, $state)              (: 'occurs' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTRange($input, $state)
  let $state := p:consume(235, $input, $state)              (: 'times' :)
  return $state
};

(:~
 : Try parsing FTTimes.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(187, $input, $state)              (: 'occurs' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTRange($input, $state)
  let $state := p:consume(235, $input, $state)              (: 'times' :)
  return $state
};

(:~
 : Parse FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'any' :)
      let $state := p:consume(81, $input, $state)           (: 'any' :)
      let $state := p:lookahead1W(216, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'word' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 260) then                  (: 'word' :)
          let $state := p:consume(260, $input, $state)      (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'all' :)
      let $state := p:consume(76, $input, $state)           (: 'all' :)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:l1] eq 261) then                      (: 'words' :)
          let $state := p:lookahead2W(214, $input, $state)  (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 13061                      (: 'words' EOF :)
              or $state[$p:lk] = 14085                      (: 'words' '!=' :)
              or $state[$p:lk] = 19205                      (: 'words' ')' :)
              or $state[$p:lk] = 19717                      (: 'words' '*' :)
              or $state[$p:lk] = 20229                      (: 'words' '+' :)
              or $state[$p:lk] = 20741                      (: 'words' ',' :)
              or $state[$p:lk] = 21253                      (: 'words' '-' :)
              or $state[$p:lk] = 24837                      (: 'words' ':' :)
              or $state[$p:lk] = 26885                      (: 'words' ';' :)
              or $state[$p:lk] = 27397                      (: 'words' '<' :)
              or $state[$p:lk] = 29445                      (: 'words' '<<' :)
              or $state[$p:lk] = 29957                      (: 'words' '<=' :)
              or $state[$p:lk] = 30981                      (: 'words' '=' :)
              or $state[$p:lk] = 32005                      (: 'words' '>' :)
              or $state[$p:lk] = 32517                      (: 'words' '>=' :)
              or $state[$p:lk] = 33029                      (: 'words' '>>' :)
              or $state[$p:lk] = 36101                      (: 'words' ']' :)
              or $state[$p:lk] = 38661                      (: 'words' 'after' :)
              or $state[$p:lk] = 41221                      (: 'words' 'and' :)
              or $state[$p:lk] = 42757                      (: 'words' 'as' :)
              or $state[$p:lk] = 43269                      (: 'words' 'ascending' :)
              or $state[$p:lk] = 43781                      (: 'words' 'at' :)
              or $state[$p:lk] = 45317                      (: 'words' 'before' :)
              or $state[$p:lk] = 46853                      (: 'words' 'case' :)
              or $state[$p:lk] = 47365                      (: 'words' 'cast' :)
              or $state[$p:lk] = 47877                      (: 'words' 'castable' :)
              or $state[$p:lk] = 49413                      (: 'words' 'collation' :)
              or $state[$p:lk] = 50949                      (: 'words' 'contains' :)
              or $state[$p:lk] = 53509                      (: 'words' 'count' :)
              or $state[$p:lk] = 55557                      (: 'words' 'default' :)
              or $state[$p:lk] = 57605                      (: 'words' 'descending' :)
              or $state[$p:lk] = 58629                      (: 'words' 'different' :)
              or $state[$p:lk] = 59653                      (: 'words' 'distance' :)
              or $state[$p:lk] = 60165                      (: 'words' 'div' :)
              or $state[$p:lk] = 62213                      (: 'words' 'else' :)
              or $state[$p:lk] = 62725                      (: 'words' 'empty' :)
              or $state[$p:lk] = 64261                      (: 'words' 'end' :)
              or $state[$p:lk] = 64773                      (: 'words' 'entire' :)
              or $state[$p:lk] = 65285                      (: 'words' 'eq' :)
              or $state[$p:lk] = 66821                      (: 'words' 'except' :)
              or $state[$p:lk] = 69893                      (: 'words' 'for' :)
              or $state[$p:lk] = 73477                      (: 'words' 'ge' :)
              or $state[$p:lk] = 74501                      (: 'words' 'group' :)
              or $state[$p:lk] = 75525                      (: 'words' 'gt' :)
              or $state[$p:lk] = 76037                      (: 'words' 'idiv' :)
              or $state[$p:lk] = 80133                      (: 'words' 'instance' :)
              or $state[$p:lk] = 80645                      (: 'words' 'intersect' :)
              or $state[$p:lk] = 81157                      (: 'words' 'into' :)
              or $state[$p:lk] = 82181                      (: 'words' 'is' :)
              or $state[$p:lk] = 84741                      (: 'words' 'le' :)
              or $state[$p:lk] = 85765                      (: 'words' 'let' :)
              or $state[$p:lk] = 87301                      (: 'words' 'lt' :)
              or $state[$p:lk] = 88837                      (: 'words' 'mod' :)
              or $state[$p:lk] = 89349                      (: 'words' 'modify' :)
              or $state[$p:lk] = 91909                      (: 'words' 'ne' :)
              or $state[$p:lk] = 97029                      (: 'words' 'only' :)
              or $state[$p:lk] = 98053                      (: 'words' 'or' :)
              or $state[$p:lk] = 98565                      (: 'words' 'order' :)
              or $state[$p:lk] = 99077                      (: 'words' 'ordered' :)
              or $state[$p:lk] = 100613                     (: 'words' 'paragraphs' :)
              or $state[$p:lk] = 107781                     (: 'words' 'return' :)
              or $state[$p:lk] = 108805                     (: 'words' 'same' :)
              or $state[$p:lk] = 109317                     (: 'words' 'satisfies' :)
              or $state[$p:lk] = 113413                     (: 'words' 'sentences' :)
              or $state[$p:lk] = 115461                     (: 'words' 'stable' :)
              or $state[$p:lk] = 115973                     (: 'words' 'start' :)
              or $state[$p:lk] = 120581                     (: 'words' 'times' :)
              or $state[$p:lk] = 121093                     (: 'words' 'to' :)
              or $state[$p:lk] = 121605                     (: 'words' 'transform' :)
              or $state[$p:lk] = 122117                     (: 'words' 'treat' :)
              or $state[$p:lk] = 124677                     (: 'words' 'union' :)
              or $state[$p:lk] = 130821                     (: 'words' 'where' :)
              or $state[$p:lk] = 131845                     (: 'words' 'window' :)
              or $state[$p:lk] = 132357                     (: 'words' 'with' :)
              or $state[$p:lk] = 132869                     (: 'words' 'without' :)
              or $state[$p:lk] = 133893                     (: 'words' 'words' :)
              or $state[$p:lk] = 136453                     (: 'words' '|' :)
              or $state[$p:lk] = 136965                     (: 'words' '||' :)
              or $state[$p:lk] = 137477                     (: 'words' '}' :)
              or $state[$p:lk] = 137989) then               (: 'words' '}`' :)
          let $state := p:memoized($state, 23)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:consume(261, $input, $state)  (: 'words' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 71429                      (: 'words' 'ftand' :)
              or $state[$p:lk] = 72453                      (: 'words' 'ftor' :)
              or $state[$p:lk] = 95493                      (: 'words' 'not' :)
              or $state[$p:lk] = 96005                      (: 'words' 'occurs' :)
              or $state[$p:lk] = 127237                     (: 'words' 'using' :)
              or $state[$p:lk] = 129797) then               (: 'words' 'weight' :)
          let $state := p:consume(261, $input, $state)      (: 'words' :)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(201, $input, $state)          (: 'phrase' :)
      return $state
  return $state
};

(:~
 : Try parsing FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'any' :)
      let $state := p:consume(81, $input, $state)           (: 'any' :)
      let $state := p:lookahead1W(216, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'word' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 260) then                  (: 'word' :)
          let $state := p:consume(260, $input, $state)      (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'all' :)
      let $state := p:consume(76, $input, $state)           (: 'all' :)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:l1] eq 261) then                      (: 'words' :)
          let $state := p:lookahead2W(214, $input, $state)  (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 13061                      (: 'words' EOF :)
              or $state[$p:lk] = 14085                      (: 'words' '!=' :)
              or $state[$p:lk] = 19205                      (: 'words' ')' :)
              or $state[$p:lk] = 19717                      (: 'words' '*' :)
              or $state[$p:lk] = 20229                      (: 'words' '+' :)
              or $state[$p:lk] = 20741                      (: 'words' ',' :)
              or $state[$p:lk] = 21253                      (: 'words' '-' :)
              or $state[$p:lk] = 24837                      (: 'words' ':' :)
              or $state[$p:lk] = 26885                      (: 'words' ';' :)
              or $state[$p:lk] = 27397                      (: 'words' '<' :)
              or $state[$p:lk] = 29445                      (: 'words' '<<' :)
              or $state[$p:lk] = 29957                      (: 'words' '<=' :)
              or $state[$p:lk] = 30981                      (: 'words' '=' :)
              or $state[$p:lk] = 32005                      (: 'words' '>' :)
              or $state[$p:lk] = 32517                      (: 'words' '>=' :)
              or $state[$p:lk] = 33029                      (: 'words' '>>' :)
              or $state[$p:lk] = 36101                      (: 'words' ']' :)
              or $state[$p:lk] = 38661                      (: 'words' 'after' :)
              or $state[$p:lk] = 41221                      (: 'words' 'and' :)
              or $state[$p:lk] = 42757                      (: 'words' 'as' :)
              or $state[$p:lk] = 43269                      (: 'words' 'ascending' :)
              or $state[$p:lk] = 43781                      (: 'words' 'at' :)
              or $state[$p:lk] = 45317                      (: 'words' 'before' :)
              or $state[$p:lk] = 46853                      (: 'words' 'case' :)
              or $state[$p:lk] = 47365                      (: 'words' 'cast' :)
              or $state[$p:lk] = 47877                      (: 'words' 'castable' :)
              or $state[$p:lk] = 49413                      (: 'words' 'collation' :)
              or $state[$p:lk] = 50949                      (: 'words' 'contains' :)
              or $state[$p:lk] = 53509                      (: 'words' 'count' :)
              or $state[$p:lk] = 55557                      (: 'words' 'default' :)
              or $state[$p:lk] = 57605                      (: 'words' 'descending' :)
              or $state[$p:lk] = 58629                      (: 'words' 'different' :)
              or $state[$p:lk] = 59653                      (: 'words' 'distance' :)
              or $state[$p:lk] = 60165                      (: 'words' 'div' :)
              or $state[$p:lk] = 62213                      (: 'words' 'else' :)
              or $state[$p:lk] = 62725                      (: 'words' 'empty' :)
              or $state[$p:lk] = 64261                      (: 'words' 'end' :)
              or $state[$p:lk] = 64773                      (: 'words' 'entire' :)
              or $state[$p:lk] = 65285                      (: 'words' 'eq' :)
              or $state[$p:lk] = 66821                      (: 'words' 'except' :)
              or $state[$p:lk] = 69893                      (: 'words' 'for' :)
              or $state[$p:lk] = 73477                      (: 'words' 'ge' :)
              or $state[$p:lk] = 74501                      (: 'words' 'group' :)
              or $state[$p:lk] = 75525                      (: 'words' 'gt' :)
              or $state[$p:lk] = 76037                      (: 'words' 'idiv' :)
              or $state[$p:lk] = 80133                      (: 'words' 'instance' :)
              or $state[$p:lk] = 80645                      (: 'words' 'intersect' :)
              or $state[$p:lk] = 81157                      (: 'words' 'into' :)
              or $state[$p:lk] = 82181                      (: 'words' 'is' :)
              or $state[$p:lk] = 84741                      (: 'words' 'le' :)
              or $state[$p:lk] = 85765                      (: 'words' 'let' :)
              or $state[$p:lk] = 87301                      (: 'words' 'lt' :)
              or $state[$p:lk] = 88837                      (: 'words' 'mod' :)
              or $state[$p:lk] = 89349                      (: 'words' 'modify' :)
              or $state[$p:lk] = 91909                      (: 'words' 'ne' :)
              or $state[$p:lk] = 97029                      (: 'words' 'only' :)
              or $state[$p:lk] = 98053                      (: 'words' 'or' :)
              or $state[$p:lk] = 98565                      (: 'words' 'order' :)
              or $state[$p:lk] = 99077                      (: 'words' 'ordered' :)
              or $state[$p:lk] = 100613                     (: 'words' 'paragraphs' :)
              or $state[$p:lk] = 107781                     (: 'words' 'return' :)
              or $state[$p:lk] = 108805                     (: 'words' 'same' :)
              or $state[$p:lk] = 109317                     (: 'words' 'satisfies' :)
              or $state[$p:lk] = 113413                     (: 'words' 'sentences' :)
              or $state[$p:lk] = 115461                     (: 'words' 'stable' :)
              or $state[$p:lk] = 115973                     (: 'words' 'start' :)
              or $state[$p:lk] = 120581                     (: 'words' 'times' :)
              or $state[$p:lk] = 121093                     (: 'words' 'to' :)
              or $state[$p:lk] = 121605                     (: 'words' 'transform' :)
              or $state[$p:lk] = 122117                     (: 'words' 'treat' :)
              or $state[$p:lk] = 124677                     (: 'words' 'union' :)
              or $state[$p:lk] = 130821                     (: 'words' 'where' :)
              or $state[$p:lk] = 131845                     (: 'words' 'window' :)
              or $state[$p:lk] = 132357                     (: 'words' 'with' :)
              or $state[$p:lk] = 132869                     (: 'words' 'without' :)
              or $state[$p:lk] = 133893                     (: 'words' 'words' :)
              or $state[$p:lk] = 136453                     (: 'words' '|' :)
              or $state[$p:lk] = 136965                     (: 'words' '||' :)
              or $state[$p:lk] = 137477                     (: 'words' '}' :)
              or $state[$p:lk] = 137989) then               (: 'words' '}`' :)
          let $state := p:memoized($state, 23)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:consume(261, $input, $state)  (: 'words' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 71429                      (: 'words' 'ftand' :)
              or $state[$p:lk] = 72453                      (: 'words' 'ftor' :)
              or $state[$p:lk] = 95493                      (: 'words' 'not' :)
              or $state[$p:lk] = 96005                      (: 'words' 'occurs' :)
              or $state[$p:lk] = 127237                     (: 'words' 'using' :)
              or $state[$p:lk] = 129797) then               (: 'words' 'weight' :)
          let $state := p:consume(261, $input, $state)      (: 'words' :)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(201, $input, $state)          (: 'phrase' :)
      return $state
  return $state
};

(:~
 : Parse FTWordsValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
  return $state
};

(:~
 : Try parsing FTWordsValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
  return $state
};

(:~
 : Parse FTWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTWordsValue($input, $state)
  let $state := p:lookahead1W(219, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'all' | 'and' | 'any' | 'as' |
                                                               'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'different' | 'distance' |
                                                               'div' | 'else' | 'empty' | 'end' | 'entire' | 'eq' |
                                                               'except' | 'for' | 'ftand' | 'ftor' | 'ge' | 'group' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'not' | 'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'phrase' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76                             (: 'all' :)
          or $state[$p:l1] = 81                             (: 'any' :)
          or $state[$p:l1] = 201) then                      (: 'phrase' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTAnyallOption($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTWordsValue($input, $state)
  let $state := p:lookahead1W(219, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'all' | 'and' | 'any' | 'as' |
                                                               'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'different' | 'distance' |
                                                               'div' | 'else' | 'empty' | 'end' | 'entire' | 'eq' |
                                                               'except' | 'for' | 'ftand' | 'ftor' | 'ge' | 'group' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'not' | 'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'phrase' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76                             (: 'all' :)
          or $state[$p:l1] = 81                             (: 'any' :)
          or $state[$p:l1] = 201) then                      (: 'phrase' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTAnyallOption($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTExtensionSelection($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWords($input, $state)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 187) then                  (: 'occurs' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Try parsing FTPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTSelection($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTExtensionSelection($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWords($input, $state)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 187) then                  (: 'occurs' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTPrimary($input, $state)
  let $state := p:lookahead1W(213, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 248) then                      (: 'using' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 253) then                      (: 'weight' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWeight($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTPrimary($input, $state)
  let $state := p:lookahead1W(213, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 248) then                      (: 'using' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 253) then                      (: 'weight' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWeight($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'ftnot' :)
      let $state := p:consume(140, $input, $state)          (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(145, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTPrimaryWithOptions($input, $state)
  return $state
};

(:~
 : Try parsing FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'ftnot' :)
      let $state := p:consume(140, $input, $state)          (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(145, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTPrimaryWithOptions($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMildNot-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 186) then                        (: 'not' :)
        $state
      else
        let $state := p:consume(186, $input, $state)        (: 'not' :)
        let $state := p:lookahead1W(52, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:consume(151, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(153, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTUnaryNot($input, $state)
        return p:parse-FTMildNot-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMildNot-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 186) then                        (: 'not' :)
        $state
      else
        let $state := p:consume(186, $input, $state)        (: 'not' :)
        let $state := p:lookahead1W(52, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:consume(151, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(153, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTUnaryNot($input, $state)
        return p:try-FTMildNot-1($input, $state)
};

(:~
 : Parse FTMildNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnaryNot($input, $state)
  let $state := p:parse-FTMildNot-1($input, $state)
  return $state
};

(:~
 : Try parsing FTMildNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTUnaryNot($input, $state)
  let $state := p:try-FTMildNot-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnd-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 139) then                          (: 'ftand' :)
      $state
    else
      let $state := p:consume(139, $input, $state)          (: 'ftand' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTMildNot($input, $state)
      return p:parse-FTAnd-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTAnd-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 139) then                          (: 'ftand' :)
      $state
    else
      let $state := p:consume(139, $input, $state)          (: 'ftand' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTMildNot($input, $state)
      return p:try-FTAnd-1($input, $state)
};

(:~
 : Parse FTAnd.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTMildNot($input, $state)
  let $state := p:parse-FTAnd-1($input, $state)
  return $state
};

(:~
 : Try parsing FTAnd.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTMildNot($input, $state)
  let $state := p:try-FTAnd-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 141) then                          (: 'ftor' :)
      $state
    else
      let $state := p:consume(141, $input, $state)          (: 'ftor' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTAnd($input, $state)
      return p:parse-FTOr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTOr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 141) then                          (: 'ftor' :)
      $state
    else
      let $state := p:consume(141, $input, $state)          (: 'ftor' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTAnd($input, $state)
      return p:try-FTOr-1($input, $state)
};

(:~
 : Parse FTOr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTAnd($input, $state)
  let $state := p:parse-FTOr-1($input, $state)
  return $state
};

(:~
 : Try parsing FTOr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTAnd($input, $state)
  let $state := p:try-FTOr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(199, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'paragraphs' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 85                               (: 'at' :)
      and $state[$p:l1] != 114                              (: 'different' :)
      and $state[$p:l1] != 116                              (: 'distance' :)
      and $state[$p:l1] != 126                              (: 'entire' :)
      and $state[$p:l1] != 193                              (: 'ordered' :)
      and $state[$p:l1] != 212                              (: 'same' :)
      and $state[$p:l1] != 257) then                        (: 'window' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTPosFilter($input, $state)
        return p:parse-FTSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(199, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'paragraphs' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 85                               (: 'at' :)
      and $state[$p:l1] != 114                              (: 'different' :)
      and $state[$p:l1] != 116                              (: 'distance' :)
      and $state[$p:l1] != 126                              (: 'entire' :)
      and $state[$p:l1] != 193                              (: 'ordered' :)
      and $state[$p:l1] != 212                              (: 'same' :)
      and $state[$p:l1] != 257) then                        (: 'window' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTPosFilter($input, $state)
        return p:try-FTSelection-1($input, $state)
};

(:~
 : Parse FTSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTOr($input, $state)
  let $state := p:parse-FTSelection-1($input, $state)
  return $state
};

(:~
 : Try parsing FTSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTOr($input, $state)
  let $state := p:try-FTSelection-1($input, $state)
  return $state
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TypeName($input, $state)
  return $state
};

(:~
 : Try parsing SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TypeName($input, $state)
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(187, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(187, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ArrowFunctionSpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrowFunctionSpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ArrowFunctionSpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrowFunctionSpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarRef($input, $state)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(35, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(221, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1(12, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:consume(20, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(6, $input, $state)             (: '#)' :)
  let $state := p:consume(30, $input, $state)               (: '#)' :)
  return $state
};

(:~
 : Try parsing Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(35, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(221, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1(12, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:consume(20, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(6, $input, $state)             (: '#)' :)
  let $state := p:consume(30, $input, $state)               (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExtensionExpr-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Predicate($input, $state)
        return p:try-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PredicateList-1($input, $state)
  return $state
};

(:~
 : Try parsing PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: '@' :)
      let $state := p:consume(67, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  return $state
};

(:~
 : Try parsing AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: '@' :)
      let $state := p:consume(67, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Try parsing ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(196, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25686                          (: 'attribute' '::' :)
          or $state[$p:lk] = 25695                          (: 'child' '::' :)
          or $state[$p:lk] = 25710                          (: 'descendant' '::' :)
          or $state[$p:lk] = 25711                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 25734                          (: 'following' '::' :)
          or $state[$p:lk] = 25735                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 25818) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(196, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25686                          (: 'attribute' '::' :)
          or $state[$p:lk] = 25695                          (: 'child' '::' :)
          or $state[$p:lk] = 25710                          (: 'descendant' '::' :)
          or $state[$p:lk] = 25711                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 25734                          (: 'following' '::' :)
          or $state[$p:lk] = 25735                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 25818) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForwardAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(44, $input, $state)               (: '..' :)
  return $state
};

(:~
 : Try parsing AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(44, $input, $state)               (: '..' :)
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(193, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(193, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Try parsing ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReverseAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (78,                                (: 'ancestor' :)
                         79,                                (: 'ancestor-or-self' :)
                         197,                               (: 'parent' :)
                         202,                               (: 'preceding' :)
                         203)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 44                             (: '..' :)
          or $state[$p:lk] = 25678                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 25679                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 25797                          (: 'parent' '::' :)
          or $state[$p:lk] = 25802                          (: 'preceding' '::' :)
          or $state[$p:lk] = 25803) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(191, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  return $state
};

(:~
 : Try parsing AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (78,                                (: 'ancestor' :)
                         79,                                (: 'ancestor-or-self' :)
                         197,                               (: 'parent' :)
                         202,                               (: 'preceding' :)
                         203)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 44                             (: '..' :)
          or $state[$p:lk] = 25678                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 25679                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 25797                          (: 'parent' '::' :)
          or $state[$p:lk] = 25802                          (: 'preceding' '::' :)
          or $state[$p:lk] = 25803) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(191, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Lookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Lookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-KeySpecifier($input, $state)
  return $state
};

(:~
 : Try parsing Lookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Lookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-KeySpecifier($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Try parsing Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(197, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 65                               (: '?' :)
      and $state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 69) then                 (: '[' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '(' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Lookup($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(197, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 65                               (: '?' :)
      and $state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 69) then                 (: '[' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Predicate($input, $state)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '(' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-ArgumentList($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Lookup($input, $state)
            return $state
        return p:try-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing PostfixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpr($input, $state)
  let $state := p:try-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(243, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 120) then                     (: 'element' :)
      let $state := p:lookahead2W(242, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (177,                          (: 'namespace' :)
                              206)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(206, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              232,                          (: 'text' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (123,                          (: 'empty-sequence' :)
                              149,                          (: 'if' :)
                              161,                          (: 'item' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(192, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(201, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              119,                          (: 'document-node' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              136,                          (: 'for' :)
                              142,                          (: 'function' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              178,                          (: 'namespace-node' :)
                              179,                          (: 'ne' :)
                              184,                          (: 'node' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              215,                          (: 'schema-attribute' :)
                              216,                          (: 'schema-element' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41046                          (: 'attribute' 'and' :)
          or $state[$p:lk] = 41080                          (: 'element' 'and' :)
          or $state[$p:lk] = 41137                          (: 'namespace' 'and' :)
          or $state[$p:lk] = 41166                          (: 'processing-instruction' 'and' :)
          or $state[$p:lk] = 42582                          (: 'attribute' 'as' :)
          or $state[$p:lk] = 42616                          (: 'element' 'as' :)
          or $state[$p:lk] = 42673                          (: 'namespace' 'as' :)
          or $state[$p:lk] = 42702                          (: 'processing-instruction' 'as' :)
          or $state[$p:lk] = 43094                          (: 'attribute' 'ascending' :)
          or $state[$p:lk] = 43128                          (: 'element' 'ascending' :)
          or $state[$p:lk] = 43185                          (: 'namespace' 'ascending' :)
          or $state[$p:lk] = 43214                          (: 'processing-instruction' 'ascending' :)
          or $state[$p:lk] = 46678                          (: 'attribute' 'case' :)
          or $state[$p:lk] = 46712                          (: 'element' 'case' :)
          or $state[$p:lk] = 46769                          (: 'namespace' 'case' :)
          or $state[$p:lk] = 46798                          (: 'processing-instruction' 'case' :)
          or $state[$p:lk] = 47190                          (: 'attribute' 'cast' :)
          or $state[$p:lk] = 47224                          (: 'element' 'cast' :)
          or $state[$p:lk] = 47281                          (: 'namespace' 'cast' :)
          or $state[$p:lk] = 47310                          (: 'processing-instruction' 'cast' :)
          or $state[$p:lk] = 47702                          (: 'attribute' 'castable' :)
          or $state[$p:lk] = 47736                          (: 'element' 'castable' :)
          or $state[$p:lk] = 47793                          (: 'namespace' 'castable' :)
          or $state[$p:lk] = 47822                          (: 'processing-instruction' 'castable' :)
          or $state[$p:lk] = 49238                          (: 'attribute' 'collation' :)
          or $state[$p:lk] = 49272                          (: 'element' 'collation' :)
          or $state[$p:lk] = 49329                          (: 'namespace' 'collation' :)
          or $state[$p:lk] = 49358                          (: 'processing-instruction' 'collation' :)
          or $state[$p:lk] = 53334                          (: 'attribute' 'count' :)
          or $state[$p:lk] = 53368                          (: 'element' 'count' :)
          or $state[$p:lk] = 53425                          (: 'namespace' 'count' :)
          or $state[$p:lk] = 53454                          (: 'processing-instruction' 'count' :)
          or $state[$p:lk] = 55382                          (: 'attribute' 'default' :)
          or $state[$p:lk] = 55416                          (: 'element' 'default' :)
          or $state[$p:lk] = 55473                          (: 'namespace' 'default' :)
          or $state[$p:lk] = 55502                          (: 'processing-instruction' 'default' :)
          or $state[$p:lk] = 57430                          (: 'attribute' 'descending' :)
          or $state[$p:lk] = 57464                          (: 'element' 'descending' :)
          or $state[$p:lk] = 57521                          (: 'namespace' 'descending' :)
          or $state[$p:lk] = 57550                          (: 'processing-instruction' 'descending' :)
          or $state[$p:lk] = 59990                          (: 'attribute' 'div' :)
          or $state[$p:lk] = 60024                          (: 'element' 'div' :)
          or $state[$p:lk] = 60081                          (: 'namespace' 'div' :)
          or $state[$p:lk] = 60110                          (: 'processing-instruction' 'div' :)
          or $state[$p:lk] = 62038                          (: 'attribute' 'else' :)
          or $state[$p:lk] = 62072                          (: 'element' 'else' :)
          or $state[$p:lk] = 62129                          (: 'namespace' 'else' :)
          or $state[$p:lk] = 62158                          (: 'processing-instruction' 'else' :)
          or $state[$p:lk] = 62550                          (: 'attribute' 'empty' :)
          or $state[$p:lk] = 62584                          (: 'element' 'empty' :)
          or $state[$p:lk] = 62641                          (: 'namespace' 'empty' :)
          or $state[$p:lk] = 62670                          (: 'processing-instruction' 'empty' :)
          or $state[$p:lk] = 64086                          (: 'attribute' 'end' :)
          or $state[$p:lk] = 64120                          (: 'element' 'end' :)
          or $state[$p:lk] = 64177                          (: 'namespace' 'end' :)
          or $state[$p:lk] = 64206                          (: 'processing-instruction' 'end' :)
          or $state[$p:lk] = 65110                          (: 'attribute' 'eq' :)
          or $state[$p:lk] = 65144                          (: 'element' 'eq' :)
          or $state[$p:lk] = 65201                          (: 'namespace' 'eq' :)
          or $state[$p:lk] = 65230                          (: 'processing-instruction' 'eq' :)
          or $state[$p:lk] = 66646                          (: 'attribute' 'except' :)
          or $state[$p:lk] = 66680                          (: 'element' 'except' :)
          or $state[$p:lk] = 66737                          (: 'namespace' 'except' :)
          or $state[$p:lk] = 66766                          (: 'processing-instruction' 'except' :)
          or $state[$p:lk] = 69718                          (: 'attribute' 'for' :)
          or $state[$p:lk] = 69752                          (: 'element' 'for' :)
          or $state[$p:lk] = 69809                          (: 'namespace' 'for' :)
          or $state[$p:lk] = 69838                          (: 'processing-instruction' 'for' :)
          or $state[$p:lk] = 73302                          (: 'attribute' 'ge' :)
          or $state[$p:lk] = 73336                          (: 'element' 'ge' :)
          or $state[$p:lk] = 73393                          (: 'namespace' 'ge' :)
          or $state[$p:lk] = 73422                          (: 'processing-instruction' 'ge' :)
          or $state[$p:lk] = 74326                          (: 'attribute' 'group' :)
          or $state[$p:lk] = 74360                          (: 'element' 'group' :)
          or $state[$p:lk] = 74417                          (: 'namespace' 'group' :)
          or $state[$p:lk] = 74446                          (: 'processing-instruction' 'group' :)
          or $state[$p:lk] = 75350                          (: 'attribute' 'gt' :)
          or $state[$p:lk] = 75384                          (: 'element' 'gt' :)
          or $state[$p:lk] = 75441                          (: 'namespace' 'gt' :)
          or $state[$p:lk] = 75470                          (: 'processing-instruction' 'gt' :)
          or $state[$p:lk] = 75862                          (: 'attribute' 'idiv' :)
          or $state[$p:lk] = 75896                          (: 'element' 'idiv' :)
          or $state[$p:lk] = 75953                          (: 'namespace' 'idiv' :)
          or $state[$p:lk] = 75982                          (: 'processing-instruction' 'idiv' :)
          or $state[$p:lk] = 79958                          (: 'attribute' 'instance' :)
          or $state[$p:lk] = 79992                          (: 'element' 'instance' :)
          or $state[$p:lk] = 80049                          (: 'namespace' 'instance' :)
          or $state[$p:lk] = 80078                          (: 'processing-instruction' 'instance' :)
          or $state[$p:lk] = 80470                          (: 'attribute' 'intersect' :)
          or $state[$p:lk] = 80504                          (: 'element' 'intersect' :)
          or $state[$p:lk] = 80561                          (: 'namespace' 'intersect' :)
          or $state[$p:lk] = 80590                          (: 'processing-instruction' 'intersect' :)
          or $state[$p:lk] = 82006                          (: 'attribute' 'is' :)
          or $state[$p:lk] = 82040                          (: 'element' 'is' :)
          or $state[$p:lk] = 82097                          (: 'namespace' 'is' :)
          or $state[$p:lk] = 82126                          (: 'processing-instruction' 'is' :)
          or $state[$p:lk] = 84566                          (: 'attribute' 'le' :)
          or $state[$p:lk] = 84600                          (: 'element' 'le' :)
          or $state[$p:lk] = 84657                          (: 'namespace' 'le' :)
          or $state[$p:lk] = 84686                          (: 'processing-instruction' 'le' :)
          or $state[$p:lk] = 85590                          (: 'attribute' 'let' :)
          or $state[$p:lk] = 85624                          (: 'element' 'let' :)
          or $state[$p:lk] = 85681                          (: 'namespace' 'let' :)
          or $state[$p:lk] = 85710                          (: 'processing-instruction' 'let' :)
          or $state[$p:lk] = 87126                          (: 'attribute' 'lt' :)
          or $state[$p:lk] = 87160                          (: 'element' 'lt' :)
          or $state[$p:lk] = 87217                          (: 'namespace' 'lt' :)
          or $state[$p:lk] = 87246                          (: 'processing-instruction' 'lt' :)
          or $state[$p:lk] = 88662                          (: 'attribute' 'mod' :)
          or $state[$p:lk] = 88696                          (: 'element' 'mod' :)
          or $state[$p:lk] = 88753                          (: 'namespace' 'mod' :)
          or $state[$p:lk] = 88782                          (: 'processing-instruction' 'mod' :)
          or $state[$p:lk] = 89174                          (: 'attribute' 'modify' :)
          or $state[$p:lk] = 89208                          (: 'element' 'modify' :)
          or $state[$p:lk] = 91734                          (: 'attribute' 'ne' :)
          or $state[$p:lk] = 91768                          (: 'element' 'ne' :)
          or $state[$p:lk] = 91825                          (: 'namespace' 'ne' :)
          or $state[$p:lk] = 91854                          (: 'processing-instruction' 'ne' :)
          or $state[$p:lk] = 96854                          (: 'attribute' 'only' :)
          or $state[$p:lk] = 96888                          (: 'element' 'only' :)
          or $state[$p:lk] = 96945                          (: 'namespace' 'only' :)
          or $state[$p:lk] = 96974                          (: 'processing-instruction' 'only' :)
          or $state[$p:lk] = 97878                          (: 'attribute' 'or' :)
          or $state[$p:lk] = 97912                          (: 'element' 'or' :)
          or $state[$p:lk] = 97969                          (: 'namespace' 'or' :)
          or $state[$p:lk] = 97998                          (: 'processing-instruction' 'or' :)
          or $state[$p:lk] = 98390                          (: 'attribute' 'order' :)
          or $state[$p:lk] = 98424                          (: 'element' 'order' :)
          or $state[$p:lk] = 98481                          (: 'namespace' 'order' :)
          or $state[$p:lk] = 98510                          (: 'processing-instruction' 'order' :)
          or $state[$p:lk] = 107606                         (: 'attribute' 'return' :)
          or $state[$p:lk] = 107640                         (: 'element' 'return' :)
          or $state[$p:lk] = 107697                         (: 'namespace' 'return' :)
          or $state[$p:lk] = 107726                         (: 'processing-instruction' 'return' :)
          or $state[$p:lk] = 109142                         (: 'attribute' 'satisfies' :)
          or $state[$p:lk] = 109176                         (: 'element' 'satisfies' :)
          or $state[$p:lk] = 109233                         (: 'namespace' 'satisfies' :)
          or $state[$p:lk] = 109262                         (: 'processing-instruction' 'satisfies' :)
          or $state[$p:lk] = 115286                         (: 'attribute' 'stable' :)
          or $state[$p:lk] = 115320                         (: 'element' 'stable' :)
          or $state[$p:lk] = 115377                         (: 'namespace' 'stable' :)
          or $state[$p:lk] = 115406                         (: 'processing-instruction' 'stable' :)
          or $state[$p:lk] = 115798                         (: 'attribute' 'start' :)
          or $state[$p:lk] = 115832                         (: 'element' 'start' :)
          or $state[$p:lk] = 115889                         (: 'namespace' 'start' :)
          or $state[$p:lk] = 115918                         (: 'processing-instruction' 'start' :)
          or $state[$p:lk] = 120918                         (: 'attribute' 'to' :)
          or $state[$p:lk] = 120952                         (: 'element' 'to' :)
          or $state[$p:lk] = 121009                         (: 'namespace' 'to' :)
          or $state[$p:lk] = 121038                         (: 'processing-instruction' 'to' :)
          or $state[$p:lk] = 121430                         (: 'attribute' 'transform' :)
          or $state[$p:lk] = 121464                         (: 'element' 'transform' :)
          or $state[$p:lk] = 121942                         (: 'attribute' 'treat' :)
          or $state[$p:lk] = 121976                         (: 'element' 'treat' :)
          or $state[$p:lk] = 122033                         (: 'namespace' 'treat' :)
          or $state[$p:lk] = 122062                         (: 'processing-instruction' 'treat' :)
          or $state[$p:lk] = 124502                         (: 'attribute' 'union' :)
          or $state[$p:lk] = 124536                         (: 'element' 'union' :)
          or $state[$p:lk] = 124593                         (: 'namespace' 'union' :)
          or $state[$p:lk] = 124622                         (: 'processing-instruction' 'union' :)
          or $state[$p:lk] = 125526                         (: 'attribute' 'update' :)
          or $state[$p:lk] = 125560                         (: 'element' 'update' :)
          or $state[$p:lk] = 130646                         (: 'attribute' 'where' :)
          or $state[$p:lk] = 130680                         (: 'element' 'where' :)
          or $state[$p:lk] = 130737                         (: 'namespace' 'where' :)
          or $state[$p:lk] = 130766                         (: 'processing-instruction' 'where' :)
          or $state[$p:lk] = 132182                         (: 'attribute' 'with' :)
          or $state[$p:lk] = 132216) then                   (: 'element' 'with' :)
      let $state := p:memoized($state, 19)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PostfixExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 1                                   (: IntegerLiteral :)
     or $state[$p:lk] = 2                                   (: DecimalLiteral :)
     or $state[$p:lk] = 3                                   (: DoubleLiteral :)
     or $state[$p:lk] = 4                                   (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 32                                  (: '%' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 43                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 65                                  (: '?' :)
     or $state[$p:lk] = 69                                  (: '[' :)
     or $state[$p:lk] = 73                                  (: '``[' :)
     or $state[$p:lk] = 82                                  (: 'array' :)
     or $state[$p:lk] = 171                                 (: 'map' :)
     or $state[$p:lk] = 2646                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 2680                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 7345                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 7374                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 7766                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 7800                                (: 'element' QName^Token :)
     or $state[$p:lk] = 14853                               (: URIQualifiedName '#' :)
     or $state[$p:lk] = 14863                               (: QName^Token '#' :)
     or $state[$p:lk] = 14926                               (: 'ancestor' '#' :)
     or $state[$p:lk] = 14927                               (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 14928                               (: 'and' '#' :)
     or $state[$p:lk] = 14931                               (: 'as' '#' :)
     or $state[$p:lk] = 14932                               (: 'ascending' '#' :)
     or $state[$p:lk] = 14933                               (: 'at' '#' :)
     or $state[$p:lk] = 14934                               (: 'attribute' '#' :)
     or $state[$p:lk] = 14939                               (: 'case' '#' :)
     or $state[$p:lk] = 14940                               (: 'cast' '#' :)
     or $state[$p:lk] = 14941                               (: 'castable' '#' :)
     or $state[$p:lk] = 14943                               (: 'child' '#' :)
     or $state[$p:lk] = 14944                               (: 'collation' '#' :)
     or $state[$p:lk] = 14945                               (: 'comment' '#' :)
     or $state[$p:lk] = 14950                               (: 'copy' '#' :)
     or $state[$p:lk] = 14952                               (: 'count' '#' :)
     or $state[$p:lk] = 14955                               (: 'declare' '#' :)
     or $state[$p:lk] = 14956                               (: 'default' '#' :)
     or $state[$p:lk] = 14957                               (: 'delete' '#' :)
     or $state[$p:lk] = 14958                               (: 'descendant' '#' :)
     or $state[$p:lk] = 14959                               (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 14960                               (: 'descending' '#' :)
     or $state[$p:lk] = 14965                               (: 'div' '#' :)
     or $state[$p:lk] = 14966                               (: 'document' '#' :)
     or $state[$p:lk] = 14967                               (: 'document-node' '#' :)
     or $state[$p:lk] = 14968                               (: 'element' '#' :)
     or $state[$p:lk] = 14969                               (: 'else' '#' :)
     or $state[$p:lk] = 14970                               (: 'empty' '#' :)
     or $state[$p:lk] = 14971                               (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 14973                               (: 'end' '#' :)
     or $state[$p:lk] = 14975                               (: 'eq' '#' :)
     or $state[$p:lk] = 14976                               (: 'every' '#' :)
     or $state[$p:lk] = 14978                               (: 'except' '#' :)
     or $state[$p:lk] = 14982                               (: 'following' '#' :)
     or $state[$p:lk] = 14983                               (: 'following-sibling' '#' :)
     or $state[$p:lk] = 14984                               (: 'for' '#' :)
     or $state[$p:lk] = 14990                               (: 'function' '#' :)
     or $state[$p:lk] = 14991                               (: 'ge' '#' :)
     or $state[$p:lk] = 14993                               (: 'group' '#' :)
     or $state[$p:lk] = 14995                               (: 'gt' '#' :)
     or $state[$p:lk] = 14996                               (: 'idiv' '#' :)
     or $state[$p:lk] = 14997                               (: 'if' '#' :)
     or $state[$p:lk] = 14998                               (: 'import' '#' :)
     or $state[$p:lk] = 15003                               (: 'insert' '#' :)
     or $state[$p:lk] = 15004                               (: 'instance' '#' :)
     or $state[$p:lk] = 15005                               (: 'intersect' '#' :)
     or $state[$p:lk] = 15007                               (: 'invoke' '#' :)
     or $state[$p:lk] = 15008                               (: 'is' '#' :)
     or $state[$p:lk] = 15009                               (: 'item' '#' :)
     or $state[$p:lk] = 15013                               (: 'le' '#' :)
     or $state[$p:lk] = 15015                               (: 'let' '#' :)
     or $state[$p:lk] = 15018                               (: 'lt' '#' :)
     or $state[$p:lk] = 15021                               (: 'mod' '#' :)
     or $state[$p:lk] = 15022                               (: 'modify' '#' :)
     or $state[$p:lk] = 15023                               (: 'module' '#' :)
     or $state[$p:lk] = 15025                               (: 'namespace' '#' :)
     or $state[$p:lk] = 15026                               (: 'namespace-node' '#' :)
     or $state[$p:lk] = 15027                               (: 'ne' '#' :)
     or $state[$p:lk] = 15032                               (: 'node' '#' :)
     or $state[$p:lk] = 15037                               (: 'only' '#' :)
     or $state[$p:lk] = 15039                               (: 'or' '#' :)
     or $state[$p:lk] = 15040                               (: 'order' '#' :)
     or $state[$p:lk] = 15041                               (: 'ordered' '#' :)
     or $state[$p:lk] = 15045                               (: 'parent' '#' :)
     or $state[$p:lk] = 15050                               (: 'preceding' '#' :)
     or $state[$p:lk] = 15051                               (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 15054                               (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 15056                               (: 'rename' '#' :)
     or $state[$p:lk] = 15057                               (: 'replace' '#' :)
     or $state[$p:lk] = 15058                               (: 'return' '#' :)
     or $state[$p:lk] = 15061                               (: 'satisfies' '#' :)
     or $state[$p:lk] = 15063                               (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 15064                               (: 'schema-element' '#' :)
     or $state[$p:lk] = 15066                               (: 'self' '#' :)
     or $state[$p:lk] = 15072                               (: 'some' '#' :)
     or $state[$p:lk] = 15073                               (: 'stable' '#' :)
     or $state[$p:lk] = 15074                               (: 'start' '#' :)
     or $state[$p:lk] = 15079                               (: 'switch' '#' :)
     or $state[$p:lk] = 15080                               (: 'text' '#' :)
     or $state[$p:lk] = 15084                               (: 'to' '#' :)
     or $state[$p:lk] = 15085                               (: 'transform' '#' :)
     or $state[$p:lk] = 15086                               (: 'treat' '#' :)
     or $state[$p:lk] = 15087                               (: 'try' '#' :)
     or $state[$p:lk] = 15090                               (: 'typeswitch' '#' :)
     or $state[$p:lk] = 15091                               (: 'union' '#' :)
     or $state[$p:lk] = 15092                               (: 'unordered' '#' :)
     or $state[$p:lk] = 15093                               (: 'update' '#' :)
     or $state[$p:lk] = 15097                               (: 'validate' '#' :)
     or $state[$p:lk] = 15103                               (: 'where' '#' :)
     or $state[$p:lk] = 15106                               (: 'with' '#' :)
     or $state[$p:lk] = 15110                               (: 'xquery' '#' :)
     or $state[$p:lk] = 17413                               (: URIQualifiedName '(' :)
     or $state[$p:lk] = 17423                               (: QName^Token '(' :)
     or $state[$p:lk] = 17486                               (: 'ancestor' '(' :)
     or $state[$p:lk] = 17487                               (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 17488                               (: 'and' '(' :)
     or $state[$p:lk] = 17491                               (: 'as' '(' :)
     or $state[$p:lk] = 17492                               (: 'ascending' '(' :)
     or $state[$p:lk] = 17493                               (: 'at' '(' :)
     or $state[$p:lk] = 17499                               (: 'case' '(' :)
     or $state[$p:lk] = 17500                               (: 'cast' '(' :)
     or $state[$p:lk] = 17501                               (: 'castable' '(' :)
     or $state[$p:lk] = 17503                               (: 'child' '(' :)
     or $state[$p:lk] = 17504                               (: 'collation' '(' :)
     or $state[$p:lk] = 17510                               (: 'copy' '(' :)
     or $state[$p:lk] = 17512                               (: 'count' '(' :)
     or $state[$p:lk] = 17515                               (: 'declare' '(' :)
     or $state[$p:lk] = 17516                               (: 'default' '(' :)
     or $state[$p:lk] = 17517                               (: 'delete' '(' :)
     or $state[$p:lk] = 17518                               (: 'descendant' '(' :)
     or $state[$p:lk] = 17519                               (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 17520                               (: 'descending' '(' :)
     or $state[$p:lk] = 17525                               (: 'div' '(' :)
     or $state[$p:lk] = 17526                               (: 'document' '(' :)
     or $state[$p:lk] = 17529                               (: 'else' '(' :)
     or $state[$p:lk] = 17530                               (: 'empty' '(' :)
     or $state[$p:lk] = 17533                               (: 'end' '(' :)
     or $state[$p:lk] = 17535                               (: 'eq' '(' :)
     or $state[$p:lk] = 17536                               (: 'every' '(' :)
     or $state[$p:lk] = 17538                               (: 'except' '(' :)
     or $state[$p:lk] = 17542                               (: 'following' '(' :)
     or $state[$p:lk] = 17543                               (: 'following-sibling' '(' :)
     or $state[$p:lk] = 17544                               (: 'for' '(' :)
     or $state[$p:lk] = 17550                               (: 'function' '(' :)
     or $state[$p:lk] = 17551                               (: 'ge' '(' :)
     or $state[$p:lk] = 17553                               (: 'group' '(' :)
     or $state[$p:lk] = 17555                               (: 'gt' '(' :)
     or $state[$p:lk] = 17556                               (: 'idiv' '(' :)
     or $state[$p:lk] = 17558                               (: 'import' '(' :)
     or $state[$p:lk] = 17563                               (: 'insert' '(' :)
     or $state[$p:lk] = 17564                               (: 'instance' '(' :)
     or $state[$p:lk] = 17565                               (: 'intersect' '(' :)
     or $state[$p:lk] = 17567                               (: 'invoke' '(' :)
     or $state[$p:lk] = 17568                               (: 'is' '(' :)
     or $state[$p:lk] = 17573                               (: 'le' '(' :)
     or $state[$p:lk] = 17575                               (: 'let' '(' :)
     or $state[$p:lk] = 17578                               (: 'lt' '(' :)
     or $state[$p:lk] = 17581                               (: 'mod' '(' :)
     or $state[$p:lk] = 17582                               (: 'modify' '(' :)
     or $state[$p:lk] = 17583                               (: 'module' '(' :)
     or $state[$p:lk] = 17585                               (: 'namespace' '(' :)
     or $state[$p:lk] = 17587                               (: 'ne' '(' :)
     or $state[$p:lk] = 17597                               (: 'only' '(' :)
     or $state[$p:lk] = 17599                               (: 'or' '(' :)
     or $state[$p:lk] = 17600                               (: 'order' '(' :)
     or $state[$p:lk] = 17601                               (: 'ordered' '(' :)
     or $state[$p:lk] = 17605                               (: 'parent' '(' :)
     or $state[$p:lk] = 17610                               (: 'preceding' '(' :)
     or $state[$p:lk] = 17611                               (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 17616                               (: 'rename' '(' :)
     or $state[$p:lk] = 17617                               (: 'replace' '(' :)
     or $state[$p:lk] = 17618                               (: 'return' '(' :)
     or $state[$p:lk] = 17621                               (: 'satisfies' '(' :)
     or $state[$p:lk] = 17626                               (: 'self' '(' :)
     or $state[$p:lk] = 17632                               (: 'some' '(' :)
     or $state[$p:lk] = 17633                               (: 'stable' '(' :)
     or $state[$p:lk] = 17634                               (: 'start' '(' :)
     or $state[$p:lk] = 17644                               (: 'to' '(' :)
     or $state[$p:lk] = 17645                               (: 'transform' '(' :)
     or $state[$p:lk] = 17646                               (: 'treat' '(' :)
     or $state[$p:lk] = 17647                               (: 'try' '(' :)
     or $state[$p:lk] = 17651                               (: 'union' '(' :)
     or $state[$p:lk] = 17652                               (: 'unordered' '(' :)
     or $state[$p:lk] = 17653                               (: 'update' '(' :)
     or $state[$p:lk] = 17657                               (: 'validate' '(' :)
     or $state[$p:lk] = 17663                               (: 'where' '(' :)
     or $state[$p:lk] = 17666                               (: 'with' '(' :)
     or $state[$p:lk] = 17670                               (: 'xquery' '(' :)
     or $state[$p:lk] = 40022                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 40056                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 40534                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 40568                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 43606                               (: 'attribute' 'at' :)
     or $state[$p:lk] = 43640                               (: 'element' 'at' :)
     or $state[$p:lk] = 44118                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 44152                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 48726                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 48760                               (: 'element' 'child' :)
     or $state[$p:lk] = 49750                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 49784                               (: 'element' 'comment' :)
     or $state[$p:lk] = 52310                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 52344                               (: 'element' 'copy' :)
     or $state[$p:lk] = 54870                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 54904                               (: 'element' 'declare' :)
     or $state[$p:lk] = 55894                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 55928                               (: 'element' 'delete' :)
     or $state[$p:lk] = 56406                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 56440                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 56918                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 56952                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 60502                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 60536                               (: 'element' 'document' :)
     or $state[$p:lk] = 61014                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 61048                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 61526                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 61560                               (: 'element' 'element' :)
     or $state[$p:lk] = 63062                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 63096                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 65622                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 65656                               (: 'element' 'every' :)
     or $state[$p:lk] = 68694                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 68728                               (: 'element' 'following' :)
     or $state[$p:lk] = 69206                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 69240                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 72790                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 72824                               (: 'element' 'function' :)
     or $state[$p:lk] = 76374                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 76408                               (: 'element' 'if' :)
     or $state[$p:lk] = 76886                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 76920                               (: 'element' 'import' :)
     or $state[$p:lk] = 79446                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 79480                               (: 'element' 'insert' :)
     or $state[$p:lk] = 81494                               (: 'attribute' 'invoke' :)
     or $state[$p:lk] = 81528                               (: 'element' 'invoke' :)
     or $state[$p:lk] = 82518                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 82552                               (: 'element' 'item' :)
     or $state[$p:lk] = 89686                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 89720                               (: 'element' 'module' :)
     or $state[$p:lk] = 90710                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 90744                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 91222                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 91256                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 94294                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 94328                               (: 'element' 'node' :)
     or $state[$p:lk] = 98902                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 98936                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 100950                              (: 'attribute' 'parent' :)
     or $state[$p:lk] = 100984                              (: 'element' 'parent' :)
     or $state[$p:lk] = 103510                              (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 103544                              (: 'element' 'preceding' :)
     or $state[$p:lk] = 104022                              (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 104056                              (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 105558                              (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 105592                              (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 106582                              (: 'attribute' 'rename' :)
     or $state[$p:lk] = 106616                              (: 'element' 'rename' :)
     or $state[$p:lk] = 107094                              (: 'attribute' 'replace' :)
     or $state[$p:lk] = 107128                              (: 'element' 'replace' :)
     or $state[$p:lk] = 110166                              (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 110200                              (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 110678                              (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 110712                              (: 'element' 'schema-element' :)
     or $state[$p:lk] = 111702                              (: 'attribute' 'self' :)
     or $state[$p:lk] = 111736                              (: 'element' 'self' :)
     or $state[$p:lk] = 114774                              (: 'attribute' 'some' :)
     or $state[$p:lk] = 114808                              (: 'element' 'some' :)
     or $state[$p:lk] = 118358                              (: 'attribute' 'switch' :)
     or $state[$p:lk] = 118392                              (: 'element' 'switch' :)
     or $state[$p:lk] = 118870                              (: 'attribute' 'text' :)
     or $state[$p:lk] = 118904                              (: 'element' 'text' :)
     or $state[$p:lk] = 122454                              (: 'attribute' 'try' :)
     or $state[$p:lk] = 122488                              (: 'element' 'try' :)
     or $state[$p:lk] = 123990                              (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 124024                              (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 125014                              (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 125048                              (: 'element' 'unordered' :)
     or $state[$p:lk] = 127574                              (: 'attribute' 'validate' :)
     or $state[$p:lk] = 127608                              (: 'element' 'validate' :)
     or $state[$p:lk] = 134230                              (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 134264                              (: 'element' 'xquery' :)
     or $state[$p:lk] = 135254                              (: 'attribute' '{' :)
     or $state[$p:lk] = 135265                              (: 'comment' '{' :)
     or $state[$p:lk] = 135286                              (: 'document' '{' :)
     or $state[$p:lk] = 135288                              (: 'element' '{' :)
     or $state[$p:lk] = 135345                              (: 'namespace' '{' :)
     or $state[$p:lk] = 135361                              (: 'ordered' '{' :)
     or $state[$p:lk] = 135374                              (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 135400                              (: 'text' '{' :)
     or $state[$p:lk] = 135412) then                        (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PostfixExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(243, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 120) then                     (: 'element' :)
      let $state := p:lookahead2W(242, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (177,                          (: 'namespace' :)
                              206)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(206, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              232,                          (: 'text' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (123,                          (: 'empty-sequence' :)
                              149,                          (: 'if' :)
                              161,                          (: 'item' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(192, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(201, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              119,                          (: 'document-node' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              136,                          (: 'for' :)
                              142,                          (: 'function' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              178,                          (: 'namespace-node' :)
                              179,                          (: 'ne' :)
                              184,                          (: 'node' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              215,                          (: 'schema-attribute' :)
                              216,                          (: 'schema-element' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41046                          (: 'attribute' 'and' :)
          or $state[$p:lk] = 41080                          (: 'element' 'and' :)
          or $state[$p:lk] = 41137                          (: 'namespace' 'and' :)
          or $state[$p:lk] = 41166                          (: 'processing-instruction' 'and' :)
          or $state[$p:lk] = 42582                          (: 'attribute' 'as' :)
          or $state[$p:lk] = 42616                          (: 'element' 'as' :)
          or $state[$p:lk] = 42673                          (: 'namespace' 'as' :)
          or $state[$p:lk] = 42702                          (: 'processing-instruction' 'as' :)
          or $state[$p:lk] = 43094                          (: 'attribute' 'ascending' :)
          or $state[$p:lk] = 43128                          (: 'element' 'ascending' :)
          or $state[$p:lk] = 43185                          (: 'namespace' 'ascending' :)
          or $state[$p:lk] = 43214                          (: 'processing-instruction' 'ascending' :)
          or $state[$p:lk] = 46678                          (: 'attribute' 'case' :)
          or $state[$p:lk] = 46712                          (: 'element' 'case' :)
          or $state[$p:lk] = 46769                          (: 'namespace' 'case' :)
          or $state[$p:lk] = 46798                          (: 'processing-instruction' 'case' :)
          or $state[$p:lk] = 47190                          (: 'attribute' 'cast' :)
          or $state[$p:lk] = 47224                          (: 'element' 'cast' :)
          or $state[$p:lk] = 47281                          (: 'namespace' 'cast' :)
          or $state[$p:lk] = 47310                          (: 'processing-instruction' 'cast' :)
          or $state[$p:lk] = 47702                          (: 'attribute' 'castable' :)
          or $state[$p:lk] = 47736                          (: 'element' 'castable' :)
          or $state[$p:lk] = 47793                          (: 'namespace' 'castable' :)
          or $state[$p:lk] = 47822                          (: 'processing-instruction' 'castable' :)
          or $state[$p:lk] = 49238                          (: 'attribute' 'collation' :)
          or $state[$p:lk] = 49272                          (: 'element' 'collation' :)
          or $state[$p:lk] = 49329                          (: 'namespace' 'collation' :)
          or $state[$p:lk] = 49358                          (: 'processing-instruction' 'collation' :)
          or $state[$p:lk] = 53334                          (: 'attribute' 'count' :)
          or $state[$p:lk] = 53368                          (: 'element' 'count' :)
          or $state[$p:lk] = 53425                          (: 'namespace' 'count' :)
          or $state[$p:lk] = 53454                          (: 'processing-instruction' 'count' :)
          or $state[$p:lk] = 55382                          (: 'attribute' 'default' :)
          or $state[$p:lk] = 55416                          (: 'element' 'default' :)
          or $state[$p:lk] = 55473                          (: 'namespace' 'default' :)
          or $state[$p:lk] = 55502                          (: 'processing-instruction' 'default' :)
          or $state[$p:lk] = 57430                          (: 'attribute' 'descending' :)
          or $state[$p:lk] = 57464                          (: 'element' 'descending' :)
          or $state[$p:lk] = 57521                          (: 'namespace' 'descending' :)
          or $state[$p:lk] = 57550                          (: 'processing-instruction' 'descending' :)
          or $state[$p:lk] = 59990                          (: 'attribute' 'div' :)
          or $state[$p:lk] = 60024                          (: 'element' 'div' :)
          or $state[$p:lk] = 60081                          (: 'namespace' 'div' :)
          or $state[$p:lk] = 60110                          (: 'processing-instruction' 'div' :)
          or $state[$p:lk] = 62038                          (: 'attribute' 'else' :)
          or $state[$p:lk] = 62072                          (: 'element' 'else' :)
          or $state[$p:lk] = 62129                          (: 'namespace' 'else' :)
          or $state[$p:lk] = 62158                          (: 'processing-instruction' 'else' :)
          or $state[$p:lk] = 62550                          (: 'attribute' 'empty' :)
          or $state[$p:lk] = 62584                          (: 'element' 'empty' :)
          or $state[$p:lk] = 62641                          (: 'namespace' 'empty' :)
          or $state[$p:lk] = 62670                          (: 'processing-instruction' 'empty' :)
          or $state[$p:lk] = 64086                          (: 'attribute' 'end' :)
          or $state[$p:lk] = 64120                          (: 'element' 'end' :)
          or $state[$p:lk] = 64177                          (: 'namespace' 'end' :)
          or $state[$p:lk] = 64206                          (: 'processing-instruction' 'end' :)
          or $state[$p:lk] = 65110                          (: 'attribute' 'eq' :)
          or $state[$p:lk] = 65144                          (: 'element' 'eq' :)
          or $state[$p:lk] = 65201                          (: 'namespace' 'eq' :)
          or $state[$p:lk] = 65230                          (: 'processing-instruction' 'eq' :)
          or $state[$p:lk] = 66646                          (: 'attribute' 'except' :)
          or $state[$p:lk] = 66680                          (: 'element' 'except' :)
          or $state[$p:lk] = 66737                          (: 'namespace' 'except' :)
          or $state[$p:lk] = 66766                          (: 'processing-instruction' 'except' :)
          or $state[$p:lk] = 69718                          (: 'attribute' 'for' :)
          or $state[$p:lk] = 69752                          (: 'element' 'for' :)
          or $state[$p:lk] = 69809                          (: 'namespace' 'for' :)
          or $state[$p:lk] = 69838                          (: 'processing-instruction' 'for' :)
          or $state[$p:lk] = 73302                          (: 'attribute' 'ge' :)
          or $state[$p:lk] = 73336                          (: 'element' 'ge' :)
          or $state[$p:lk] = 73393                          (: 'namespace' 'ge' :)
          or $state[$p:lk] = 73422                          (: 'processing-instruction' 'ge' :)
          or $state[$p:lk] = 74326                          (: 'attribute' 'group' :)
          or $state[$p:lk] = 74360                          (: 'element' 'group' :)
          or $state[$p:lk] = 74417                          (: 'namespace' 'group' :)
          or $state[$p:lk] = 74446                          (: 'processing-instruction' 'group' :)
          or $state[$p:lk] = 75350                          (: 'attribute' 'gt' :)
          or $state[$p:lk] = 75384                          (: 'element' 'gt' :)
          or $state[$p:lk] = 75441                          (: 'namespace' 'gt' :)
          or $state[$p:lk] = 75470                          (: 'processing-instruction' 'gt' :)
          or $state[$p:lk] = 75862                          (: 'attribute' 'idiv' :)
          or $state[$p:lk] = 75896                          (: 'element' 'idiv' :)
          or $state[$p:lk] = 75953                          (: 'namespace' 'idiv' :)
          or $state[$p:lk] = 75982                          (: 'processing-instruction' 'idiv' :)
          or $state[$p:lk] = 79958                          (: 'attribute' 'instance' :)
          or $state[$p:lk] = 79992                          (: 'element' 'instance' :)
          or $state[$p:lk] = 80049                          (: 'namespace' 'instance' :)
          or $state[$p:lk] = 80078                          (: 'processing-instruction' 'instance' :)
          or $state[$p:lk] = 80470                          (: 'attribute' 'intersect' :)
          or $state[$p:lk] = 80504                          (: 'element' 'intersect' :)
          or $state[$p:lk] = 80561                          (: 'namespace' 'intersect' :)
          or $state[$p:lk] = 80590                          (: 'processing-instruction' 'intersect' :)
          or $state[$p:lk] = 82006                          (: 'attribute' 'is' :)
          or $state[$p:lk] = 82040                          (: 'element' 'is' :)
          or $state[$p:lk] = 82097                          (: 'namespace' 'is' :)
          or $state[$p:lk] = 82126                          (: 'processing-instruction' 'is' :)
          or $state[$p:lk] = 84566                          (: 'attribute' 'le' :)
          or $state[$p:lk] = 84600                          (: 'element' 'le' :)
          or $state[$p:lk] = 84657                          (: 'namespace' 'le' :)
          or $state[$p:lk] = 84686                          (: 'processing-instruction' 'le' :)
          or $state[$p:lk] = 85590                          (: 'attribute' 'let' :)
          or $state[$p:lk] = 85624                          (: 'element' 'let' :)
          or $state[$p:lk] = 85681                          (: 'namespace' 'let' :)
          or $state[$p:lk] = 85710                          (: 'processing-instruction' 'let' :)
          or $state[$p:lk] = 87126                          (: 'attribute' 'lt' :)
          or $state[$p:lk] = 87160                          (: 'element' 'lt' :)
          or $state[$p:lk] = 87217                          (: 'namespace' 'lt' :)
          or $state[$p:lk] = 87246                          (: 'processing-instruction' 'lt' :)
          or $state[$p:lk] = 88662                          (: 'attribute' 'mod' :)
          or $state[$p:lk] = 88696                          (: 'element' 'mod' :)
          or $state[$p:lk] = 88753                          (: 'namespace' 'mod' :)
          or $state[$p:lk] = 88782                          (: 'processing-instruction' 'mod' :)
          or $state[$p:lk] = 89174                          (: 'attribute' 'modify' :)
          or $state[$p:lk] = 89208                          (: 'element' 'modify' :)
          or $state[$p:lk] = 91734                          (: 'attribute' 'ne' :)
          or $state[$p:lk] = 91768                          (: 'element' 'ne' :)
          or $state[$p:lk] = 91825                          (: 'namespace' 'ne' :)
          or $state[$p:lk] = 91854                          (: 'processing-instruction' 'ne' :)
          or $state[$p:lk] = 96854                          (: 'attribute' 'only' :)
          or $state[$p:lk] = 96888                          (: 'element' 'only' :)
          or $state[$p:lk] = 96945                          (: 'namespace' 'only' :)
          or $state[$p:lk] = 96974                          (: 'processing-instruction' 'only' :)
          or $state[$p:lk] = 97878                          (: 'attribute' 'or' :)
          or $state[$p:lk] = 97912                          (: 'element' 'or' :)
          or $state[$p:lk] = 97969                          (: 'namespace' 'or' :)
          or $state[$p:lk] = 97998                          (: 'processing-instruction' 'or' :)
          or $state[$p:lk] = 98390                          (: 'attribute' 'order' :)
          or $state[$p:lk] = 98424                          (: 'element' 'order' :)
          or $state[$p:lk] = 98481                          (: 'namespace' 'order' :)
          or $state[$p:lk] = 98510                          (: 'processing-instruction' 'order' :)
          or $state[$p:lk] = 107606                         (: 'attribute' 'return' :)
          or $state[$p:lk] = 107640                         (: 'element' 'return' :)
          or $state[$p:lk] = 107697                         (: 'namespace' 'return' :)
          or $state[$p:lk] = 107726                         (: 'processing-instruction' 'return' :)
          or $state[$p:lk] = 109142                         (: 'attribute' 'satisfies' :)
          or $state[$p:lk] = 109176                         (: 'element' 'satisfies' :)
          or $state[$p:lk] = 109233                         (: 'namespace' 'satisfies' :)
          or $state[$p:lk] = 109262                         (: 'processing-instruction' 'satisfies' :)
          or $state[$p:lk] = 115286                         (: 'attribute' 'stable' :)
          or $state[$p:lk] = 115320                         (: 'element' 'stable' :)
          or $state[$p:lk] = 115377                         (: 'namespace' 'stable' :)
          or $state[$p:lk] = 115406                         (: 'processing-instruction' 'stable' :)
          or $state[$p:lk] = 115798                         (: 'attribute' 'start' :)
          or $state[$p:lk] = 115832                         (: 'element' 'start' :)
          or $state[$p:lk] = 115889                         (: 'namespace' 'start' :)
          or $state[$p:lk] = 115918                         (: 'processing-instruction' 'start' :)
          or $state[$p:lk] = 120918                         (: 'attribute' 'to' :)
          or $state[$p:lk] = 120952                         (: 'element' 'to' :)
          or $state[$p:lk] = 121009                         (: 'namespace' 'to' :)
          or $state[$p:lk] = 121038                         (: 'processing-instruction' 'to' :)
          or $state[$p:lk] = 121430                         (: 'attribute' 'transform' :)
          or $state[$p:lk] = 121464                         (: 'element' 'transform' :)
          or $state[$p:lk] = 121942                         (: 'attribute' 'treat' :)
          or $state[$p:lk] = 121976                         (: 'element' 'treat' :)
          or $state[$p:lk] = 122033                         (: 'namespace' 'treat' :)
          or $state[$p:lk] = 122062                         (: 'processing-instruction' 'treat' :)
          or $state[$p:lk] = 124502                         (: 'attribute' 'union' :)
          or $state[$p:lk] = 124536                         (: 'element' 'union' :)
          or $state[$p:lk] = 124593                         (: 'namespace' 'union' :)
          or $state[$p:lk] = 124622                         (: 'processing-instruction' 'union' :)
          or $state[$p:lk] = 125526                         (: 'attribute' 'update' :)
          or $state[$p:lk] = 125560                         (: 'element' 'update' :)
          or $state[$p:lk] = 130646                         (: 'attribute' 'where' :)
          or $state[$p:lk] = 130680                         (: 'element' 'where' :)
          or $state[$p:lk] = 130737                         (: 'namespace' 'where' :)
          or $state[$p:lk] = 130766                         (: 'processing-instruction' 'where' :)
          or $state[$p:lk] = 132182                         (: 'attribute' 'with' :)
          or $state[$p:lk] = 132216) then                   (: 'element' 'with' :)
      let $state := p:memoized($state, 19)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PostfixExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 1                                   (: IntegerLiteral :)
     or $state[$p:lk] = 2                                   (: DecimalLiteral :)
     or $state[$p:lk] = 3                                   (: DoubleLiteral :)
     or $state[$p:lk] = 4                                   (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 32                                  (: '%' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 43                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 65                                  (: '?' :)
     or $state[$p:lk] = 69                                  (: '[' :)
     or $state[$p:lk] = 73                                  (: '``[' :)
     or $state[$p:lk] = 82                                  (: 'array' :)
     or $state[$p:lk] = 171                                 (: 'map' :)
     or $state[$p:lk] = 2646                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 2680                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 7345                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 7374                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 7766                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 7800                                (: 'element' QName^Token :)
     or $state[$p:lk] = 14853                               (: URIQualifiedName '#' :)
     or $state[$p:lk] = 14863                               (: QName^Token '#' :)
     or $state[$p:lk] = 14926                               (: 'ancestor' '#' :)
     or $state[$p:lk] = 14927                               (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 14928                               (: 'and' '#' :)
     or $state[$p:lk] = 14931                               (: 'as' '#' :)
     or $state[$p:lk] = 14932                               (: 'ascending' '#' :)
     or $state[$p:lk] = 14933                               (: 'at' '#' :)
     or $state[$p:lk] = 14934                               (: 'attribute' '#' :)
     or $state[$p:lk] = 14939                               (: 'case' '#' :)
     or $state[$p:lk] = 14940                               (: 'cast' '#' :)
     or $state[$p:lk] = 14941                               (: 'castable' '#' :)
     or $state[$p:lk] = 14943                               (: 'child' '#' :)
     or $state[$p:lk] = 14944                               (: 'collation' '#' :)
     or $state[$p:lk] = 14945                               (: 'comment' '#' :)
     or $state[$p:lk] = 14950                               (: 'copy' '#' :)
     or $state[$p:lk] = 14952                               (: 'count' '#' :)
     or $state[$p:lk] = 14955                               (: 'declare' '#' :)
     or $state[$p:lk] = 14956                               (: 'default' '#' :)
     or $state[$p:lk] = 14957                               (: 'delete' '#' :)
     or $state[$p:lk] = 14958                               (: 'descendant' '#' :)
     or $state[$p:lk] = 14959                               (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 14960                               (: 'descending' '#' :)
     or $state[$p:lk] = 14965                               (: 'div' '#' :)
     or $state[$p:lk] = 14966                               (: 'document' '#' :)
     or $state[$p:lk] = 14967                               (: 'document-node' '#' :)
     or $state[$p:lk] = 14968                               (: 'element' '#' :)
     or $state[$p:lk] = 14969                               (: 'else' '#' :)
     or $state[$p:lk] = 14970                               (: 'empty' '#' :)
     or $state[$p:lk] = 14971                               (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 14973                               (: 'end' '#' :)
     or $state[$p:lk] = 14975                               (: 'eq' '#' :)
     or $state[$p:lk] = 14976                               (: 'every' '#' :)
     or $state[$p:lk] = 14978                               (: 'except' '#' :)
     or $state[$p:lk] = 14982                               (: 'following' '#' :)
     or $state[$p:lk] = 14983                               (: 'following-sibling' '#' :)
     or $state[$p:lk] = 14984                               (: 'for' '#' :)
     or $state[$p:lk] = 14990                               (: 'function' '#' :)
     or $state[$p:lk] = 14991                               (: 'ge' '#' :)
     or $state[$p:lk] = 14993                               (: 'group' '#' :)
     or $state[$p:lk] = 14995                               (: 'gt' '#' :)
     or $state[$p:lk] = 14996                               (: 'idiv' '#' :)
     or $state[$p:lk] = 14997                               (: 'if' '#' :)
     or $state[$p:lk] = 14998                               (: 'import' '#' :)
     or $state[$p:lk] = 15003                               (: 'insert' '#' :)
     or $state[$p:lk] = 15004                               (: 'instance' '#' :)
     or $state[$p:lk] = 15005                               (: 'intersect' '#' :)
     or $state[$p:lk] = 15007                               (: 'invoke' '#' :)
     or $state[$p:lk] = 15008                               (: 'is' '#' :)
     or $state[$p:lk] = 15009                               (: 'item' '#' :)
     or $state[$p:lk] = 15013                               (: 'le' '#' :)
     or $state[$p:lk] = 15015                               (: 'let' '#' :)
     or $state[$p:lk] = 15018                               (: 'lt' '#' :)
     or $state[$p:lk] = 15021                               (: 'mod' '#' :)
     or $state[$p:lk] = 15022                               (: 'modify' '#' :)
     or $state[$p:lk] = 15023                               (: 'module' '#' :)
     or $state[$p:lk] = 15025                               (: 'namespace' '#' :)
     or $state[$p:lk] = 15026                               (: 'namespace-node' '#' :)
     or $state[$p:lk] = 15027                               (: 'ne' '#' :)
     or $state[$p:lk] = 15032                               (: 'node' '#' :)
     or $state[$p:lk] = 15037                               (: 'only' '#' :)
     or $state[$p:lk] = 15039                               (: 'or' '#' :)
     or $state[$p:lk] = 15040                               (: 'order' '#' :)
     or $state[$p:lk] = 15041                               (: 'ordered' '#' :)
     or $state[$p:lk] = 15045                               (: 'parent' '#' :)
     or $state[$p:lk] = 15050                               (: 'preceding' '#' :)
     or $state[$p:lk] = 15051                               (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 15054                               (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 15056                               (: 'rename' '#' :)
     or $state[$p:lk] = 15057                               (: 'replace' '#' :)
     or $state[$p:lk] = 15058                               (: 'return' '#' :)
     or $state[$p:lk] = 15061                               (: 'satisfies' '#' :)
     or $state[$p:lk] = 15063                               (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 15064                               (: 'schema-element' '#' :)
     or $state[$p:lk] = 15066                               (: 'self' '#' :)
     or $state[$p:lk] = 15072                               (: 'some' '#' :)
     or $state[$p:lk] = 15073                               (: 'stable' '#' :)
     or $state[$p:lk] = 15074                               (: 'start' '#' :)
     or $state[$p:lk] = 15079                               (: 'switch' '#' :)
     or $state[$p:lk] = 15080                               (: 'text' '#' :)
     or $state[$p:lk] = 15084                               (: 'to' '#' :)
     or $state[$p:lk] = 15085                               (: 'transform' '#' :)
     or $state[$p:lk] = 15086                               (: 'treat' '#' :)
     or $state[$p:lk] = 15087                               (: 'try' '#' :)
     or $state[$p:lk] = 15090                               (: 'typeswitch' '#' :)
     or $state[$p:lk] = 15091                               (: 'union' '#' :)
     or $state[$p:lk] = 15092                               (: 'unordered' '#' :)
     or $state[$p:lk] = 15093                               (: 'update' '#' :)
     or $state[$p:lk] = 15097                               (: 'validate' '#' :)
     or $state[$p:lk] = 15103                               (: 'where' '#' :)
     or $state[$p:lk] = 15106                               (: 'with' '#' :)
     or $state[$p:lk] = 15110                               (: 'xquery' '#' :)
     or $state[$p:lk] = 17413                               (: URIQualifiedName '(' :)
     or $state[$p:lk] = 17423                               (: QName^Token '(' :)
     or $state[$p:lk] = 17486                               (: 'ancestor' '(' :)
     or $state[$p:lk] = 17487                               (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 17488                               (: 'and' '(' :)
     or $state[$p:lk] = 17491                               (: 'as' '(' :)
     or $state[$p:lk] = 17492                               (: 'ascending' '(' :)
     or $state[$p:lk] = 17493                               (: 'at' '(' :)
     or $state[$p:lk] = 17499                               (: 'case' '(' :)
     or $state[$p:lk] = 17500                               (: 'cast' '(' :)
     or $state[$p:lk] = 17501                               (: 'castable' '(' :)
     or $state[$p:lk] = 17503                               (: 'child' '(' :)
     or $state[$p:lk] = 17504                               (: 'collation' '(' :)
     or $state[$p:lk] = 17510                               (: 'copy' '(' :)
     or $state[$p:lk] = 17512                               (: 'count' '(' :)
     or $state[$p:lk] = 17515                               (: 'declare' '(' :)
     or $state[$p:lk] = 17516                               (: 'default' '(' :)
     or $state[$p:lk] = 17517                               (: 'delete' '(' :)
     or $state[$p:lk] = 17518                               (: 'descendant' '(' :)
     or $state[$p:lk] = 17519                               (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 17520                               (: 'descending' '(' :)
     or $state[$p:lk] = 17525                               (: 'div' '(' :)
     or $state[$p:lk] = 17526                               (: 'document' '(' :)
     or $state[$p:lk] = 17529                               (: 'else' '(' :)
     or $state[$p:lk] = 17530                               (: 'empty' '(' :)
     or $state[$p:lk] = 17533                               (: 'end' '(' :)
     or $state[$p:lk] = 17535                               (: 'eq' '(' :)
     or $state[$p:lk] = 17536                               (: 'every' '(' :)
     or $state[$p:lk] = 17538                               (: 'except' '(' :)
     or $state[$p:lk] = 17542                               (: 'following' '(' :)
     or $state[$p:lk] = 17543                               (: 'following-sibling' '(' :)
     or $state[$p:lk] = 17544                               (: 'for' '(' :)
     or $state[$p:lk] = 17550                               (: 'function' '(' :)
     or $state[$p:lk] = 17551                               (: 'ge' '(' :)
     or $state[$p:lk] = 17553                               (: 'group' '(' :)
     or $state[$p:lk] = 17555                               (: 'gt' '(' :)
     or $state[$p:lk] = 17556                               (: 'idiv' '(' :)
     or $state[$p:lk] = 17558                               (: 'import' '(' :)
     or $state[$p:lk] = 17563                               (: 'insert' '(' :)
     or $state[$p:lk] = 17564                               (: 'instance' '(' :)
     or $state[$p:lk] = 17565                               (: 'intersect' '(' :)
     or $state[$p:lk] = 17567                               (: 'invoke' '(' :)
     or $state[$p:lk] = 17568                               (: 'is' '(' :)
     or $state[$p:lk] = 17573                               (: 'le' '(' :)
     or $state[$p:lk] = 17575                               (: 'let' '(' :)
     or $state[$p:lk] = 17578                               (: 'lt' '(' :)
     or $state[$p:lk] = 17581                               (: 'mod' '(' :)
     or $state[$p:lk] = 17582                               (: 'modify' '(' :)
     or $state[$p:lk] = 17583                               (: 'module' '(' :)
     or $state[$p:lk] = 17585                               (: 'namespace' '(' :)
     or $state[$p:lk] = 17587                               (: 'ne' '(' :)
     or $state[$p:lk] = 17597                               (: 'only' '(' :)
     or $state[$p:lk] = 17599                               (: 'or' '(' :)
     or $state[$p:lk] = 17600                               (: 'order' '(' :)
     or $state[$p:lk] = 17601                               (: 'ordered' '(' :)
     or $state[$p:lk] = 17605                               (: 'parent' '(' :)
     or $state[$p:lk] = 17610                               (: 'preceding' '(' :)
     or $state[$p:lk] = 17611                               (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 17616                               (: 'rename' '(' :)
     or $state[$p:lk] = 17617                               (: 'replace' '(' :)
     or $state[$p:lk] = 17618                               (: 'return' '(' :)
     or $state[$p:lk] = 17621                               (: 'satisfies' '(' :)
     or $state[$p:lk] = 17626                               (: 'self' '(' :)
     or $state[$p:lk] = 17632                               (: 'some' '(' :)
     or $state[$p:lk] = 17633                               (: 'stable' '(' :)
     or $state[$p:lk] = 17634                               (: 'start' '(' :)
     or $state[$p:lk] = 17644                               (: 'to' '(' :)
     or $state[$p:lk] = 17645                               (: 'transform' '(' :)
     or $state[$p:lk] = 17646                               (: 'treat' '(' :)
     or $state[$p:lk] = 17647                               (: 'try' '(' :)
     or $state[$p:lk] = 17651                               (: 'union' '(' :)
     or $state[$p:lk] = 17652                               (: 'unordered' '(' :)
     or $state[$p:lk] = 17653                               (: 'update' '(' :)
     or $state[$p:lk] = 17657                               (: 'validate' '(' :)
     or $state[$p:lk] = 17663                               (: 'where' '(' :)
     or $state[$p:lk] = 17666                               (: 'with' '(' :)
     or $state[$p:lk] = 17670                               (: 'xquery' '(' :)
     or $state[$p:lk] = 40022                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 40056                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 40534                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 40568                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 43606                               (: 'attribute' 'at' :)
     or $state[$p:lk] = 43640                               (: 'element' 'at' :)
     or $state[$p:lk] = 44118                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 44152                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 48726                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 48760                               (: 'element' 'child' :)
     or $state[$p:lk] = 49750                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 49784                               (: 'element' 'comment' :)
     or $state[$p:lk] = 52310                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 52344                               (: 'element' 'copy' :)
     or $state[$p:lk] = 54870                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 54904                               (: 'element' 'declare' :)
     or $state[$p:lk] = 55894                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 55928                               (: 'element' 'delete' :)
     or $state[$p:lk] = 56406                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 56440                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 56918                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 56952                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 60502                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 60536                               (: 'element' 'document' :)
     or $state[$p:lk] = 61014                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 61048                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 61526                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 61560                               (: 'element' 'element' :)
     or $state[$p:lk] = 63062                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 63096                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 65622                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 65656                               (: 'element' 'every' :)
     or $state[$p:lk] = 68694                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 68728                               (: 'element' 'following' :)
     or $state[$p:lk] = 69206                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 69240                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 72790                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 72824                               (: 'element' 'function' :)
     or $state[$p:lk] = 76374                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 76408                               (: 'element' 'if' :)
     or $state[$p:lk] = 76886                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 76920                               (: 'element' 'import' :)
     or $state[$p:lk] = 79446                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 79480                               (: 'element' 'insert' :)
     or $state[$p:lk] = 81494                               (: 'attribute' 'invoke' :)
     or $state[$p:lk] = 81528                               (: 'element' 'invoke' :)
     or $state[$p:lk] = 82518                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 82552                               (: 'element' 'item' :)
     or $state[$p:lk] = 89686                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 89720                               (: 'element' 'module' :)
     or $state[$p:lk] = 90710                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 90744                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 91222                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 91256                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 94294                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 94328                               (: 'element' 'node' :)
     or $state[$p:lk] = 98902                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 98936                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 100950                              (: 'attribute' 'parent' :)
     or $state[$p:lk] = 100984                              (: 'element' 'parent' :)
     or $state[$p:lk] = 103510                              (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 103544                              (: 'element' 'preceding' :)
     or $state[$p:lk] = 104022                              (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 104056                              (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 105558                              (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 105592                              (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 106582                              (: 'attribute' 'rename' :)
     or $state[$p:lk] = 106616                              (: 'element' 'rename' :)
     or $state[$p:lk] = 107094                              (: 'attribute' 'replace' :)
     or $state[$p:lk] = 107128                              (: 'element' 'replace' :)
     or $state[$p:lk] = 110166                              (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 110200                              (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 110678                              (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 110712                              (: 'element' 'schema-element' :)
     or $state[$p:lk] = 111702                              (: 'attribute' 'self' :)
     or $state[$p:lk] = 111736                              (: 'element' 'self' :)
     or $state[$p:lk] = 114774                              (: 'attribute' 'some' :)
     or $state[$p:lk] = 114808                              (: 'element' 'some' :)
     or $state[$p:lk] = 118358                              (: 'attribute' 'switch' :)
     or $state[$p:lk] = 118392                              (: 'element' 'switch' :)
     or $state[$p:lk] = 118870                              (: 'attribute' 'text' :)
     or $state[$p:lk] = 118904                              (: 'element' 'text' :)
     or $state[$p:lk] = 122454                              (: 'attribute' 'try' :)
     or $state[$p:lk] = 122488                              (: 'element' 'try' :)
     or $state[$p:lk] = 123990                              (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 124024                              (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 125014                              (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 125048                              (: 'element' 'unordered' :)
     or $state[$p:lk] = 127574                              (: 'attribute' 'validate' :)
     or $state[$p:lk] = 127608                              (: 'element' 'validate' :)
     or $state[$p:lk] = 134230                              (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 134264                              (: 'element' 'xquery' :)
     or $state[$p:lk] = 135254                              (: 'attribute' '{' :)
     or $state[$p:lk] = 135265                              (: 'comment' '{' :)
     or $state[$p:lk] = 135286                              (: 'document' '{' :)
     or $state[$p:lk] = 135288                              (: 'element' '{' :)
     or $state[$p:lk] = 135345                              (: 'namespace' '{' :)
     or $state[$p:lk] = 135361                              (: 'ordered' '{' :)
     or $state[$p:lk] = 135374                              (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 135400                              (: 'text' '{' :)
     or $state[$p:lk] = 135412) then                        (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PostfixExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 26) then                         (: '!' :)
        let $state := p:lookahead2W(234, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 45                          (: '/' :)
           and $state[$p:lk] != 46                          (: '//' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 61                          (: '=>' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 245                         (: 'update' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269                         (: '}`' :)
           and $state[$p:lk] != 23066                       (: '!' '/' :)
           and $state[$p:lk] != 23578) then                 (: '!' '//' :)
        let $state := p:memoized($state, 18)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 45) then             (: '/' :)
                let $state := p:consume(45, $input, $state) (: '/' :)
                return $state
              else if ($state[$p:l1] = 46) then             (: '//' :)
                let $state := p:consume(46, $input, $state) (: '//' :)
                return $state
              else
                let $state := p:consume(26, $input, $state) (: '!' :)
                return $state
            let $state := p:lookahead1W(233, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                                '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                                'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                                'cast' | 'castable' | 'child' | 'collation' |
                                                                'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                                'delete' | 'descendant' | 'descendant-or-self' |
                                                                'descending' | 'div' | 'document' | 'document-node' |
                                                                'element' | 'else' | 'empty' | 'empty-sequence' |
                                                                'end' | 'eq' | 'every' | 'except' | 'following' |
                                                                'following-sibling' | 'for' | 'function' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                'parent' | 'preceding' | 'preceding-sibling' |
                                                                'processing-instruction' | 'rename' | 'replace' |
                                                                'return' | 'satisfies' | 'schema-attribute' |
                                                                'schema-element' | 'self' | 'some' | 'stable' |
                                                                'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                'update' | 'validate' | 'where' | 'with' | 'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-StepExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 45                               (: '/' :)
      and $state[$p:lk] != 46) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 45) then                 (: '/' :)
            let $state := p:consume(45, $input, $state)     (: '/' :)
            return $state
          else if ($state[$p:l1] = 46) then                 (: '//' :)
            let $state := p:consume(46, $input, $state)     (: '//' :)
            return $state
          else
            let $state := p:consume(26, $input, $state)     (: '!' :)
            return $state
        let $state := p:lookahead1W(233, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 26) then                         (: '!' :)
        let $state := p:lookahead2W(234, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 45                          (: '/' :)
           and $state[$p:lk] != 46                          (: '//' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 61                          (: '=>' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 245                         (: 'update' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269                         (: '}`' :)
           and $state[$p:lk] != 23066                       (: '!' '/' :)
           and $state[$p:lk] != 23578) then                 (: '!' '//' :)
        let $state := p:memoized($state, 18)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 45) then             (: '/' :)
                let $state := p:consume(45, $input, $state) (: '/' :)
                return $state
              else if ($state[$p:l1] = 46) then             (: '//' :)
                let $state := p:consume(46, $input, $state) (: '//' :)
                return $state
              else
                let $state := p:consume(26, $input, $state) (: '!' :)
                return $state
            let $state := p:lookahead1W(233, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                                '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                                'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                                'cast' | 'castable' | 'child' | 'collation' |
                                                                'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                                'delete' | 'descendant' | 'descendant-or-self' |
                                                                'descending' | 'div' | 'document' | 'document-node' |
                                                                'element' | 'else' | 'empty' | 'empty-sequence' |
                                                                'end' | 'eq' | 'every' | 'except' | 'following' |
                                                                'following-sibling' | 'for' | 'function' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                'parent' | 'preceding' | 'preceding-sibling' |
                                                                'processing-instruction' | 'rename' | 'replace' |
                                                                'return' | 'satisfies' | 'schema-attribute' |
                                                                'schema-element' | 'self' | 'some' | 'stable' |
                                                                'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                'update' | 'validate' | 'where' | 'with' | 'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-StepExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 18, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-RelativePathExpr-1($input, $state)
      else if ($state[$p:lk] != -1
           and $state[$p:lk] != 45                          (: '/' :)
           and $state[$p:lk] != 46) then                    (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 45) then                 (: '/' :)
            let $state := p:consume(45, $input, $state)     (: '/' :)
            return $state
          else if ($state[$p:l1] = 46) then                 (: '//' :)
            let $state := p:consume(46, $input, $state)     (: '//' :)
            return $state
          else
            let $state := p:consume(26, $input, $state)     (: '!' :)
            return $state
        let $state := p:lookahead1W(233, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-StepExpr($input, $state)
        return p:try-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StepExpr($input, $state)
  let $state := p:try-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/' :)
      let $state := p:consume(45, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(244, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ':' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' | ']' |
                                                               '``[' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'words' | 'xquery' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25                         (: EOF :)
              or $state[$p:l1] = 26                         (: '!' :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 40                         (: ',' :)
              or $state[$p:l1] = 41                         (: '-' :)
              or $state[$p:l1] = 48                         (: ':' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '=>' :)
              or $state[$p:l1] = 62                         (: '>' :)
              or $state[$p:l1] = 63                         (: '>=' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 70                         (: ']' :)
              or $state[$p:l1] = 75                         (: 'after' :)
              or $state[$p:l1] = 88                         (: 'before' :)
              or $state[$p:l1] = 99                         (: 'contains' :)
              or $state[$p:l1] = 158                        (: 'into' :)
              or $state[$p:l1] = 196                        (: 'paragraphs' :)
              or $state[$p:l1] = 221                        (: 'sentences' :)
              or $state[$p:l1] = 235                        (: 'times' :)
              or $state[$p:l1] = 261                        (: 'words' :)
              or $state[$p:l1] = 266                        (: '|' :)
              or $state[$p:l1] = 267                        (: '||' :)
              or $state[$p:l1] = 268                        (: '}' :)
              or $state[$p:l1] = 269) then                  (: '}`' :)
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 46) then                       (: '//' :)
      let $state := p:consume(46, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(233, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/' :)
      let $state := p:consume(45, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(244, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ':' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' | ']' |
                                                               '``[' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'words' | 'xquery' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25                         (: EOF :)
              or $state[$p:l1] = 26                         (: '!' :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 40                         (: ',' :)
              or $state[$p:l1] = 41                         (: '-' :)
              or $state[$p:l1] = 48                         (: ':' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '=>' :)
              or $state[$p:l1] = 62                         (: '>' :)
              or $state[$p:l1] = 63                         (: '>=' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 70                         (: ']' :)
              or $state[$p:l1] = 75                         (: 'after' :)
              or $state[$p:l1] = 88                         (: 'before' :)
              or $state[$p:l1] = 99                         (: 'contains' :)
              or $state[$p:l1] = 158                        (: 'into' :)
              or $state[$p:l1] = 196                        (: 'paragraphs' :)
              or $state[$p:l1] = 221                        (: 'sentences' :)
              or $state[$p:l1] = 235                        (: 'times' :)
              or $state[$p:l1] = 261                        (: 'words' :)
              or $state[$p:l1] = 266                        (: '|' :)
              or $state[$p:l1] = 267                        (: '||' :)
              or $state[$p:l1] = 268                        (: '}' :)
              or $state[$p:l1] = 269) then                  (: '}`' :)
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 46) then                       (: '//' :)
      let $state := p:consume(46, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(233, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26) then                           (: '!' :)
      $state
    else
      let $state := p:consume(26, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(234, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26) then                           (: '!' :)
      $state
    else
      let $state := p:consume(26, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(234, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PathExpr($input, $state)
      return p:try-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PathExpr($input, $state)
  let $state := p:try-SimpleMapExpr-1($input, $state)
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'lax' :)
      let $state := p:consume(164, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(229, $input, $state)          (: 'strict' :)
      return $state
  return $state
};

(:~
 : Try parsing ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'lax' :)
      let $state := p:consume(164, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(229, $input, $state)          (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(249, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 264) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 241) then                  (: 'type' :)
          let $state := p:consume(241, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(249, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 264) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 241) then                  (: 'type' :)
          let $state := p:consume(241, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeName($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 249) then                          (: 'validate' :)
      let $state := p:lookahead2W(212, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'type' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' |
                                                               '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 84217                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 117497                         (: 'validate' 'strict' :)
          or $state[$p:lk] = 123641                         (: 'validate' 'type' :)
          or $state[$p:lk] = 135417) then                   (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SimpleMapExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 249) then                          (: 'validate' :)
      let $state := p:lookahead2W(212, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'type' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' |
                                                               '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 84217                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 117497                         (: 'validate' 'strict' :)
          or $state[$p:lk] = 123641                         (: 'validate' 'type' :)
          or $state[$p:lk] = 135417) then                   (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SimpleMapExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 41) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 41) then                 (: '-' :)
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 41) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 41) then                 (: '-' :)
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
        return p:try-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  return $state
};

(:~
 : Try parsing UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ArrowExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrowExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                               '>=' | '>>' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 61) then                         (: '=>' :)
        $state
      else
        let $state := p:consume(61, $input, $state)         (: '=>' :)
        let $state := p:lookahead1W(227, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '$' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ArrowFunctionSpecifier($input, $state)
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | '(' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ArgumentList($input, $state)
        return p:parse-ArrowExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArrowExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrowExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                               '>=' | '>>' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 61) then                         (: '=>' :)
        $state
      else
        let $state := p:consume(61, $input, $state)         (: '=>' :)
        let $state := p:lookahead1W(227, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '$' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ArrowFunctionSpecifier($input, $state)
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | '(' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ArgumentList($input, $state)
        return p:try-ArrowExpr-1($input, $state)
};

(:~
 : Parse ArrowExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrowExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:parse-ArrowExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing ArrowExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrowExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnaryExpr($input, $state)
  let $state := p:try-ArrowExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BasexUpdateExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexUpdateExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] eq 245) then                        (: 'update' :)
        let $state := p:lookahead2W(239, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '{' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 135413) then                     (: 'update' '{' :)
        $state
      else
        let $state := p:consume(245, $input, $state)        (: 'update' :)
        let $state := p:lookahead1W(80, $input, $state)     (: S^WS | ('(' ':') | '{' :)
        let $state := p:consume(264, $input, $state)        (: '{' :)
        let $state := p:lookahead1W(240, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 268) then               (: '}' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Expr($input, $state)
            return $state
          else
            $state
        let $state := p:consume(268, $input, $state)        (: '}' :)
        return p:parse-BasexUpdateExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BasexUpdateExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexUpdateExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] eq 245) then                        (: 'update' :)
        let $state := p:lookahead2W(239, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '{' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 135413) then                     (: 'update' '{' :)
        $state
      else
        let $state := p:consume(245, $input, $state)        (: 'update' :)
        let $state := p:lookahead1W(80, $input, $state)     (: S^WS | ('(' ':') | '{' :)
        let $state := p:consume(264, $input, $state)        (: '{' :)
        let $state := p:lookahead1W(240, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 268) then               (: '}' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Expr($input, $state)
            return $state
          else
            $state
        let $state := p:consume(268, $input, $state)        (: '}' :)
        return p:try-BasexUpdateExpr-1($input, $state)
};

(:~
 : Parse BasexUpdateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexUpdateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ArrowExpr($input, $state)
  let $state := p:parse-BasexUpdateExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing BasexUpdateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexUpdateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ArrowExpr($input, $state)
  let $state := p:try-BasexUpdateExpr-1($input, $state)
  return $state
};

(:~
 : Parse BasexUpdate1Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexUpdate1Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-BasexUpdateExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing BasexUpdate1Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexUpdate1Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-BasexUpdateExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TransformWithExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TransformWithExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-BasexUpdate1Expr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 237) then                          (: 'transform' :)
      let $state := p:lookahead2W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 132333) then                   (: 'transform' 'with' :)
      let $state := p:memoized($state, 17)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(237, $input, $state)      (: 'transform' :)
          let $state := p:lookahead1W(78, $input, $state)   (: S^WS | ('(' ':') | 'with' :)
          let $state := p:consume(258, $input, $state)      (: 'with' :)
          let $state := p:lookahead1W(80, $input, $state)   (: S^WS | ('(' ':') | '{' :)
          let $state := p:consume(264, $input, $state)      (: '{' :)
          let $state := p:lookahead1W(240, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 268) then             (: '}' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Expr($input, $state)
              return $state
            else
              $state
          let $state := p:consume(268, $input, $state)      (: '}' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(240, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 268) then                 (: '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          return $state
        else
          $state
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing TransformWithExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TransformWithExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-BasexUpdate1Expr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 237) then                          (: 'transform' :)
      let $state := p:lookahead2W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 132333) then                   (: 'transform' 'with' :)
      let $state := p:memoized($state, 17)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(237, $input, $state)      (: 'transform' :)
          let $state := p:lookahead1W(78, $input, $state)   (: S^WS | ('(' ':') | 'with' :)
          let $state := p:consume(258, $input, $state)      (: 'with' :)
          let $state := p:lookahead1W(80, $input, $state)   (: S^WS | ('(' ':') | '{' :)
          let $state := p:consume(264, $input, $state)      (: '{' :)
          let $state := p:lookahead1W(240, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 268) then             (: '}' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Expr($input, $state)
              return $state
            else
              $state
          let $state := p:consume(268, $input, $state)      (: '}' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(240, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 268) then                 (: '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expr($input, $state)
          return $state
        else
          $state
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TransformWithExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 92) then                           (: 'cast' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42588) then                    (: 'cast' 'as' :)
      let $state := p:memoized($state, 16)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(92, $input, $state)       (: 'cast' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TransformWithExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 92) then                           (: 'cast' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42588) then                    (: 'cast' 'as' :)
      let $state := p:memoized($state, 16)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(92, $input, $state)       (: 'cast' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 93) then                           (: 'castable' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42589) then                    (: 'castable' 'as' :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(93, $input, $state)       (: 'castable' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CastExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 93) then                           (: 'castable' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42589) then                    (: 'castable' 'as' :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(93, $input, $state)       (: 'castable' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 238) then                          (: 'treat' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42734) then                    (: 'treat' 'as' :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(238, $input, $state)      (: 'treat' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CastableExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 238) then                          (: 'treat' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42734) then                    (: 'treat' 'as' :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(238, $input, $state)      (: 'treat' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 156) then                          (: 'instance' :)
      let $state := p:lookahead2W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 96412) then                    (: 'instance' 'of' :)
      let $state := p:memoized($state, 13)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(156, $input, $state)      (: 'instance' :)
          let $state := p:lookahead1W(59, $input, $state)   (: S^WS | ('(' ':') | 'of' :)
          let $state := p:consume(188, $input, $state)      (: 'of' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TreatExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 156) then                          (: 'instance' :)
      let $state := p:lookahead2W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 96412) then                    (: 'instance' 'of' :)
      let $state := p:memoized($state, 13)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(156, $input, $state)      (: 'instance' :)
          let $state := p:lookahead1W(59, $input, $state)   (: S^WS | ('(' ':') | 'of' :)
          let $state := p:consume(188, $input, $state)      (: 'of' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           157)) then                       (: 'intersect' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 12)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 157) then            (: 'intersect' :)
                let $state := p:consume(157, $input, $state) (: 'intersect' :)
                return $state
              else
                let $state := p:consume(130, $input, $state) (: 'except' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-InstanceofExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 157) then                (: 'intersect' :)
            let $state := p:consume(157, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(130, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           157)) then                       (: 'intersect' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 12)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 157) then            (: 'intersect' :)
                let $state := p:consume(157, $input, $state) (: 'intersect' :)
                return $state
              else
                let $state := p:consume(130, $input, $state) (: 'except' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-InstanceofExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 12, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-IntersectExceptExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 157) then                (: 'intersect' :)
            let $state := p:consume(157, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(130, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-InstanceofExpr($input, $state)
        return p:try-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InstanceofExpr($input, $state)
  let $state := p:try-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (243,                             (: 'union' :)
                           266)) then                       (: '|' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 11)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 243) then            (: 'union' :)
                let $state := p:consume(243, $input, $state) (: 'union' :)
                return $state
              else
                let $state := p:consume(266, $input, $state) (: '|' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-IntersectExceptExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 243) then                (: 'union' :)
            let $state := p:consume(243, $input, $state)    (: 'union' :)
            return $state
          else
            let $state := p:consume(266, $input, $state)    (: '|' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (243,                             (: 'union' :)
                           266)) then                       (: '|' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 11)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 243) then            (: 'union' :)
                let $state := p:consume(243, $input, $state) (: 'union' :)
                return $state
              else
                let $state := p:consume(266, $input, $state) (: '|' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-IntersectExceptExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 11, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-UnionExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 243) then                (: 'union' :)
            let $state := p:consume(243, $input, $state)    (: 'union' :)
            return $state
          else
            let $state := p:consume(266, $input, $state)    (: '|' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-IntersectExceptExpr($input, $state)
        return p:try-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-IntersectExceptExpr($input, $state)
  let $state := p:try-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (38,                              (: '*' :)
                           117,                             (: 'div' :)
                           148,                             (: 'idiv' :)
                           173)) then                       (: 'mod' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 10)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 38) then             (: '*' :)
                let $state := p:consume(38, $input, $state) (: '*' :)
                return $state
              else if ($state[$p:l1] = 117) then            (: 'div' :)
                let $state := p:consume(117, $input, $state) (: 'div' :)
                return $state
              else if ($state[$p:l1] = 148) then            (: 'idiv' :)
                let $state := p:consume(148, $input, $state) (: 'idiv' :)
                return $state
              else
                let $state := p:consume(173, $input, $state) (: 'mod' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-UnionExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '*' :)
            let $state := p:consume(38, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 117) then                (: 'div' :)
            let $state := p:consume(117, $input, $state)    (: 'div' :)
            return $state
          else if ($state[$p:l1] = 148) then                (: 'idiv' :)
            let $state := p:consume(148, $input, $state)    (: 'idiv' :)
            return $state
          else
            let $state := p:consume(173, $input, $state)    (: 'mod' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (38,                              (: '*' :)
                           117,                             (: 'div' :)
                           148,                             (: 'idiv' :)
                           173)) then                       (: 'mod' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 10)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 38) then             (: '*' :)
                let $state := p:consume(38, $input, $state) (: '*' :)
                return $state
              else if ($state[$p:l1] = 117) then            (: 'div' :)
                let $state := p:consume(117, $input, $state) (: 'div' :)
                return $state
              else if ($state[$p:l1] = 148) then            (: 'idiv' :)
                let $state := p:consume(148, $input, $state) (: 'idiv' :)
                return $state
              else
                let $state := p:consume(173, $input, $state) (: 'mod' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-UnionExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 10, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-MultiplicativeExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '*' :)
            let $state := p:consume(38, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 117) then                (: 'div' :)
            let $state := p:consume(117, $input, $state)    (: 'div' :)
            return $state
          else if ($state[$p:l1] = 148) then                (: 'idiv' :)
            let $state := p:consume(148, $input, $state)    (: 'idiv' :)
            return $state
          else
            let $state := p:consume(173, $input, $state)    (: 'mod' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-UnionExpr($input, $state)
        return p:try-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnionExpr($input, $state)
  let $state := p:try-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (39,                              (: '+' :)
                           41)) then                        (: '-' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 39) then             (: '+' :)
                let $state := p:consume(39, $input, $state) (: '+' :)
                return $state
              else
                let $state := p:consume(41, $input, $state) (: '-' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-MultiplicativeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '+' :)
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
          else
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (39,                              (: '+' :)
                           41)) then                        (: '-' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 39) then             (: '+' :)
                let $state := p:consume(39, $input, $state) (: '+' :)
                return $state
              else
                let $state := p:consume(41, $input, $state) (: '-' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-MultiplicativeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 9, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-AdditiveExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '+' :)
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
          else
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-MultiplicativeExpr($input, $state)
        return p:try-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MultiplicativeExpr($input, $state)
  let $state := p:try-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 236) then                          (: 'to' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 27                            (: '!=' :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 53                            (: '<' :)
         and $state[$p:lk] != 57                            (: '<<' :)
         and $state[$p:lk] != 58                            (: '<=' :)
         and $state[$p:lk] != 60                            (: '=' :)
         and $state[$p:lk] != 62                            (: '>' :)
         and $state[$p:lk] != 63                            (: '>=' :)
         and $state[$p:lk] != 64                            (: '>>' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 127                           (: 'eq' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 143                           (: 'ge' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 147                           (: 'gt' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 160                           (: 'is' :)
         and $state[$p:lk] != 165                           (: 'le' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 170                           (: 'lt' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 179                           (: 'ne' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(236, $input, $state)      (: 'to' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 236) then                          (: 'to' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 27                            (: '!=' :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 53                            (: '<' :)
         and $state[$p:lk] != 57                            (: '<<' :)
         and $state[$p:lk] != 58                            (: '<=' :)
         and $state[$p:lk] != 60                            (: '=' :)
         and $state[$p:lk] != 62                            (: '>' :)
         and $state[$p:lk] != 63                            (: '>=' :)
         and $state[$p:lk] != 64                            (: '>>' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 127                           (: 'eq' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 143                           (: 'ge' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 147                           (: 'gt' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 160                           (: 'is' :)
         and $state[$p:lk] != 165                           (: 'le' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 170                           (: 'lt' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 179                           (: 'ne' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(236, $input, $state)      (: 'to' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 267) then                        (: '||' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(267, $input, $state)    (: '||' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-RangeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(267, $input, $state)        (: '||' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-RangeExpr($input, $state)
        return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 267) then                        (: '||' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(267, $input, $state)    (: '||' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-RangeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 7, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-StringConcatExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(267, $input, $state)        (: '||' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-RangeExpr($input, $state)
        return p:try-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-RangeExpr($input, $state)
  let $state := p:try-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Parse FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 99) then                           (: 'contains' :)
      let $state := p:lookahead2W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 118883) then                   (: 'contains' 'text' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(99, $input, $state)       (: 'contains' :)
          let $state := p:lookahead1W(69, $input, $state)   (: S^WS | ('(' ':') | 'text' :)
          let $state := p:consume(232, $input, $state)      (: 'text' :)
          let $state := p:lookahead1W(153, $input, $state)  (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTSelection($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 259) then              (: 'without' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-FTIgnoreOption($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(99, $input, $state)           (: 'contains' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 259) then                  (: 'without' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 99) then                           (: 'contains' :)
      let $state := p:lookahead2W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 118883) then                   (: 'contains' 'text' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(99, $input, $state)       (: 'contains' :)
          let $state := p:lookahead1W(69, $input, $state)   (: S^WS | ('(' ':') | 'text' :)
          let $state := p:consume(232, $input, $state)      (: 'text' :)
          let $state := p:lookahead1W(153, $input, $state)  (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTSelection($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 259) then              (: 'without' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-FTIgnoreOption($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(99, $input, $state)           (: 'contains' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 259) then                  (: 'without' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:l1] = (27,                                (: '!=' :)
                         53,                                (: '<' :)
                         57,                                (: '<<' :)
                         58,                                (: '<=' :)
                         60,                                (: '=' :)
                         62,                                (: '>' :)
                         63,                                (: '>=' :)
                         64,                                (: '>>' :)
                         127,                               (: 'eq' :)
                         143,                               (: 'ge' :)
                         147,                               (: 'gt' :)
                         160,                               (: 'is' :)
                         165,                               (: 'le' :)
                         170,                               (: 'lt' :)
                         179)) then                         (: 'ne' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 236                           (: 'to' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 127                    (: 'eq' :)
                  or $state[$p:l1] = 143                    (: 'ge' :)
                  or $state[$p:l1] = 147                    (: 'gt' :)
                  or $state[$p:l1] = 165                    (: 'le' :)
                  or $state[$p:l1] = 170                    (: 'lt' :)
                  or $state[$p:l1] = 179) then              (: 'ne' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ValueComp($input, $state)
              return $state
            else if ($state[$p:l1] = 57                     (: '<<' :)
                  or $state[$p:l1] = 64                     (: '>>' :)
                  or $state[$p:l1] = 160) then              (: 'is' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-NodeComp($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-GeneralComp($input, $state)
              return $state
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTContainsExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 127                        (: 'eq' :)
              or $state[$p:l1] = 143                        (: 'ge' :)
              or $state[$p:l1] = 147                        (: 'gt' :)
              or $state[$p:l1] = 165                        (: 'le' :)
              or $state[$p:l1] = 170                        (: 'lt' :)
              or $state[$p:l1] = 179) then                  (: 'ne' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 160) then                  (: 'is' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTContainsExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:l1] = (27,                                (: '!=' :)
                         53,                                (: '<' :)
                         57,                                (: '<<' :)
                         58,                                (: '<=' :)
                         60,                                (: '=' :)
                         62,                                (: '>' :)
                         63,                                (: '>=' :)
                         64,                                (: '>>' :)
                         127,                               (: 'eq' :)
                         143,                               (: 'ge' :)
                         147,                               (: 'gt' :)
                         160,                               (: 'is' :)
                         165,                               (: 'le' :)
                         170,                               (: 'lt' :)
                         179)) then                         (: 'ne' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 236                           (: 'to' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 127                    (: 'eq' :)
                  or $state[$p:l1] = 143                    (: 'ge' :)
                  or $state[$p:l1] = 147                    (: 'gt' :)
                  or $state[$p:l1] = 165                    (: 'le' :)
                  or $state[$p:l1] = 170                    (: 'lt' :)
                  or $state[$p:l1] = 179) then              (: 'ne' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ValueComp($input, $state)
              return $state
            else if ($state[$p:l1] = 57                     (: '<<' :)
                  or $state[$p:l1] = 64                     (: '>>' :)
                  or $state[$p:l1] = 160) then              (: 'is' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-NodeComp($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-GeneralComp($input, $state)
              return $state
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTContainsExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 127                        (: 'eq' :)
              or $state[$p:l1] = 143                        (: 'ge' :)
              or $state[$p:l1] = 147                        (: 'gt' :)
              or $state[$p:l1] = 165                        (: 'le' :)
              or $state[$p:l1] = 170                        (: 'lt' :)
              or $state[$p:l1] = 179) then                  (: 'ne' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 160) then                  (: 'is' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-NodeComp($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTContainsExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 80) then                         (: 'and' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 4)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(80, $input, $state)     (: 'and' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-ComparisonExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(80, $input, $state)         (: 'and' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 80) then                         (: 'and' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 4)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(80, $input, $state)     (: 'and' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-ComparisonExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 4, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-AndExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(80, $input, $state)         (: 'and' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ComparisonExpr($input, $state)
        return p:try-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ComparisonExpr($input, $state)
  let $state := p:try-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 191) then                        (: 'or' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(191, $input, $state)    (: 'or' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-AndExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(191, $input, $state)        (: 'or' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 191) then                        (: 'or' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(191, $input, $state)    (: 'or' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-AndExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 3, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-OrExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(191, $input, $state)        (: 'or' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AndExpr($input, $state)
        return p:try-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AndExpr($input, $state)
  let $state := p:try-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse CopyModifySpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifySpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing CopyModifySpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CopyModifySpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CopyModifyExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifyExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | 'modify' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-CopyModifySpec($input, $state)
        return p:parse-CopyModifyExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CopyModifyExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CopyModifyExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | 'modify' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-CopyModifySpec($input, $state)
        return p:try-CopyModifyExpr-1($input, $state)
};

(:~
 : Parse CopyModifyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(102, $input, $state)              (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CopyModifySpec($input, $state)
  let $state := p:parse-CopyModifyExpr-1($input, $state)
  let $state := p:consume(174, $input, $state)              (: 'modify' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing CopyModifyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CopyModifyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(102, $input, $state)              (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CopyModifySpec($input, $state)
  let $state := p:try-CopyModifyExpr-1($input, $state)
  let $state := p:consume(174, $input, $state)              (: 'modify' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse KeySpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KeySpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing KeySpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-KeySpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NCName($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnaryLookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryLookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-KeySpecifier($input, $state)
  return $state
};

(:~
 : Try parsing UnaryLookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryLookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-KeySpecifier($input, $state)
  return $state
};

(:~
 : Parse StringConstructorInterpolation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructorInterpolation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(74, $input, $state)               (: '`{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 269) then                     (: '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(269, $input, $state)              (: '}`' :)
  return $state
};

(:~
 : Try parsing StringConstructorInterpolation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructorInterpolation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(74, $input, $state)               (: '`{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 269) then                     (: '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(269, $input, $state)              (: '}`' :)
  return $state
};

(:~
 : Parse the 1st loop of production StringConstructorContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructorContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: ']``' | '`{' :)
    return
      if ($state[$p:l1] != 74) then                         (: '`{' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-StringConstructorInterpolation($input, $state)
        let $state := p:lookahead1(1, $input, $state)       (: StringConstructorChars :)
        let $state := p:consume(16, $input, $state)         (: StringConstructorChars :)
        return p:parse-StringConstructorContent-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StringConstructorContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructorContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: ']``' | '`{' :)
    return
      if ($state[$p:l1] != 74) then                         (: '`{' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-StringConstructorInterpolation($input, $state)
        let $state := p:lookahead1(1, $input, $state)       (: StringConstructorChars :)
        let $state := p:consume(16, $input, $state)         (: StringConstructorChars :)
        return p:try-StringConstructorContent-1($input, $state)
};

(:~
 : Parse StringConstructorContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructorContent($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(1, $input, $state)             (: StringConstructorChars :)
  let $state := p:consume(16, $input, $state)               (: StringConstructorChars :)
  let $state := p:parse-StringConstructorContent-1($input, $state)
  return $state
};

(:~
 : Try parsing StringConstructorContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructorContent($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(1, $input, $state)             (: StringConstructorChars :)
  let $state := p:consume(16, $input, $state)               (: StringConstructorChars :)
  let $state := p:try-StringConstructorContent-1($input, $state)
  return $state
};

(:~
 : Parse StringConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(73, $input, $state)               (: '``[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StringConstructorContent($input, $state)
  let $state := p:consume(72, $input, $state)               (: ']``' :)
  return $state
};

(:~
 : Try parsing StringConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(73, $input, $state)               (: '``[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StringConstructorContent($input, $state)
  let $state := p:consume(72, $input, $state)               (: ']``' :)
  return $state
};

(:~
 : Parse CurlyArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurlyArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CurlyArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CurlyArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SquareArrayConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ']' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-SquareArrayConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SquareArrayConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SquareArrayConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ']' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ExprSingle($input, $state)
        return p:try-SquareArrayConstructor-1($input, $state)
};

(:~
 : Parse SquareArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SquareArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(238, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | ']' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 70) then                      (: ']' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-SquareArrayConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Try parsing SquareArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SquareArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(238, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | ']' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 70) then                      (: ']' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      let $state := p:try-SquareArrayConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Parse ArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SquareArrayConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurlyArrayConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SquareArrayConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CurlyArrayConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse MapValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing MapValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse MapKeyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapKeyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing MapKeyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapKeyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse MapConstructorEntry.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapConstructorEntry($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MapKeyExpr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ':' :)
  let $state := p:consume(48, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MapValueExpr($input, $state)
  return $state
};

(:~
 : Try parsing MapConstructorEntry.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapConstructorEntry($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MapKeyExpr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ':' :)
  let $state := p:consume(48, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MapValueExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MapConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | ',' | '}' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-MapConstructorEntry($input, $state)
        return p:parse-MapConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MapConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | ',' | '}' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-MapConstructorEntry($input, $state)
        return p:try-MapConstructor-1($input, $state)
};

(:~
 : Parse MapConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MapConstructorEntry($input, $state)
      let $state := p:parse-MapConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing MapConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MapConstructorEntry($input, $state)
      let $state := p:try-MapConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Param($input, $state)
        return p:try-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return $state
};

(:~
 : Try parsing ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Param($input, $state)
  let $state := p:try-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Annotation($input, $state)
        return p:parse-InlineFunctionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Annotation($input, $state)
        return p:try-InlineFunctionExpr-1($input, $state)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionBody($input, $state)
  return $state
};

(:~
 : Try parsing InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FunctionBody($input, $state)
  return $state
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  return $state
};

(:~
 : Try parsing NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  return $state
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InlineFunctionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamedFunctionRef($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InlineFunctionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NamedFunctionRef($input, $state)
      return $state
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Try parsing URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Try parsing PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  return $state
};

(:~
 : Try parsing Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrefixExpr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URIExpr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PrefixExpr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URIExpr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse EnclosedContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing EnclosedContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnclosedContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedContentExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedContentExpr($input, $state)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(118, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(118, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(59, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(15, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(4, $input, $state)         (: DirPIContents :)
      let $state := p:consume(23, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:consume(66, $input, $state)               (: '?>' :)
  return $state
};

(:~
 : Try parsing DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(59, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(15, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(4, $input, $state)         (: DirPIContents :)
      let $state := p:consume(23, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:consume(66, $input, $state)               (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(54, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(3, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(22, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:consume(42, $input, $state)               (: '-->' :)
  return $state
};

(:~
 : Try parsing DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(54, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(3, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(22, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:consume(42, $input, $state)               (: '-->' :)
  return $state
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(55, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(5, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(24, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(11, $input, $state)            (: ']]>' :)
  let $state := p:consume(71, $input, $state)               (: ']]>' :)
  return $state
};

(:~
 : Try parsing CDataSection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(55, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(5, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(24, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(11, $input, $state)            (: ']]>' :)
  let $state := p:consume(71, $input, $state)               (: ']]>' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 265) then                      (: '{{' :)
      let $state := p:consume(265, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 270) then                      (: '}}' :)
      let $state := p:consume(270, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 265) then                      (: '{{' :)
      let $state := p:consume(265, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 270) then                      (: '}}' :)
      let $state := p:consume(270, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(158, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(158, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-QuotAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(159, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(159, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-AposAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(16, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(33, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(33, $input, $state)           (: "'" :)
      return $state
  return $state
};

(:~
 : Try parsing DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(16, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      let $state := p:try-DirAttributeValue-1($input, $state)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(33, $input, $state)           (: "'" :)
      let $state := p:try-DirAttributeValue-2($input, $state)
      let $state := p:consume(33, $input, $state)           (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 17) then                         (: S :)
        $state
      else
        let $state := p:consume(17, $input, $state)         (: S :)
        let $state := p:lookahead1(223, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 17                      (: S :)
               and $state[$p:l1] != 47                      (: '/>' :)
               and $state[$p:l1] != 62) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(13, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:consume(60, $input, $state)     (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 17) then                         (: S :)
        $state
      else
        let $state := p:consume(17, $input, $state)         (: S :)
        let $state := p:lookahead1(223, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 17                      (: S :)
               and $state[$p:l1] != 47                      (: '/>' :)
               and $state[$p:l1] != 62) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-QName($input, $state)
            let $state := p:lookahead1(13, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:consume(60, $input, $state)     (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:try-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Try parsing DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(164, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(164, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-DirElemContent($input, $state)
        return p:try-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(53, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: '/>' :)
      let $state := p:consume(47, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(62, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(56, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(14, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 17) then                   (: S :)
          let $state := p:consume(17, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
  return $state
};

(:~
 : Try parsing DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(53, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: '/>' :)
      let $state := p:consume(47, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(62, $input, $state)           (: '>' :)
      let $state := p:try-DirElemConstructor-1($input, $state)
      let $state := p:consume(56, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-QName($input, $state)
      let $state := p:lookahead1(14, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 17) then                   (: S :)
          let $state := p:consume(17, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(244, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(244, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  return $state
};

(:~
 : Try parsing ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  return $state
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 65) then                           (: '?' :)
      let $state := p:lookahead2W(180, $input, $state)      (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | ',' | 'and' | 'as' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19009                          (: '?' ')' :)
          or $state[$p:lk] = 20545) then                    (: '?' ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing Argument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 65) then                           (: '?' :)
      let $state := p:lookahead2W(180, $input, $state)      (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | ',' | 'and' | 'as' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19009                          (: '?' ')' :)
          or $state[$p:lk] = 20545) then                    (: '?' ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArgumentPlaceholder($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Argument($input, $state)
        return p:try-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Argument($input, $state)
      let $state := p:try-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse FunctionEQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FunctionEQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ArgumentList($input, $state)
  return $state
};

(:~
 : Try parsing FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FunctionEQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ArgumentList($input, $state)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(43, $input, $state)               (: '.' :)
  return $state
};

(:~
 : Try parsing ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(43, $input, $state)               (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 177) then                          (: 'namespace' :)
      let $state := p:lookahead2W(179, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'as' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 206) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(177, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (86,                           (: 'attribute' :)
                              120)) then                    (: 'element' :)
      let $state := p:lookahead2W(226, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              232)) then                    (: 'text' :)
      let $state := p:lookahead2W(84, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(133, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              95,                           (: 'child' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              136,                          (: 'for' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              179,                          (: 'ne' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              218,                          (: 'self' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17413                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17423                          (: QName^Token '(' :)
          or $state[$p:lk] = 17486                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17487                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17488                          (: 'and' '(' :)
          or $state[$p:lk] = 17491                          (: 'as' '(' :)
          or $state[$p:lk] = 17492                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17493                          (: 'at' '(' :)
          or $state[$p:lk] = 17499                          (: 'case' '(' :)
          or $state[$p:lk] = 17500                          (: 'cast' '(' :)
          or $state[$p:lk] = 17501                          (: 'castable' '(' :)
          or $state[$p:lk] = 17503                          (: 'child' '(' :)
          or $state[$p:lk] = 17504                          (: 'collation' '(' :)
          or $state[$p:lk] = 17510                          (: 'copy' '(' :)
          or $state[$p:lk] = 17512                          (: 'count' '(' :)
          or $state[$p:lk] = 17515                          (: 'declare' '(' :)
          or $state[$p:lk] = 17516                          (: 'default' '(' :)
          or $state[$p:lk] = 17517                          (: 'delete' '(' :)
          or $state[$p:lk] = 17518                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17519                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17520                          (: 'descending' '(' :)
          or $state[$p:lk] = 17525                          (: 'div' '(' :)
          or $state[$p:lk] = 17526                          (: 'document' '(' :)
          or $state[$p:lk] = 17529                          (: 'else' '(' :)
          or $state[$p:lk] = 17530                          (: 'empty' '(' :)
          or $state[$p:lk] = 17533                          (: 'end' '(' :)
          or $state[$p:lk] = 17535                          (: 'eq' '(' :)
          or $state[$p:lk] = 17536                          (: 'every' '(' :)
          or $state[$p:lk] = 17538                          (: 'except' '(' :)
          or $state[$p:lk] = 17542                          (: 'following' '(' :)
          or $state[$p:lk] = 17543                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17544                          (: 'for' '(' :)
          or $state[$p:lk] = 17551                          (: 'ge' '(' :)
          or $state[$p:lk] = 17553                          (: 'group' '(' :)
          or $state[$p:lk] = 17555                          (: 'gt' '(' :)
          or $state[$p:lk] = 17556                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17558                          (: 'import' '(' :)
          or $state[$p:lk] = 17563                          (: 'insert' '(' :)
          or $state[$p:lk] = 17564                          (: 'instance' '(' :)
          or $state[$p:lk] = 17565                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17567                          (: 'invoke' '(' :)
          or $state[$p:lk] = 17568                          (: 'is' '(' :)
          or $state[$p:lk] = 17573                          (: 'le' '(' :)
          or $state[$p:lk] = 17575                          (: 'let' '(' :)
          or $state[$p:lk] = 17578                          (: 'lt' '(' :)
          or $state[$p:lk] = 17581                          (: 'mod' '(' :)
          or $state[$p:lk] = 17582                          (: 'modify' '(' :)
          or $state[$p:lk] = 17583                          (: 'module' '(' :)
          or $state[$p:lk] = 17585                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17587                          (: 'ne' '(' :)
          or $state[$p:lk] = 17597                          (: 'only' '(' :)
          or $state[$p:lk] = 17599                          (: 'or' '(' :)
          or $state[$p:lk] = 17600                          (: 'order' '(' :)
          or $state[$p:lk] = 17601                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17605                          (: 'parent' '(' :)
          or $state[$p:lk] = 17610                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17611                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17616                          (: 'rename' '(' :)
          or $state[$p:lk] = 17617                          (: 'replace' '(' :)
          or $state[$p:lk] = 17618                          (: 'return' '(' :)
          or $state[$p:lk] = 17621                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17626                          (: 'self' '(' :)
          or $state[$p:lk] = 17632                          (: 'some' '(' :)
          or $state[$p:lk] = 17633                          (: 'stable' '(' :)
          or $state[$p:lk] = 17634                          (: 'start' '(' :)
          or $state[$p:lk] = 17644                          (: 'to' '(' :)
          or $state[$p:lk] = 17645                          (: 'transform' '(' :)
          or $state[$p:lk] = 17646                          (: 'treat' '(' :)
          or $state[$p:lk] = 17647                          (: 'try' '(' :)
          or $state[$p:lk] = 17651                          (: 'union' '(' :)
          or $state[$p:lk] = 17652                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17653                          (: 'update' '(' :)
          or $state[$p:lk] = 17657                          (: 'validate' '(' :)
          or $state[$p:lk] = 17663                          (: 'where' '(' :)
          or $state[$p:lk] = 17666                          (: 'with' '(' :)
          or $state[$p:lk] = 17670) then                    (: 'xquery' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 135361) then                   (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135412) then                   (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 119                            (: 'document-node' :)
          or $state[$p:lk] = 123                            (: 'empty-sequence' :)
          or $state[$p:lk] = 142                            (: 'function' :)
          or $state[$p:lk] = 149                            (: 'if' :)
          or $state[$p:lk] = 161                            (: 'item' :)
          or $state[$p:lk] = 178                            (: 'namespace-node' :)
          or $state[$p:lk] = 184                            (: 'node' :)
          or $state[$p:lk] = 215                            (: 'schema-attribute' :)
          or $state[$p:lk] = 216                            (: 'schema-element' :)
          or $state[$p:lk] = 231                            (: 'switch' :)
          or $state[$p:lk] = 242                            (: 'typeswitch' :)
          or $state[$p:lk] = 14853                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14863                          (: QName^Token '#' :)
          or $state[$p:lk] = 14926                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14927                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14928                          (: 'and' '#' :)
          or $state[$p:lk] = 14931                          (: 'as' '#' :)
          or $state[$p:lk] = 14932                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14933                          (: 'at' '#' :)
          or $state[$p:lk] = 14934                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14939                          (: 'case' '#' :)
          or $state[$p:lk] = 14940                          (: 'cast' '#' :)
          or $state[$p:lk] = 14941                          (: 'castable' '#' :)
          or $state[$p:lk] = 14943                          (: 'child' '#' :)
          or $state[$p:lk] = 14944                          (: 'collation' '#' :)
          or $state[$p:lk] = 14945                          (: 'comment' '#' :)
          or $state[$p:lk] = 14950                          (: 'copy' '#' :)
          or $state[$p:lk] = 14952                          (: 'count' '#' :)
          or $state[$p:lk] = 14955                          (: 'declare' '#' :)
          or $state[$p:lk] = 14956                          (: 'default' '#' :)
          or $state[$p:lk] = 14957                          (: 'delete' '#' :)
          or $state[$p:lk] = 14958                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14959                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14960                          (: 'descending' '#' :)
          or $state[$p:lk] = 14965                          (: 'div' '#' :)
          or $state[$p:lk] = 14966                          (: 'document' '#' :)
          or $state[$p:lk] = 14968                          (: 'element' '#' :)
          or $state[$p:lk] = 14969                          (: 'else' '#' :)
          or $state[$p:lk] = 14970                          (: 'empty' '#' :)
          or $state[$p:lk] = 14973                          (: 'end' '#' :)
          or $state[$p:lk] = 14975                          (: 'eq' '#' :)
          or $state[$p:lk] = 14976                          (: 'every' '#' :)
          or $state[$p:lk] = 14978                          (: 'except' '#' :)
          or $state[$p:lk] = 14982                          (: 'following' '#' :)
          or $state[$p:lk] = 14983                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14984                          (: 'for' '#' :)
          or $state[$p:lk] = 14991                          (: 'ge' '#' :)
          or $state[$p:lk] = 14993                          (: 'group' '#' :)
          or $state[$p:lk] = 14995                          (: 'gt' '#' :)
          or $state[$p:lk] = 14996                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14998                          (: 'import' '#' :)
          or $state[$p:lk] = 15003                          (: 'insert' '#' :)
          or $state[$p:lk] = 15004                          (: 'instance' '#' :)
          or $state[$p:lk] = 15005                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15007                          (: 'invoke' '#' :)
          or $state[$p:lk] = 15008                          (: 'is' '#' :)
          or $state[$p:lk] = 15013                          (: 'le' '#' :)
          or $state[$p:lk] = 15015                          (: 'let' '#' :)
          or $state[$p:lk] = 15018                          (: 'lt' '#' :)
          or $state[$p:lk] = 15021                          (: 'mod' '#' :)
          or $state[$p:lk] = 15022                          (: 'modify' '#' :)
          or $state[$p:lk] = 15023                          (: 'module' '#' :)
          or $state[$p:lk] = 15025                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15027                          (: 'ne' '#' :)
          or $state[$p:lk] = 15037                          (: 'only' '#' :)
          or $state[$p:lk] = 15039                          (: 'or' '#' :)
          or $state[$p:lk] = 15040                          (: 'order' '#' :)
          or $state[$p:lk] = 15041                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15045                          (: 'parent' '#' :)
          or $state[$p:lk] = 15050                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15051                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15054                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15056                          (: 'rename' '#' :)
          or $state[$p:lk] = 15057                          (: 'replace' '#' :)
          or $state[$p:lk] = 15058                          (: 'return' '#' :)
          or $state[$p:lk] = 15061                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15066                          (: 'self' '#' :)
          or $state[$p:lk] = 15072                          (: 'some' '#' :)
          or $state[$p:lk] = 15073                          (: 'stable' '#' :)
          or $state[$p:lk] = 15074                          (: 'start' '#' :)
          or $state[$p:lk] = 15080                          (: 'text' '#' :)
          or $state[$p:lk] = 15084                          (: 'to' '#' :)
          or $state[$p:lk] = 15085                          (: 'transform' '#' :)
          or $state[$p:lk] = 15086                          (: 'treat' '#' :)
          or $state[$p:lk] = 15087                          (: 'try' '#' :)
          or $state[$p:lk] = 15091                          (: 'union' '#' :)
          or $state[$p:lk] = 15092                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15093                          (: 'update' '#' :)
          or $state[$p:lk] = 15097                          (: 'validate' '#' :)
          or $state[$p:lk] = 15103                          (: 'where' '#' :)
          or $state[$p:lk] = 15106                          (: 'with' '#' :)
          or $state[$p:lk] = 15110) then                    (: 'xquery' '#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MapConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 69                             (: '[' :)
          or $state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: '``[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryLookup($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 177) then                          (: 'namespace' :)
      let $state := p:lookahead2W(179, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'as' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 206) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(177, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (86,                           (: 'attribute' :)
                              120)) then                    (: 'element' :)
      let $state := p:lookahead2W(226, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              232)) then                    (: 'text' :)
      let $state := p:lookahead2W(84, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(133, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              95,                           (: 'child' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              136,                          (: 'for' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              179,                          (: 'ne' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              218,                          (: 'self' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17413                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17423                          (: QName^Token '(' :)
          or $state[$p:lk] = 17486                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17487                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17488                          (: 'and' '(' :)
          or $state[$p:lk] = 17491                          (: 'as' '(' :)
          or $state[$p:lk] = 17492                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17493                          (: 'at' '(' :)
          or $state[$p:lk] = 17499                          (: 'case' '(' :)
          or $state[$p:lk] = 17500                          (: 'cast' '(' :)
          or $state[$p:lk] = 17501                          (: 'castable' '(' :)
          or $state[$p:lk] = 17503                          (: 'child' '(' :)
          or $state[$p:lk] = 17504                          (: 'collation' '(' :)
          or $state[$p:lk] = 17510                          (: 'copy' '(' :)
          or $state[$p:lk] = 17512                          (: 'count' '(' :)
          or $state[$p:lk] = 17515                          (: 'declare' '(' :)
          or $state[$p:lk] = 17516                          (: 'default' '(' :)
          or $state[$p:lk] = 17517                          (: 'delete' '(' :)
          or $state[$p:lk] = 17518                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17519                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17520                          (: 'descending' '(' :)
          or $state[$p:lk] = 17525                          (: 'div' '(' :)
          or $state[$p:lk] = 17526                          (: 'document' '(' :)
          or $state[$p:lk] = 17529                          (: 'else' '(' :)
          or $state[$p:lk] = 17530                          (: 'empty' '(' :)
          or $state[$p:lk] = 17533                          (: 'end' '(' :)
          or $state[$p:lk] = 17535                          (: 'eq' '(' :)
          or $state[$p:lk] = 17536                          (: 'every' '(' :)
          or $state[$p:lk] = 17538                          (: 'except' '(' :)
          or $state[$p:lk] = 17542                          (: 'following' '(' :)
          or $state[$p:lk] = 17543                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17544                          (: 'for' '(' :)
          or $state[$p:lk] = 17551                          (: 'ge' '(' :)
          or $state[$p:lk] = 17553                          (: 'group' '(' :)
          or $state[$p:lk] = 17555                          (: 'gt' '(' :)
          or $state[$p:lk] = 17556                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17558                          (: 'import' '(' :)
          or $state[$p:lk] = 17563                          (: 'insert' '(' :)
          or $state[$p:lk] = 17564                          (: 'instance' '(' :)
          or $state[$p:lk] = 17565                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17567                          (: 'invoke' '(' :)
          or $state[$p:lk] = 17568                          (: 'is' '(' :)
          or $state[$p:lk] = 17573                          (: 'le' '(' :)
          or $state[$p:lk] = 17575                          (: 'let' '(' :)
          or $state[$p:lk] = 17578                          (: 'lt' '(' :)
          or $state[$p:lk] = 17581                          (: 'mod' '(' :)
          or $state[$p:lk] = 17582                          (: 'modify' '(' :)
          or $state[$p:lk] = 17583                          (: 'module' '(' :)
          or $state[$p:lk] = 17585                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17587                          (: 'ne' '(' :)
          or $state[$p:lk] = 17597                          (: 'only' '(' :)
          or $state[$p:lk] = 17599                          (: 'or' '(' :)
          or $state[$p:lk] = 17600                          (: 'order' '(' :)
          or $state[$p:lk] = 17601                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17605                          (: 'parent' '(' :)
          or $state[$p:lk] = 17610                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17611                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17616                          (: 'rename' '(' :)
          or $state[$p:lk] = 17617                          (: 'replace' '(' :)
          or $state[$p:lk] = 17618                          (: 'return' '(' :)
          or $state[$p:lk] = 17621                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17626                          (: 'self' '(' :)
          or $state[$p:lk] = 17632                          (: 'some' '(' :)
          or $state[$p:lk] = 17633                          (: 'stable' '(' :)
          or $state[$p:lk] = 17634                          (: 'start' '(' :)
          or $state[$p:lk] = 17644                          (: 'to' '(' :)
          or $state[$p:lk] = 17645                          (: 'transform' '(' :)
          or $state[$p:lk] = 17646                          (: 'treat' '(' :)
          or $state[$p:lk] = 17647                          (: 'try' '(' :)
          or $state[$p:lk] = 17651                          (: 'union' '(' :)
          or $state[$p:lk] = 17652                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17653                          (: 'update' '(' :)
          or $state[$p:lk] = 17657                          (: 'validate' '(' :)
          or $state[$p:lk] = 17663                          (: 'where' '(' :)
          or $state[$p:lk] = 17666                          (: 'with' '(' :)
          or $state[$p:lk] = 17670) then                    (: 'xquery' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 135361) then                   (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135412) then                   (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 119                            (: 'document-node' :)
          or $state[$p:lk] = 123                            (: 'empty-sequence' :)
          or $state[$p:lk] = 142                            (: 'function' :)
          or $state[$p:lk] = 149                            (: 'if' :)
          or $state[$p:lk] = 161                            (: 'item' :)
          or $state[$p:lk] = 178                            (: 'namespace-node' :)
          or $state[$p:lk] = 184                            (: 'node' :)
          or $state[$p:lk] = 215                            (: 'schema-attribute' :)
          or $state[$p:lk] = 216                            (: 'schema-element' :)
          or $state[$p:lk] = 231                            (: 'switch' :)
          or $state[$p:lk] = 242                            (: 'typeswitch' :)
          or $state[$p:lk] = 14853                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14863                          (: QName^Token '#' :)
          or $state[$p:lk] = 14926                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14927                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14928                          (: 'and' '#' :)
          or $state[$p:lk] = 14931                          (: 'as' '#' :)
          or $state[$p:lk] = 14932                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14933                          (: 'at' '#' :)
          or $state[$p:lk] = 14934                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14939                          (: 'case' '#' :)
          or $state[$p:lk] = 14940                          (: 'cast' '#' :)
          or $state[$p:lk] = 14941                          (: 'castable' '#' :)
          or $state[$p:lk] = 14943                          (: 'child' '#' :)
          or $state[$p:lk] = 14944                          (: 'collation' '#' :)
          or $state[$p:lk] = 14945                          (: 'comment' '#' :)
          or $state[$p:lk] = 14950                          (: 'copy' '#' :)
          or $state[$p:lk] = 14952                          (: 'count' '#' :)
          or $state[$p:lk] = 14955                          (: 'declare' '#' :)
          or $state[$p:lk] = 14956                          (: 'default' '#' :)
          or $state[$p:lk] = 14957                          (: 'delete' '#' :)
          or $state[$p:lk] = 14958                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14959                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14960                          (: 'descending' '#' :)
          or $state[$p:lk] = 14965                          (: 'div' '#' :)
          or $state[$p:lk] = 14966                          (: 'document' '#' :)
          or $state[$p:lk] = 14968                          (: 'element' '#' :)
          or $state[$p:lk] = 14969                          (: 'else' '#' :)
          or $state[$p:lk] = 14970                          (: 'empty' '#' :)
          or $state[$p:lk] = 14973                          (: 'end' '#' :)
          or $state[$p:lk] = 14975                          (: 'eq' '#' :)
          or $state[$p:lk] = 14976                          (: 'every' '#' :)
          or $state[$p:lk] = 14978                          (: 'except' '#' :)
          or $state[$p:lk] = 14982                          (: 'following' '#' :)
          or $state[$p:lk] = 14983                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14984                          (: 'for' '#' :)
          or $state[$p:lk] = 14991                          (: 'ge' '#' :)
          or $state[$p:lk] = 14993                          (: 'group' '#' :)
          or $state[$p:lk] = 14995                          (: 'gt' '#' :)
          or $state[$p:lk] = 14996                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14998                          (: 'import' '#' :)
          or $state[$p:lk] = 15003                          (: 'insert' '#' :)
          or $state[$p:lk] = 15004                          (: 'instance' '#' :)
          or $state[$p:lk] = 15005                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15007                          (: 'invoke' '#' :)
          or $state[$p:lk] = 15008                          (: 'is' '#' :)
          or $state[$p:lk] = 15013                          (: 'le' '#' :)
          or $state[$p:lk] = 15015                          (: 'let' '#' :)
          or $state[$p:lk] = 15018                          (: 'lt' '#' :)
          or $state[$p:lk] = 15021                          (: 'mod' '#' :)
          or $state[$p:lk] = 15022                          (: 'modify' '#' :)
          or $state[$p:lk] = 15023                          (: 'module' '#' :)
          or $state[$p:lk] = 15025                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15027                          (: 'ne' '#' :)
          or $state[$p:lk] = 15037                          (: 'only' '#' :)
          or $state[$p:lk] = 15039                          (: 'or' '#' :)
          or $state[$p:lk] = 15040                          (: 'order' '#' :)
          or $state[$p:lk] = 15041                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15045                          (: 'parent' '#' :)
          or $state[$p:lk] = 15050                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15051                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15054                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15056                          (: 'rename' '#' :)
          or $state[$p:lk] = 15057                          (: 'replace' '#' :)
          or $state[$p:lk] = 15058                          (: 'return' '#' :)
          or $state[$p:lk] = 15061                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15066                          (: 'self' '#' :)
          or $state[$p:lk] = 15072                          (: 'some' '#' :)
          or $state[$p:lk] = 15073                          (: 'stable' '#' :)
          or $state[$p:lk] = 15074                          (: 'start' '#' :)
          or $state[$p:lk] = 15080                          (: 'text' '#' :)
          or $state[$p:lk] = 15084                          (: 'to' '#' :)
          or $state[$p:lk] = 15085                          (: 'transform' '#' :)
          or $state[$p:lk] = 15086                          (: 'treat' '#' :)
          or $state[$p:lk] = 15087                          (: 'try' '#' :)
          or $state[$p:lk] = 15091                          (: 'union' '#' :)
          or $state[$p:lk] = 15092                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15093                          (: 'update' '#' :)
          or $state[$p:lk] = 15097                          (: 'validate' '#' :)
          or $state[$p:lk] = 15103                          (: 'where' '#' :)
          or $state[$p:lk] = 15106                          (: 'with' '#' :)
          or $state[$p:lk] = 15110) then                    (: 'xquery' '#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MapConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 69                             (: '[' :)
          or $state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: '``[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StringConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryLookup($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UpdatingFunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UpdatingFunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-UpdatingFunctionCall-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UpdatingFunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UpdatingFunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ExprSingle($input, $state)
        return p:try-UpdatingFunctionCall-1($input, $state)
};

(:~
 : Parse UpdatingFunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UpdatingFunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(159, $input, $state)              (: 'invoke' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'updating' :)
  let $state := p:consume(246, $input, $state)              (: 'updating' :)
  let $state := p:lookahead1W(232, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               '$' | '%' | '(' | ('(' ':') | '.' | '<' | '<!--' | '<?' |
                                                               '?' | '[' | '``[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-UpdatingFunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing UpdatingFunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UpdatingFunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(159, $input, $state)              (: 'invoke' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'updating' :)
  let $state := p:consume(246, $input, $state)              (: 'updating' :)
  let $state := p:lookahead1W(232, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               '$' | '%' | '(' | ('(' ':') | '.' | '<' | '<!--' | '<?' |
                                                               '?' | '[' | '``[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      let $state := p:try-UpdatingFunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(209, $input, $state)              (: 'replace' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 250) then                      (: 'value' :)
      let $state := p:consume(250, $input, $state)          (: 'value' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'with' :)
  let $state := p:consume(258, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(209, $input, $state)              (: 'replace' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 250) then                      (: 'value' :)
      let $state := p:consume(250, $input, $state)          (: 'value' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'with' :)
  let $state := p:consume(258, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing NewNameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(208, $input, $state)              (: 'rename' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NewNameExpr($input, $state)
  return $state
};

(:~
 : Try parsing RenameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(208, $input, $state)              (: 'rename' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NewNameExpr($input, $state)
  return $state
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(109, $input, $state)              (: 'delete' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Try parsing DeleteExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(109, $input, $state)              (: 'delete' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing TargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'after' :)
      let $state := p:consume(75, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'before' :)
      let $state := p:consume(88, $input, $state)           (: 'before' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(114, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 133) then              (: 'first' :)
              let $state := p:consume(133, $input, $state)  (: 'first' :)
              return $state
            else
              let $state := p:consume(163, $input, $state)  (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:consume(158, $input, $state)          (: 'into' :)
      return $state
  return $state
};

(:~
 : Try parsing InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'after' :)
      let $state := p:consume(75, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'before' :)
      let $state := p:consume(88, $input, $state)           (: 'before' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(114, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 133) then              (: 'first' :)
              let $state := p:consume(133, $input, $state)  (: 'first' :)
              return $state
            else
              let $state := p:consume(163, $input, $state)  (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:consume(158, $input, $state)          (: 'into' :)
      return $state
  return $state
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SourceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(155, $input, $state)              (: 'insert' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SourceExpr($input, $state)
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'after' | 'as' | 'before' | 'into' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Try parsing InsertExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(155, $input, $state)              (: 'insert' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SourceExpr($input, $state)
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'after' | 'as' | 'before' | 'into' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: Wildcard :)
      let $state := p:consume(21, $input, $state)           (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: Wildcard :)
      let $state := p:consume(21, $input, $state)           (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(224, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(224, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-NameTest($input, $state)
        return p:try-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Try parsing CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NameTest($input, $state)
  let $state := p:try-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(94, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(94, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CatchErrorList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse EnclosedTryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedTryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing EnclosedTryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnclosedTryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(239, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedTryTargetExpr($input, $state)
  return $state
};

(:~
 : Try parsing TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(239, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedTryTargetExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(188, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 94) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-CatchClause($input, $state)
    let $state := p:lookahead1W(188, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 94) then                         (: 'catch' :)
        $state
      else
        p:try-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TryClause($input, $state)
  let $state := p:try-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse BasexIfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexIfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing BasexIfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexIfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:consume(121, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:consume(121, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-SequenceType($input, $state)
        return p:try-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Try parsing SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  let $state := p:try-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(91, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(230, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceTypeUnion($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(91, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(230, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarName($input, $state)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceTypeUnion($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-CaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:try-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(242, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(242, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:try-TypeswitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(91, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(91, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:try-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-SwitchCaseClause-1($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(160, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ']' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(160, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ']' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ExprSingle($input, $state)
        return p:try-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return $state
};

(:~
 : Try parsing Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:try-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:try-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(231, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SwitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(231, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:try-SwitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse QuantifiedVarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedVarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing QuantifiedVarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuantifiedVarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(96, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-QuantifiedVarDecl($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(96, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-QuantifiedVarDecl($input, $state)
        return p:try-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QuantifiedVarDecl($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(213, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-QuantifiedVarDecl($input, $state)
  let $state := p:try-QuantifiedExpr-1($input, $state)
  let $state := p:consume(213, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(104, $input, $state)              (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(104, $input, $state)              (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84                             (: 'ascending' :)
          or $state[$p:l1] = 112) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 84) then                   (: 'ascending' :)
          let $state := p:consume(84, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(112, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(169, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(115, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 144) then                  (: 'greatest' :)
          let $state := p:consume(144, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(166, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84                             (: 'ascending' :)
          or $state[$p:l1] = 112) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 84) then                   (: 'ascending' :)
          let $state := p:consume(84, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(112, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(169, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(115, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 144) then                  (: 'greatest' :)
          let $state := p:consume(144, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(166, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(173, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  return $state
};

(:~
 : Try parsing OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(173, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-OrderSpec($input, $state)
        return p:try-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Try parsing OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-OrderSpec($input, $state)
  let $state := p:try-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(61, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  return $state
};

(:~
 : Try parsing OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(61, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingVariable.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing GroupingVariable.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 31) then                           (: '$' :)
      let $state := p:lookahead2W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2591                           (: '$' URIQualifiedName :)
          or $state[$p:lk] = 7711                           (: '$' QName^Token :)
          or $state[$p:lk] = 39967                          (: '$' 'ancestor' :)
          or $state[$p:lk] = 40479                          (: '$' 'ancestor-or-self' :)
          or $state[$p:lk] = 40991                          (: '$' 'and' :)
          or $state[$p:lk] = 42527                          (: '$' 'as' :)
          or $state[$p:lk] = 43039                          (: '$' 'ascending' :)
          or $state[$p:lk] = 43551                          (: '$' 'at' :)
          or $state[$p:lk] = 44063                          (: '$' 'attribute' :)
          or $state[$p:lk] = 46623                          (: '$' 'case' :)
          or $state[$p:lk] = 47135                          (: '$' 'cast' :)
          or $state[$p:lk] = 47647                          (: '$' 'castable' :)
          or $state[$p:lk] = 48671                          (: '$' 'child' :)
          or $state[$p:lk] = 49183                          (: '$' 'collation' :)
          or $state[$p:lk] = 49695                          (: '$' 'comment' :)
          or $state[$p:lk] = 52255                          (: '$' 'copy' :)
          or $state[$p:lk] = 53279                          (: '$' 'count' :)
          or $state[$p:lk] = 54815                          (: '$' 'declare' :)
          or $state[$p:lk] = 55327                          (: '$' 'default' :)
          or $state[$p:lk] = 55839                          (: '$' 'delete' :)
          or $state[$p:lk] = 56351                          (: '$' 'descendant' :)
          or $state[$p:lk] = 56863                          (: '$' 'descendant-or-self' :)
          or $state[$p:lk] = 57375                          (: '$' 'descending' :)
          or $state[$p:lk] = 59935                          (: '$' 'div' :)
          or $state[$p:lk] = 60447                          (: '$' 'document' :)
          or $state[$p:lk] = 60959                          (: '$' 'document-node' :)
          or $state[$p:lk] = 61471                          (: '$' 'element' :)
          or $state[$p:lk] = 61983                          (: '$' 'else' :)
          or $state[$p:lk] = 62495                          (: '$' 'empty' :)
          or $state[$p:lk] = 63007                          (: '$' 'empty-sequence' :)
          or $state[$p:lk] = 64031                          (: '$' 'end' :)
          or $state[$p:lk] = 65055                          (: '$' 'eq' :)
          or $state[$p:lk] = 65567                          (: '$' 'every' :)
          or $state[$p:lk] = 66591                          (: '$' 'except' :)
          or $state[$p:lk] = 68639                          (: '$' 'following' :)
          or $state[$p:lk] = 69151                          (: '$' 'following-sibling' :)
          or $state[$p:lk] = 69663                          (: '$' 'for' :)
          or $state[$p:lk] = 72735                          (: '$' 'function' :)
          or $state[$p:lk] = 73247                          (: '$' 'ge' :)
          or $state[$p:lk] = 74271                          (: '$' 'group' :)
          or $state[$p:lk] = 75295                          (: '$' 'gt' :)
          or $state[$p:lk] = 75807                          (: '$' 'idiv' :)
          or $state[$p:lk] = 76319                          (: '$' 'if' :)
          or $state[$p:lk] = 76831                          (: '$' 'import' :)
          or $state[$p:lk] = 79391                          (: '$' 'insert' :)
          or $state[$p:lk] = 79903                          (: '$' 'instance' :)
          or $state[$p:lk] = 80415                          (: '$' 'intersect' :)
          or $state[$p:lk] = 81439                          (: '$' 'invoke' :)
          or $state[$p:lk] = 81951                          (: '$' 'is' :)
          or $state[$p:lk] = 82463                          (: '$' 'item' :)
          or $state[$p:lk] = 84511                          (: '$' 'le' :)
          or $state[$p:lk] = 85535                          (: '$' 'let' :)
          or $state[$p:lk] = 87071                          (: '$' 'lt' :)
          or $state[$p:lk] = 88607                          (: '$' 'mod' :)
          or $state[$p:lk] = 89119                          (: '$' 'modify' :)
          or $state[$p:lk] = 89631                          (: '$' 'module' :)
          or $state[$p:lk] = 90655                          (: '$' 'namespace' :)
          or $state[$p:lk] = 91167                          (: '$' 'namespace-node' :)
          or $state[$p:lk] = 91679                          (: '$' 'ne' :)
          or $state[$p:lk] = 94239                          (: '$' 'node' :)
          or $state[$p:lk] = 96799                          (: '$' 'only' :)
          or $state[$p:lk] = 97823                          (: '$' 'or' :)
          or $state[$p:lk] = 98335                          (: '$' 'order' :)
          or $state[$p:lk] = 98847                          (: '$' 'ordered' :)
          or $state[$p:lk] = 100895                         (: '$' 'parent' :)
          or $state[$p:lk] = 103455                         (: '$' 'preceding' :)
          or $state[$p:lk] = 103967                         (: '$' 'preceding-sibling' :)
          or $state[$p:lk] = 105503                         (: '$' 'processing-instruction' :)
          or $state[$p:lk] = 106527                         (: '$' 'rename' :)
          or $state[$p:lk] = 107039                         (: '$' 'replace' :)
          or $state[$p:lk] = 107551                         (: '$' 'return' :)
          or $state[$p:lk] = 109087                         (: '$' 'satisfies' :)
          or $state[$p:lk] = 110111                         (: '$' 'schema-attribute' :)
          or $state[$p:lk] = 110623                         (: '$' 'schema-element' :)
          or $state[$p:lk] = 111647                         (: '$' 'self' :)
          or $state[$p:lk] = 114719                         (: '$' 'some' :)
          or $state[$p:lk] = 115231                         (: '$' 'stable' :)
          or $state[$p:lk] = 115743                         (: '$' 'start' :)
          or $state[$p:lk] = 118303                         (: '$' 'switch' :)
          or $state[$p:lk] = 118815                         (: '$' 'text' :)
          or $state[$p:lk] = 120863                         (: '$' 'to' :)
          or $state[$p:lk] = 121375                         (: '$' 'transform' :)
          or $state[$p:lk] = 121887                         (: '$' 'treat' :)
          or $state[$p:lk] = 122399                         (: '$' 'try' :)
          or $state[$p:lk] = 123935                         (: '$' 'typeswitch' :)
          or $state[$p:lk] = 124447                         (: '$' 'union' :)
          or $state[$p:lk] = 124959                         (: '$' 'unordered' :)
          or $state[$p:lk] = 125471                         (: '$' 'update' :)
          or $state[$p:lk] = 127519                         (: '$' 'validate' :)
          or $state[$p:lk] = 130591                         (: '$' 'where' :)
          or $state[$p:lk] = 132127                         (: '$' 'with' :)
          or $state[$p:lk] = 134175) then                   (: '$' 'xquery' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-GroupingVariable($input, $state)
          let $state := p:lookahead1W(171, $input, $state)  (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 51                     (: ':=' :)
                  or $state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 83) then           (: 'as' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-TypeDeclaration($input, $state)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(30, $input, $state) (: S^WS | ('(' ':') | ':=' :)
              let $state := p:consume(51, $input, $state)   (: ':=' :)
              let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                  StringLiteral | URIQualifiedName | QName^Token |
                                                                  S^WS | Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                                  '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                                  '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                  'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                  'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                  'castable' | 'child' | 'collation' | 'comment' |
                                                                  'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                  'descendant' | 'descendant-or-self' | 'descending' |
                                                                  'div' | 'document' | 'document-node' | 'element' |
                                                                  'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                  'every' | 'except' | 'following' |
                                                                  'following-sibling' | 'for' | 'function' | 'ge' |
                                                                  'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                  'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                  'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                  'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                  'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                  'parent' | 'preceding' | 'preceding-sibling' |
                                                                  'processing-instruction' | 'rename' | 'replace' |
                                                                  'return' | 'satisfies' | 'schema-attribute' |
                                                                  'schema-element' | 'self' | 'some' | 'stable' |
                                                                  'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                  'treat' | 'try' | 'typeswitch' | 'union' |
                                                                  'unordered' | 'update' | 'validate' | 'where' |
                                                                  'with' | 'xquery' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ExprSingle($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(166, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 96) then               (: 'collation' :)
              let $state := p:consume(96, $input, $state)   (: 'collation' :)
              let $state := p:lookahead1W(19, $input, $state) (: StringLiteral | S^WS | ('(' ':') :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-URILiteral($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupingVariable($input, $state)
      let $state := p:lookahead1W(171, $input, $state)      (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51                         (: ':=' :)
              or $state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-TypeDeclaration($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(30, $input, $state)   (: S^WS | ('(' ':') | ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(166, $input, $state)      (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 96) then                   (: 'collation' :)
          let $state := p:consume(96, $input, $state)       (: 'collation' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-URILiteral($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 31) then                           (: '$' :)
      let $state := p:lookahead2W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2591                           (: '$' URIQualifiedName :)
          or $state[$p:lk] = 7711                           (: '$' QName^Token :)
          or $state[$p:lk] = 39967                          (: '$' 'ancestor' :)
          or $state[$p:lk] = 40479                          (: '$' 'ancestor-or-self' :)
          or $state[$p:lk] = 40991                          (: '$' 'and' :)
          or $state[$p:lk] = 42527                          (: '$' 'as' :)
          or $state[$p:lk] = 43039                          (: '$' 'ascending' :)
          or $state[$p:lk] = 43551                          (: '$' 'at' :)
          or $state[$p:lk] = 44063                          (: '$' 'attribute' :)
          or $state[$p:lk] = 46623                          (: '$' 'case' :)
          or $state[$p:lk] = 47135                          (: '$' 'cast' :)
          or $state[$p:lk] = 47647                          (: '$' 'castable' :)
          or $state[$p:lk] = 48671                          (: '$' 'child' :)
          or $state[$p:lk] = 49183                          (: '$' 'collation' :)
          or $state[$p:lk] = 49695                          (: '$' 'comment' :)
          or $state[$p:lk] = 52255                          (: '$' 'copy' :)
          or $state[$p:lk] = 53279                          (: '$' 'count' :)
          or $state[$p:lk] = 54815                          (: '$' 'declare' :)
          or $state[$p:lk] = 55327                          (: '$' 'default' :)
          or $state[$p:lk] = 55839                          (: '$' 'delete' :)
          or $state[$p:lk] = 56351                          (: '$' 'descendant' :)
          or $state[$p:lk] = 56863                          (: '$' 'descendant-or-self' :)
          or $state[$p:lk] = 57375                          (: '$' 'descending' :)
          or $state[$p:lk] = 59935                          (: '$' 'div' :)
          or $state[$p:lk] = 60447                          (: '$' 'document' :)
          or $state[$p:lk] = 60959                          (: '$' 'document-node' :)
          or $state[$p:lk] = 61471                          (: '$' 'element' :)
          or $state[$p:lk] = 61983                          (: '$' 'else' :)
          or $state[$p:lk] = 62495                          (: '$' 'empty' :)
          or $state[$p:lk] = 63007                          (: '$' 'empty-sequence' :)
          or $state[$p:lk] = 64031                          (: '$' 'end' :)
          or $state[$p:lk] = 65055                          (: '$' 'eq' :)
          or $state[$p:lk] = 65567                          (: '$' 'every' :)
          or $state[$p:lk] = 66591                          (: '$' 'except' :)
          or $state[$p:lk] = 68639                          (: '$' 'following' :)
          or $state[$p:lk] = 69151                          (: '$' 'following-sibling' :)
          or $state[$p:lk] = 69663                          (: '$' 'for' :)
          or $state[$p:lk] = 72735                          (: '$' 'function' :)
          or $state[$p:lk] = 73247                          (: '$' 'ge' :)
          or $state[$p:lk] = 74271                          (: '$' 'group' :)
          or $state[$p:lk] = 75295                          (: '$' 'gt' :)
          or $state[$p:lk] = 75807                          (: '$' 'idiv' :)
          or $state[$p:lk] = 76319                          (: '$' 'if' :)
          or $state[$p:lk] = 76831                          (: '$' 'import' :)
          or $state[$p:lk] = 79391                          (: '$' 'insert' :)
          or $state[$p:lk] = 79903                          (: '$' 'instance' :)
          or $state[$p:lk] = 80415                          (: '$' 'intersect' :)
          or $state[$p:lk] = 81439                          (: '$' 'invoke' :)
          or $state[$p:lk] = 81951                          (: '$' 'is' :)
          or $state[$p:lk] = 82463                          (: '$' 'item' :)
          or $state[$p:lk] = 84511                          (: '$' 'le' :)
          or $state[$p:lk] = 85535                          (: '$' 'let' :)
          or $state[$p:lk] = 87071                          (: '$' 'lt' :)
          or $state[$p:lk] = 88607                          (: '$' 'mod' :)
          or $state[$p:lk] = 89119                          (: '$' 'modify' :)
          or $state[$p:lk] = 89631                          (: '$' 'module' :)
          or $state[$p:lk] = 90655                          (: '$' 'namespace' :)
          or $state[$p:lk] = 91167                          (: '$' 'namespace-node' :)
          or $state[$p:lk] = 91679                          (: '$' 'ne' :)
          or $state[$p:lk] = 94239                          (: '$' 'node' :)
          or $state[$p:lk] = 96799                          (: '$' 'only' :)
          or $state[$p:lk] = 97823                          (: '$' 'or' :)
          or $state[$p:lk] = 98335                          (: '$' 'order' :)
          or $state[$p:lk] = 98847                          (: '$' 'ordered' :)
          or $state[$p:lk] = 100895                         (: '$' 'parent' :)
          or $state[$p:lk] = 103455                         (: '$' 'preceding' :)
          or $state[$p:lk] = 103967                         (: '$' 'preceding-sibling' :)
          or $state[$p:lk] = 105503                         (: '$' 'processing-instruction' :)
          or $state[$p:lk] = 106527                         (: '$' 'rename' :)
          or $state[$p:lk] = 107039                         (: '$' 'replace' :)
          or $state[$p:lk] = 107551                         (: '$' 'return' :)
          or $state[$p:lk] = 109087                         (: '$' 'satisfies' :)
          or $state[$p:lk] = 110111                         (: '$' 'schema-attribute' :)
          or $state[$p:lk] = 110623                         (: '$' 'schema-element' :)
          or $state[$p:lk] = 111647                         (: '$' 'self' :)
          or $state[$p:lk] = 114719                         (: '$' 'some' :)
          or $state[$p:lk] = 115231                         (: '$' 'stable' :)
          or $state[$p:lk] = 115743                         (: '$' 'start' :)
          or $state[$p:lk] = 118303                         (: '$' 'switch' :)
          or $state[$p:lk] = 118815                         (: '$' 'text' :)
          or $state[$p:lk] = 120863                         (: '$' 'to' :)
          or $state[$p:lk] = 121375                         (: '$' 'transform' :)
          or $state[$p:lk] = 121887                         (: '$' 'treat' :)
          or $state[$p:lk] = 122399                         (: '$' 'try' :)
          or $state[$p:lk] = 123935                         (: '$' 'typeswitch' :)
          or $state[$p:lk] = 124447                         (: '$' 'union' :)
          or $state[$p:lk] = 124959                         (: '$' 'unordered' :)
          or $state[$p:lk] = 125471                         (: '$' 'update' :)
          or $state[$p:lk] = 127519                         (: '$' 'validate' :)
          or $state[$p:lk] = 130591                         (: '$' 'where' :)
          or $state[$p:lk] = 132127                         (: '$' 'with' :)
          or $state[$p:lk] = 134175) then                   (: '$' 'xquery' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-GroupingVariable($input, $state)
          let $state := p:lookahead1W(171, $input, $state)  (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 51                     (: ':=' :)
                  or $state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 83) then           (: 'as' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-TypeDeclaration($input, $state)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(30, $input, $state) (: S^WS | ('(' ':') | ':=' :)
              let $state := p:consume(51, $input, $state)   (: ':=' :)
              let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                  StringLiteral | URIQualifiedName | QName^Token |
                                                                  S^WS | Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                                  '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                                  '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                  'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                  'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                  'castable' | 'child' | 'collation' | 'comment' |
                                                                  'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                  'descendant' | 'descendant-or-self' | 'descending' |
                                                                  'div' | 'document' | 'document-node' | 'element' |
                                                                  'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                  'every' | 'except' | 'following' |
                                                                  'following-sibling' | 'for' | 'function' | 'ge' |
                                                                  'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                  'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                  'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                  'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                  'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                  'parent' | 'preceding' | 'preceding-sibling' |
                                                                  'processing-instruction' | 'rename' | 'replace' |
                                                                  'return' | 'satisfies' | 'schema-attribute' |
                                                                  'schema-element' | 'self' | 'some' | 'stable' |
                                                                  'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                  'treat' | 'try' | 'typeswitch' | 'union' |
                                                                  'unordered' | 'update' | 'validate' | 'where' |
                                                                  'with' | 'xquery' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ExprSingle($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(166, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 96) then               (: 'collation' :)
              let $state := p:consume(96, $input, $state)   (: 'collation' :)
              let $state := p:lookahead1W(19, $input, $state) (: StringLiteral | S^WS | ('(' ':') :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-URILiteral($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-GroupingVariable($input, $state)
      let $state := p:lookahead1W(171, $input, $state)      (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51                         (: ':=' :)
              or $state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-TypeDeclaration($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(30, $input, $state)   (: S^WS | ('(' ':') | ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ExprSingle($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(166, $input, $state)      (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 96) then                   (: 'collation' :)
          let $state := p:consume(96, $input, $state)       (: 'collation' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-URILiteral($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-GroupingSpec($input, $state)
        return p:try-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Try parsing GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-GroupingSpec($input, $state)
  let $state := p:try-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(145, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(90, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Try parsing GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(145, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(90, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(255, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(255, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 136                            (: 'for' :)
          or $state[$p:l1] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 136                            (: 'for' :)
          or $state[$p:l1] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(223, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Try parsing SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(223, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(125, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(125, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 205) then                      (: 'previous' :)
      let $state := p:consume(205, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 180) then                      (: 'next' :)
      let $state := p:consume(180, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 205) then                      (: 'previous' :)
      let $state := p:consume(205, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 180) then                      (: 'next' :)
      let $state := p:consume(180, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(226, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(226, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(240, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 125                            (: 'end' :)
          or $state[$p:l1] = 189) then                      (: 'only' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(240, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 125                            (: 'end' :)
          or $state[$p:l1] = 189) then                      (: 'only' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 240) then                      (: 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TumblingWindowClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 240) then                      (: 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TumblingWindowClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ':=' | 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScoreVar($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing LetBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarName($input, $state)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ':=' | 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeDeclaration($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTScoreVar($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(87, $input, $state)     (: S^WS | '$' | ('(' ':') | 'score' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LetBinding($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(87, $input, $state)     (: S^WS | '$' | ('(' ':') | 'score' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-LetBinding($input, $state)
        return p:try-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(167, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return $state
};

(:~
 : Try parsing LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(167, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-LetBinding($input, $state)
  let $state := p:try-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse FTScoreVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTScoreVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(217, $input, $state)              (: 'score' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing FTScoreVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTScoreVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(217, $input, $state)              (: 'score' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  return $state
};

(:~
 : Try parsing AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Try parsing TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(156, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' |
                                                               'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'allowing' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 217) then                      (: 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScoreVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing ForBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(156, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' |
                                                               'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'allowing' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 217) then                      (: 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTScoreVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ForBinding($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ForBinding($input, $state)
        return p:try-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return $state
};

(:~
 : Try parsing ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ForBinding($input, $state)
  let $state := p:try-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008) then                    (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008) then                    (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(163, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 210) then                         (: 'return' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(163, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 210) then                         (: 'return' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-IntermediateClause($input, $state)
        return p:try-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ReturnClause($input, $state)
  return $state
};

(:~
 : Try parsing FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InitialClause($input, $state)
  let $state := p:try-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(210, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'sliding' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'tumbling' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 159) then                     (: 'invoke' :)
      let $state := p:lookahead2W(203, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'updating' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 167) then                     (: 'let' :)
      let $state := p:lookahead2W(207, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 208) then                     (: 'rename' :)
      let $state := p:lookahead2W(202, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 209) then                     (: 'replace' :)
      let $state := p:lookahead2W(209, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'value' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 239) then                     (: 'try' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (109,                          (: 'delete' :)
                              155)) then                    (: 'insert' :)
      let $state := p:lookahead2W(208, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'nodes' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (102,                          (: 'copy' :)
                              128,                          (: 'every' :)
                              224)) then                    (: 'some' :)
      let $state := p:lookahead2W(200, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (149,                          (: 'if' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17557) then                    (: 'if' '(' :)
      let $state := p:memoized($state, 26)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-IfExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -5, -5)
            else
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -6, -6)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008                          (: 'for' '$' :)
          or $state[$p:lk] = 16039                          (: 'let' '$' :)
          or $state[$p:lk] = 111271                         (: 'let' 'score' :)
          or $state[$p:lk] = 114312                         (: 'for' 'sliding' :)
          or $state[$p:lk] = 123016) then                   (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 16000                          (: 'every' '$' :)
          or $state[$p:lk] = 16096) then                    (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17639) then                    (: 'switch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17650) then                    (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BasexIfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135407) then                   (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94363                          (: 'insert' 'node' :)
          or $state[$p:lk] = 94875) then                    (: 'insert' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94317                          (: 'delete' 'node' :)
          or $state[$p:lk] = 94829) then                    (: 'delete' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94416) then                    (: 'rename' 'node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94417                          (: 'replace' 'node' :)
          or $state[$p:lk] = 128209) then                   (: 'replace' 'value' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 126111) then                   (: 'invoke' 'updating' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UpdatingFunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 15974) then                    (: 'copy' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyModifyExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(210, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'sliding' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'tumbling' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 159) then                     (: 'invoke' :)
      let $state := p:lookahead2W(203, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'updating' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 167) then                     (: 'let' :)
      let $state := p:lookahead2W(207, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 208) then                     (: 'rename' :)
      let $state := p:lookahead2W(202, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 209) then                     (: 'replace' :)
      let $state := p:lookahead2W(209, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'value' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 239) then                     (: 'try' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (109,                          (: 'delete' :)
                              155)) then                    (: 'insert' :)
      let $state := p:lookahead2W(208, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'nodes' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (102,                          (: 'copy' :)
                              128,                          (: 'every' :)
                              224)) then                    (: 'some' :)
      let $state := p:lookahead2W(200, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (149,                          (: 'if' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17557) then                    (: 'if' '(' :)
      let $state := p:memoized($state, 26)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-IfExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -5, -5)
            else
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -6, -6)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008                          (: 'for' '$' :)
          or $state[$p:lk] = 16039                          (: 'let' '$' :)
          or $state[$p:lk] = 111271                         (: 'let' 'score' :)
          or $state[$p:lk] = 114312                         (: 'for' 'sliding' :)
          or $state[$p:lk] = 123016) then                   (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 16000                          (: 'every' '$' :)
          or $state[$p:lk] = 16096) then                    (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17639) then                    (: 'switch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17650) then                    (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-BasexIfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135407) then                   (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94363                          (: 'insert' 'node' :)
          or $state[$p:lk] = 94875) then                    (: 'insert' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94317                          (: 'delete' 'node' :)
          or $state[$p:lk] = 94829) then                    (: 'delete' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94416) then                    (: 'rename' 'node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94417                          (: 'replace' 'node' :)
          or $state[$p:lk] = 128209) then                   (: 'replace' 'value' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 126111) then                   (: 'invoke' 'updating' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UpdatingFunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 15974) then                    (: 'copy' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CopyModifyExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TypedArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing TypedArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AnyArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 82) then                           (: 'array' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 22)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyArrayTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyArrayTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedArrayTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 82) then                           (: 'array' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 22)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyArrayTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyArrayTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypedArrayTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse TypedMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing TypedMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AnyMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse MapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 171) then                          (: 'map' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 21)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyMapTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyMapTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedMapTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing MapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 171) then                          (: 'map' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 21)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyMapTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyMapTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypedMapTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(39, $input, $state)           (: '+' :)
      return $state
  return $state
};

(:~
 : Try parsing OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(39, $input, $state)           (: '+' :)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 123) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17531) then                    (: 'empty-sequence' '(' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(198, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 65) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Try parsing SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 123) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17531) then                    (: 'empty-sequence' '(' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ItemType($input, $state)
      let $state := p:lookahead1W(198, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 65) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-SequenceType($input, $state)
        return p:try-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(231, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Try parsing TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(231, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      let $state := p:try-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Try parsing NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(144, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(144, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Literal($input, $state)
        return p:try-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(32, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(155, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(144, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      let $state := p:parse-Annotation-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(32, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(155, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(144, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Literal($input, $state)
      let $state := p:try-Annotation-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Annotation($input, $state)
        return p:try-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 20)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyFunctionTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyFunctionTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 20)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyFunctionTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyFunctionTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(178, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(178, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  return $state
};

(:~
 : Try parsing AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(215, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(215, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  return $state
};

(:~
 : Try parsing ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(216, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(216, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(92, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 65) then               (: '?' :)
              let $state := p:consume(65, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeName($input, $state)
          let $state := p:lookahead1W(92, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 65) then               (: '?' :)
              let $state := p:consume(65, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(119, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'element' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(119, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'element' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ElementTest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamespaceNodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NamespaceNodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         142,                               (: 'function' :)
                         161,                               (: 'item' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17569) then                    (: 'item' '(' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MapTest($input, $state)
      return $state
    else if ($state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedItemType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         142,                               (: 'function' :)
                         161,                               (: 'item' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17569) then                    (: 'item' '(' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MapTest($input, $state)
      return $state
    else if ($state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedItemType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(101, $input, $state)              (: 'context' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(161, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(132, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(98, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Try parsing FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTStopWords($input, $state)
  return $state
};

(:~
 : Try parsing FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTStopWords($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWords-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-FTStopWords-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWords-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:try-FTStopWords-1($input, $state)
};

(:~
 : Parse FTStopWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:parse-FTStopWords-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
  return $state
};

(:~
 : Try parsing FTStopWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-URILiteral($input, $state)
      return $state
    else
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:try-FTStopWords-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 24)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 24)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 24, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-FTStopWordOption-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-1($input, $state)
};

(:~
 : Parse the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 25)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 25, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 25, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordOption-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 25)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 25, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 25, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-FTStopWordOption-2($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-2($input, $state)
};

(:~
 : Parse FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 228) then                      (: 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          let $state := p:parse-FTStopWordOption-2($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTStopWords($input, $state)
          let $state := p:parse-FTStopWordOption-1($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
  return $state
};

(:~
 : Try parsing FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 228) then                      (: 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          let $state := p:try-FTStopWordOption-2($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTStopWords($input, $state)
          let $state := p:try-FTStopWordOption-1($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
  return $state
};

(:~
 : Parse FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(113, $input, $state)              (: 'diacritics' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 154) then                      (: 'insensitive' :)
      let $state := p:consume(154, $input, $state)          (: 'insensitive' :)
      return $state
    else
      let $state := p:consume(219, $input, $state)          (: 'sensitive' :)
      return $state
  return $state
};

(:~
 : Try parsing FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(113, $input, $state)              (: 'diacritics' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 154) then                      (: 'insensitive' :)
      let $state := p:consume(154, $input, $state)          (: 'insensitive' :)
      return $state
    else
      let $state := p:consume(219, $input, $state)          (: 'sensitive' :)
      return $state
  return $state
};

(:~
 : Parse FTCaseOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(118, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 154) then                  (: 'insensitive' :)
          let $state := p:consume(154, $input, $state)      (: 'insensitive' :)
          return $state
        else
          let $state := p:consume(219, $input, $state)      (: 'sensitive' :)
          return $state
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'lowercase' :)
      let $state := p:consume(169, $input, $state)          (: 'lowercase' :)
      return $state
    else
      let $state := p:consume(247, $input, $state)          (: 'uppercase' :)
      return $state
  return $state
};

(:~
 : Try parsing FTCaseOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(118, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 154) then                  (: 'insensitive' :)
          let $state := p:consume(154, $input, $state)      (: 'insensitive' :)
          return $state
        else
          let $state := p:consume(219, $input, $state)      (: 'sensitive' :)
          return $state
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'lowercase' :)
      let $state := p:consume(169, $input, $state)          (: 'lowercase' :)
      return $state
    else
      let $state := p:consume(247, $input, $state)          (: 'uppercase' :)
      return $state
  return $state
};

(:~
 : Parse FTStemOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 227) then                      (: 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
  return $state
};

(:~
 : Try parsing FTStemOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 227) then                      (: 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
  return $state
};

(:~
 : Parse FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
  return $state
};

(:~
 : Try parsing FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
  return $state
};

(:~
 : Parse FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(217, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'relationship' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 207) then                      (: 'relationship' :)
      let $state := p:consume(207, $input, $state)          (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(215, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 85) then                           (: 'at' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 129                            (: 'exactly' :)
          or $state[$p:lk] = 137                            (: 'from' :)
          or $state[$p:lk] = 85077                          (: 'at' 'least' :)
          or $state[$p:lk] = 90197) then                    (: 'at' 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:consume(168, $input, $state)          (: 'levels' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URILiteral($input, $state)
  let $state := p:lookahead1W(217, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'relationship' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 207) then                      (: 'relationship' :)
      let $state := p:consume(207, $input, $state)          (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(215, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 85) then                           (: 'at' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 129                            (: 'exactly' :)
          or $state[$p:lk] = 137                            (: 'from' :)
          or $state[$p:lk] = 85077                          (: 'at' 'least' :)
          or $state[$p:lk] = 90197) then                    (: 'at' 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:consume(168, $input, $state)          (: 'levels' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTThesaurusID($input, $state)
        return p:parse-FTThesaurusOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTThesaurusOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTThesaurusID($input, $state)
        return p:try-FTThesaurusOption-1($input, $state)
};

(:~
 : Parse FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 234) then                      (: 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 85) then                   (: 'at' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          return $state
        else
          let $state := p:consume(34, $input, $state)       (: '(' :)
          let $state := p:lookahead1W(105, $input, $state)  (: S^WS | ('(' ':') | 'at' | 'default' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 85) then               (: 'at' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-FTThesaurusID($input, $state)
              return $state
            else
              let $state := p:consume(108, $input, $state)  (: 'default' :)
              return $state
          let $state := p:parse-FTThesaurusOption-1($input, $state)
          let $state := p:consume(37, $input, $state)       (: ')' :)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      return $state
  return $state
};

(:~
 : Try parsing FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 234) then                      (: 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 85) then                   (: 'at' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          return $state
        else
          let $state := p:consume(34, $input, $state)       (: '(' :)
          let $state := p:lookahead1W(105, $input, $state)  (: S^WS | ('(' ':') | 'at' | 'default' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 85) then               (: 'at' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-FTThesaurusID($input, $state)
              return $state
            else
              let $state := p:consume(108, $input, $state)  (: 'default' :)
              return $state
          let $state := p:try-FTThesaurusOption-1($input, $state)
          let $state := p:consume(37, $input, $state)       (: ')' :)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      return $state
  return $state
};

(:~
 : Parse FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 256) then                      (: 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
  return $state
};

(:~
 : Try parsing FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 256) then                      (: 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
  return $state
};

(:~
 : Parse FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(162, $input, $state)              (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Try parsing FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(162, $input, $state)              (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTMatchOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 181) then                          (: 'no' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 162) then                      (: 'language' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 256                            (: 'wildcards' :)
          or $state[$p:lk] = 131253) then                   (: 'no' 'wildcards' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 234                            (: 'thesaurus' :)
          or $state[$p:lk] = 119989) then                   (: 'no' 'thesaurus' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 227                            (: 'stemming' :)
          or $state[$p:lk] = 116405) then                   (: 'no' 'stemming' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 113) then                      (: 'diacritics' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 228                            (: 'stop' :)
          or $state[$p:lk] = 116917) then                   (: 'no' 'stop' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 190) then                      (: 'option' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTExtensionOption($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTCaseOption($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FTMatchOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 181) then                          (: 'no' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 162) then                      (: 'language' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 256                            (: 'wildcards' :)
          or $state[$p:lk] = 131253) then                   (: 'no' 'wildcards' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 234                            (: 'thesaurus' :)
          or $state[$p:lk] = 119989) then                   (: 'no' 'thesaurus' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 227                            (: 'stemming' :)
          or $state[$p:lk] = 116405) then                   (: 'no' 'stemming' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 113) then                      (: 'diacritics' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 228                            (: 'stop' :)
          or $state[$p:lk] = 116917) then                   (: 'no' 'stop' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 190) then                      (: 'option' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTExtensionOption($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTCaseOption($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(248, $input, $state)            (: 'using' :)
    let $state := p:lookahead1W(170, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-FTMatchOption($input, $state)
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    return
      if ($state[$p:l1] != 248) then                        (: 'using' :)
        $state
      else
        p:parse-FTMatchOptions-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMatchOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(248, $input, $state)            (: 'using' :)
    let $state := p:lookahead1W(170, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-FTMatchOption($input, $state)
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    return
      if ($state[$p:l1] != 248) then                        (: 'using' :)
        $state
      else
        p:try-FTMatchOptions-1($input, $state)
};

(:~
 : Parse FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FTMatchOptions-1($input, $state)
  return $state
};

(:~
 : Try parsing FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTMatchOptions-1($input, $state)
  return $state
};

(:~
 : Parse FTOptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'ft-option' :)
  let $state := p:consume(138, $input, $state)              (: 'ft-option' :)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'using' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTMatchOptions($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(150, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(175, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(82, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(174, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(174, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(150, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(214, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(131, $input, $state)          (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 4) then                       (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 150) then                          (: 'import' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 109718) then                   (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  return $state
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(174, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(60, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 106) then                      (: 'decimal-separator' :)
      let $state := p:consume(106, $input, $state)          (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'grouping-separator' :)
      let $state := p:consume(146, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'infinity' :)
      let $state := p:consume(152, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'minus-sign' :)
      let $state := p:consume(172, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'NaN' :)
      let $state := p:consume(68, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'percent' :)
      let $state := p:consume(200, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'per-mille' :)
      let $state := p:consume(199, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 263) then                      (: 'zero-digit' :)
      let $state := p:consume(263, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'digit' :)
      let $state := p:consume(115, $input, $state)          (: 'digit' :)
      return $state
    else if ($state[$p:l1] = 198) then                      (: 'pattern-separator' :)
      let $state := p:consume(198, $input, $state)          (: 'pattern-separator' :)
      return $state
    else
      let $state := p:consume(131, $input, $state)          (: 'exponent-separator' :)
      return $state
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QName^Token :)
      let $state := p:consume(15, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'copy' :)
      let $state := p:consume(102, $input, $state)          (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'declare' :)
      let $state := p:consume(107, $input, $state)          (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'delete' :)
      let $state := p:consume(109, $input, $state)          (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state := p:consume(118, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'every' :)
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'following' :)
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'import' :)
      let $state := p:consume(150, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'insert' :)
      let $state := p:consume(155, $input, $state)          (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'invoke' :)
      let $state := p:consume(159, $input, $state)          (: 'invoke' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'module' :)
      let $state := p:consume(175, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'modify' :)
      let $state := p:consume(174, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state := p:consume(193, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 208) then                      (: 'rename' :)
      let $state := p:consume(208, $input, $state)          (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'replace' :)
      let $state := p:consume(209, $input, $state)          (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'transform' :)
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'try' :)
      let $state := p:consume(239, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 244) then                      (: 'unordered' :)
      let $state := p:consume(244, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      return $state
    else if ($state[$p:l1] = 249) then                      (: 'validate' :)
      let $state := p:consume(249, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      return $state
    else
      let $state := p:consume(262, $input, $state)          (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Try parsing FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QName^Token :)
      let $state := p:consume(15, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'copy' :)
      let $state := p:consume(102, $input, $state)          (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'declare' :)
      let $state := p:consume(107, $input, $state)          (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'delete' :)
      let $state := p:consume(109, $input, $state)          (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state := p:consume(118, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'every' :)
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'following' :)
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'import' :)
      let $state := p:consume(150, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'insert' :)
      let $state := p:consume(155, $input, $state)          (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'invoke' :)
      let $state := p:consume(159, $input, $state)          (: 'invoke' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'module' :)
      let $state := p:consume(175, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'modify' :)
      let $state := p:consume(174, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state := p:consume(193, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 208) then                      (: 'rename' :)
      let $state := p:consume(208, $input, $state)          (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'replace' :)
      let $state := p:consume(209, $input, $state)          (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'transform' :)
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'try' :)
      let $state := p:consume(239, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 244) then                      (: 'unordered' :)
      let $state := p:consume(244, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      return $state
    else if ($state[$p:l1] = 249) then                      (: 'validate' :)
      let $state := p:consume(249, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      return $state
    else
      let $state := p:consume(262, $input, $state)          (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(218, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state := p:consume(97, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state := p:consume(119, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'empty-sequence' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'function' :)
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'if' :)
      let $state := p:consume(149, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'item' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state := p:consume(178, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state := p:consume(206, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state := p:consume(215, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state := p:consume(216, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'switch' :)
      let $state := p:consume(231, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'typeswitch' :)
      let $state := p:consume(242, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(218, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state := p:consume(97, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state := p:consume(119, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'empty-sequence' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'function' :)
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'if' :)
      let $state := p:consume(149, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'item' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state := p:consume(178, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state := p:consume(206, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state := p:consume(215, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state := p:consume(216, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'switch' :)
      let $state := p:consume(231, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'typeswitch' :)
      let $state := p:consume(242, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(220, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing EQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(220, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(172, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'exponent-separator' | 'grouping-separator' |
                                                               'infinity' | 'minus-sign' | 'pattern-separator' |
                                                               'per-mille' | 'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(60, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'decimal-format' :)
      let $state := p:consume(105, $input, $state)          (: 'decimal-format' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(105, $input, $state)          (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return $state
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 153) then                      (: 'inherit' :)
      let $state := p:consume(153, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(182, $input, $state)          (: 'no-inherit' :)
      return $state
  return $state
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 204) then                      (: 'preserve' :)
      let $state := p:consume(204, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(183, $input, $state)          (: 'no-preserve' :)
      return $state
  return $state
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(103, $input, $state)              (: 'copy-namespaces' :)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  return $state
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'revalidation' :)
  let $state := p:consume(211, $input, $state)              (: 'revalidation' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 229) then                      (: 'strict' :)
      let $state := p:consume(229, $input, $state)          (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'lax' :)
      let $state := p:consume(164, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(222, $input, $state)          (: 'skip' :)
      return $state
  return $state
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(192, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 144) then                      (: 'greatest' :)
      let $state := p:consume(144, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(166, $input, $state)          (: 'least' :)
      return $state
  return $state
};

(:~
 : Try parsing EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(192, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 144) then                      (: 'greatest' :)
      let $state := p:consume(144, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(166, $input, $state)          (: 'least' :)
      return $state
  return $state
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(194, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state := p:consume(193, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(244, $input, $state)          (: 'unordered' :)
      return $state
  return $state
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(98, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 230) then                      (: 'strip' :)
      let $state := p:consume(230, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(204, $input, $state)          (: 'preserve' :)
      return $state
  return $state
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(87, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(96, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Try parsing DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(96, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URILiteral($input, $state)
  return $state
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(89, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 204) then                      (: 'preserve' :)
      let $state := p:consume(204, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(230, $input, $state)          (: 'strip' :)
      return $state
  return $state
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 107) then                          (: 'declare' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' | 'revalidation' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 55403) then                    (: 'declare' 'default' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-DefaultCollationDecl($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-EmptyOrderDecl($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -6, -6)
                else
                  p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -9, -9)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 45675) then                    (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = -2) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 44651) then                    (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 50283) then                    (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 99435) then                    (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 108139) then                   (: 'declare' 'revalidation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RevalidationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 52843) then                    (: 'declare' 'copy-namespaces' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DecimalFormatDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Try parsing DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URILiteral($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(236, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 107) then                        (: 'declare' :)
        let $state := p:lookahead2W(185, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'contains' | 'context' |
                                                               'copy-namespaces' | 'decimal-format' | 'default' |
                                                               'div' | 'eq' | 'except' | 'ft-option' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'option' |
                                                               'or' | 'ordering' | 'revalidation' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'updating' | 'variable' |
                                                               '|' | '||' :)
        return $state
      else if ($state[$p:l1] eq 150) then                   (: 'import' :)
        let $state := p:lookahead2W(183, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'schema' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'update' | '|' |
                                                               '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 44651                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 45675                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 50283                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 52843                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 53867                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 55403                            (: 'declare' 'default' :)
      and $state[$p:lk] != 70763                            (: 'declare' 'ft-option' :)
      and $state[$p:lk] != 89750                            (: 'import' 'module' :)
      and $state[$p:lk] != 90731                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 99435                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 108139                           (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 109718) then                     (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 107) then                    (: 'declare' :)
            let $state := p:lookahead2W(167, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'ft-option' | 'namespace' | 'ordering' |
                                                                'revalidation' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 55403) then              (: 'declare' 'default' :)
            let $state := p:memoized($state, 0)
            return
              if ($state[$p:lk] != 0) then
                $state
              else
                let $backtrack := $state
                let $state := p:strip-result($state)
                let $state :=
                  if ($state[$p:error]) then
                    $state
                  else
                    p:try-DefaultNamespaceDecl($input, $state)
                return
                  if (not($state[$p:error])) then
                    p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
                  else
                    p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
          else
            $state
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = -1) then
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 90731) then              (: 'declare' 'namespace' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 150) then                (: 'import' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else if ($state[$p:lk] = 70763) then              (: 'declare' 'ft-option' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FTOptionDecl($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(236, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 107) then                        (: 'declare' :)
        let $state := p:lookahead2W(184, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'context' | 'div' | 'eq' |
                                                               'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'option' | 'or' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'updating' | 'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 16491                            (: 'declare' '%' :)
      and $state[$p:lk] != 51819                            (: 'declare' 'context' :)
      and $state[$p:lk] != 72811                            (: 'declare' 'function' :)
      and $state[$p:lk] != 97387                            (: 'declare' 'option' :)
      and $state[$p:lk] != 126059                           (: 'declare' 'updating' :)
      and $state[$p:lk] != 128619) then                     (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 107) then                    (: 'declare' :)
            let $state := p:lookahead2W(161, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'updating' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 51819) then              (: 'declare' 'context' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 97387) then              (: 'declare' 'option' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return $state
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Try parsing URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: NCName^Token :)
      let $state := p:consume(14, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
  return $state
};

(:~
 : Try parsing NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: NCName^Token :)
      let $state := p:consume(14, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(175, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(174, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(60, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  return $state
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(52, $input, $state)               (: ';' :)
  return $state
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(262, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 124) then                      (: 'encoding' :)
      let $state := p:consume(124, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(252, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 124) then                  (: 'encoding' :)
          let $state := p:consume(124, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 262) then                          (: 'xquery' :)
      let $state := p:lookahead2W(182, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'encoding' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'update' |
                                                               'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 63750                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 129286) then                   (: 'xquery' 'version' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 175) then                          (: 'module' :)
      let $state := p:lookahead2W(181, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'or' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 90799) then                    (: 'module' 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  return $state
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(25, $input, $state)               (: EOF :)
  return $state
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 6),
    0, 0, 0,
    subsequence($state, 10)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 18) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, false(), <memo/>))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 3)
    else
      p:matchW($input, $state[$p:e1], $set)
  return
  (
    $match[1] * 512 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 10)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Strip result from lexer state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore lexer state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the lexer state before backtracking started.
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $dpi for input position $e0. Reconstruct state from the parameters.
 :
 : @param $state the lexer state to be restored.
 : @param $update the lexer state containing updates.
 : @param $dpi the decision point id.
 : @param $e0 the input position.
 : @param $v the id of the successful alternative.
 : @param $lk the new lookahead code.
 : @return the reconstructed state.
 :)
declare function p:memoize($state as item()+,
                           $update as item()+,
                           $dpi as xs:integer,
                           $e0 as xs:integer,
                           $v as xs:integer,
                           $lk as xs:integer) as item()+
{
  $lk,
  subsequence($state, $p:b0, $p:memo - $p:b0),
  let $memo := $update[$p:memo]
  let $errors := ($memo, $update[$p:error])[.]
  return
    element memo
    {
      $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
      $memo/value,
      element value {attribute key {$e0 * 32 + $dpi}, $v}
    },
  subsequence($state, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $dpi
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $dpi the decision point id.
 : @return the updated state.
 :)
declare function p:memoized($state as item()+, $dpi as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 32 + $dpi])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, false(), <memo/>)
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
