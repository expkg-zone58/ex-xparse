xquery version "1.0" encoding "UTF-8";

(: This file was generated on Fri Sep 16, 2022 15:38 (UTC+01) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: xquery-update-30-20170124.ebnf -xquery -name XQuery :)

(:~
 : The parser that was generated for the XQuery grammar.
 :)
module namespace p="XQuery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 38, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 38,
  38
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 355, 371,
  387, 423, 423, 423, 415, 339, 331, 339, 331, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 440, 440, 440, 440, 440, 440, 440, 324, 339, 339, 339, 339, 339, 339, 339, 339, 401, 423, 423, 424, 422,
  423, 423, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 338, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 38, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48,
  30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  38, 38, 38, 30, 30, 38, 38, 38, 38, 38, 38, 38, 68, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 38, 30, 38, 30, 30, 38
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 86019, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
  207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20116, 17920, 17943, 17943, 17974, 17943, 17943, 17943, 17925, 17941, 17943, 17944, 17960, 17981, 17997, 20734,
  29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734,
  20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734,
  20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259,
  18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461,
  18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711,
  18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930,
  18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 19344, 19366, 19382, 20734, 19350, 23999,
  20734, 29410, 24292, 20734, 22494, 21364, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 38285, 25918, 26179, 32411,
  20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931,
  20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057,
  18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888,
  18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635,
  18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907,
  18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328,
  19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 19970, 19423, 20734, 20734, 19442, 20734, 20734, 19463, 19482, 19517, 19463, 20734, 21629, 19535,
  25536, 20734, 29410, 24292, 20734, 19566, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 19601, 26179,
  32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056,
  32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807,
  19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204,
  20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844,
  18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914,
  18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044,
  19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 19635, 18445, 20734, 20734, 19671, 20734, 20734, 18445, 34411, 19694, 19724, 19708, 18443,
  18517, 23999, 20734, 29410, 19746, 20734, 19766, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 19795,
  26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142,
  19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 19821, 19852, 19162, 19115,
  22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414,
  19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530,
  22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871,
  18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306,
  19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 19545, 20255, 20734, 20734, 19874, 20734, 20734, 20471, 19909, 19517, 20734, 20247,
  32307, 19960, 23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243,
  25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122,
  18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162,
  19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391,
  18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600,
  26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841,
  18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249,
  19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734, 20734, 20734, 19986, 20734, 20734, 20734, 19994, 19517, 20010,
  20734, 22906, 22916, 23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772,
  18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317,
  18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237,
  19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891,
  18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584,
  18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825,
  18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220,
  19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 23319, 20032,
  20734, 20734, 20734, 21510, 24878, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124,
  18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 20050,
  38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813,
  18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430,
  18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567,
  18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809,
  18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679,
  19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 22926, 20066, 20734, 20734, 20085, 20734, 20734, 19011, 18005,
  19517, 19011, 20734, 21697, 20106, 24542, 20734, 29410, 24292, 20734, 20132, 20734, 20734, 19466, 18359, 20734, 33357,
  19124, 18772, 18243, 25689, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138,
  18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121,
  22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197,
  18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550,
  18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793,
  18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126,
  20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20177, 20194, 20194, 20163, 20194, 20194, 20189,
  20216, 20148, 20210, 20232, 20277, 20292, 23999, 20734, 24294, 20332, 20734, 22494, 20734, 20734, 19466, 18359, 20734,
  33357, 19124, 18772, 18243, 25918, 26179, 25069, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118,
  18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168,
  19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407,
  19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873,
  18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804,
  18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797,
  19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20384, 20734, 20734, 20350, 20734, 20734,
  34505, 33496, 20380, 20400, 20406, 24551, 20422, 23999, 20734, 29410, 20438, 20734, 22494, 20734, 20734, 19466, 18359,
  20734, 33357, 19124, 18772, 18243, 25918, 26179, 23922, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313,
  18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152,
  19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384,
  18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583,
  20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760,
  18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124,
  22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 34514, 20734, 20734, 33354, 20734,
  20734, 20734, 34411, 20456, 20494, 20499, 20515, 20528, 23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466,
  18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663,
  38313, 18118, 18138, 20554, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368,
  19152, 19168, 19121, 22813, 20570, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884,
  18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566,
  18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209,
  18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184,
  19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734, 20734, 20734, 33354,
  20734, 20734, 20734, 34411, 20592, 20643, 20648, 36504, 20664, 23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734,
  19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734, 21274, 20734, 26215, 18021, 18057, 18073,
  18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650,
  18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346,
  18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549,
  18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325,
  30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142,
  19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 25043, 20734, 20734,
  20703, 20733, 20734, 25045, 35803, 20719, 20751, 20756, 20734, 18744, 23999, 20734, 29410, 24292, 20734, 22494, 20734,
  20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057,
  18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211,
  18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331,
  18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533,
  18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731,
  21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101,
  19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20772, 20734, 20734,
  20734, 33354, 20734, 20734, 20734, 34411, 20795, 20837, 20842, 37492, 20858, 20904, 20734, 29410, 24292, 20734, 22494,
  20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 25197, 21274, 30372, 20734, 20734,
  37515, 37516, 26628, 30813, 30814, 30814, 34457, 20941, 20941, 20941, 27894, 20734, 20734, 20734, 21294, 36522, 29931,
  25633, 37516, 28506, 30814, 30814, 30814, 25288, 20938, 20941, 20941, 20941, 28273, 20958, 20734, 20734, 20734, 34168,
  25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 20982, 37516,
  38076, 26313, 30814, 26320, 30168, 34369, 20941, 21178, 20734, 38226, 20734, 37514, 30814, 30814, 21003, 20941, 33807,
  21145, 20734, 19397, 27680, 30814, 23256, 20941, 21052, 36462, 25633, 21072, 28602, 30010, 20734, 28245, 21096, 21137,
  33948, 21161, 26455, 23589, 29963, 23259, 28831, 21177, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734,
  20734, 20734, 33354, 20734, 20734, 20734, 21194, 19517, 20734, 20734, 37953, 21223, 23999, 20734, 29410, 24292, 20734,
  21269, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 37899, 20734, 20734, 28031, 20734, 20090, 20734, 20734,
  20734, 37515, 37516, 26628, 30813, 30814, 30814, 34457, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 21294, 20734,
  20734, 25633, 37516, 28506, 30814, 30814, 30814, 25288, 20938, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734,
  20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162,
  37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941,
  20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973,
  30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545,
  21290, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 21310, 21341, 21394, 21380, 21401, 23999, 20734, 29410, 24292,
  20734, 22494, 34523, 32757, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734,
  26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541,
  27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302,
  26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678,
  21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699,
  18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987,
  19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  19545, 21417, 20734, 20734, 33354, 20734, 20734, 20734, 21434, 19517, 20734, 20734, 28293, 21469, 20618, 20734, 29410,
  24292, 20734, 21505, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 25998, 20734, 20734, 28031, 20734, 28733,
  21526, 20734, 20734, 37515, 37516, 26628, 30813, 30814, 30814, 34457, 20941, 20941, 20941, 21025, 20734, 20734, 20734,
  30878, 21545, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 25288, 20938, 20941, 20941, 20941, 33031, 20734, 20734,
  20734, 20734, 21548, 25631, 37516, 30806, 30814, 30814, 30814, 30407, 20940, 20941, 20941, 20941, 21565, 20734, 20734,
  20734, 25162, 37516, 38076, 30814, 30814, 37185, 21585, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814,
  26980, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734,
  28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 19545, 19730, 20734, 20734, 21606, 21625, 20734, 19585, 34411, 21645, 20069, 21670, 20734, 22273, 20607, 20734,
  19519, 21693, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 19426, 21875, 22198, 22203, 25918, 26179, 29465, 20734,
  20090, 20734, 26215, 18021, 18057, 18073, 18663, 21713, 22463, 21729, 21752, 21978, 21768, 21784, 22112, 32931, 20734,
  20734, 34541, 27245, 18174, 18211, 18650, 18221, 21878, 21846, 21872, 22170, 21894, 22302, 21969, 21900, 22113, 18259,
  18315, 18302, 26917, 20734, 18331, 18346, 18102, 22090, 21916, 21736, 22374, 21932, 22572, 21960, 21994, 21253, 18461,
  18504, 35678, 21569, 18088, 22010, 21856, 22233, 22026, 21238, 22584, 22596, 22051, 18600, 26530, 22844, 18635, 22434,
  22075, 22129, 21944, 22145, 21811, 21325, 30209, 22186, 22219, 22249, 22289, 22404, 18841, 18871, 22318, 22330, 22346,
  18946, 22362, 22390, 22524, 22420, 22101, 22450, 20818, 22160, 20821, 20810, 22479, 22510, 22559, 21798, 22612, 22264,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 19545, 29022, 20734, 20734, 22628, 22641, 20734, 20734, 34411, 22663, 19495, 19501, 20734, 19233, 23999,
  20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411,
  20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931,
  20734, 20734, 34541, 22698, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 18999,
  18259, 18315, 18302, 26917, 22733, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 22750,
  18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 22766, 22782, 18550, 18567, 18584, 18600, 26530, 22844, 18635,
  18711, 18679, 22829, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907,
  18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328,
  19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 20734, 22881, 22942, 22947, 19550, 22963,
  23999, 20734, 29410, 24292, 20734, 22494, 20734, 19447, 19466, 18359, 20734, 33357, 19124, 18772, 19858, 25918, 26179,
  32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056,
  32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807,
  19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204,
  20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844,
  18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914,
  18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044,
  19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20538, 37865, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23007, 23029, 23034, 20734,
  23013, 29242, 20734, 29410, 24292, 20734, 22494, 20734, 34111, 19466, 18359, 20734, 33357, 19124, 18772, 20576, 25918,
  26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142,
  19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115,
  22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414,
  19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530,
  22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871,
  18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306,
  19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20302, 20312, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23050, 23072, 23077,
  20312, 23056, 23093, 20734, 29410, 24292, 20734, 22494, 20734, 19750, 19466, 18359, 20734, 33357, 19124, 18772, 18777,
  23119, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122,
  18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162,
  19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391,
  18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600,
  26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841,
  18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249,
  19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 23182, 20734, 20734, 20734, 23153, 20734, 20734, 20734, 34411, 19517, 23156,
  20734, 20734, 23172, 23999, 20734, 29410, 24292, 20734, 22494, 34532, 20734, 19466, 18359, 20734, 33357, 19124, 18772,
  20687, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317,
  18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237,
  19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891,
  18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584,
  18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825,
  18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220,
  19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 19517,
  20734, 20734, 21056, 23198, 23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124,
  18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158,
  38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813,
  18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430,
  18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567,
  18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809,
  18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679,
  19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411,
  23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852,
  30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814,
  32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 23275, 20734, 25633, 37516, 28506, 30814, 30814, 30814,
  28636, 23295, 20941, 20941, 20941, 31669, 20734, 20734, 20734, 20734, 21548, 25631, 37516, 30806, 30814, 30814, 30814,
  27470, 20940, 20941, 20941, 20941, 21565, 20734, 20734, 34637, 25162, 37516, 38076, 30814, 30814, 32070, 21585, 20941,
  20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734, 23314, 27680, 30814, 23256,
  20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259,
  29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 20734, 20734, 20734,
  34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734,
  25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814,
  30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 23275, 20734, 25633, 37516, 28506, 30814, 30814,
  30814, 28636, 23295, 20941, 20941, 20941, 31669, 20734, 20734, 20734, 20734, 21548, 25631, 37516, 30806, 30814, 30814,
  30814, 27470, 20940, 20941, 20941, 20941, 21565, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814, 32070, 21585,
  20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734, 20734, 27680, 30814,
  23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963,
  23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 20734, 20734,
  20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516,
  20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351,
  30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 23335, 20734, 25633, 37516, 28506, 30814,
  30814, 30814, 28636, 23295, 20941, 20941, 20941, 31669, 20734, 20734, 20734, 20734, 21548, 25631, 37516, 30806, 30814,
  30814, 30814, 27470, 20940, 20941, 20941, 20941, 21565, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814, 32070,
  21585, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734, 20734, 27680,
  30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256,
  29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 20734,
  20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163,
  37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628,
  24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 23275, 20734, 25633, 37516, 28506,
  30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 31669, 20734, 20734, 20734, 20734, 23351, 25631, 37516, 30806,
  30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 21565, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814,
  32070, 21585, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734, 20734,
  27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371,
  23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354,
  20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 26486, 20734, 20734,
  25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 29430, 20734, 20734, 20734, 37515, 37516,
  26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 23275, 20734, 25633, 37516,
  28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 31669, 20734, 20734, 20734, 20734, 21548, 25631, 37516,
  30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 21565, 20734, 20734, 20734, 25162, 37516, 38076, 30814,
  30814, 32070, 21585, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734,
  20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256,
  27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734,
  33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734, 20734,
  20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515,
  37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734, 20734, 25633,
  37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734, 20734, 25631,
  37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162, 37516, 38076,
  30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273,
  20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041,
  23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734,
  20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734,
  20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 30173, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734,
  37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734, 20734,
  25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734, 20734,
  25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162, 37516,
  38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941,
  28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012,
  18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734,
  20734, 20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 31755, 20913, 20734, 29410, 24292, 20734,
  20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734,
  20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734,
  20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734,
  20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162,
  37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941,
  20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973,
  30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116,
  20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23374, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292,
  20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 28775,
  20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734,
  20734, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734,
  20734, 20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734,
  25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080,
  20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245,
  29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  21116, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23402, 23415, 20913, 20734, 29410,
  24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734,
  20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734,
  20734, 20734, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734,
  20734, 20734, 20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734,
  20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814,
  21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734,
  28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 21116, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734,
  29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734,
  20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734,
  20734, 20734, 20734, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734,
  20734, 20734, 20734, 20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734,
  20734, 20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 23431, 37514, 30814,
  30814, 21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010,
  20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 23450, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913,
  20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031,
  20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734,
  20734, 20734, 20734, 20734, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273,
  20734, 20734, 20734, 20734, 20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409,
  20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514,
  30814, 30814, 21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256,
  30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630,
  33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23471, 23521, 23560, 20734, 19779,
  23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179,
  32411, 20734, 20090, 32670, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056,
  32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807,
  19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204,
  20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844,
  18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 23613, 18871, 18914,
  18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044,
  19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 19517, 20734, 20734, 20734,
  21510, 23999, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918,
  26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142,
  19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115,
  22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414,
  19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530,
  22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871,
  18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306,
  19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 23649, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 18971, 23685, 21447, 21453,
  20734, 21207, 23725, 20734, 29410, 24292, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 19312,
  25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122,
  18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162,
  19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391,
  18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600,
  26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841,
  18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249,
  19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 21116, 20334, 20734, 20734, 33354, 23750, 20734, 23734, 23775, 23823, 23838,
  23854, 23869, 23882, 21654, 23898, 23916, 23938, 34104, 23986, 24024, 24072, 28234, 24111, 24087, 24140, 24192, 24230,
  24246, 24262, 20734, 24283, 32299, 20734, 26019, 33091, 29823, 37515, 24959, 26595, 24351, 30814, 31773, 24310, 20941,
  20941, 36714, 28272, 25035, 23789, 22710, 20734, 23275, 20734, 24619, 37516, 24339, 28207, 30814, 36597, 24368, 24384,
  24403, 20941, 24420, 31669, 37358, 20734, 20734, 29229, 21548, 24448, 28101, 37029, 24464, 24485, 24507, 27470, 32618,
  37535, 38042, 20941, 24529, 25699, 20734, 24567, 25162, 37516, 38076, 30814, 38024, 27192, 21585, 20941, 32736, 27350,
  24605, 20734, 20734, 37514, 30814, 27462, 26980, 20941, 24635, 29168, 20734, 20734, 27680, 24655, 24676, 28421, 29408,
  20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 24692, 23256, 29912, 23259, 24721, 37327,
  29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20735, 24745, 20734, 33354, 22682, 20734, 20734, 24763, 24779,
  24794, 24800, 24816, 24829, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814,
  25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576,
  20941, 20941, 20941, 28272, 20734, 20734, 20734, 24845, 24865, 29865, 25633, 37516, 24912, 30814, 30814, 30814, 24940,
  23295, 20941, 20941, 33642, 31669, 20734, 20734, 20734, 20734, 21548, 25631, 37516, 30806, 30814, 30814, 30814, 27470,
  20940, 20941, 20941, 20941, 21565, 20734, 20734, 18189, 24008, 24956, 36130, 30814, 30814, 32070, 24975, 20941, 20941,
  21178, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941,
  29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 36779, 25013, 29968,
  32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 25061, 20734, 33354, 20261, 20734, 20316, 20016,
  25085, 25100, 25116, 25131, 25144, 20913, 20734, 19619, 24292, 26075, 20734, 20734, 20734, 25163, 37516, 20734, 25852,
  32818, 25266, 26801, 20734, 25161, 28031, 25160, 31853, 20734, 25179, 35962, 25213, 37516, 35951, 25254, 25286, 30814,
  26732, 32260, 20941, 20941, 28272, 25304, 33470, 20734, 20734, 23275, 38535, 25633, 25322, 28506, 27000, 31913, 32525,
  28636, 23295, 25339, 31530, 20941, 31669, 20734, 20734, 20734, 33223, 21548, 25631, 37516, 30806, 30814, 30814, 37308,
  27470, 20940, 20941, 20941, 29363, 21565, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 25773, 32070, 21585, 20941,
  31042, 21178, 20734, 20734, 35194, 33520, 30814, 25397, 26980, 30500, 20941, 26843, 20734, 20734, 25417, 24491, 23256,
  32096, 29408, 20734, 25633, 30814, 25445, 32952, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 25468, 25498,
  29968, 32196, 29974, 26831, 32226, 37268, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 24176, 20734, 33354, 22647, 20734, 25523,
  27900, 25561, 25576, 25582, 25598, 25611, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25627, 37818, 24267,
  25649, 30908, 25429, 21590, 20734, 35328, 35665, 29061, 20734, 20734, 28402, 31383, 25723, 35922, 25227, 25751, 30814,
  25789, 30465, 28185, 25815, 25812, 28272, 20734, 21489, 20734, 25831, 23275, 20734, 25633, 37516, 28506, 30814, 30814,
  30814, 28636, 23295, 20941, 20941, 20941, 31669, 25850, 20734, 25868, 25887, 21548, 25631, 37516, 31718, 30814, 30814,
  30814, 25905, 34608, 20941, 20941, 31822, 21565, 20734, 20734, 20734, 18274, 25952, 37176, 30814, 26418, 32070, 25969,
  20941, 28662, 21178, 29458, 22859, 35455, 33678, 30838, 28127, 26980, 25374, 25993, 28273, 20734, 20734, 27680, 30814,
  23256, 20941, 29408, 26014, 25633, 30814, 26035, 34151, 20734, 28245, 29973, 30012, 18041, 23256, 30660, 31745, 35581,
  32233, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 18195, 20734, 33354, 26058, 26073,
  23137, 22865, 26091, 26106, 26122, 26137, 26150, 20913, 27237, 28802, 37475, 26166, 26909, 25676, 26208, 26231, 26270,
  23486, 27659, 26298, 30258, 26336, 20734, 26352, 31414, 19085, 31858, 31153, 20734, 29992, 37515, 25323, 26377, 24924,
  26404, 28145, 26442, 23597, 28669, 30715, 26471, 26507, 26523, 26546, 29254, 26562, 37755, 26582, 26611, 36896, 26644,
  26672, 26710, 26748, 26764, 26790, 26817, 33451, 26859, 24036, 20734, 34709, 20734, 26894, 26933, 26951, 32153, 26970,
  30814, 26996, 27016, 21014, 27045, 29733, 23298, 21565, 27064, 27081, 23103, 25162, 27109, 27129, 27156, 27177, 27226,
  27261, 27304, 27324, 27366, 20734, 27387, 20734, 27421, 26686, 27448, 26980, 27486, 27506, 28273, 27532, 27561, 27577,
  27710, 27593, 27620, 27650, 20734, 27675, 27696, 31069, 27748, 22059, 28245, 29353, 31086, 27770, 27140, 29703, 34016,
  27786, 27846, 19836, 27862, 29974, 29650, 27883, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 27916, 21529,
  27940, 20734, 27924, 27959, 27974, 27980, 27996, 28009, 20913, 20734, 28025, 24292, 20734, 35236, 20734, 35238, 25306,
  37516, 35236, 28452, 32063, 34666, 21590, 20734, 28075, 28031, 28075, 20734, 28047, 28064, 20734, 28093, 37516, 26628,
  28117, 30814, 30814, 32576, 28179, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 23275, 20734, 25633, 37516, 28506,
  30814, 30814, 32985, 28636, 23295, 20941, 20941, 36708, 31669, 20734, 32910, 20734, 20734, 21548, 25631, 30119, 30806,
  30814, 36022, 30814, 27470, 20940, 20941, 37894, 20941, 21565, 35474, 20734, 20734, 35001, 32687, 28201, 30814, 34131,
  28223, 21585, 20941, 32864, 28269, 20734, 20734, 20734, 37514, 30814, 30814, 26980, 20941, 20941, 28273, 20734, 20734,
  27680, 30814, 23256, 20941, 24168, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371,
  23256, 29963, 23259, 29968, 32196, 29974, 29664, 32226, 31615, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354,
  20734, 28289, 21609, 34411, 28309, 28324, 28330, 28346, 28359, 20913, 20734, 29410, 24292, 20734, 30032, 20734, 20734,
  25163, 37516, 20734, 25852, 30814, 25266, 21590, 28375, 20734, 28031, 20734, 20734, 20734, 28400, 20734, 37515, 37516,
  26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734, 20734, 25633, 37516,
  28506, 30814, 30814, 30814, 33538, 28418, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734, 20734, 25631, 37516,
  30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162, 37516, 38076, 30814,
  30814, 26320, 30168, 20941, 20941, 21178, 20734, 23129, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 27867, 28437,
  28468, 27680, 30814, 23256, 20941, 29408, 33556, 28497, 28522, 29314, 28566, 20734, 28588, 28618, 36241, 18041, 23256,
  27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 37238, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734,
  33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 34316, 24292, 20734, 20734, 31305,
  31303, 25163, 37517, 20734, 25852, 28634, 28652, 29370, 20734, 20734, 28685, 23544, 19578, 20734, 20734, 20734, 37515,
  37516, 26628, 24351, 30814, 28951, 32576, 20941, 20941, 30326, 28272, 20734, 31491, 20734, 20734, 20734, 20734, 25633,
  37516, 27432, 30814, 30814, 30814, 30139, 23295, 20941, 20941, 20941, 28710, 28729, 20734, 20734, 20734, 20734, 25631,
  37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 38256, 20734, 25162, 37516, 38076,
  30814, 30814, 28749, 30168, 20941, 24404, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273,
  20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 25364, 34479, 18041,
  23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20440,
  28774, 33354, 23660, 21484, 28791, 28818, 28855, 28870, 28886, 28901, 28914, 20913, 20734, 35965, 28694, 20734, 20734,
  30858, 29768, 29525, 28930, 29517, 25852, 28946, 28967, 25452, 20734, 20734, 28031, 20734, 29004, 20734, 20734, 20364,
  37515, 29038, 29058, 29077, 28136, 30815, 29101, 29147, 30287, 30292, 29167, 22675, 29184, 35542, 29200, 20734, 29270,
  25633, 27113, 29291, 30814, 30814, 29339, 37207, 23295, 20941, 33650, 29386, 29406, 20734, 20734, 29426, 29446, 20734,
  25631, 37516, 33711, 30814, 30814, 30814, 27470, 29481, 20941, 20941, 20941, 29409, 38473, 29502, 29547, 29563, 37516,
  38076, 37004, 30814, 26320, 30168, 36630, 20941, 35603, 35126, 20734, 21677, 29584, 29620, 33985, 29636, 29749, 30686,
  29784, 20734, 24896, 33284, 29805, 28839, 36442, 29408, 29821, 29839, 30814, 23256, 30010, 29860, 28245, 29973, 30012,
  18041, 23256, 27371, 29881, 29963, 23259, 29968, 32196, 29897, 26831, 32226, 31630, 29955, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734,
  20734, 20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734,
  29990, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734,
  20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734,
  20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734,
  20734, 25631, 37516, 30806, 30814, 31895, 30814, 27470, 20940, 20941, 30008, 20941, 29409, 20734, 20734, 20734, 25162,
  37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941,
  20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973,
  30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116,
  20734, 20734, 20734, 33354, 20734, 30028, 23434, 26388, 30048, 30063, 30069, 30085, 30098, 20913, 25936, 29410, 24292,
  36075, 32015, 20734, 19944, 25163, 30114, 19942, 23575, 30135, 31657, 30173, 30155, 20734, 28031, 30189, 36299, 28077,
  20734, 20734, 37393, 37825, 26628, 31558, 30225, 30245, 30274, 36807, 20941, 30308, 30350, 30369, 20734, 20734, 35996,
  20734, 20734, 29531, 37516, 28506, 30388, 25766, 31512, 33538, 30423, 29151, 20941, 30439, 28273, 32651, 26871, 20734,
  38221, 38437, 25631, 37516, 30457, 30814, 30229, 36151, 27470, 20940, 20941, 29125, 37928, 28713, 20734, 20734, 20734,
  25162, 29598, 38076, 30481, 30814, 26320, 30168, 30499, 20941, 27754, 20734, 34848, 30516, 30552, 30573, 30814, 21080,
  30594, 20941, 28273, 30611, 23358, 27680, 30814, 23256, 20941, 29408, 19935, 25633, 30814, 30631, 27288, 20734, 28245,
  29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 34758, 30654, 30676, 26831, 30702, 31630, 33152, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  21116, 20734, 20734, 23503, 22991, 20734, 23499, 20734, 34411, 30731, 30746, 30752, 30768, 30781, 20913, 34061, 29410,
  24292, 25834, 20734, 20734, 25236, 25163, 30797, 34062, 25238, 30831, 24705, 21590, 20734, 37076, 28031, 20734, 30854,
  30874, 20734, 20734, 37515, 37516, 26628, 32516, 30814, 30894, 32576, 29728, 31001, 25381, 25507, 27405, 20734, 20734,
  20734, 20734, 20734, 25633, 37516, 28506, 35860, 24352, 30814, 28636, 30931, 35630, 36624, 20941, 28273, 18479, 25928,
  20734, 19611, 19805, 25631, 37516, 30806, 30974, 30814, 30965, 32161, 20940, 30999, 27048, 31017, 29409, 20734, 20734,
  20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814,
  21080, 20941, 20941, 36249, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 38190, 30814, 31035, 33765, 20734,
  28245, 29973, 30012, 31058, 31102, 31125, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 21116, 20734, 20734, 31149, 31169, 20734, 22896, 31189, 31199, 31215, 31230, 31239, 31255, 31268, 20913, 26491,
  29410, 31284, 31321, 20734, 34965, 26361, 31346, 31362, 31399, 31439, 31455, 35081, 31471, 27943, 20734, 24056, 20734,
  20734, 18612, 34406, 20734, 37515, 37516, 31487, 24351, 31507, 37113, 32576, 20941, 31528, 33250, 37703, 20734, 35410,
  20734, 20734, 23807, 20734, 36862, 37516, 31546, 31904, 30814, 30814, 31584, 31600, 20941, 20941, 29131, 28273, 20734,
  20734, 23633, 20734, 19678, 31697, 37516, 31734, 30814, 30814, 31771, 31789, 31818, 20941, 35636, 30949, 33160, 31838,
  36983, 20734, 31874, 23709, 35027, 31938, 37450, 26320, 32893, 31954, 33256, 21178, 31991, 25545, 32007, 37514, 37846,
  30814, 21080, 35499, 20941, 28273, 32031, 37576, 32049, 31568, 33624, 32086, 32120, 20734, 32141, 32177, 35299, 27821,
  36575, 23386, 29973, 32193, 18041, 32212, 28980, 32249, 25354, 32276, 29968, 32196, 29974, 27634, 32226, 31630, 35573,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 21116, 20734, 20734, 21356, 33354, 21418, 38262, 23279, 32454, 32323, 32338, 32344, 32360, 32373, 20627,
  32389, 32405, 32427, 32448, 20734, 32470, 32474, 34877, 32490, 32541, 32555, 32592, 29690, 32634, 20734, 20734, 28031,
  20734, 32650, 23970, 32667, 20734, 37515, 32686, 26628, 24351, 33978, 28154, 32703, 20941, 32732, 30944, 32752, 31173,
  20734, 32773, 24581, 32791, 18470, 23697, 29604, 32504, 32815, 30578, 30814, 30983, 32834, 20941, 32859, 36040, 36740,
  20734, 32880, 20734, 20734, 20734, 25631, 37516, 30806, 33002, 30814, 30814, 27470, 20940, 30334, 20941, 20941, 29409,
  20734, 32909, 32926, 25162, 37516, 38076, 30814, 30814, 30915, 32947, 20941, 20941, 21178, 20779, 20734, 20734, 32968,
  32984, 33001, 33018, 33597, 30595, 29761, 20734, 20734, 38070, 33070, 34804, 20941, 29408, 20734, 25633, 30814, 23256,
  30010, 33088, 31886, 34434, 27308, 33107, 27721, 24323, 33176, 29963, 23259, 29968, 32196, 29974, 33205, 33239, 31630,
  36771, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 20734, 23759, 22734, 28481, 33272, 26626, 23234, 33312, 33325,
  20913, 20734, 33341, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 33373, 25852, 30814, 25266, 21590, 27065, 30204,
  28031, 20734, 18035, 33395, 20734, 20734, 19893, 37516, 33418, 34196, 24513, 36356, 33438, 27811, 27281, 34831, 27830,
  20734, 20734, 29275, 27210, 33942, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941,
  24432, 20734, 20734, 20734, 33467, 33486, 33512, 31709, 30806, 36199, 33536, 30814, 26694, 20940, 27516, 20941, 20941,
  29409, 33554, 20734, 20734, 25162, 37516, 38076, 30814, 33572, 25796, 36436, 20941, 33593, 21178, 20734, 20734, 20734,
  37514, 30814, 30814, 21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814,
  23256, 30010, 20734, 28245, 29973, 35348, 33613, 23256, 29677, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226,
  31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250,
  21106, 20913, 20734, 29410, 24292, 20734, 30615, 20734, 20734, 33666, 33702, 33050, 33054, 33727, 33747, 34375, 33781,
  20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941,
  28272, 20734, 20734, 20734, 20734, 20734, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 34214, 33803, 20941, 20941,
  20941, 28273, 20734, 20734, 20734, 20734, 20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941,
  20941, 29409, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734,
  20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633,
  30398, 24729, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831,
  32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 36307, 33823, 21121, 23900, 33826, 32125, 33842, 33857, 33863,
  33879, 33892, 20913, 20734, 22978, 31423, 23536, 33908, 29215, 20734, 28758, 25735, 33927, 33964, 34001, 26656, 34039,
  20734, 20734, 28031, 34055, 34078, 35777, 19647, 20734, 19290, 37516, 24124, 24351, 34127, 37105, 32576, 30441, 20941,
  34147, 28272, 20734, 28384, 20734, 34167, 33911, 28380, 25633, 37516, 34184, 34212, 34230, 30814, 34250, 34266, 26042,
  20941, 32843, 34290, 20734, 34310, 34332, 34391, 20734, 27093, 37400, 35052, 30814, 34427, 34450, 25663, 34473, 29390,
  34023, 20941, 34495, 20734, 19407, 20734, 34557, 37516, 38076, 34578, 30814, 26320, 31802, 20941, 20941, 35507, 20734,
  31296, 20734, 37514, 30814, 30814, 34597, 20941, 20941, 34633, 24887, 20734, 34653, 30814, 34682, 24387, 29408, 34706,
  25633, 30814, 23256, 30010, 20734, 28245, 29973, 24639, 33787, 34725, 34750, 23256, 31645, 34774, 34796, 32196, 29974,
  27338, 34820, 33137, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 33379, 33354, 34847, 27029, 24997, 34864, 34893, 34908,
  34914, 34930, 34943, 22035, 20734, 29410, 24292, 20734, 24047, 20734, 34959, 36681, 36887, 36673, 34981, 32569, 36180,
  21590, 23669, 34997, 28031, 36069, 20734, 20734, 22543, 33043, 35017, 35043, 36104, 35068, 24469, 30814, 32576, 35097,
  34617, 20941, 28272, 35122, 20734, 35142, 20734, 20734, 20734, 25633, 37516, 36332, 30814, 35171, 30814, 28636, 23295,
  29486, 20941, 20941, 28273, 20734, 35193, 35210, 20734, 35254, 19884, 25953, 35289, 30814, 36406, 25482, 35315, 35344,
  20941, 31079, 35364, 31969, 20734, 20734, 20734, 36001, 30557, 38076, 30814, 35426, 26320, 30168, 20942, 35393, 21178,
  20734, 35451, 35266, 37514, 25401, 38082, 29085, 31109, 35384, 28273, 20734, 35471, 27680, 30814, 23256, 20941, 30353,
  38442, 26935, 30814, 35490, 36274, 35523, 28245, 29973, 30012, 18041, 35558, 27371, 23256, 36555, 35597, 28988, 37150,
  35619, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 24849, 33354, 20734, 21549, 25190, 35652, 35694,
  35709, 35725, 35740, 35753, 20913, 25889, 18619, 35769, 33402, 35793, 23963, 24589, 35819, 26282, 35897, 23213, 35846,
  28550, 27732, 37363, 31330, 35876, 20734, 28048, 34093, 19923, 22536, 35913, 35938, 35981, 36017, 24660, 24214, 24154,
  36038, 29323, 35375, 36056, 35225, 20734, 23952, 20734, 20734, 31681, 36091, 36120, 36487, 36146, 36167, 36196, 36215,
  36231, 33633, 36265, 25977, 28273, 30530, 18488, 32290, 20734, 36290, 19281, 36323, 36348, 36372, 36403, 33731, 36422,
  25270, 34734, 20941, 37140, 25026, 20734, 20734, 36458, 20966, 36478, 26254, 37054, 26725, 26320, 34345, 35106, 33759,
  28572, 36503, 36520, 18961, 37783, 28537, 30814, 32607, 36538, 20941, 36571, 35535, 20734, 29844, 36591, 36613, 36646,
  36662, 20734, 38406, 34234, 36697, 36730, 26192, 18286, 33122, 34274, 18041, 23256, 27371, 23256, 29963, 23259, 36756,
  34690, 36387, 36795, 32226, 37253, 36823, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 19014, 33354, 20734, 26566, 20734, 36847,
  36912, 36927, 36935, 36951, 36964, 20913, 20734, 29410, 36980, 23455, 20734, 20734, 20734, 25163, 37516, 20734, 31975,
  36999, 33296, 21590, 32799, 20734, 28031, 20734, 20734, 18855, 20734, 20734, 37020, 37516, 26628, 37045, 30814, 30814,
  28163, 29114, 20941, 20941, 32716, 23505, 35891, 32033, 20734, 37557, 37070, 37684, 37792, 28506, 33072, 31922, 37092,
  28636, 23295, 33189, 32104, 37129, 28273, 29939, 20734, 20734, 20734, 20734, 25631, 37166, 30806, 37201, 30814, 30814,
  26426, 37223, 20941, 20941, 20941, 37283, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941,
  20941, 34780, 20734, 32775, 20734, 37514, 37305, 30814, 28253, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256,
  20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 35830, 29973, 37324, 18041, 23256, 27371, 23256, 29963, 23259,
  31133, 36547, 29974, 26831, 38005, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354, 24747, 26878, 20734,
  37343, 37379, 31377, 34562, 37416, 37429, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734,
  25852, 37445, 29716, 21590, 20734, 20734, 37466, 20734, 20734, 20734, 20734, 37491, 26244, 37516, 26628, 29303, 27161,
  30814, 32576, 27271, 30317, 20941, 28272, 20734, 20734, 20734, 29789, 20734, 20734, 37508, 33686, 28506, 30814, 35177,
  30814, 28636, 23295, 20941, 37533, 20941, 28273, 20734, 20734, 20734, 20734, 20734, 25631, 37516, 30806, 30814, 30814,
  30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168,
  20941, 20941, 21178, 20734, 37551, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814,
  23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 27397, 28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963,
  23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 37593, 37573, 20734, 27203,
  37592, 27545, 37609, 37624, 37630, 37646, 37659, 20913, 20734, 29410, 24292, 20734, 20734, 20734, 20734, 25163, 37516,
  20734, 25852, 34581, 25266, 27604, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516, 26628, 24351,
  30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734, 20734, 25633, 37516, 28506, 30814,
  30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 19272, 20734, 25631, 37516, 30806, 30814,
  30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20478, 20734, 20734, 25162, 37516, 38076, 37975, 30814, 37675,
  30168, 30638, 20941, 37700, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273, 20734, 20734, 27680,
  30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371, 23256,
  29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 23450, 20734, 20734, 20734, 33354, 20734,
  20734, 20734, 34411, 23229, 26626, 29568, 37719, 37732, 20913, 20734, 29410, 37748, 20734, 20734, 20734, 20734, 37771,
  37808, 35273, 35155, 37841, 27799, 21590, 20734, 20734, 28031, 37289, 19655, 37862, 20734, 20734, 37515, 37516, 26628,
  24351, 30814, 30814, 37881, 20941, 20941, 27490, 24986, 20734, 20734, 20734, 20734, 20734, 20734, 25633, 37516, 28506,
  30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734, 20734, 25631, 37516, 30806,
  30814, 30814, 30814, 35435, 20940, 20941, 20941, 20941, 36831, 20734, 20734, 20734, 25162, 37516, 38076, 30814, 30814,
  26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273, 20734, 20734,
  27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256, 27371,
  23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734, 33354,
  20734, 20734, 20734, 34411, 23229, 26626, 20987, 23250, 21106, 20922, 20734, 29410, 24292, 20734, 30536, 20734, 20734,
  25163, 37516, 20734, 25871, 30483, 25266, 26774, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515, 37516,
  26628, 24351, 30814, 30814, 37915, 20941, 20941, 31019, 28272, 23627, 20734, 37949, 20734, 20734, 20734, 25633, 26954,
  28506, 24206, 30814, 37969, 28636, 37991, 20941, 37933, 20941, 28273, 33422, 20734, 20734, 20734, 20734, 25631, 36877,
  30806, 33577, 30814, 30814, 27470, 20940, 34358, 20941, 20941, 29409, 34294, 20734, 20734, 25162, 29042, 38076, 30814,
  38021, 29922, 30168, 20941, 38040, 35402, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 33217, 20734,
  23799, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041, 23256,
  27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 21116, 20734, 20734, 20734,
  33354, 20734, 20734, 20734, 34411, 38058, 26626, 20987, 23250, 21106, 20913, 20734, 29410, 24292, 20734, 20734, 20734,
  20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734, 20734, 20734, 20734, 37515,
  37516, 26628, 24351, 30814, 30814, 32576, 20941, 20941, 20941, 28272, 20734, 20734, 20734, 20734, 20734, 20734, 25633,
  37516, 28506, 30814, 30814, 30814, 28636, 23295, 20941, 20941, 20941, 28273, 20734, 20734, 20734, 20734, 20734, 25631,
  37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734, 20734, 25162, 37516, 38076,
  30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814, 21080, 20941, 20941, 28273,
  20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734, 28245, 29973, 30012, 18041,
  23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734, 20734,
  20734, 38098, 38164, 38124, 38145, 38108, 38180, 38158, 25707, 38129, 38206, 23999, 20734, 29410, 24292, 20734, 38242,
  20734, 20734, 19466, 18359, 20734, 33357, 19124, 38278, 18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215, 18021,
  18057, 18073, 18663, 38313, 18118, 18138, 38301, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245, 18174,
  18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917, 20734,
  18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569, 18088,
  18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715, 18683,
  18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030, 19073,
  19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545, 20734,
  20734, 20734, 33354, 20734, 38335, 38333, 34411, 38351, 38373, 38378, 20734, 38357, 23999, 20734, 29410, 24292, 20734,
  22494, 20734, 20734, 22717, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734, 26215,
  18021, 18057, 18073, 18663, 38313, 18118, 18138, 18158, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541, 27245,
  18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302, 26917,
  20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678, 21569,
  18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699, 18715,
  18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987, 19030,
  19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 19545,
  20734, 20734, 20734, 33354, 20734, 20734, 20734, 21036, 38394, 21824, 21830, 20734, 38422, 23999, 20734, 29410, 24292,
  20734, 38458, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18243, 25918, 26179, 32411, 20734, 20090, 20734,
  26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 38489, 38317, 18122, 18142, 19056, 32931, 20734, 20734, 34541,
  27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259, 18315, 18302,
  26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461, 18504, 35678,
  21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711, 18679, 18699,
  18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930, 18946, 18987,
  19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  19545, 20734, 20734, 20734, 33354, 20734, 20734, 20734, 34411, 19517, 20734, 20734, 20734, 24095, 20913, 20734, 29410,
  24292, 20734, 20734, 20734, 20734, 25163, 37516, 20734, 25852, 30814, 25266, 21590, 20734, 20734, 28031, 20734, 20734,
  20734, 20734, 20734, 37515, 37516, 26628, 30813, 30814, 30814, 34457, 20941, 20941, 20941, 28272, 20734, 20734, 20734,
  20734, 20734, 20734, 25633, 37516, 28506, 30814, 30814, 30814, 25288, 20938, 20941, 20941, 20941, 28273, 20734, 20734,
  20734, 20734, 20734, 25631, 37516, 30806, 30814, 30814, 30814, 27470, 20940, 20941, 20941, 20941, 29409, 20734, 20734,
  20734, 25162, 37516, 38076, 30814, 30814, 26320, 30168, 20941, 20941, 21178, 20734, 20734, 20734, 37514, 30814, 30814,
  21080, 20941, 20941, 28273, 20734, 20734, 27680, 30814, 23256, 20941, 29408, 20734, 25633, 30814, 23256, 30010, 20734,
  28245, 29973, 30012, 18041, 23256, 27371, 23256, 29963, 23259, 29968, 32196, 29974, 26831, 32226, 31630, 33152, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 29018, 29014, 32432, 38505, 38510, 20734, 38526, 22492, 20734,
  20734, 20734, 20734, 22494, 20734, 20734, 19466, 18359, 20734, 33357, 19124, 18772, 18777, 25918, 26179, 20034, 20734,
  20090, 20734, 26215, 18021, 18057, 18073, 18663, 38313, 18118, 18138, 38301, 38317, 18122, 18142, 19056, 32931, 20734,
  20734, 34541, 27245, 18174, 18211, 18650, 18368, 19152, 19168, 19121, 22813, 18237, 19162, 19115, 22807, 19057, 18259,
  18315, 18302, 26917, 20734, 18331, 18346, 18884, 18384, 18407, 19197, 18430, 18891, 18391, 18414, 19204, 20888, 18461,
  18504, 35678, 21569, 18088, 18533, 18549, 18566, 18583, 20873, 18550, 18567, 18584, 18600, 26530, 22844, 18635, 18711,
  18679, 18699, 18715, 18683, 18731, 21325, 30209, 18760, 18804, 18793, 18809, 18825, 18841, 18871, 18914, 18907, 18930,
  18946, 18987, 19030, 19073, 19101, 19142, 19184, 19124, 22797, 19126, 20679, 19220, 19249, 19306, 19044, 19328, 19263,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734, 20734,
  20734, 20734, 73957, 73957, 69860, 69860, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957,
  73957, 45056, 49152, 73957, 73957, 73957, 73957, 40960, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957,
  73957, 73957, 73957, 73957, 73957, 73957, 73957, 0, 0, 69860, 73957, 69860, 73957, 73957, 73957, 73957, 73957, 73957,
  73957, 73957, 73957, 73957, 73957, 73957, 272, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957, 73957,
  73957, 73957, 73957, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 69860, 73957, 0, 1056768, 232, 233, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 45056, 135488, 0, 0, 0, 0, 1511424, 0, 1548288, 1564672, 0, 0, 1613824, 1630208, 1642496, 0, 1671168, 1708032,
  1839104, 0, 0, 0, 0, 0, 822, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 415, 415, 415, 415, 415, 0, 1114112, 1114112, 1355776,
  1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1511424, 1114112, 1114112, 1548288, 1114112,
  1564672, 1114112, 1114112, 1613824, 1630208, 1642496, 1114112, 1671168, 1114112, 1708032, 1114112, 1114112, 1114112,
  1839104, 1114112, 1114112, 1114112, 1114112, 1433600, 1114112, 1114112, 1495040, 1114112, 1556480, 1114112, 1114112,
  1114112, 1712128, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1908736, 0, 1110657, 1110657, 1110657,
  1110657, 1110657, 1389185, 1393281, 1110657, 1110016, 1110016, 1110016, 1110016, 1110016, 1548288, 1110016, 1564672,
  1110016, 1572864, 1110016, 1110016, 1613824, 1110016, 1110016, 1630208, 1642496, 1110016, 1110016, 1671168, 1642496,
  1110016, 1110016, 1671168, 1110016, 1110016, 1708032, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1839104, 1110016, 1110016, 1110016, 1839104, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 698, 0, 0, 701, 1110016, 1110016, 1355776, 1318912, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1351680, 0,
  1474560, 0, 0, 0, 0, 0, 1568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 250, 251, 252, 0, 0, 0, 0, 0, 1650688, 0, 0, 0,
  1650688, 1114112, 1351680, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 0, 0, 1650688, 0, 0,
  1110016, 1110657, 1110657, 1352321, 0, 0, 0, 1110016, 1110016, 1351680, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 0, 0, 5, 0, 0, 1388544, 0, 0, 0, 0, 0, 0, 0, 0, 1490944,
  0, 1605632, 1617920, 0, 0, 0, 0, 0, 1579, 1580, 0, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 415, 415, 415, 415,
  1965, 415, 415, 415, 0, 0, 0, 0, 1699840, 0, 1622016, 0, 0, 0, 0, 1675264, 0, 0, 1687552, 0, 0, 0, 0, 0, 0, 0,
  1835008, 0, 1896448, 0, 1908736, 0, 0, 0, 0, 1392640, 0, 1568768, 0, 0, 0, 0, 0, 1114112, 1114112, 1114112, 1388544,
  1392640, 1114112, 1114112, 1114112, 1490944, 1114112, 1114112, 1114112, 1568768, 1114112, 1114112, 1605632, 1114112,
  1699840, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112,
  1114112, 1114112, 1114112, 1114112, 0, 0, 1650688, 0, 0, 1110016, 1110016, 1110016, 1351680, 1110016, 1110016,
  1425408, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1490944, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1568768, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1568768, 1110016, 1110016,
  1110016, 1110016, 1605632, 1110016, 1617920, 1622016, 1110016, 1110016, 1110016, 1687552, 1699840, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1908736, 1110016,
  0, 0, 0, 0, 1073152, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1712128, 0, 0, 0, 0, 1814528,
  0, 0, 0, 0, 0, 0, 0, 0, 1136, 0, 0, 0, 0, 0, 0, 0, 0, 1325, 0, 0, 0, 0, 0, 0, 0, 0, 1337, 0, 1338, 0, 0, 0, 1340, 0,
  0, 1527808, 0, 1634304, 0, 0, 0, 0, 1691648, 1884160, 0, 0, 1822720, 0, 0, 0, 0, 0, 0, 118784, 118784, 0, 0, 0,
  1130716, 86019, 4, 5, 0, 1114112, 1814528, 1114112, 1847296, 1867776, 1900544, 1335296, 1110016, 1110016, 1110016,
  1110016, 1110016, 1404928, 1110016, 1110016, 1433600, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1495040,
  1515520, 1110016, 1527808, 1110016, 1110016, 1556480, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1712128, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1814528,
  1110016, 1110016, 1110016, 1847296, 1110016, 1867776, 1110016, 1110016, 1900544, 1110016, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1658880, 0, 1703936, 0, 1769472, 0, 1781760, 0, 1904640, 0, 1654784, 0, 0, 0, 0, 0, 0, 772, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  500, 0, 0, 0, 0, 0, 272, 0, 0, 1114112, 1376256, 1114112, 1114112, 1114112, 1114112, 1519616, 1114112, 1114112,
  1654784, 1769472, 1114112, 1810432, 1114112, 1474560, 1114112, 1114112, 1507328, 1114112, 1540096, 1114112, 1114112,
  1114112, 1114112, 1638400, 1650688, 1114112, 1114112, 1114112, 0, 1708032, 0, 1630208, 0, 1708032, 0, 0, 0, 0, 0,
  1581056, 0, 1110016, 1576960, 1593344, 1110016, 1110016, 1654784, 1658880, 1110016, 1110016, 1724416, 1110016,
  1110016, 1761280, 1110016, 1769472, 1110016, 1110016, 1810432, 1826816, 1110016, 1110016, 1810432, 1826816, 1110016,
  1110016, 1110016, 1110016, 1912832, 0, 0, 0, 0, 1110016, 1110016, 1110016, 1376256, 1110016, 1110016, 1110016,
  1110016, 1110016, 1454080, 1110016, 1110016, 1110016, 1110016, 1519616, 1110016, 1110016, 1576960, 1593344, 1110016,
  1110016, 1110016, 1110016, 1912832, 0, 0, 0, 0, 1421312, 0, 0, 1449984, 1486848, 0, 0, 0, 0, 0, 0, 163840, 163840,
  163840, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 1114112, 1114112, 1114112, 1449984, 1114112, 1114112, 1114112, 1114112,
  1114112, 1110016, 1110016, 1110016, 1110016, 0, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 0, 0, 0, 0, 0, 1765376, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1413120, 1445888, 1449984, 1110016, 1110016, 1486848, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1716224, 1110016, 1110016, 1765376, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1372160, 0, 0, 0, 0, 0, 0, 1720320, 0, 1875968, 1544192, 0, 1523712, 1503232, 1552384, 0, 0, 1748992, 0,
  1855488, 0, 1339392, 1753088, 1888256, 0, 0, 0, 1585152, 0, 0, 0, 0, 0, 840, 0, 841, 0, 0, 0, 0, 0, 0, 841, 0, 0, 0,
  0, 0, 1396736, 1597440, 0, 0, 1114112, 1396736, 1114112, 1114112, 1597440, 1114112, 1114112, 1114112, 1114112,
  1114112, 1114112, 1908736, 0, 1110016, 1110016, 1110016, 1110016, 1110016, 1388544, 1392640, 1110016, 1110016,
  1110016, 1425408, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1880064,
  1343488, 1110016, 1110016, 1396736, 1110016, 1110016, 1110016, 1478656, 1110016, 1110016, 1544192, 1597440, 1110016,
  1110016, 1110016, 1110016, 1110016, 1544192, 1597440, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1880064, 0, 1409024, 0, 0, 0, 1662976, 0, 1777664, 0, 0, 1871872, 0, 0, 0, 0, 0, 1732608,
  0, 0, 0, 0, 0, 1720, 0, 0, 0, 1724, 0, 0, 0, 0, 0, 0, 0, 278528, 0, 0, 0, 45056, 49152, 0, 0, 0, 1359872, 0, 1601536,
  1359872, 1409024, 1114112, 1601536, 1777664, 1110016, 1359872, 1368064, 1409024, 1110016, 1110016, 1110016, 1110016,
  232, 0, 0, 0, 232, 0, 233, 0, 0, 0, 233, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 268, 0, 0, 1531904, 1601536, 1662976,
  1740800, 1110016, 1777664, 1110016, 1110016, 1110016, 1871872, 1110016, 1359872, 1368064, 1409024, 1110016, 1110016,
  0, 0, 0, 1347584, 1110016, 1110016, 1110016, 1110016, 1785856, 1347584, 1110016, 1110016, 1110016, 1110016, 1110016,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110016, 1110016, 1531904, 1601536, 1662976, 1740800, 1110016, 1777664, 1110016,
  1110016, 1110016, 1871872, 0, 0, 0, 0, 0, 0, 807, 0, 0, 0, 0, 0, 813, 0, 0, 0, 0, 1679360, 0, 0, 0, 0, 1646592, 0,
  1916928, 1466368, 1466368, 1110016, 1458176, 1466368, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1638400, 1650688, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1863680,
  1110016, 1458176, 1466368, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1474560, 1110016, 1110016, 1110016, 1110016, 1507328, 1110016, 1110016, 1110016, 1110016,
  1540096, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1863680, 0, 0, 0,
  0, 0, 1683456, 0, 0, 0, 0, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1794048,
  1806336, 1110016, 1110016, 1110016, 1830912, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1908736,
  1110016, 1482752, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1380352, 0, 1437696, 1789952, 0, 0,
  0, 0, 0, 0, 208896, 208896, 208896, 0, 0, 2, 86019, 4, 5, 0, 1110016, 1110016, 1499136, 1110016, 1667072, 1110016,
  1110016, 1110016, 1789952, 1110016, 1110016, 1499136, 1110016, 1667072, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1757184, 1757184, 0, 0, 0, 0, 0, 0, 0, 0, 1363, 0, 0, 0, 0, 0, 0, 0, 0, 1390, 0, 367, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 887, 367, 1110016, 1789952, 1429504, 0, 0, 0, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 0, 0, 2191824, 1785856, 1441792, 0,
  1728512, 1110016, 1536000, 1744896, 1110016, 1110016, 1536000, 1744896, 1110016, 1560576, 1462272, 1110016, 1462272,
  0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106843, 106843, 106843, 0, 0, 2, 86019, 4, 5, 0, 0, 106843, 0, 0, 0, 106843,
  347, 347, 347, 347, 347, 347, 347, 347, 106843, 347, 106843, 106843, 106843, 106843, 106843, 106843, 106843, 106843,
  106843, 106843, 106843, 106843, 106843, 106843, 106843, 0, 0, 0, 0, 0, 1820, 0, 0, 0, 1824, 0, 0, 0, 0, 0, 0, 0, 1557,
  0, 0, 0, 0, 0, 0, 0, 1562, 0, 232, 114688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110657, 1110657, 0, 0, 272, 232,
  232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229376, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1114112, 1114112, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115004, 49152, 0, 0, 0, 0, 0, 0, 208896, 208896, 208896, 208896,
  208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 0, 0, 40960, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1126907, 232, 232, 232, 232, 232, 232, 0, 0, 232, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 213452, 213452, 213452, 213452, 0, 0, 0, 0, 1056768, 0, 0, 0, 0, 0, 0, 32768, 0, 0, 0, 0, 0, 0, 823,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 236, 0, 0, 0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 0, 0, 0, 0, 0, 0,
  1362, 0, 0, 0, 0, 0, 0, 0, 0, 499, 0, 0, 0, 0, 0, 0, 272, 0, 1130716, 86019, 4, 5, 224, 0, 0, 0, 0, 0, 224, 0, 0, 0,
  0, 0, 0, 856, 857, 0, 0, 0, 0, 0, 0, 0, 0, 825, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 118784, 118784, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1377, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 118784, 118784, 0, 0, 118784, 0,
  118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 0, 0, 118784, 0, 118784, 118784,
  118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 236, 0, 0, 0, 0, 272, 272, 0, 143360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 253952, 0, 0, 0, 0, 0, 0, 1056768, 0, 0, 0, 0, 0, 0, 0, 547, 0, 0, 0, 0, 0, 0, 274432, 274432, 0, 0, 0, 2, 86019,
  4, 5, 0, 0, 0, 0, 759, 763, 0, 1355776, 0, 0, 1384448, 0, 0, 0, 0, 0, 0, 0, 1374, 0, 0, 0, 0, 0, 1380, 0, 0, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1851392, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1241, 0, 0, 0, 0, 0, 2081, 415, 415, 2083, 415, 2085, 415, 415, 415, 415, 2090, 0, 1246, 0, 1110016, 1110016, 1351680,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 229376, 0, 5,
  0, 0, 272, 0, 0, 0, 0, 126976, 126976, 126976, 0, 0, 0, 0, 0, 0, 0, 1389, 0, 0, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 884, 367, 367, 367, 367, 367, 0, 126976, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 45056, 49152, 126976, 0, 0, 0, 0,
  0, 855, 0, 0, 0, 0, 0, 770, 0, 0, 0, 0, 0, 0, 1898, 0, 0, 0, 0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 126976,
  126976, 126976, 126976, 126976, 126976, 0, 0, 126976, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114688, 0,
  0, 272, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 131072, 0, 45056, 49152, 0, 131072, 0, 0, 131072, 0, 0, 0,
  131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 45056, 49152, 0, 245, 322, 0, 317, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1363968, 1110016, 1839104, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 975, 0, 0, 978,
  1110016, 1110016, 1355776, 0, 233, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 236, 0, 236, 0, 0, 272, 233, 233, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1060864, 0, 0, 0, 233, 233, 233, 233, 233, 233, 0, 0, 233, 0, 0, 2, 86019, 4, 5, 0,
  0, 0, 0, 0, 0, 69860, 69860, 69860, 69860, 0, 0, 0, 0, 0, 1056768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 230, 40960,
  230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 139494, 139494, 139494, 230, 230, 273, 230, 230, 139494, 230, 230,
  230, 230, 230, 276, 230, 230, 230, 230, 0, 0, 230, 230, 139494, 230, 230, 230, 230, 230, 230, 230, 230, 230, 139494,
  230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 139494, 230, 230, 139494, 139494,
  230, 230, 230, 230, 230, 230, 230, 230, 230, 139494, 230, 45056, 49152, 230, 230, 230, 230, 139494, 230, 139494,
  139494, 139494, 139494, 139494, 139494, 139494, 139494, 139494, 139494, 139494, 139494, 0, 0, 0, 0, 0, 126976, 0, 0,
  0, 0, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 241, 241, 0, 0, 0, 0, 0, 0, 230, 0, 230, 230, 230, 139494, 230,
  139494, 139494, 139494, 139494, 139494, 139494, 139540, 139540, 139540, 139540, 139540, 139540, 139494, 139494,
  139494, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 245760, 0, 0, 0, 0, 245760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 0, 0, 0,
  1126906, 1126906, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 272, 0, 0, 0, 0, 151552, 0, 0, 0, 0, 151552,
  151552, 0, 0, 0, 0, 0, 865, 0, 0, 0, 0, 0, 0, 0, 0, 0, 871, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151552, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 151552, 0, 0, 0, 151552, 151552, 151552, 151552, 151552, 151552, 151552, 151552, 151552, 151552,
  151552, 151552, 151552, 151552, 151552, 0, 0, 151552, 0, 0, 0, 151552, 151552, 151552, 151552, 0, 0, 0, 86019, 4, 5,
  122880, 272, 196608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 254, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  155648, 155648, 155648, 0, 0, 0, 0, 0, 126976, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1546, 0, 0, 0, 0, 0, 0, 155648,
  0, 0, 0, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648,
  155648, 155648, 0, 0, 0, 0, 0, 98741, 0, 0, 0, 155648, 0, 0, 155648, 0, 98741, 98741, 98741, 98741, 98741, 98741,
  155648, 155648, 98741, 0, 0, 2, 86019, 4, 5, 0, 0, 241664, 0, 0, 0, 0, 241664, 0, 0, 0, 1110016, 1839104, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 698, 0, 98304, 701, 1110016, 1110016, 1355776, 0, 0, 98304,
  1110016, 1110016, 1351680, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 0, 0, 233472, 0, 5, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 159744, 159744, 0, 0, 0, 0, 0, 147456,
  1056768, 232, 233, 0, 200704, 0, 0, 0, 0, 0, 0, 231, 232, 233, 0, 0, 0, 0, 0, 0, 0, 232, 233, 0, 0, 0, 0, 0, 473, 0,
  0, 159744, 0, 0, 0, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744,
  159744, 159744, 159744, 0, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 0, 0, 2, 86019, 4,
  5, 0, 0, 0, 0, 0, 1110016, 1110016, 1482752, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 237568, 0, 237568, 0, 5, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163840, 0, 163840, 163840,
  0, 40960, 163840, 0, 163840, 0, 163840, 0, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 163840, 0, 0, 0, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840,
  163840, 163840, 163840, 163840, 163840, 163840, 163840, 0, 0, 2, 221, 4, 5, 0, 225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1698, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 167936, 167936, 0, 0, 0, 0, 0, 1110657, 1110657,
  1483393, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110716, 1110716, 1110716, 1110716, 1110716,
  1110716, 1110716, 1110716, 1110716, 1110716, 0, 0, 0, 167936, 0, 0, 0, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 0, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 53466, 53466, 2, 0, 4, 5, 0, 0, 0, 0, 0, 1335296, 1110016, 1110016, 1110016, 1110016,
  1110016, 1404928, 1110016, 1110016, 1433600, 1110016, 0, 0, 0, 0, 0, 0, 1400832, 0, 0, 0, 0, 0, 0, 0, 1495040, 465, 0,
  0, 0, 0, 0, 1056768, 232, 233, 0, 0, 0, 0, 0, 0, 0, 232, 233, 0, 0, 0, 0, 0, 0, 0, 232, 233, 0, 0, 0, 0, 0, 0, 474,
  99281, 0, 0, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1665, 1318, 0, 0, 0, 0,
  0, 0, 1324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1583, 0, 0, 0, 0, 0, 367, 0, 1575, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367,
  0, 0, 0, 0, 415, 1763, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  1486, 438, 438, 438, 438, 438, 0, 1045, 0, 0, 0, 1051, 0, 0, 0, 0, 0, 0, 0, 888832, 0, 0, 0, 319, 319, 0, 0, 0, 438,
  438, 0, 1887, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 266240, 266240, 1913, 415, 415, 415, 415, 415, 415, 1919,
  415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 438, 438, 438, 438, 1969, 415, 1970, 1971, 415, 415, 415, 415,
  415, 415, 438, 438, 438, 438, 438, 438, 415, 415, 438, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  263, 0, 0, 0, 0, 438, 438, 1981, 438, 1982, 1983, 438, 438, 438, 438, 438, 438, 0, 0, 0, 0, 0, 0, 1800, 0, 0, 0, 0, 0,
  415, 415, 415, 2005, 415, 415, 415, 438, 2009, 438, 438, 438, 438, 438, 438, 2015, 2091, 438, 438, 438, 438, 438, 438,
  438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 308, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0, 0, 0, 0, 0, 278528, 278528,
  278528, 0, 0, 2, 86019, 4, 2191824, 0, 176589, 176589, 176589, 176589, 176589, 176589, 0, 0, 176589, 53466, 53466, 2,
  86019, 4, 5, 0, 0, 0, 0, 0, 1335996, 1110716, 1110716, 1110716, 1110716, 1110716, 1405628, 1110716, 1110716, 1434300,
  1110716, 0, 0, 0, 0, 0, 0, 1400832, 0, 0, 0, 0, 0, 0, 0, 1495040, 0, 0, 0, 0, 1057309, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1060864, 829, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1064960, 0, 0, 0, 40960, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 184668, 184668, 184668, 0, 0, 0, 0, 0, 1892352, 0, 1589248, 0, 0, 0, 1716224, 0, 1802240, 0, 1445888,
  0, 184668, 0, 0, 0, 184668, 0, 0, 0, 0, 0, 0, 0, 0, 184668, 0, 0, 0, 0, 259, 260, 261, 262, 0, 0, 0, 0, 0, 0, 0, 0,
  558, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 184668, 184668, 184668, 184668, 184668, 184668,
  184668, 184668, 184668, 184668, 184668, 184668, 184668, 184668, 184668, 0, 0, 0, 2, 86019, 4, 5, 0, 231, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284, 309, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0, 0, 0, 0, 0, 278528,
  278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 0,
  309, 309, 309, 309, 309, 309, 0, 0, 309, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 0, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1085, 0, 0, 0, 0, 0, 0, 0, 541, 309, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 835, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 835, 1121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 300, 438, 1314, 0,
  1316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1847296, 1867776, 1335296, 1643, 0, 0, 0, 0, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 0, 0, 0, 53466, 5, 0, 0, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 0, 0, 0, 236,
  236, 236, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 232, 232, 232, 0, 40960, 0, 0, 0, 0, 0, 0, 236, 0, 0, 0, 0, 0, 0,
  0, 232, 233, 0, 0, 0, 0, 472, 0, 0, 0, 0, 235, 0, 235, 0, 235, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1725, 1726, 0, 0, 0, 0,
  147456, 1126907, 0, 147456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 233, 233, 233, 0, 1110657, 1110657, 1356417,
  1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1512065, 1643137,
  1110657, 1110657, 1671809, 1110657, 1110657, 1708673, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657,
  1110657, 1110657, 1794689, 1806977, 1110657, 1110657, 1110657, 1831553, 1110657, 1110657, 1839745, 1110657, 1110657,
  1110657, 1110657, 1110657, 1110657, 1110657, 698, 0, 0, 701, 1110716, 1110716, 1356476, 1110716, 1548988, 1110716,
  1565372, 1110716, 1573564, 1110716, 1110716, 1614524, 1110716, 1110716, 1630908, 1643196, 1110716, 1110716, 1671868,
  1110716, 1110716, 1708732, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716,
  1839804, 1110716, 1110716, 0, 0, 0, 1348225, 1110657, 1110657, 1110657, 1110657, 1786497, 1348284, 1110716, 1110716,
  1110716, 1110716, 1913532, 0, 0, 0, 0, 1421312, 0, 0, 1449984, 1486848, 0, 0, 0, 0, 0, 0, 888832, 888832, 888832,
  888832, 888832, 888832, 888832, 888832, 888832, 888832, 888832, 888832, 888832, 888832, 888832, 0, 1110657, 1110657,
  1507969, 1110657, 1110657, 1110657, 1110657, 1540737, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657,
  1110657, 1495681, 1516161, 1110657, 1528449, 1110657, 1110657, 1557121, 1110657, 1110657, 1110657, 1110657, 1639041,
  1651329, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657,
  1110657, 1110657, 1110657, 1110657, 1475201, 1110657, 1110657, 0, 0, 0, 1110716, 1110716, 1352380, 1110716, 1110716,
  1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1852092, 1110716, 1110716,
  1110716, 1110657, 1110657, 1569409, 1110657, 1110657, 1110657, 1110657, 1606273, 1110657, 1618561, 1622657, 1110657,
  1110657, 1110657, 1688193, 1700481, 0, 1110716, 1110716, 1110716, 1110716, 1110716, 1389244, 1393340, 1110716,
  1110716, 1110716, 1426108, 1110716, 1110716, 1110716, 1110716, 1110716, 1454780, 1110716, 1110716, 1110716, 1110716,
  1520316, 1110716, 1110716, 1577660, 1594044, 1110716, 1606332, 1110716, 1618620, 1622716, 1110716, 1110716, 1110716,
  1688252, 1700540, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1639100, 1651388, 1110716, 1110716,
  1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1512124, 1110716, 1110716, 1110716,
  1110716, 1110716, 1110716, 1794748, 1807036, 1110716, 1110716, 1110716, 1831612, 1110716, 1110716, 1110716, 1110716,
  1110716, 1110716, 1110716, 1909436, 1114112, 1814528, 1114112, 1847296, 1867776, 1900544, 1335937, 1110657, 1110657,
  1110657, 1110657, 1110657, 1405569, 1110657, 1110657, 1434241, 1110657, 1110657, 1847937, 1110657, 1868417, 1110657,
  1110657, 1901185, 1110657, 0, 0, 0, 0, 0, 0, 0, 232, 233, 0, 0, 0, 471, 0, 0, 0, 1110716, 1847996, 1110716, 1868476,
  1110716, 1110716, 1901244, 1110716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1956, 1957, 0, 0, 1960, 0, 0, 1110657, 1577601,
  1593985, 1110657, 1110657, 1655425, 1659521, 1110657, 1110657, 1725057, 1110657, 1110657, 1761921, 1110657, 1770113,
  1110657, 1110657, 1426049, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1491585, 1110657, 1110657,
  1110657, 1110657, 1110657, 1110657, 1864321, 1110716, 1458876, 1467068, 1110716, 1110716, 1110716, 1110716, 1110716,
  1110716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110657, 1811073, 1827457, 1110657, 1110657, 1110657, 1110657, 1913473,
  0, 0, 0, 0, 1110716, 1110716, 1110716, 1376956, 1110716, 1655484, 1659580, 1110716, 1110716, 1725116, 1110716,
  1110716, 1761980, 1110716, 1770172, 1110716, 1110716, 1811132, 1827516, 1110716, 0, 1417216, 0, 0, 1773568, 0, 0, 0,
  0, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1852033, 1110657, 1110657, 1110657, 1110657, 1110657,
  1110657, 1110657, 0, 0, 0, 0, 0, 1114112, 1114112, 1114112, 1449984, 1114112, 1114112, 1114112, 1114112, 1114112,
  1110657, 1110657, 1110657, 1110657, 699, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716,
  1110716, 1110716, 1110716, 0, 0, 0, 0, 5, 1110657, 1413761, 1446529, 1450625, 1110657, 1110657, 1487489, 1110657,
  1110657, 1110657, 1110657, 1110657, 1110657, 1716865, 1110657, 1110657, 1110657, 1110657, 1110657, 1712769, 1110657,
  1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1815169, 1766017, 1110657, 1110657, 1110657,
  1110657, 1110657, 1110657, 1110716, 1110716, 1110716, 1110716, 1110716, 1413820, 1446588, 1450684, 1110716, 1110657,
  1110716, 1110657, 1110716, 1110657, 1110716, 1757825, 1757884, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 2, 86019, 4, 5, 0,
  1110716, 1487548, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1716924, 1110716, 1110716, 1766076, 1110716,
  1110716, 1110716, 1110716, 1475260, 1110716, 1110716, 1110716, 1110716, 1508028, 1110716, 1110716, 1110716, 1110716,
  1540796, 1110716, 1110716, 1344129, 1110657, 1110657, 1397377, 1110657, 1110657, 1110657, 1479297, 1110657, 1110657,
  1544833, 1598081, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1880705, 1344188, 1110716, 1110716, 1397436,
  1110716, 1110716, 1110716, 1479356, 1110716, 1110716, 1544892, 1598140, 1110716, 1110716, 1110716, 1110716, 1110716,
  1110716, 1110716, 1110716, 1110716, 1110716, 1880764, 0, 1409024, 1359872, 0, 1601536, 1359872, 1409024, 1114112,
  1601536, 1777664, 1110657, 1360513, 1368705, 1409665, 1110657, 1110657, 1110657, 1110657, 1110657, 1110657, 1909377,
  1110657, 0, 0, 0, 0, 1073152, 0, 0, 0, 1532545, 1602177, 1663617, 1741441, 1110657, 1778305, 1110657, 1110657,
  1110657, 1872513, 1110716, 1360572, 1368764, 1409724, 1110716, 1110716, 1372160, 0, 0, 0, 0, 0, 0, 1720320, 0,
  1875968, 1544192, 0, 1523712, 1503232, 0, 1679360, 0, 0, 0, 0, 1646592, 0, 1916928, 1466368, 1466368, 1110657,
  1458817, 1467009, 1110657, 1110657, 1110657, 1376897, 1110657, 1110657, 1110657, 1110657, 1110657, 1454721, 1110657,
  1110657, 1110657, 1110657, 1520257, 1110657, 1110716, 1110716, 1864380, 0, 0, 0, 0, 0, 1683456, 0, 0, 0, 0, 1110657,
  1110657, 1110657, 1110657, 1110657, 1548929, 1110657, 1565313, 1110657, 1573505, 1110657, 1110657, 1614465, 1110657,
  1110657, 1630849, 1110716, 1483452, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1380352, 0,
  1437696, 1789952, 0, 0, 0, 0, 0, 0, 1056768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110657, 1110657, 1499777, 1110657,
  1667713, 1110657, 1110657, 1110657, 1790593, 1110716, 1110716, 1499836, 1110716, 1667772, 1110716, 1110716, 1532604,
  1602236, 1663676, 1741500, 1110716, 1778364, 1110716, 1110716, 1110716, 1872572, 0, 0, 0, 0, 0, 0, 867, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 859, 0, 769, 859, 0, 0, 862, 1110716, 1790652, 1429504, 0, 0, 0, 1110657, 1110657, 1110657, 1110657,
  1110657, 1110657, 1110716, 1110716, 1110716, 1110716, 1491644, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716,
  1110716, 1569468, 1110716, 1110716, 1110716, 1110716, 1110716, 1495740, 1516220, 1110716, 1528508, 1110716, 1110716,
  1557180, 1110716, 1110716, 1110716, 1110716, 1712828, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716, 1110716,
  1110716, 1110716, 1815228, 1110716, 1786556, 1441792, 0, 1728512, 1110657, 1536641, 1745537, 1110657, 1110716,
  1536700, 1745596, 1110716, 1560576, 1462913, 1110657, 1462972, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 208896, 0,
  0, 208896, 208896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 0, 282, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 208896, 0, 0, 0,
  208896, 0, 0, 0, 0, 0, 0, 1065, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 57344, 0, 0, 0, 28672, 0, 0,
  1540096, 0, 1638400, 0, 0, 0, 0, 0, 0, 1096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 884736, 0, 0, 0, 1114112, 1114112, 57344,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 1110016, 232, 0, 233, 0, 0, 0, 1400832, 0, 0, 0, 0, 0, 0, 0,
  1495040, 1110016, 1110016, 1847296, 1110016, 1867776, 1110016, 1110016, 1900544, 1110016, 698, 0, 0, 0, 698, 0, 701,
  0, 0, 0, 701, 0, 1335296, 1110016, 1110016, 1110016, 1110016, 1110016, 1404928, 1110016, 1110016, 1433600, 1110016, 0,
  1417216, 0, 0, 1773568, 0, 0, 0, 0, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1851392, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 1110016,
  1810432, 1826816, 1110016, 1110016, 1110016, 1110016, 1912832, 698, 0, 701, 0, 1110016, 1110016, 1110016, 1376256,
  1810432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1519616, 0, 0, 0, 0, 0, 1708, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 45056,
  49152, 0, 0, 0, 0, 213321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 213341, 213341, 213341, 0, 0, 0, 0, 290, 0, 291, 292, 294,
  258, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 0, 0, 2,
  86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 213341, 0, 0, 0, 213341, 213341, 213341, 213341, 213341, 213341,
  213341, 213341, 213341, 213341, 213341, 213341, 213341, 213341, 213341, 0, 213452, 213452, 213452, 213452, 213452,
  213452, 213341, 213341, 213454, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 495, 496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 277, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 241664, 241664, 241664, 0, 0, 2, 86019, 4, 5,
  0, 0, 241664, 0, 0, 0, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664,
  241664, 241664, 241664, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246110, 246110, 246110, 0, 0, 2, 86019, 0, 5, 0, 0,
  246110, 0, 0, 0, 246110, 246110, 246110, 246110, 246110, 246110, 246110, 246110, 246110, 246110, 246110, 246110,
  246110, 246110, 246110, 0, 0, 262144, 0, 0, 0, 0, 1056768, 232, 233, 192512, 0, 0, 0, 0, 0, 0, 0, 1569, 0, 0, 1570, 0,
  0, 0, 0, 0, 172032, 282624, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 0, 0, 0, 0, 0, 0, 1710, 0, 0, 0, 0, 0, 0, 0, 0,
  249, 279, 0, 279, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258048, 0, 0, 258048, 0, 258048, 0, 0, 258048,
  0, 0, 258048, 0, 0, 0, 0, 0, 2, 86019, 1138910, 5, 0, 0, 0, 0, 226, 0, 0, 0, 0, 226, 0, 266240, 266240, 266240,
  266240, 266240, 266240, 0, 0, 266240, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 512, 0, 0, 0, 0, 574, 0, 586, 640, 0, 415,
  645, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 0, 0, 0, 0, 428, 415, 415, 415, 415, 438, 415, 415, 415,
  415, 415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 0, 0, 0, 0, 1121, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 261, 0, 0, 0, 99281, 0, 1245, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  1527, 438, 0, 0, 0, 0, 1819, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 317, 317, 0, 0, 0, 0, 0, 0, 1121, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1127, 1121, 0, 0, 0, 0, 0, 1373, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1825, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0,
  0, 332, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 415, 415, 415, 415, 415, 415, 1967, 415, 436, 436, 436, 415,
  439, 436, 436, 436, 436, 436, 436, 436, 436, 439, 439, 439, 439, 439, 439, 436, 436, 439, 53466, 53466, 2, 86019, 4,
  5, 0, 0, 0, 1717, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288, 305, 0, 53467, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 532, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274432, 274432, 274432, 0, 0, 0, 0, 514, 0, 0, 0,
  573, 0, 580, 0, 631, 0, 0, 0, 0, 0, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1072, 0, 0, 274432, 0, 0, 0,
  274432, 0, 0, 0, 0, 0, 0, 0, 0, 274432, 0, 0, 0, 0, 525, 0, 0, 528, 0, 0, 0, 0, 0, 0, 0, 0, 809, 0, 0, 0, 0, 0, 0, 0,
  274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432, 274432,
  274432, 0, 0, 0, 0, 536, 484, 0, 0, 0, 531, 0, 0, 0, 0, 415, 415, 415, 415, 415, 415, 415, 2037, 438, 438, 438, 438,
  438, 438, 438, 438, 998, 438, 438, 438, 1002, 438, 438, 438, 1552384, 0, 0, 1748992, 0, 1855488, 0, 1339392, 1753088,
  1888256, 221184, 0, 0, 1585152, 0, 0, 0, 0, 0, 1064, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1350, 0, 0, 0, 0, 0, 0, 2, 86019,
  4, 223, 0, 0, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 253, 0, 253, 0, 0, 0, 0, 0, 0, 0, 767, 0, 0, 769, 0, 0, 0, 0, 0, 0,
  40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278528, 0, 0, 0, 0, 0, 0, 1146, 0, 367, 367, 367, 1149, 367, 367, 367, 367, 367,
  367, 1592, 367, 367, 367, 1594, 367, 367, 367, 1597, 367, 0, 0, 466, 0, 0, 0, 1056768, 232, 233, 0, 0, 0, 0, 0, 0, 0,
  237, 0, 237, 304, 237, 0, 0, 0, 0, 0, 0, 237, 0, 280, 0, 237, 237, 280, 0, 0, 0, 0, 0, 0, 0, 293, 0, 0, 0, 0, 0, 293,
  0, 0, 0, 0, 0, 311, 313, 280, 0, 0, 280, 0, 0, 45056, 49152, 280, 0, 0, 0, 0, 0, 1079, 0, 0, 0, 1083, 0, 0, 0, 0, 0,
  0, 0, 1822, 0, 0, 0, 0, 0, 0, 0, 0, 1123, 0, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 237, 0, 339, 341, 351, 351,
  351, 368, 351, 368, 368, 368, 351, 391, 391, 391, 391, 391, 391, 391, 405, 391, 405, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 368, 391, 391, 391, 391, 416, 416, 416, 416, 440, 416, 416, 416, 416, 416, 416, 416, 416, 440,
  440, 440, 440, 440, 440, 416, 416, 440, 53466, 53466, 2, 86019, 4, 5, 0, 475, 476, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 263, 0, 491, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 1363968, 272, 272, 0, 0, 0, 510, 0,
  0, 0, 0, 0, 0, 0, 518, 0, 0, 0, 0, 0, 1095, 0, 0, 0, 0, 1100, 0, 0, 0, 0, 0, 0, 556, 0, 0, 0, 0, 0, 0, 0, 0, 0, 843,
  0, 0, 0, 0, 0, 0, 537, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 0, 548, 0, 0, 0, 0, 0, 0, 1056768, 232, 233, 0, 0, 0, 0, 0, 0,
  0, 0, 1582, 0, 0, 0, 0, 0, 0, 367, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 560, 0, 0, 0, 0, 0, 0, 1323, 0, 0, 0, 1327, 0,
  0, 0, 0, 0, 0, 471, 0, 471, 0, 0, 0, 0, 0, 0, 0, 796, 0, 272, 272, 798, 0, 0, 0, 0, 566, 0, 0, 0, 0, 572, 0, 0, 510,
  0, 0, 0, 0, 0, 0, 576, 0, 0, 576, 0, 0, 0, 475, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53466, 53466, 2, 86019, 4, 5, 0, 367, 598,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 621, 367, 367, 367, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 827, 0, 0,
  636, 637, 0, 0, 0, 0, 0, 510, 0, 537, 510, 0, 415, 415, 415, 415, 415, 415, 415, 973, 415, 698, 99281, 909, 701, 980,
  438, 438, 0, 0, 0, 0, 0, 1891, 0, 0, 0, 0, 0, 0, 0, 0, 247, 248, 0, 0, 0, 0, 0, 0, 415, 647, 415, 415, 415, 415, 415,
  671, 415, 675, 415, 680, 415, 683, 415, 415, 415, 415, 415, 415, 415, 1187, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 957, 958, 415, 415, 415, 415, 415, 694, 415, 415, 415, 0, 438, 438, 438, 438, 707, 438, 438, 438, 438, 438, 731,
  438, 735, 438, 740, 438, 743, 438, 438, 754, 438, 438, 0, 0, 0, 53466, 5, 0, 0, 0, 760, 764, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 582, 0, 0, 0, 0, 0, 0, 0, 792, 0, 0, 0, 0, 0, 272, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1126906,
  415, 415, 965, 415, 415, 415, 415, 415, 415, 698, 99281, 909, 701, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415,
  2028, 415, 367, 367, 367, 1172, 367, 367, 367, 0, 0, 0, 0, 0, 909, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 1210, 415, 415, 415, 415, 415, 1233, 415, 415, 415, 415, 415, 415, 415, 415, 1242, 1245,
  99281, 1247, 1245, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1883, 438, 1263, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1679, 1294, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 1306, 438, 438, 438, 438, 0, 0, 1049, 0, 0, 0, 0, 0, 1055, 0, 0, 0, 0, 0, 1385, 0, 0, 1387, 0, 0, 0, 0, 367,
  367, 367, 367, 1395, 1396, 1422, 415, 415, 415, 1425, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 941, 415,
  415, 945, 415, 415, 415, 415, 415, 415, 1440, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1853, 1854, 415,
  415, 415, 415, 415, 415, 415, 415, 1451, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 940, 415, 415, 415, 415,
  415, 438, 1314, 0, 1316, 0, 0, 1530, 0, 0, 0, 0, 0, 1535, 0, 0, 0, 0, 0, 0, 1056768, 232, 20950, 0, 0, 0, 0, 0, 0, 0,
  0, 151552, 0, 151552, 151552, 0, 0, 0, 0, 0, 1564, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1572, 0, 0, 0, 0, 0, 1111, 0,
  1113, 0, 0, 0, 0, 0, 0, 0, 0, 574, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1694, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1700, 0, 0, 0, 0, 0,
  1145, 0, 0, 367, 367, 367, 367, 367, 367, 367, 1154, 438, 438, 438, 1784, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 0, 0, 0, 1991, 415, 415, 415, 415, 1846, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 942,
  415, 415, 415, 946, 415, 415, 1858, 415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438, 1869, 438, 438, 438,
  2018, 0, 2020, 0, 0, 0, 0, 2024, 0, 2026, 415, 415, 415, 415, 0, 438, 438, 438, 438, 438, 438, 714, 438, 438, 727,
  438, 0, 0, 2078, 0, 2080, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438,
  1938, 239, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0, 0, 0, 0, 312, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0,
  0, 321, 0, 40960, 0, 321, 0, 0, 0, 0, 0, 0, 0, 312, 0, 0, 0, 369, 0, 369, 369, 369, 321, 312, 312, 312, 312, 312, 312,
  312, 312, 312, 312, 369, 312, 312, 312, 312, 417, 417, 417, 417, 417, 441, 417, 417, 417, 417, 417, 417, 417, 417,
  441, 441, 441, 441, 441, 441, 417, 417, 441, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 0, 1109, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 267, 0, 0, 0, 0, 0, 0, 1121, 0, 0, 0, 0, 0, 0, 0, 0, 1125, 0, 0, 0, 0, 0, 0, 1056768, 468, 469, 0, 0, 0,
  0, 0, 0, 0, 0, 1810, 0, 0, 0, 0, 0, 0, 0, 0, 1823, 0, 0, 0, 0, 0, 1828, 0, 367, 1169, 367, 367, 367, 367, 367, 0, 0,
  0, 0, 0, 909, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 928, 415, 415, 415, 415, 1228, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 1245, 367, 367, 1589, 367, 367, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 367, 367, 898, 367, 899, 1643, 0, 0, 0, 0, 438, 438, 438, 1647, 438, 1649, 438, 438, 438, 438, 438, 0, 1046,
  0, 0, 0, 1052, 0, 0, 0, 0, 0, 0, 299, 0, 303, 0, 0, 0, 0, 0, 306, 0, 2060, 415, 2062, 415, 438, 438, 438, 438, 2068,
  438, 2070, 438, 2072, 438, 0, 0, 0, 0, 0, 0, 0, 1531, 0, 0, 0, 0, 0, 0, 0, 1066, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163840, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 241, 242, 243, 244, 245, 246, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1126906, 1126906, 0, 0, 0, 0,
  1363968, 323, 40960, 323, 322, 330, 323, 330, 0, 330, 330, 330, 342, 352, 352, 352, 370, 385, 370, 370, 370, 388, 392,
  392, 392, 403, 403, 404, 404, 392, 404, 392, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 370, 404, 404, 404,
  404, 418, 418, 418, 418, 442, 418, 418, 418, 418, 418, 418, 418, 418, 442, 442, 442, 442, 442, 442, 418, 418, 442,
  53466, 53466, 2, 86019, 4, 5, 0, 802, 775, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 367, 850, 0, 0, 0, 0, 0,
  0, 0, 858, 0, 858, 0, 0, 0, 0, 0, 0, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 810, 0, 812, 0, 0, 0, 0, 0, 367, 367, 875, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 886, 367, 367, 367, 0, 788, 0, 0, 906, 787, 0, 0, 0, 0, 0, 0, 0, 485, 0, 0, 0,
  0, 0, 0, 0, 0, 415, 415, 909, 415, 911, 913, 415, 415, 415, 415, 415, 922, 415, 927, 415, 415, 415, 415, 0, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 1487, 438, 438, 1490, 415, 933, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 0, 0, 0, 1060, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 594, 1155, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 900, 438, 438, 1265, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 1274, 438, 0, 0, 0, 0, 0, 2050, 0, 0, 0, 415, 415, 415, 415, 415, 415, 415, 415, 1975, 415, 438,
  438, 438, 438, 438, 438, 1776, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1031, 438, 438, 438, 438, 438, 438, 415,
  415, 415, 1755, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1752, 415, 415, 0, 1831, 0, 367, 367,
  367, 367, 367, 367, 1838, 367, 367, 415, 415, 415, 415, 0, 438, 438, 438, 438, 438, 438, 438, 438, 438, 725, 438, 415,
  415, 415, 415, 1929, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438, 438, 756, 438, 0, 0, 0, 53466, 5, 438, 2047, 0,
  2048, 0, 0, 0, 0, 0, 0, 415, 415, 415, 2057, 415, 415, 415, 415, 415, 415, 415, 1453, 415, 415, 415, 415, 415, 415,
  415, 1458, 415, 415, 415, 415, 438, 438, 438, 2067, 438, 438, 438, 438, 438, 438, 0, 0, 1047, 0, 0, 0, 1053, 0, 0, 0,
  0, 0, 0, 248, 301, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 0, 0, 0, 0, 1056768, 20947, 233, 0, 0, 0, 0, 0, 0, 0, 0, 1711,
  0, 0, 0, 1714, 0, 0, 0, 0, 40960, 0, 282, 0, 0, 0, 333, 0, 0, 340, 343, 353, 353, 353, 371, 353, 371, 371, 371, 389,
  393, 393, 393, 393, 393, 393, 393, 393, 393, 393, 371, 393, 393, 393, 393, 419, 419, 419, 419, 419, 443, 419, 419,
  419, 419, 419, 419, 419, 419, 443, 443, 443, 443, 443, 443, 419, 419, 443, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 0,
  582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 367, 367, 367, 582, 0, 0, 0, 0, 0, 582, 0, 0, 0, 0, 0, 0,
  0, 415, 415, 415, 415, 415, 415, 415, 1465, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 555, 0, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0,
  0, 233, 1355776, 0, 0, 1384448, 0, 0, 0, 0, 0, 0, 0, 1544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 872448, 872448, 0, 0, 0, 872448,
  0, 872, 367, 874, 367, 367, 367, 367, 367, 367, 367, 367, 885, 367, 367, 367, 367, 367, 609, 367, 367, 367, 367, 619,
  367, 367, 624, 367, 367, 909, 415, 912, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 931, 415, 415, 415,
  415, 415, 415, 1200, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1630, 415, 415, 415, 415, 415, 415, 947, 415,
  415, 949, 415, 951, 415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 1470, 0, 0, 0, 0, 1019, 438, 1021, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1017, 438, 438, 0, 0, 1108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 534, 0, 0, 0, 1319, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 415, 0, 0, 1344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 546, 415, 415, 0, 1356, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 489, 0, 415, 415, 415, 1462, 1463, 415,
  415, 415, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 0, 0, 0, 0, 0, 0, 1336, 0, 0, 0, 0, 0, 0, 0,
  0, 483, 484, 0, 0, 0, 0, 0, 0, 1587, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1408,
  1643, 0, 0, 0, 0, 438, 438, 1646, 438, 438, 438, 438, 438, 438, 438, 438, 1303, 1304, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 1785, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 541, 0, 53466, 5, 0, 0, 0, 0,
  1897, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 845, 0, 0, 0, 0, 415, 415, 415, 415, 415, 1930, 415, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 1270, 438, 438, 438, 438, 438, 438, 0, 0, 0, 279, 0, 281, 0, 0, 0, 0, 0, 0, 0, 249, 281, 252, 279,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 535, 0, 0, 40960, 0, 0, 0, 252, 251, 0, 0, 251, 251, 344, 354, 364, 354,
  372, 354, 372, 372, 372, 354, 394, 394, 394, 394, 394, 394, 394, 406, 394, 406, 394, 394, 394, 394, 394, 394, 394,
  394, 394, 394, 372, 394, 394, 394, 394, 420, 420, 420, 420, 444, 420, 420, 420, 420, 420, 420, 420, 420, 444, 444,
  444, 444, 444, 444, 420, 420, 444, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 523, 0, 0, 0, 0, 0, 0, 0, 0, 0, 533, 0, 0,
  0, 0, 0, 0, 1581056, 0, 0, 0, 0, 0, 1695744, 0, 0, 0, 0, 0, 0, 1954, 0, 0, 0, 0, 0, 0, 0, 0, 1961, 567, 568, 0, 570,
  0, 0, 573, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 0, 0, 0, 0, 0, 580, 0, 585, 0, 588, 0, 0, 0, 0, 0, 588, 0,
  367, 367, 367, 367, 367, 367, 367, 882, 367, 367, 367, 367, 367, 367, 367, 415, 1601, 415, 415, 415, 415, 415, 1606,
  415, 415, 597, 367, 600, 367, 367, 608, 367, 614, 367, 617, 367, 620, 367, 367, 367, 367, 367, 610, 367, 615, 367,
  367, 367, 367, 622, 367, 367, 367, 646, 415, 650, 415, 415, 662, 415, 672, 415, 676, 415, 415, 682, 685, 689, 415,
  415, 415, 415, 415, 415, 1614, 415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 0, 0, 0, 438, 736, 438, 438,
  742, 745, 749, 438, 438, 438, 438, 0, 0, 0, 53466, 5, 0, 0, 777, 0, 0, 0, 0, 0, 782, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0,
  0, 0, 0, 0, 575, 0, 367, 902, 367, 0, 0, 0, 0, 0, 0, 0, 870, 0, 0, 0, 0, 0, 0, 305, 0, 0, 0, 0, 45056, 49152, 0, 0, 0,
  932, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 944, 415, 415, 415, 415, 415, 415, 415, 1627, 415,
  415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 1471, 1245, 0, 0, 0, 415, 415, 966, 415, 415, 415, 972, 415, 415, 698,
  99281, 909, 701, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2027, 415, 415, 438, 438, 1042, 438, 438, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1057, 0, 0, 0, 0, 542, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 487, 488, 0, 0, 1059, 0, 0, 0, 0, 0, 0, 0, 0,
  1068, 0, 0, 0, 0, 0, 1073, 1074, 0, 1076, 1077, 0, 0, 1080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1576960, 0, 0, 1818624, 0,
  0, 1090, 0, 0, 0, 0, 0, 0, 0, 1098, 0, 0, 0, 0, 1103, 0, 1105, 0, 1120, 0, 1121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  297, 0, 0, 0, 0, 0, 1143, 0, 0, 0, 0, 0, 1147, 367, 1148, 367, 1150, 367, 367, 367, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 860, 367, 367, 1156, 367, 367, 1158, 367, 367, 367, 367, 1162, 367, 367, 367, 1166, 367, 0, 367, 367, 367, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1179, 415, 415, 1182, 415, 415, 415, 415, 415, 415, 415, 1191, 415, 415, 415, 415, 0,
  438, 438, 438, 438, 438, 438, 438, 438, 723, 438, 438, 1195, 415, 415, 415, 1198, 415, 415, 415, 415, 415, 415, 415,
  1205, 1207, 415, 415, 415, 415, 415, 415, 415, 1747, 415, 415, 415, 415, 415, 415, 415, 415, 0, 1469, 0, 0, 1245, 0,
  1475, 0, 415, 415, 415, 1214, 1215, 415, 1217, 1218, 415, 415, 415, 415, 415, 415, 1225, 415, 415, 415, 415, 415, 415,
  1626, 415, 415, 415, 415, 415, 415, 415, 415, 415, 698, 99281, 909, 701, 438, 981, 983, 1227, 415, 415, 415, 415, 415,
  415, 1234, 415, 415, 415, 415, 415, 1240, 0, 1245, 99281, 0, 1245, 1250, 1251, 438, 1252, 438, 438, 1255, 438, 438,
  438, 438, 438, 438, 752, 438, 438, 438, 438, 0, 0, 0, 53466, 5, 438, 1264, 438, 438, 438, 438, 1268, 438, 438, 438,
  1271, 438, 438, 438, 438, 438, 744, 438, 438, 438, 438, 438, 0, 0, 0, 53466, 5, 438, 438, 1278, 1280, 438, 438, 438,
  438, 438, 1287, 1288, 438, 1290, 1291, 438, 438, 0, 0, 0, 0, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438, 0, 0,
  0, 1798, 0, 0, 0, 0, 0, 1801, 0, 0, 438, 438, 438, 1313, 0, 1314, 0, 0, 0, 0, 0, 1316, 0, 0, 0, 0, 0, 0, 1335, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 295, 0, 0, 0, 0, 0, 0, 1121, 0, 0, 0, 0, 1372, 0, 0, 0, 0, 0, 0, 1379, 0, 1381, 0, 0, 0, 0, 542,
  0, 0, 545, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1798144, 0, 0, 0, 0, 0, 1859584, 0, 1384, 0, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367,
  367, 367, 367, 1912, 367, 367, 367, 1399, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1165, 367,
  367, 415, 1423, 415, 415, 415, 415, 415, 1428, 415, 1430, 415, 415, 415, 415, 415, 415, 415, 415, 1641, 0, 1643, 0,
  438, 438, 438, 438, 415, 415, 1448, 1449, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1192, 415, 415,
  415, 415, 415, 415, 415, 415, 1464, 415, 415, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 265, 0, 0, 0, 0, 0, 0, 0, 298, 0, 299,
  1491, 438, 1493, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1513, 438, 438, 1538, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 774, 0, 0, 1553, 0, 0, 0, 1556, 0, 0, 0, 1558, 1559, 0, 0, 0, 0, 0, 0, 1388, 0, 0, 0,
  1392, 367, 1394, 367, 367, 367, 367, 1588, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1164,
  367, 367, 367, 1599, 367, 367, 367, 367, 367, 415, 415, 415, 415, 1604, 415, 415, 415, 415, 415, 415, 415, 438, 438,
  438, 438, 2011, 438, 438, 438, 438, 415, 415, 1610, 415, 1612, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  943, 415, 415, 415, 415, 415, 561567, 415, 1623, 415, 1625, 415, 415, 415, 1629, 415, 415, 415, 415, 1634, 415, 415,
  415, 415, 415, 415, 1639, 415, 415, 0, 1641, 0, 0, 0, 0, 0, 0, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1114, 0, 0, 0, 0, 0, 0,
  415, 415, 415, 415, 415, 1638, 415, 415, 415, 0, 1641, 0, 0, 0, 0, 0, 0, 481, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1540096,
  0, 1638400, 0, 0, 0, 0, 1643, 0, 0, 0, 0, 438, 438, 438, 438, 1648, 438, 438, 438, 438, 438, 438, 996, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 1010, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1946, 438, 438, 438, 438, 0, 0, 438,
  1654, 438, 1656, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 1989, 0, 0, 561590, 438, 1667, 438,
  1669, 438, 438, 438, 1673, 438, 438, 438, 438, 1678, 438, 438, 0, 0, 0, 0, 415, 415, 415, 415, 2122, 415, 438, 438,
  438, 438, 438, 1683, 438, 438, 0, 0, 0, 0, 0, 1690, 0, 0, 438, 438, 438, 438, 1682, 438, 438, 438, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 415, 415, 415, 0, 0, 1705, 0, 0, 0, 0, 0, 0, 1712, 0, 0, 0, 0, 0, 0, 0, 1955, 0, 0, 0, 0, 0, 0, 0, 0,
  1067, 0, 0, 0, 0, 1071, 0, 0, 1730, 0, 367, 367, 367, 367, 367, 367, 367, 367, 1738, 367, 367, 367, 367, 367, 367,
  1175, 0, 0, 0, 0, 0, 909, 415, 415, 415, 415, 415, 415, 415, 1756, 415, 415, 415, 415, 415, 415, 415, 415, 1761, 415,
  415, 415, 415, 415, 415, 415, 1757, 415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 1245, 0, 0, 0, 438, 438, 438,
  1774, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1034, 438, 438, 438, 1783, 438, 438, 438, 438, 438,
  438, 438, 438, 1788, 438, 438, 438, 438, 438, 438, 1496, 438, 438, 438, 1500, 438, 438, 438, 438, 438, 0, 0, 1806, 0,
  0, 0, 0, 0, 0, 1811, 1812, 0, 1813, 0, 0, 0, 0, 0, 269, 0, 0, 269, 0, 0, 45056, 49152, 269, 0, 0, 1815, 0, 0, 1818, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1829, 1830, 0, 0, 367, 1834, 367, 367, 367, 1837, 367, 1839, 367, 415, 415, 415, 1844,
  415, 1857, 1859, 415, 415, 1862, 1863, 438, 438, 438, 1867, 438, 438, 438, 438, 438, 748, 438, 438, 438, 438, 438, 0,
  0, 0, 53466, 5, 438, 438, 1872, 438, 438, 1875, 438, 438, 438, 438, 438, 438, 1880, 1882, 438, 438, 0, 0, 0, 0, 415,
  415, 2120, 2121, 415, 415, 438, 438, 2126, 2127, 1885, 1886, 0, 0, 0, 0, 1890, 0, 1892, 0, 0, 0, 0, 0, 0, 0, 588, 588,
  0, 0, 631, 0, 0, 415, 415, 1903, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 367, 367, 367, 367, 415, 415, 415, 415,
  415, 415, 1915, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1923, 415, 415, 415, 415, 415, 415, 415, 1849, 415,
  415, 1852, 415, 415, 415, 415, 415, 415, 415, 438, 438, 438, 2010, 438, 438, 438, 438, 438, 747, 438, 438, 438, 438,
  438, 0, 0, 0, 53466, 5, 438, 438, 438, 438, 1941, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 0, 0, 0, 0, 0, 1691,
  0, 0, 0, 1993, 0, 0, 1996, 0, 0, 0, 0, 367, 415, 415, 415, 415, 2001, 2046, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 415, 2056,
  415, 415, 415, 415, 0, 438, 438, 438, 438, 438, 438, 718, 438, 438, 438, 438, 990, 438, 438, 438, 438, 1000, 438, 438,
  438, 438, 438, 438, 1943, 438, 438, 438, 438, 438, 438, 438, 0, 0, 1048, 0, 0, 0, 1054, 0, 0, 0, 0, 415, 415, 415,
  415, 438, 438, 2066, 438, 438, 438, 438, 438, 438, 438, 2074, 2075, 438, 438, 2092, 438, 2094, 438, 438, 438, 438, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1802, 0, 438, 2129, 0, 0, 0, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438, 438, 847, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 45056, 49152, 0, 0, 282, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 275,
  275, 45056, 49152, 0, 275, 0, 0, 0, 285, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 772, 773, 0, 324, 40960, 324, 0, 324,
  324, 324, 0, 324, 324, 324, 324, 0, 0, 0, 373, 275, 373, 373, 373, 275, 324, 324, 324, 324, 324, 324, 324, 324, 324,
  324, 373, 324, 324, 324, 324, 421, 421, 421, 421, 421, 445, 421, 421, 421, 421, 421, 421, 421, 421, 445, 445, 445,
  445, 445, 445, 421, 421, 445, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 493, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272,
  272, 0, 0, 0, 0, 0, 833, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 832, 0, 0, 0, 853, 0, 0, 0, 0, 0, 0, 0, 0, 776,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 771, 0, 0, 367, 367, 367, 876, 367, 367, 880, 367, 367, 367, 367, 367, 367,
  367, 367, 1403, 367, 367, 367, 367, 367, 367, 367, 909, 415, 415, 415, 415, 915, 415, 415, 415, 923, 415, 415, 415,
  415, 415, 415, 415, 415, 1758, 415, 415, 415, 415, 415, 415, 415, 415, 939, 415, 415, 415, 415, 415, 415, 415, 415,
  953, 415, 415, 415, 415, 415, 415, 415, 415, 954, 415, 415, 415, 415, 415, 415, 415, 415, 974, 698, 99281, 909, 701,
  438, 438, 438, 438, 985, 438, 438, 438, 993, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1001, 438, 438, 438,
  438, 438, 367, 367, 1600, 367, 367, 367, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1190, 415, 415, 415, 415,
  415, 415, 1636, 415, 415, 415, 415, 415, 415, 415, 0, 1641, 0, 0, 0, 0, 0, 0, 491, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367,
  367, 367, 415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 438, 438, 1770, 438, 1680, 438, 438, 438, 438, 438, 438,
  438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 309, 309, 309, 309, 325,
  40960, 325, 0, 325, 325, 325, 334, 325, 325, 325, 325, 355, 355, 355, 374, 355, 374, 374, 374, 355, 395, 395, 395,
  395, 395, 395, 395, 395, 395, 395, 374, 395, 395, 395, 395, 422, 422, 422, 422, 422, 446, 422, 422, 422, 422, 422,
  422, 422, 422, 446, 446, 446, 446, 446, 446, 422, 422, 446, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 0, 761, 765, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1081, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 861, 0,
  99281, 1248, 1245, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1881, 438, 438, 1804, 0, 0, 0,
  1808, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1814, 0, 0, 0, 0, 544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 642, 0, 1816, 0, 0, 0, 0,
  1821, 0, 0, 0, 0, 0, 1826, 0, 0, 0, 0, 0, 307, 0, 0, 307, 0, 0, 45056, 49152, 307, 0, 0, 0, 0, 1905, 0, 0, 0, 0, 0,
  1908, 367, 367, 367, 367, 367, 367, 367, 0, 0, 0, 0, 0, 909, 415, 415, 415, 415, 1914, 415, 415, 415, 415, 415, 415,
  415, 1921, 415, 415, 415, 415, 1924, 415, 415, 415, 415, 415, 415, 1746, 415, 1748, 415, 415, 415, 1751, 415, 415,
  415, 415, 0, 438, 438, 705, 438, 438, 438, 438, 438, 724, 730, 733, 1939, 438, 438, 438, 438, 1942, 438, 438, 438,
  438, 438, 438, 438, 438, 0, 0, 0, 0, 1689, 0, 0, 1692, 0, 1962, 0, 367, 367, 1963, 367, 367, 415, 415, 415, 415, 415,
  1966, 415, 415, 415, 415, 415, 415, 415, 1931, 438, 438, 438, 438, 438, 438, 1937, 438, 415, 415, 415, 415, 1972, 415,
  415, 415, 415, 415, 438, 438, 438, 438, 438, 1978, 415, 648, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 0, 1245, 415, 695, 415, 415, 0, 438, 438, 438, 438, 708, 438, 438, 438, 438, 438, 438, 1671, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 1014, 438, 438, 438, 438, 438, 438, 0, 0, 791, 0, 0, 0, 0, 0, 0, 272, 272, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 517, 0, 0, 0, 438, 438, 1312, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1536, 0, 0, 0, 0, 0, 1320,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 541, 830, 0, 0, 1635, 415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 0, 0, 0,
  589, 591, 0, 0, 0, 0, 0, 367, 367, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 849, 0, 0, 0, 302, 0, 0, 0, 0, 0,
  0, 253, 0, 0, 0, 0, 0, 0, 497, 498, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 254, 253, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0,
  0, 0, 0, 415, 2082, 415, 415, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438, 1870, 0, 40960, 0,
  0, 0, 0, 0, 335, 0, 0, 0, 254, 356, 356, 356, 375, 356, 375, 375, 375, 356, 396, 401, 401, 401, 401, 401, 401, 407,
  401, 407, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 375, 401, 401, 401, 401, 423, 423, 423, 423, 447, 423,
  423, 423, 423, 423, 423, 423, 423, 447, 447, 447, 447, 447, 447, 423, 423, 447, 53466, 53466, 2, 86019, 4, 5, 0, 367,
  367, 601, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 627, 415, 415, 651, 415, 659, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 959, 415, 415, 415, 415, 415, 696, 415, 415, 0, 438, 438, 438, 438, 438, 711,
  438, 719, 438, 438, 438, 0, 2019, 0, 0, 2022, 0, 0, 0, 0, 0, 415, 415, 415, 415, 415, 415, 415, 2087, 415, 415, 438,
  0, 0, 819, 0, 0, 0, 0, 0, 0, 826, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 208896, 0, 0, 0,
  367, 367, 889, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1596, 367, 367, 367, 901, 367, 367, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814, 0, 816, 909, 415, 415, 415, 415, 415, 415, 917, 415, 415, 415, 415, 415, 415,
  415, 415, 0, 1470, 0, 1476, 438, 438, 438, 438, 415, 415, 415, 415, 969, 415, 415, 415, 415, 698, 99281, 909, 701,
  438, 438, 438, 438, 991, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1507, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 1305, 438, 438, 438, 438, 438, 438, 438, 438, 987, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 1273, 438, 438, 438, 1039, 438, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1803, 0, 1075, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1088, 1089, 0, 1107, 0, 0, 0, 0, 0, 0, 0, 0, 1115, 0, 0, 0, 1117, 0, 0, 0, 0, 554, 0, 0, 0,
  0, 0, 495, 0, 0, 563, 0, 0, 0, 0, 0, 1360, 0, 0, 0, 0, 0, 0, 1366, 0, 0, 0, 0, 0, 0, 1056768, 232, 233, 0, 0, 204800,
  0, 0, 0, 0, 0, 0, 1112, 0, 0, 0, 0, 0, 0, 0, 0, 1118, 0, 1128, 1129, 0, 1131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1101,
  0, 0, 0, 0, 1168, 367, 367, 367, 367, 367, 367, 0, 0, 1088, 0, 0, 909, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  926, 415, 415, 415, 415, 415, 415, 415, 438, 1932, 438, 438, 438, 438, 438, 438, 438, 1012, 438, 438, 438, 1016, 438,
  438, 438, 438, 415, 415, 1212, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1224, 415, 415, 415, 415, 415, 415,
  415, 1974, 415, 415, 438, 438, 438, 438, 438, 438, 1520, 438, 438, 438, 438, 438, 438, 438, 438, 438, 755, 438, 0, 0,
  0, 53466, 5, 438, 438, 438, 1297, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1501, 1502, 438, 1504,
  1310, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 1345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 542, 0, 0, 0, 0, 0, 0, 1358, 0, 0, 0, 0, 0, 0, 0, 1365, 0, 0, 0, 0, 0, 0, 1696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1126907, 0, 0, 0, 0, 1363968, 0, 438, 438, 438, 1481, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1272,
  438, 438, 438, 438, 0, 0, 0, 0, 1554, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1561, 0, 0, 0, 0, 577, 0, 0, 0, 577, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 1152, 367, 367, 0, 0, 1565, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1573,
  1574, 0, 0, 1577, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 0, 0, 0, 0, 435, 0, 0, 1732, 367, 367, 1734, 367, 367, 367,
  367, 367, 367, 367, 1739, 367, 367, 367, 367, 367, 1591, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1163, 367,
  367, 367, 367, 367, 415, 1742, 415, 415, 415, 1745, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1753, 415, 415, 415,
  415, 1765, 415, 415, 415, 0, 0, 0, 0, 438, 1769, 438, 438, 0, 0, 0, 0, 415, 2119, 415, 415, 415, 2123, 438, 2125, 438,
  438, 0, 0, 0, 0, 2118, 415, 415, 415, 415, 415, 2124, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 2025, 0, 415, 415, 415,
  415, 0, 438, 438, 438, 438, 709, 712, 438, 720, 438, 438, 438, 0, 0, 0, 0, 0, 0, 2023, 0, 0, 0, 415, 415, 415, 415, 0,
  438, 438, 438, 438, 438, 438, 717, 438, 438, 438, 438, 989, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  1511, 1512, 438, 438, 438, 438, 1772, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1780, 438, 438, 438, 438, 0, 0,
  1797, 0, 0, 0, 0, 0, 0, 0, 0, 0, 505, 0, 0, 0, 0, 0, 0, 1792, 438, 438, 438, 1795, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1116, 0, 0, 0, 0, 415, 415, 415, 415, 1847, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1856, 0, 1895, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 869, 0, 0, 1904, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 367, 367, 367, 367, 415,
  415, 1843, 415, 1950, 0, 0, 0, 1953, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1125, 0, 0, 0, 0, 415, 2031, 415, 2033, 2034,
  2035, 415, 438, 438, 438, 438, 2041, 438, 2043, 2044, 2045, 415, 415, 415, 2105, 415, 2106, 415, 415, 415, 438, 438,
  438, 2111, 438, 2112, 438, 0, 0, 0, 2049, 0, 0, 0, 2052, 0, 415, 415, 415, 415, 415, 415, 415, 415, 1640, 0, 0, 0, 0,
  0, 0, 0, 1134, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1326, 0, 0, 0, 0, 0, 0, 438, 2148, 2149, 415, 438, 415, 438, 415, 438, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 0, 538, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 870, 0, 438, 1505, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 0, 0, 0, 0, 0, 0, 286, 288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 549, 0, 0, 0, 326, 40960, 326, 0, 326, 326,
  326, 0, 326, 326, 326, 326, 357, 357, 357, 376, 357, 376, 376, 376, 357, 397, 397, 397, 397, 397, 397, 397, 397, 397,
  397, 376, 397, 397, 397, 412, 424, 424, 424, 424, 424, 448, 424, 424, 424, 424, 424, 424, 424, 424, 448, 448, 448,
  448, 448, 448, 424, 424, 448, 53466, 53466, 2, 86019, 4, 5, 0, 367, 367, 367, 602, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 367, 367, 367, 1405, 367, 367, 367, 367, 415, 415, 415, 653, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 1239, 415, 0, 1245, 0, 0, 0, 761, 765, 0, 0, 0, 0, 0, 0, 0, 771, 0, 0, 0, 0, 0, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 0, 0, 0, 218, 5, 0, 0, 0, 804, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 815, 0, 0, 0, 0, 779,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1736704, 0, 0, 0, 0, 415, 415, 415, 935, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 1444, 415, 415, 415, 415, 415, 415, 415, 415, 950, 415, 415, 415, 415, 415, 415, 960, 415, 415, 415,
  415, 0, 438, 438, 438, 706, 438, 710, 438, 438, 722, 438, 732, 415, 415, 415, 415, 415, 971, 415, 415, 415, 698,
  99281, 909, 701, 438, 438, 438, 438, 1009, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1033, 438, 438, 438,
  438, 438, 1020, 438, 438, 438, 438, 438, 438, 1030, 438, 438, 438, 438, 438, 438, 438, 1013, 438, 438, 438, 438, 438,
  438, 438, 438, 1029, 438, 438, 438, 438, 438, 438, 438, 438, 1498, 438, 438, 438, 438, 438, 438, 438, 438, 1041, 438,
  438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1894, 0, 0, 0, 0, 1061, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 847, 0, 0,
  415, 415, 415, 415, 1184, 1185, 415, 415, 415, 1189, 415, 415, 415, 415, 415, 415, 415, 415, 1920, 415, 415, 415, 415,
  415, 415, 415, 415, 1466, 0, 0, 0, 1245, 1472, 0, 0, 99281, 1248, 1245, 438, 438, 438, 438, 438, 438, 438, 1257, 1258,
  438, 438, 438, 1262, 438, 1295, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1004, 1006,
  1409, 367, 367, 367, 367, 367, 367, 0, 415, 415, 415, 415, 415, 415, 415, 415, 415, 698, 99281, 909, 701, 438, 982,
  438, 415, 1609, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 692, 415, 1653, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1782, 0, 0, 0, 1718, 0, 0, 0, 0, 1723, 0, 0, 0, 0, 1728,
  0, 0, 0, 0, 0, 1322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0, 0, 0, 0, 0, 367, 367, 1733, 367, 367, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 1595, 367, 367, 367, 367, 415, 415, 415, 415, 1744, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 1204, 415, 1208, 1209, 415, 1771, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 1791, 0, 0, 0, 1807, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0, 0, 415, 415, 1928, 415, 415, 415, 415,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 1660, 438, 438, 438, 438, 438, 438, 438, 438, 438, 2093, 438, 2095, 438,
  438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 415, 2029, 2103, 415, 415, 415, 415, 415, 415, 415, 415, 2109, 438, 438,
  438, 438, 438, 438, 1786, 438, 438, 438, 438, 1789, 438, 438, 438, 438, 438, 438, 0, 0, 0, 415, 2133, 415, 415, 415,
  415, 438, 2137, 438, 438, 438, 438, 1023, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1036, 438, 0, 40960, 0, 0, 0,
  0, 0, 336, 0, 0, 0, 277, 358, 358, 366, 377, 358, 377, 377, 377, 358, 398, 398, 398, 398, 398, 398, 398, 398, 398,
  398, 377, 398, 398, 398, 398, 425, 425, 425, 425, 425, 449, 425, 425, 425, 425, 425, 425, 425, 425, 449, 449, 449,
  449, 449, 449, 425, 425, 449, 53466, 53711, 2, 86019, 4, 5, 0, 367, 367, 367, 603, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 367, 367, 367, 0, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 963, 415,
  415, 415, 654, 415, 415, 667, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1749, 415, 415, 415, 415, 415, 0, 0,
  0, 820, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 562, 0, 0, 565, 0, 0, 0, 837, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 830,
  830, 0, 0, 415, 415, 948, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 961, 415, 415, 415, 415, 415, 415, 665,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 0, 0, 1642, 0, 1243, 0, 99281, 0, 1245, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 1259, 438, 438, 438, 438, 1024, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1524, 438, 438,
  438, 438, 415, 415, 415, 415, 1450, 415, 415, 415, 1454, 415, 415, 415, 415, 415, 415, 415, 415, 1429, 415, 415, 415,
  415, 415, 415, 415, 415, 1235, 415, 415, 415, 415, 415, 0, 1245, 438, 1492, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 1018, 438, 438, 1517, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 1037, 438, 415, 415, 415, 795039, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1674, 438, 438,
  438, 438, 438, 438, 0, 0, 0, 1994, 0, 0, 0, 0, 0, 0, 367, 415, 415, 415, 415, 415, 415, 415, 438, 438, 1933, 438, 438,
  438, 438, 438, 438, 1508, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1986, 438, 438, 0, 0, 0, 0, 415, 415, 415, 415,
  415, 2007, 415, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1779, 438, 438, 438, 438, 438, 438, 438, 2017, 438, 0, 0,
  0, 2021, 0, 0, 0, 0, 0, 0, 415, 415, 415, 415, 415, 415, 415, 415, 2088, 415, 438, 0, 0, 257, 258, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 846, 0, 0, 0, 0, 0, 272, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1070, 0, 0, 0, 0, 0, 257, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 291, 0, 0, 291, 0, 0, 45056, 49152, 291, 0, 0, 0, 40960, 0, 257, 0, 0, 0, 0, 0, 0, 0, 0,
  359, 365, 365, 378, 365, 378, 378, 378, 359, 365, 365, 365, 365, 365, 365, 365, 365, 365, 365, 408, 365, 365, 378,
  409, 408, 365, 365, 426, 426, 426, 426, 426, 450, 426, 426, 426, 426, 426, 426, 426, 426, 450, 450, 450, 450, 450,
  450, 426, 426, 450, 53466, 53466, 2, 86019, 4, 5, 0, 272, 272, 0, 0, 0, 0, 0, 0, 513, 0, 0, 516, 0, 0, 0, 0, 0, 0,
  1709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 529, 0, 0, 0, 0, 0, 0, 0, 781,
  0, 0, 0, 0, 0, 786, 0, 0, 0, 0, 0, 583, 0, 0, 0, 0, 0, 592, 0, 513, 0, 0, 367, 595, 367, 367, 367, 604, 367, 367, 612,
  367, 367, 367, 618, 367, 367, 367, 625, 367, 310, 367, 367, 367, 310, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 868, 0, 0, 0, 0,
  0, 0, 0, 592, 0, 0, 0, 575, 0, 0, 486, 0, 630, 0, 0, 516, 0, 0, 0, 0, 793, 0, 795, 0, 0, 272, 272, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 519, 0, 634, 0, 0, 0, 575, 486, 639, 0, 0, 0, 0, 0, 0, 0, 415, 643, 415, 415, 415, 655, 415, 415,
  668, 415, 415, 415, 678, 415, 415, 415, 415, 693, 438, 438, 738, 438, 438, 438, 438, 753, 438, 438, 438, 0, 0, 0,
  53466, 5, 367, 367, 367, 904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1086, 0, 0, 0, 415, 415, 415, 415, 937, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 1222, 415, 415, 415, 415, 1007, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 1292, 1293, 367, 367, 1171, 367, 367, 367, 367, 0, 0, 0, 0, 0, 909, 415, 415, 415,
  415, 415, 415, 415, 918, 924, 415, 415, 415, 415, 415, 415, 415, 415, 1850, 1851, 415, 415, 415, 415, 1855, 415, 415,
  415, 415, 415, 1232, 415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 1245, 99281, 0, 1245, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 1261, 438, 0, 0, 0, 2142, 415, 415, 415, 2144, 438, 438, 438, 0, 415, 415, 438, 0, 0, 0,
  415, 415, 415, 415, 438, 438, 438, 438, 0, 415, 415, 438, 0, 0, 0, 0, 0, 0, 2051, 0, 2053, 415, 2055, 415, 415, 415,
  415, 0, 438, 438, 438, 438, 438, 438, 713, 438, 438, 438, 438, 0, 1314, 0, 0, 0, 0, 0, 1316, 0, 0, 0, 0, 0, 0, 1133,
  0, 0, 0, 0, 0, 0, 1139, 0, 0, 1383, 0, 0, 0, 0, 0, 0, 0, 0, 1391, 367, 1393, 367, 367, 367, 367, 367, 1401, 1402, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 0, 415, 415, 415, 415, 415, 415, 415, 1421, 367, 367, 367, 367, 1413, 367,
  367, 0, 415, 415, 1417, 415, 415, 415, 415, 415, 415, 415, 438, 438, 2039, 438, 438, 438, 438, 438, 438, 415, 415,
  438, 53466, 53711, 2, 86019, 4, 5, 0, 415, 1447, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  962, 415, 415, 415, 1461, 415, 415, 415, 415, 415, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 1652, 0, 438, 438, 1480, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1525, 1526, 438,
  438, 0, 0, 1540, 0, 0, 1542, 0, 0, 0, 0, 0, 0, 0, 0, 1550, 0, 0, 0, 0, 821, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 828, 542,
  0, 0, 0, 0, 0, 0, 0, 1578, 0, 0, 1581, 0, 0, 1584, 0, 0, 0, 0, 367, 367, 367, 367, 367, 1964, 415, 415, 415, 415, 415,
  415, 415, 415, 1442, 415, 415, 415, 415, 415, 415, 415, 415, 1188, 415, 415, 415, 415, 415, 415, 415, 415, 1201, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 1202, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1611, 415, 1613, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 1620, 438, 438, 1655, 438, 1657, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1664,
  438, 0, 1049, 0, 1055, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532, 0, 0, 0, 415, 415, 0, 0, 0, 0, 1695, 0, 0, 0, 1697, 0, 0,
  0, 0, 0, 1701, 1702, 0, 0, 0, 0, 1719, 0, 0, 1722, 0, 0, 0, 0, 0, 0, 0, 0, 536, 0, 0, 0, 549, 0, 0, 0, 0, 1805, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1104, 0, 0, 0, 0, 1833, 367, 367, 367, 367, 367, 367, 367, 367, 415, 1842, 415,
  415, 415, 415, 415, 415, 666, 415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 1641, 0, 0, 0, 0, 0, 438, 438, 438,
  1873, 1874, 438, 438, 438, 438, 1878, 438, 438, 438, 438, 438, 438, 1876, 1877, 438, 438, 438, 438, 438, 438, 438,
  438, 1286, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 0, 1888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0,
  0, 264, 0, 0, 0, 1906, 0, 0, 0, 0, 367, 367, 1909, 1910, 367, 367, 367, 367, 367, 1414, 367, 0, 415, 415, 415, 415,
  415, 415, 415, 415, 0, 1468, 0, 0, 1245, 0, 1474, 0, 415, 415, 415, 415, 1916, 1917, 1918, 415, 415, 415, 415, 415,
  415, 415, 415, 1925, 1979, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 415, 2003, 415,
  415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 2013, 438, 438, 0, 0, 0, 415, 415, 415, 415, 415, 415, 438, 438,
  438, 438, 438, 2069, 438, 438, 438, 438, 0, 0, 2030, 415, 415, 415, 415, 415, 415, 438, 438, 438, 2040, 438, 438, 438,
  438, 438, 992, 438, 997, 438, 438, 438, 438, 438, 1003, 438, 438, 415, 2061, 415, 2063, 438, 438, 438, 438, 438, 438,
  438, 2071, 438, 2073, 0, 0, 0, 0, 0, 1346, 0, 1347, 1348, 0, 0, 0, 0, 0, 0, 0, 808, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126976,
  0, 0, 126976, 126976, 126976, 126976, 261, 40960, 261, 262, 261, 331, 261, 0, 261, 261, 261, 331, 360, 360, 360, 379,
  386, 379, 379, 379, 390, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 379, 399, 399, 399, 399, 427, 427, 427,
  427, 427, 451, 427, 427, 427, 427, 427, 427, 427, 427, 451, 451, 451, 451, 451, 451, 427, 427, 451, 53466, 53466, 2,
  86019, 4, 5, 0, 0, 0, 477, 478, 479, 480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 0, 492, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 272, 272, 0, 0, 0, 0, 1363968, 272, 272, 0, 0, 509, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 102400, 102400,
  102400, 0, 0, 522, 0, 524, 0, 526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 261, 45056, 49152, 0, 260, 262, 473, 551, 552, 553,
  0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 599, 367, 367, 607, 367, 367, 367, 616, 367, 367, 367, 367,
  623, 367, 367, 367, 367, 1173, 367, 367, 0, 1070, 0, 0, 0, 909, 415, 415, 415, 415, 415, 415, 415, 919, 415, 415, 415,
  415, 415, 415, 415, 415, 1219, 1220, 415, 415, 415, 415, 415, 415, 479, 0, 0, 628, 0, 0, 0, 559, 0, 0, 0, 0, 0, 632,
  0, 590, 559, 559, 0, 0, 0, 492, 526, 0, 590, 0, 0, 590, 415, 415, 415, 415, 415, 415, 669, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 698, 99281, 909, 701, 438, 438, 438, 415, 649, 652, 415, 660, 415, 415, 415, 674, 677, 415, 415,
  415, 686, 690, 415, 415, 415, 415, 415, 415, 1767, 415, 0, 0, 0, 0, 438, 438, 438, 438, 438, 438, 1483, 438, 1485,
  438, 438, 438, 1488, 438, 438, 734, 737, 438, 438, 438, 746, 750, 438, 438, 438, 438, 0, 0, 0, 53466, 5, 817, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1329, 0, 0, 852, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 848, 0, 0, 888, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1598, 415, 415, 415, 415, 970, 415, 415, 415, 415,
  698, 99281, 909, 701, 438, 438, 438, 438, 1044, 0, 0, 0, 0, 1050, 0, 0, 0, 1056, 0, 0, 438, 438, 1008, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1677, 438, 438, 438, 1040, 438, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 188416, 0, 0, 0, 0, 0, 1091, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1715, 0, 1119, 0, 0, 0, 0, 1122, 0,
  549, 0, 0, 0, 0, 0, 0, 0, 0, 768, 0, 0, 0, 0, 0, 0, 0, 415, 415, 1181, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 684, 415, 415, 99281, 0, 1245, 438, 438, 438, 438, 438, 1254, 438, 438, 438, 438, 438, 438, 438,
  1302, 438, 438, 438, 438, 438, 438, 438, 1309, 438, 1277, 438, 1281, 1282, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 1676, 438, 438, 438, 438, 0, 0, 1331, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 0, 0, 0, 0, 0, 438, 438, 438,
  438, 438, 438, 438, 438, 1651, 438, 438, 1552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 1567, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1507328, 0, 0, 0, 0, 0, 0, 1644, 0, 1248, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 1947, 438, 438, 0, 0, 0, 1731, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1740, 1741,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1226, 1754, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 1435, 415, 415, 415, 1764, 415, 415, 415, 415, 0, 0, 0, 0, 1768, 438,
  438, 438, 438, 1045, 1314, 0, 0, 0, 0, 1051, 1316, 0, 0, 0, 0, 0, 0, 866, 0, 0, 0, 0, 0, 0, 0, 0, 0, 578, 0, 0, 0, 0,
  0, 0, 0, 0, 415, 415, 1845, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1193, 415, 0,
  0, 1952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 860, 0, 0, 1992, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 415, 415, 415, 2000,
  415, 415, 415, 415, 415, 415, 1973, 415, 415, 415, 438, 438, 438, 438, 1977, 438, 0, 2141, 0, 415, 415, 415, 415, 438,
  438, 438, 438, 0, 415, 415, 438, 415, 438, 415, 438, 415, 438, 415, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1534, 0, 0,
  1537, 0, 415, 415, 2032, 415, 415, 415, 415, 438, 2038, 438, 438, 438, 2042, 438, 438, 438, 438, 1266, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 1275, 438, 438, 0, 2115, 0, 2117, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438,
  0, 1796, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1364, 0, 0, 0, 0, 0, 438, 438, 0, 2131, 0, 415, 415, 415, 415, 415, 415, 438,
  438, 438, 438, 438, 1025, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1675, 438, 438, 438, 438, 438, 0, 40960,
  0, 0, 0, 0, 0, 337, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 1836, 367, 367, 367, 367, 415, 415, 415, 415, 0, 438,
  438, 438, 438, 438, 438, 438, 721, 438, 438, 438, 428, 428, 428, 428, 452, 428, 428, 428, 428, 428, 428, 428, 428,
  452, 452, 452, 452, 452, 452, 428, 428, 452, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 502,
  0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110016, 1110016, 0, 494, 502, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 265, 266, 0, 0, 0, 0, 0, 834, 0, 838, 0, 0, 774, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530, 0, 0, 0, 0, 0, 512, 367,
  367, 367, 774, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1328, 0, 0, 0, 415, 415, 415, 968, 415, 415, 415, 415, 415, 698,
  99281, 909, 701, 438, 438, 438, 438, 1298, 438, 1300, 438, 438, 438, 438, 438, 438, 1307, 438, 438, 0, 0, 1357, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1087, 0, 0, 0, 0, 0, 1370, 0, 0, 0, 0, 0, 1376, 0, 0, 0, 0, 0, 0, 0, 151552, 0, 0, 0,
  45056, 49152, 0, 0, 0, 0, 0, 0, 1386, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 367, 367, 1737, 367, 367, 367, 367,
  367, 367, 415, 1437, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1243, 1245, 0, 1539, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1901, 0, 415, 415, 415, 415, 1624, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 1431, 1432, 415, 415, 415, 438, 438, 438, 1668, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  1781, 438, 438, 438, 0, 0, 0, 0, 1995, 0, 0, 1997, 0, 0, 367, 415, 415, 415, 415, 415, 415, 415, 438, 1865, 438, 438,
  438, 438, 438, 438, 438, 1269, 438, 438, 438, 438, 438, 438, 438, 438, 1301, 438, 438, 438, 438, 438, 438, 438, 438,
  1285, 438, 438, 438, 438, 438, 438, 438, 0, 578, 0, 0, 0, 0, 0, 0, 0, 0, 0, 578, 0, 0, 367, 367, 367, 367, 367, 1736,
  367, 367, 367, 367, 367, 367, 367, 367, 1160, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 605, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 0, 415, 415, 415, 1418, 415, 415, 415, 415, 415, 415, 415, 656, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1456, 415, 415, 415, 415, 415, 697, 415, 0, 438, 438, 438, 438, 438,
  438, 716, 438, 438, 438, 438, 438, 1670, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 795062, 438, 438, 438, 0,
  0, 0, 0, 0, 762, 766, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 1998, 415, 415, 415, 415, 99281, 1249, 1245, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1790, 438, 438, 438, 0, 0, 272, 0, 0, 0, 0, 0, 263, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 263, 40960, 263, 264, 263, 263, 263, 0, 263, 263, 263, 263, 0, 0, 0, 380, 0, 380, 380, 380, 264,
  263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 380, 263, 263, 263, 263, 429, 429, 429, 429, 429, 453, 429, 429,
  429, 429, 429, 429, 429, 429, 453, 453, 453, 453, 453, 453, 429, 429, 453, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 540,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1126, 0, 0, 0, 589, 0, 0, 0, 629, 0, 0, 0, 0, 554, 0, 0, 0, 633, 0, 0, 0, 0,
  839, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 415, 1999, 415, 415, 415, 0, 635, 0, 0, 0, 0, 0, 0, 0, 0, 591, 0, 0, 591,
  415, 415, 415, 415, 415, 415, 938, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1759, 415, 415, 415, 415, 1762,
  415, 415, 415, 415, 415, 663, 415, 415, 415, 415, 679, 681, 415, 415, 691, 415, 415, 415, 415, 415, 415, 2036, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 1509, 438, 438, 438, 438, 438, 1515, 438, 438, 739, 741, 438, 438, 751, 438,
  438, 438, 438, 0, 0, 0, 53466, 5, 0, 0, 803, 0, 805, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 485, 0, 0, 0, 0, 0, 0, 0, 818,
  0, 0, 0, 0, 0, 0, 0, 0, 827, 0, 0, 0, 831, 0, 0, 0, 0, 839, 0, 0, 0, 0, 0, 844, 0, 0, 0, 0, 0, 0, 527, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 110592, 0, 233472, 249856, 0, 0, 415, 415, 934, 936, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 1632, 415, 415, 415, 438, 438, 438, 1022, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1948,
  438, 0, 0, 1106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1382, 367, 1170, 367, 367, 367, 1174, 367, 0, 0, 0, 0,
  0, 909, 415, 415, 415, 415, 415, 415, 415, 920, 415, 415, 415, 415, 930, 415, 415, 415, 1180, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 1244, 1245, 415, 415, 415, 1197, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 1922, 415, 415, 415, 415, 1229, 415, 415, 415, 415, 415, 415, 415, 1236, 415, 1238, 415, 415, 0,
  1245, 99281, 0, 1245, 438, 438, 438, 438, 1253, 438, 438, 438, 438, 438, 438, 438, 438, 1985, 438, 438, 438, 0, 0, 0,
  0, 438, 1311, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1548, 0, 0, 0, 0, 0, 0, 1332, 1333, 1334, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 501, 0, 503, 0, 0, 272, 0, 1343, 0, 0, 0, 0, 0, 0, 0, 1349, 0, 0, 1351, 0, 0, 0, 0, 0, 438, 1645, 438,
  438, 438, 438, 438, 1650, 438, 438, 438, 438, 1494, 1495, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1658, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 757, 0, 0, 0, 53466, 5, 1355, 0, 0, 0, 0, 0, 1361, 0, 0, 0, 0, 0, 0,
  1367, 1368, 0, 0, 0, 0, 854, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 0, 0, 415, 415, 415, 1438, 1439, 415,
  1441, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1976, 438, 438, 438, 438, 438, 1446, 415, 415, 415, 415, 415,
  1452, 415, 415, 415, 415, 415, 415, 415, 415, 415, 698, 0, 0, 701, 438, 438, 438, 0, 1478, 438, 438, 438, 1482, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 1987, 438, 0, 0, 0, 0, 1528, 0, 0, 0, 0, 0, 0, 0, 0, 1532, 0, 0, 0, 0, 0,
  0, 0, 151552, 151552, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 0, 0, 0, 225280, 0, 0, 0, 0, 0, 0, 0, 0, 237568,
  0, 0, 0, 0, 0, 0, 0, 0, 1626112, 0, 0, 0, 0, 1064960, 0, 0, 0, 0, 1576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 0,
  295, 0, 0, 433, 1608, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 688, 415, 415, 415,
  415, 415, 415, 415, 1766, 415, 415, 0, 0, 0, 0, 438, 438, 438, 438, 438, 438, 438, 1484, 438, 438, 438, 438, 438, 438,
  438, 1011, 438, 438, 1015, 438, 438, 438, 438, 438, 438, 1793, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1571, 0,
  0, 0, 0, 0, 1832, 367, 367, 367, 367, 367, 367, 367, 367, 1840, 1841, 415, 415, 415, 415, 0, 438, 438, 702, 438, 438,
  438, 438, 438, 438, 726, 438, 415, 415, 415, 1860, 415, 415, 415, 1864, 438, 438, 438, 438, 438, 438, 438, 438, 2098,
  0, 0, 0, 0, 2100, 0, 2102, 0, 0, 1896, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1352, 0, 1354, 415, 415, 415, 415, 2006,
  415, 415, 2008, 438, 438, 438, 438, 438, 438, 438, 438, 1497, 438, 1499, 438, 438, 438, 438, 438, 438, 2016, 438, 438,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 415, 415, 415, 2084, 415, 2086, 415, 415, 415, 438, 415, 415, 415, 415, 438, 2065,
  438, 438, 438, 438, 438, 438, 438, 438, 0, 0, 0, 1688, 0, 0, 0, 0, 0, 0, 0, 2079, 0, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 438, 438, 438, 438, 1868, 438, 438, 438, 438, 2128, 438, 2130, 0, 2132, 415, 415, 415, 415, 415,
  415, 438, 438, 438, 438, 438, 1026, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1038, 278, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1716, 0, 299, 0, 0, 0, 0, 314, 0, 0, 0, 0, 45056, 49152, 0, 0, 0, 0, 0, 587, 0, 0, 590, 0, 0, 0, 0,
  593, 367, 367, 327, 40960, 327, 0, 327, 327, 327, 0, 327, 327, 327, 345, 0, 0, 265, 381, 0, 381, 381, 381, 0, 345,
  345, 345, 345, 345, 345, 345, 345, 345, 345, 381, 345, 345, 410, 413, 430, 430, 430, 430, 430, 454, 430, 430, 430,
  430, 430, 430, 430, 430, 454, 454, 454, 454, 454, 454, 430, 430, 454, 53466, 53466, 2, 86019, 4, 5, 0, 0, 0, 569, 0,
  571, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 516, 0, 0, 0, 564, 0, 584, 0, 0, 0, 571, 0, 584, 0, 0, 0, 0, 0, 0, 0, 415, 644,
  0, 0, 0, 778, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1586, 0, 0, 367, 0, 367, 367, 367, 367, 877, 367, 881, 367, 883,
  367, 367, 367, 367, 367, 367, 415, 415, 415, 415, 415, 415, 415, 415, 1607, 415, 367, 367, 367, 890, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 0, 1415, 415, 415, 415, 1419, 415, 415, 415, 909, 415, 415, 415, 415,
  415, 916, 415, 415, 925, 415, 415, 929, 415, 415, 415, 415, 0, 438, 438, 703, 438, 438, 438, 715, 438, 438, 728, 438,
  438, 438, 986, 438, 438, 995, 438, 438, 999, 438, 438, 438, 438, 438, 438, 438, 1659, 438, 438, 438, 438, 1662, 1663,
  438, 438, 0, 0, 0, 1062, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1699, 0, 0, 0, 0, 0, 1092, 0, 1094, 0, 0, 1097, 0, 0, 0,
  0, 1102, 0, 0, 0, 0, 0, 638, 0, 0, 0, 0, 0, 0, 0, 0, 415, 415, 415, 415, 415, 415, 415, 1199, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 1203, 415, 415, 415, 415, 415, 1330, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1729, 1342,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1353, 0, 0, 0, 0, 1063, 0, 0, 0, 0, 0, 1069, 0, 0, 0, 0, 0, 0, 544, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 839, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1378, 0, 0, 0, 0, 0, 0, 1721, 0, 0, 0, 0, 0, 0, 0, 0, 0, 579,
  0, 0, 0, 0, 0, 0, 367, 367, 1411, 367, 367, 367, 367, 0, 415, 1416, 415, 415, 415, 415, 415, 415, 415, 438, 438, 438,
  438, 1934, 1935, 1936, 438, 438, 415, 1460, 415, 415, 415, 415, 415, 415, 0, 0, 0, 0, 1245, 0, 0, 0, 0, 0, 780, 0, 0,
  0, 783, 0, 785, 0, 0, 787, 788, 0, 438, 1479, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1988,
  0, 1990, 0, 1516, 438, 438, 438, 438, 438, 438, 438, 1521, 438, 1523, 438, 438, 438, 438, 438, 1027, 1028, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 1787, 438, 438, 438, 438, 438, 438, 438, 438, 1672, 438, 438, 438, 438, 438, 438,
  438, 438, 1684, 0, 0, 0, 0, 0, 0, 0, 0, 1082, 0, 1084, 0, 0, 0, 0, 0, 1621, 415, 415, 415, 415, 415, 415, 415, 1628,
  415, 415, 415, 415, 415, 415, 415, 415, 1467, 0, 0, 0, 1245, 1473, 0, 0, 1703, 0, 0, 1706, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1727, 0, 0, 0, 0, 0, 1817, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1549, 0, 0, 1926, 415, 415, 415, 415, 415,
  415, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1777, 438, 438, 438, 438, 438, 438, 438, 438, 1685, 1686, 0, 0, 0,
  0, 0, 0, 0, 1951, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1958, 0, 0, 0, 0, 0, 0, 1809, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1099, 0, 0, 0,
  0, 0, 0, 2002, 415, 2004, 415, 415, 415, 415, 438, 438, 438, 438, 438, 2012, 438, 2014, 438, 415, 438, 415, 438, 2152,
  2153, 415, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 415, 415, 415, 415, 2059, 415, 415, 415, 415, 2064, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 0, 0, 1687, 0, 0, 0, 0, 0, 415, 2104, 415, 415, 415, 415, 415, 415, 415, 438, 2110, 438,
  438, 438, 438, 438, 1267, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1510, 438, 438, 438, 438, 438, 0, 300, 0,
  0, 0, 0, 315, 0, 0, 0, 0, 45056, 49152, 0, 0, 0, 0, 0, 794, 0, 0, 0, 272, 272, 0, 799, 0, 0, 0, 0, 0, 0, 1335296, 0,
  1433600, 1556480, 0, 1900544, 0, 0, 1470464, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 361, 361, 361, 382, 361, 382,
  382, 382, 361, 400, 400, 402, 402, 402, 402, 361, 400, 361, 400, 361, 361, 361, 361, 361, 361, 361, 361, 361, 361,
  382, 361, 361, 411, 414, 431, 431, 431, 431, 455, 431, 431, 431, 431, 431, 431, 431, 431, 455, 455, 455, 455, 455,
  455, 431, 431, 455, 53466, 53466, 2, 86019, 4, 5, 0, 272, 272, 0, 0, 0, 0, 0, 512, 0, 0, 0, 0, 0, 0, 0, 0, 842, 0, 0,
  0, 0, 0, 0, 0, 0, 539, 0, 0, 0, 0, 0, 0, 512, 539, 0, 0, 0, 0, 0, 0, 0, 163840, 0, 0, 0, 45056, 49152, 0, 0, 0, 0, 0,
  581, 0, 586, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 367, 367, 367, 367, 415, 415, 415, 415, 415, 415, 415, 1968, 415, 415,
  415, 415, 415, 664, 670, 673, 415, 415, 415, 415, 415, 687, 415, 415, 415, 415, 415, 415, 1186, 415, 415, 415, 415,
  415, 415, 415, 415, 1194, 789, 0, 0, 0, 0, 0, 0, 0, 797, 272, 272, 0, 0, 800, 801, 0, 0, 0, 0, 1078, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 581, 0, 586, 0, 0, 0, 0, 873, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367,
  893, 367, 367, 895, 367, 367, 367, 367, 367, 367, 367, 367, 891, 367, 892, 367, 367, 367, 367, 367, 896, 897, 367,
  367, 367, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 504, 505, 272, 367, 367, 903, 0,
  0, 905, 844, 0, 0, 905, 0, 0, 0, 801, 905, 0, 0, 0, 0, 1110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1585, 0, 0, 0, 367, 909,
  910, 415, 415, 914, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1443, 415, 415, 415, 415, 984, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1308, 438, 438, 438, 438, 1043, 438, 0, 0, 0, 1049,
  0, 0, 0, 1055, 0, 0, 0, 0, 0, 806, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 531, 0, 0, 0, 0, 536, 0, 1142, 0, 0, 0, 0, 0, 0, 367,
  367, 367, 367, 1151, 367, 367, 367, 0, 0, 0, 0, 0, 0, 866, 0, 907, 908, 0, 866, 0, 367, 367, 367, 1157, 367, 367, 367,
  367, 367, 1161, 367, 367, 367, 367, 367, 367, 415, 415, 415, 1603, 415, 1605, 415, 415, 415, 415, 415, 415, 415, 1183,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1455, 415, 415, 415, 415, 415, 1196, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 1206, 415, 415, 415, 415, 0, 438, 438, 704, 438, 438, 438, 438, 438, 438, 729, 438,
  1211, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1433, 415, 415, 415, 415, 1230, 1231,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 0, 1245, 99281, 0, 1245, 438, 438, 438, 438, 438, 438, 1256, 438,
  438, 438, 438, 438, 438, 1984, 438, 438, 438, 438, 438, 0, 0, 0, 0, 0, 1799, 0, 0, 0, 0, 0, 0, 438, 438, 1279, 438,
  438, 438, 1284, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1944, 438, 438, 438, 438, 438, 438, 1949, 0, 0, 0, 1369,
  0, 0, 0, 0, 0, 1375, 0, 0, 0, 0, 0, 0, 0, 824, 0, 0, 0, 0, 0, 0, 0, 0, 263, 264, 0, 0, 0, 0, 0, 0, 1397, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1062, 0, 0, 0, 0, 909, 415, 415, 415, 367, 1410, 367,
  1412, 367, 367, 367, 0, 415, 415, 415, 415, 415, 415, 415, 415, 415, 956, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  1424, 415, 415, 1427, 415, 415, 415, 415, 415, 415, 415, 1434, 415, 415, 415, 415, 415, 415, 2107, 2108, 415, 438,
  438, 438, 438, 438, 438, 2113, 1436, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1445,
  415, 415, 1459, 415, 415, 415, 415, 415, 415, 415, 0, 0, 1470, 0, 1245, 0, 0, 1476, 0, 0, 0, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 1879, 438, 438, 438, 438, 438, 1563, 0, 0, 1566, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1900, 0, 0, 0, 367, 367, 367, 1590, 367, 367, 367, 367, 1593, 367, 367, 367, 367, 367, 367, 367, 1063, 0, 0, 1176,
  1139, 909, 415, 415, 415, 1693, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 0, 1704, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 217088, 0, 438, 438, 1773, 438, 1775, 438, 438, 438, 1778, 438, 438, 438, 438, 438, 438, 438, 2097,
  438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2054, 415, 415, 415, 415, 415, 438, 438, 1794, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1959, 0, 0, 0, 415, 415, 415, 415, 415, 1848, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1221, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 1861, 415, 415, 438, 438, 1866, 438, 438, 438, 438, 438, 438, 1283, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 1661, 438, 438, 438, 438, 438, 1871, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 1884, 438, 438, 0, 0, 0, 1889, 0, 0, 0, 0, 1893, 0, 0, 0, 0, 0, 0, 571, 0, 0, 0, 0, 584, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 596, 415, 1927, 415, 415, 415, 415, 415, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  1299, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1032, 438, 438, 438, 1035, 438, 438, 438, 438, 1940, 438, 438,
  438, 438, 1945, 438, 438, 438, 438, 438, 0, 0, 0, 1315, 0, 761, 0, 0, 0, 1317, 0, 765, 2076, 2077, 0, 0, 0, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 2089, 438, 415, 438, 2150, 2151, 415, 438, 415, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  415, 415, 415, 415, 2058, 415, 2114, 438, 0, 0, 2116, 0, 415, 415, 415, 415, 415, 415, 438, 438, 438, 438, 988, 994,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 1005, 2147, 415, 438, 415, 438, 415, 438, 415, 438, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1533, 0, 0, 0, 0, 0, 0, 0, 268, 0, 0, 0, 0, 0, 0, 268, 0, 45056, 49152, 0, 268, 0, 0, 0, 0, 1144, 0, 0, 0, 367,
  367, 367, 367, 367, 367, 1153, 367, 367, 367, 367, 1400, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 613,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 0, 1143, 0, 1059, 1059, 909, 1177, 1178, 415, 0, 40960, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 362, 362, 362, 383, 387, 383, 383, 383, 387, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 387, 362,
  383, 362, 362, 362, 362, 432, 432, 432, 432, 432, 456, 432, 432, 432, 432, 432, 432, 432, 432, 456, 456, 456, 456,
  456, 456, 432, 432, 456, 53466, 53466, 2, 86019, 4, 5, 0, 272, 272, 508, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1560,
  0, 0, 415, 415, 415, 415, 661, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1617, 415, 415, 415, 415, 0,
  367, 367, 367, 367, 367, 879, 367, 367, 367, 367, 367, 367, 367, 367, 367, 1385, 415, 415, 415, 415, 415, 415, 1420,
  415, 909, 415, 415, 415, 415, 415, 415, 415, 921, 415, 415, 415, 415, 415, 415, 415, 415, 1615, 415, 415, 415, 415,
  1618, 1619, 415, 0, 0, 0, 1130, 0, 1132, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 784, 0, 0, 0, 0, 0, 415, 415, 1213, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 1223, 415, 415, 415, 415, 415, 415, 415, 952, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 955, 415, 415, 415, 415, 415, 415, 438, 438, 1296, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 438, 1519, 438, 438, 438, 1522, 438, 438, 438, 438, 438, 438, 2096, 438, 438, 0, 2099, 0, 0, 0, 0, 0, 367, 1398,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 415, 415, 1602, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 1466, 1641, 0, 0, 0, 0, 1472, 415, 415, 415, 415, 415, 1426, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 1237, 415, 415, 415, 0, 1245, 1477, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1489,
  438, 438, 0, 0, 0, 415, 415, 2134, 2135, 415, 415, 438, 438, 2138, 2139, 438, 0, 0, 0, 415, 415, 415, 415, 438, 438,
  438, 438, 0, 415, 2146, 438, 0, 0, 0, 415, 415, 415, 2143, 438, 438, 438, 2145, 0, 415, 415, 438, 0, 0, 0, 0, 1529, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 811, 0, 0, 0, 0, 0, 415, 415, 1743, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 1457, 415, 415, 438, 1980, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 0, 0, 0, 0, 2101, 0, 0, 0,
  310, 0, 0, 0, 0, 0, 0, 310, 0, 45056, 49152, 0, 310, 0, 0, 0, 0, 1321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 770, 0, 0, 0,
  0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0, 367, 367, 367, 367, 367, 878, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 1404, 367, 367, 367, 1406, 1407, 367, 433, 433, 433, 433, 457, 433, 433, 433, 433, 433, 433, 433, 433, 457,
  457, 457, 457, 457, 457, 433, 433, 457, 53466, 53466, 2, 86019, 4, 5, 0, 415, 415, 415, 657, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 415, 415, 1631, 415, 415, 415, 415, 0, 790, 0, 0, 0, 0, 0, 0, 0, 272, 272, 0, 0, 0, 0, 0, 0,
  0, 514, 515, 0, 0, 0, 0, 520, 863, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 1141, 0, 0, 0, 0, 0, 0, 0,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 626, 1276, 438, 438, 438, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1503, 438, 0, 0, 0, 0, 1707, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1124,
  0, 0, 0, 0, 0, 271, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1827, 0, 0, 271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 269, 270, 328, 40960, 328, 0, 328, 328, 328, 0, 328, 328, 328, 346, 0, 0, 0, 384, 0, 384, 384, 384, 0, 346,
  346, 346, 346, 346, 346, 346, 346, 346, 346, 384, 346, 346, 346, 346, 434, 434, 434, 434, 434, 458, 434, 434, 434,
  434, 434, 434, 434, 434, 458, 458, 458, 458, 458, 458, 434, 434, 458, 53466, 53466, 2, 86019, 4, 5, 0, 415, 415, 415,
  1637, 415, 415, 415, 415, 415, 0, 0, 0, 0, 0, 0, 0, 1072, 367, 367, 367, 367, 367, 367, 367, 367, 438, 438, 1681, 438,
  438, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1058, 435, 435, 435, 435, 459, 435, 435, 435, 435, 435, 435, 435,
  435, 459, 459, 459, 459, 459, 459, 435, 435, 459, 53466, 53466, 2, 86019, 4, 5, 0, 272, 272, 0, 0, 0, 0, 511, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1137, 0, 0, 0, 0, 0, 1140, 0, 579, 0, 0, 0, 0, 0, 0, 0, 0, 0, 579, 0, 0, 367, 367, 367, 367, 1735,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 1159, 367, 367, 367, 367, 367, 367, 367, 1167, 367, 367, 367, 606, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 611, 367, 367, 367, 367, 367, 367, 367, 367, 367, 894, 367,
  367, 367, 367, 367, 367, 415, 415, 415, 658, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1750, 415,
  415, 415, 415, 0, 0, 836, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 241664, 0, 0, 964, 415, 415, 415, 415, 415, 415, 415,
  415, 698, 99281, 909, 701, 438, 438, 438, 438, 1506, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 0, 180224,
  0, 53466, 5, 415, 415, 967, 415, 415, 415, 415, 415, 415, 698, 99281, 909, 701, 438, 438, 438, 438, 1518, 438, 438,
  438, 438, 438, 438, 438, 438, 438, 438, 438, 1289, 438, 438, 438, 438, 0, 0, 0, 1093, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 176436, 176589, 176589, 176589, 415, 415, 415, 415, 415, 1216, 415, 415, 415, 415, 415, 415, 415, 415, 415, 415,
  1616, 415, 415, 415, 415, 415, 99281, 0, 1245, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 1260, 438, 438, 0, 0,
  0, 415, 415, 415, 415, 2136, 415, 438, 438, 438, 438, 2140, 415, 415, 1622, 415, 415, 415, 415, 415, 415, 415, 415,
  415, 415, 415, 415, 415, 1633, 415, 415, 438, 1666, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438, 438,
  438, 1514, 438, 0, 40960, 0, 0, 0, 0, 0, 338, 0, 0, 0, 0, 0, 0, 0, 367, 367, 1835, 367, 367, 367, 367, 367, 367, 415,
  415, 415, 415, 415, 415, 415, 415, 415, 415, 415, 1760, 415, 415, 415, 415, 0, 872448, 272, 0, 872448, 0, 872448, 0,
  0, 872448, 0, 872448, 0, 0, 0, 0, 872448, 0, 0, 0, 0, 872766, 872766, 872448, 0, 0, 872448, 872448, 0, 0, 0, 0, 0, 0,
  0, 0, 872448, 872448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 872448, 872448, 0, 0, 872448, 872448, 0, 0, 0, 0, 0, 872448, 0,
  872448, 0, 0, 872448, 872448, 0, 0, 0, 0, 0, 0, 0, 0, 872448, 0, 872448, 0, 0, 0, 0, 0, 0, 0, 872766, 0, 0, 0, 0, 0,
  0, 0, 872448, 0, 0, 0, 0, 0, 0, 0, 794624, 367, 367, 367, 367, 367, 367, 367, 794991, 0, 0, 0, 872448, 0, 0, 872448,
  872448, 0, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 1359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1713, 0, 0, 0, 0, 0, 0, 0, 0,
  1056768, 0, 0, 0, 0, 0, 0, 0, 0, 876544, 0, 0, 0, 0, 0, 1555, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 259, 261, 296, 0, 0, 0,
  1110016, 1110016, 1110016, 1110714, 0, 1110016, 1110717, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 758, 0, 758, 0, 5, 1110016, 1839104, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 0, 0, 0, 0, 1110016, 1110016, 1355776, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1511424, 1110016, 1110016, 1110016, 1110016, 0, 880640, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 880640, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 881003, 881003, 881003, 0, 0, 2,
  86019, 4, 5, 0, 0, 881003, 0, 0, 0, 881003, 881003, 881003, 881003, 881003, 881003, 881003, 881003, 881003, 881003,
  881003, 881003, 881003, 881003, 881003, 0, 0, 319, 0, 0, 0, 0, 0, 0, 0, 0, 0, 888832, 0, 0, 0, 0, 0, 0, 1907, 0, 367,
  367, 367, 367, 367, 1911, 367, 367, 0, 0, 0, 0, 888832, 0, 888832, 888832, 888832, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0,
  1371, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1899, 0, 0, 0, 1902, 0, 0, 0, 0, 1056768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 892928, 0,
  0, 0, 0, 1541, 0, 1543, 0, 0, 1545, 0, 1547, 0, 0, 0, 1551, 1110016, 1839104, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 976, 0, 0, 979, 1110016, 1110016, 1355776, 0, 102400, 0, 0, 0, 102400, 102400, 102400,
  102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 0, 102400, 0, 0, 0, 0,
  0, 102400, 102400, 102400, 0, 0, 0, 0, 0, 0, 0, 1135, 0, 0, 1138, 0, 0, 0, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  471, 477, 475, 479, 483, 487, 491, 495, 999, 1312, 1256, 1263, 635, 514, 521, 508, 1161, 501, 1593, 1265, 814, 815,
  534, 551, 502, 1174, 507, 987, 512, 814, 518, 534, 857, 502, 502, 528, 989, 814, 563, 533, 534, 539, 502, 1322, 544,
  545, 549, 535, 502, 529, 814, 555, 557, 502, 561, 855, 567, 812, 572, 1580, 576, 853, 580, 585, 581, 589, 593, 597,
  601, 606, 602, 610, 614, 618, 622, 630, 502, 717, 629, 502, 502, 1306, 502, 502, 1008, 502, 502, 502, 502, 502, 910,
  502, 502, 1383, 502, 502, 502, 502, 502, 502, 502, 502, 1078, 502, 502, 502, 502, 502, 502, 502, 634, 502, 502, 502,
  502, 502, 1221, 502, 502, 502, 724, 502, 502, 502, 1222, 502, 502, 502, 502, 502, 502, 502, 502, 502, 748, 834, 502,
  639, 901, 645, 649, 653, 657, 917, 663, 667, 674, 678, 679, 683, 916, 1349, 690, 697, 703, 502, 891, 502, 1232, 502,
  950, 707, 711, 715, 502, 721, 502, 967, 502, 728, 732, 981, 502, 1371, 502, 1552, 502, 739, 743, 747, 773, 723, 752,
  758, 762, 1118, 766, 771, 777, 781, 524, 785, 789, 1124, 793, 797, 801, 805, 809, 819, 823, 827, 502, 832, 838, 1015,
  842, 846, 850, 1544, 1438, 1442, 861, 865, 869, 873, 1099, 877, 1441, 881, 754, 767, 885, 502, 898, 502, 1546, 1441,
  905, 1141, 699, 909, 568, 914, 502, 921, 925, 932, 936, 941, 502, 1346, 502, 1189, 894, 947, 954, 502, 1319, 828, 961,
  1196, 965, 888, 1538, 971, 975, 1230, 993, 996, 1006, 1027, 1363, 1012, 1019, 1024, 1020, 1031, 1035, 502, 1355, 1039,
  1043, 1047, 1051, 1055, 502, 1059, 1063, 1523, 1067, 1071, 1607, 1608, 1356, 1062, 1526, 1075, 1084, 1088, 1092, 1609,
  1098, 1377, 1103, 957, 1107, 1111, 686, 502, 943, 502, 1397, 1587, 1408, 1218, 937, 1117, 502, 1122, 641, 1128, 1135,
  1150, 1155, 502, 1160, 1165, 1169, 497, 502, 1173, 1178, 1182, 1156, 1186, 1193, 1203, 1207, 1211, 1215, 1227, 1236,
  1144, 1146, 502, 502, 502, 1240, 693, 1244, 1248, 1251, 1255, 1094, 1278, 928, 1260, 1269, 1273, 984, 1223, 1277,
  1282, 1286, 1080, 1290, 1292, 502, 735, 540, 1296, 1300, 1304, 1310, 502, 1316, 502, 978, 502, 1326, 1330, 1151, 502,
  1199, 502, 659, 1334, 1339, 1343, 1353, 1113, 502, 1365, 1568, 1360, 1369, 1375, 1574, 1131, 1138, 1381, 1387, 1391,
  1395, 1401, 1405, 1412, 1416, 1423, 1420, 1427, 1431, 1435, 502, 1002, 1446, 1450, 1454, 1458, 1462, 502, 1468, 1478,
  1482, 1486, 1490, 1497, 1501, 1506, 1471, 1510, 1515, 1520, 502, 1530, 502, 1536, 1474, 1471, 1559, 1335, 502, 1502,
  1542, 502, 1550, 625, 1556, 1566, 1572, 502, 1578, 502, 1604, 1493, 1584, 1562, 502, 1591, 502, 1597, 1601, 1613,
  1516, 502, 1619, 1623, 1627, 1464, 1631, 1615, 1532, 1511, 670, 1635, 502, 502, 502, 502, 503, 1699, 1639, 1643, 1668,
  1653, 1650, 1668, 1668, 1668, 1668, 1646, 1668, 1657, 1663, 1667, 1659, 1672, 1675, 1679, 1682, 1686, 1690, 1694,
  1698, 3259, 2213, 1704, 1704, 1710, 2877, 1724, 1704, 1704, 1704, 1704, 1705, 1751, 1704, 1704, 1704, 1718, 1777,
  2111, 1842, 1842, 1743, 1757, 1842, 2113, 1755, 1757, 1714, 2510, 1704, 1704, 3317, 2233, 1770, 1704, 1704, 1775,
  1776, 1756, 1757, 1757, 1757, 1757, 1704, 1781, 1704, 1704, 1704, 1765, 3243, 1842, 1842, 1842, 1800, 1805, 1757,
  1757, 1757, 1747, 1821, 1842, 1816, 1757, 1757, 1759, 1704, 3241, 3244, 1842, 1842, 1842, 1801, 1760, 1704, 1704,
  1704, 1934, 1843, 1757, 1757, 1758, 1842, 1828, 1757, 1759, 1832, 2996, 1843, 1757, 1833, 1833, 2112, 1827, 1758,
  1842, 1812, 1740, 1827, 1808, 1811, 1840, 1847, 1851, 1855, 1861, 1865, 1869, 1883, 1883, 1883, 1885, 1883, 1892,
  1873, 1877, 1881, 1883, 1889, 2733, 1896, 1900, 1904, 1908, 1912, 2730, 1916, 1920, 1924, 3231, 1929, 1704, 1704,
  3372, 3435, 2971, 1704, 1704, 1704, 1938, 2363, 1704, 1704, 1704, 2110, 2503, 1964, 1704, 1704, 1727, 1704, 1984,
  1988, 1992, 1996, 2000, 2001, 2005, 2006, 2010, 2014, 2211, 2489, 1960, 2166, 1704, 1704, 1733, 2257, 2020, 2025,
  2838, 2031, 2603, 1704, 2097, 1704, 1704, 3431, 2214, 2035, 1704, 2041, 2045, 3330, 1704, 2050, 1704, 1704, 2586,
  1959, 2165, 1704, 1709, 2792, 2409, 2079, 3063, 2097, 1704, 1732, 3415, 2908, 2679, 2089, 1704, 1704, 1933, 2414,
  1784, 3191, 2706, 2710, 2227, 2094, 1704, 2102, 2129, 1704, 1704, 2106, 2117, 2157, 1704, 1704, 1948, 1704, 2421,
  2118, 2129, 1704, 1704, 1704, 2363, 1704, 2749, 2127, 1708, 3148, 3347, 2134, 1704, 1771, 2280, 3048, 2853, 2171,
  1704, 2630, 2180, 1704, 1704, 2184, 2188, 1704, 1704, 1704, 2211, 1704, 3318, 2166, 1704, 2773, 2727, 1704, 2852,
  2193, 3309, 3157, 1704, 2199, 2203, 2201, 1704, 1704, 1704, 2391, 3316, 2164, 1704, 1704, 1954, 2742, 3418, 2596,
  2346, 3013, 2209, 1704, 1704, 2218, 1704, 3419, 2628, 2239, 2248, 1704, 1704, 2252, 3098, 3375, 1704, 3374, 1704,
  2863, 2267, 2779, 1704, 2781, 2919, 2263, 1704, 2781, 2920, 2174, 2856, 1704, 2272, 1704, 1776, 1842, 1842, 1842,
  1842, 1737, 2781, 3363, 2175, 2780, 1941, 2176, 2016, 2779, 1707, 1704, 1704, 1704, 2476, 2892, 1732, 1704, 1704,
  1959, 2165, 2572, 2214, 2286, 2295, 3341, 2312, 2316, 2320, 2328, 2333, 2329, 2323, 2324, 2324, 2337, 1704, 1825,
  1843, 1757, 1757, 1757, 1818, 1820, 2366, 2370, 2350, 3056, 1796, 2758, 2356, 2167, 3105, 3217, 2361, 3163, 2375,
  1704, 3163, 2375, 1732, 1704, 2376, 2343, 2381, 3066, 2371, 2911, 3396, 3400, 3404, 1704, 1932, 2499, 1704, 1954,
  2708, 1704, 1763, 2235, 2369, 3398, 3402, 2080, 1704, 1971, 2879, 1975, 2455, 2367, 1955, 2398, 2870, 1704, 1704,
  1704, 2613, 2415, 2871, 1704, 1704, 1978, 1704, 1704, 2892, 1704, 1704, 2300, 2419, 1704, 1764, 2234, 1704, 2965,
  2075, 2368, 2352, 1704, 3427, 2425, 1704, 1704, 1709, 2801, 3074, 2431, 1704, 1704, 2037, 2793, 3208, 1704, 2459,
  1704, 2058, 2067, 2128, 1704, 3072, 2467, 1704, 2059, 1704, 2570, 2572, 2482, 1762, 2904, 2544, 2501, 1704, 1704,
  2122, 2165, 2483, 1763, 2595, 2109, 2931, 2027, 2507, 1704, 2138, 3131, 1704, 2142, 2146, 1704, 1771, 2984, 1704,
  1776, 1776, 1776, 1777, 1842, 2571, 2523, 2904, 1834, 1704, 2530, 1704, 2189, 1703, 1704, 1704, 3248, 3185, 1925,
  2541, 1704, 1704, 2130, 1704, 2828, 2535, 2533, 1704, 2308, 2304, 2298, 2788, 2463, 2462, 1704, 2563, 2554, 2536,
  2557, 2788, 1835, 2932, 2550, 2339, 2904, 2576, 2577, 2584, 2581, 2592, 2601, 2362, 1704, 2394, 2624, 2515, 2617,
  2085, 1949, 2820, 2621, 2635, 2639, 2643, 2650, 2654, 2646, 2658, 2664, 2664, 2660, 2608, 1704, 1704, 3215, 3138,
  2668, 2673, 1704, 2098, 2687, 2694, 2699, 1706, 2195, 2703, 2716, 1704, 2724, 2986, 1704, 2362, 1704, 1704, 1720,
  2969, 2074, 2737, 1704, 2746, 2756, 1704, 1704, 2980, 2764, 2409, 1704, 1704, 2150, 1704, 2766, 1704, 1704, 1704,
  2892, 2513, 3138, 2668, 2673, 2400, 2777, 1704, 3219, 2787, 2291, 1704, 1704, 2255, 3088, 2805, 1704, 1704, 1704,
  3013, 2813, 2835, 1704, 1704, 2261, 2268, 2817, 2826, 1762, 1704, 2387, 2410, 3135, 2568, 2848, 1704, 2848, 3353,
  2081, 1704, 2404, 2408, 1704, 2046, 1704, 2566, 1795, 1704, 2453, 1704, 1704, 1704, 3038, 2832, 2862, 1704, 1704,
  2889, 2867, 1704, 1704, 1704, 3043, 3123, 2392, 2243, 1761, 1704, 2884, 2751, 2427, 2875, 1704, 1704, 1704, 3324,
  2365, 2244, 1704, 2883, 2849, 2849, 1704, 2848, 1704, 2845, 3084, 1704, 2440, 2376, 2446, 2884, 2752, 2851, 1954,
  2488, 2493, 1704, 2136, 3129, 3047, 2890, 1704, 2848, 2862, 2362, 2897, 2885, 2854, 2495, 1704, 2366, 2862, 3084,
  3025, 1793, 1704, 2478, 2166, 1704, 2364, 1704, 1704, 1704, 2149, 1795, 3355, 2046, 1704, 2519, 1704, 1704, 2123,
  2166, 2566, 1704, 1794, 1793, 2149, 2903, 2060, 2082, 2915, 2924, 2928, 3091, 2936, 2940, 2944, 2946, 2950, 2952,
  2952, 2953, 1704, 1704, 1704, 3356, 1790, 1704, 1762, 1704, 2537, 1776, 1776, 1731, 1704, 1720, 2975, 2434, 3018,
  3008, 2979, 1771, 2984, 2903, 3025, 1704, 2957, 2961, 2990, 2994, 1704, 3315, 3000, 3006, 1704, 3012, 3017, 1787,
  1704, 1704, 2278, 2282, 2151, 3024, 1704, 2957, 2990, 2994, 1704, 3022, 2676, 3007, 1704, 1704, 2436, 1953, 1704,
  2967, 1704, 1704, 2449, 2822, 2137, 3130, 2166, 1704, 2544, 2472, 1704, 2059, 1776, 1776, 3029, 2082, 1704, 2526,
  3079, 2994, 3022, 3033, 3053, 1704, 1704, 1704, 3360, 3060, 3025, 2525, 3078, 3083, 1954, 3034, 1704, 2545, 2468,
  1704, 2058, 2067, 2073, 1704, 3038, 1704, 1704, 2607, 2612, 1704, 3102, 3109, 2442, 1704, 2549, 1704, 1704, 2138,
  3145, 1704, 3113, 1704, 1704, 2740, 2155, 2205, 3119, 1704, 1704, 2770, 1704, 1704, 3142, 1704, 1704, 2782, 2847,
  3115, 3161, 2588, 3025, 3167, 2849, 1704, 2083, 1704, 3174, 1704, 1704, 2797, 1704, 3178, 1704, 3183, 2850, 3024,
  1704, 3179, 1704, 2567, 1704, 2752, 3178, 2899, 3203, 2669, 3189, 3224, 2229, 2109, 2631, 3200, 2109, 3196, 3195,
  3206, 1856, 3195, 2224, 3195, 3224, 1836, 3212, 3223, 1857, 3228, 3235, 3238, 1704, 2572, 2343, 2483, 1709, 1704,
  1704, 2454, 2917, 2783, 3390, 2159, 3252, 3256, 3263, 3267, 3271, 3275, 3279, 3283, 3286, 3289, 3293, 3299, 3296,
  3303, 1704, 1704, 2841, 1704, 3335, 1704, 3307, 2559, 2587, 2689, 1704, 2669, 1930, 3307, 2587, 2808, 3313, 2060,
  2392, 2090, 1704, 2063, 2241, 1704, 2384, 3322, 1980, 1704, 3328, 1704, 2669, 3389, 2596, 1944, 1719, 1704, 1944,
  1719, 1704, 1704, 1704, 3367, 1704, 3334, 1704, 3307, 3339, 2393, 1704, 1704, 2484, 3069, 1704, 1704, 1704, 3423,
  3002, 1931, 3345, 1704, 2683, 2569, 1704, 2357, 2204, 1931, 1709, 3153, 1704, 1704, 2843, 2856, 3151, 3155, 1704,
  1704, 2891, 2377, 3380, 1704, 1704, 1704, 2893, 1704, 1704, 2221, 3368, 3381, 1704, 1704, 2995, 2163, 2597, 2212,
  2690, 2061, 2214, 1704, 3351, 1704, 1704, 3394, 2393, 2069, 1704, 1704, 3095, 2084, 1704, 3360, 1704, 1704, 3127,
  3121, 2712, 3379, 1704, 1704, 3241, 1842, 2275, 2808, 2062, 2394, 1967, 3041, 1763, 1765, 3408, 1704, 1704, 3242,
  1776, 2695, 3412, 1704, 3049, 3433, 2857, 2807, 1704, 2695, 3385, 1704, 2720, 1704, 1704, 1704, 2762, 2307, 1704,
  1766, 1704, 1704, 2054, 2052, 3425, 2021, 3434, 2858, 2809, 2452, 2626, 2289, 1704, 1704, 2054, 1953, 3170, 2392,
  1766, 1704, 2853, 1704, 2855, 3443, 4158, 3456, 3449, 3452, 3455, 3704, 3463, 3453, 3704, 3462, 3461, 3706, 3463,
  3463, 3702, 3703, 3704, 3460, 3706, 3463, 3695, 3468, 3506, 3705, 4009, 3466, 3706, 3464, 3463, 3463, 3463, 3463,
  3507, 3502, 3503, 3514, 3514, 3514, 3513, 3512, 3505, 3509, 3468, 3511, 3516, 3469, 3779, 3518, 3535, 3538, 3536,
  3539, 3541, 3542, 3544, 3542, 3542, 3546, 3548, 3439, 4086, 3796, 3443, 3824, 3443, 3443, 3443, 3443, 3441, 3443,
  3443, 3443, 3444, 3485, 3776, 3804, 3482, 3571, 3701, 3654, 3443, 3443, 3443, 3458, 3443, 3733, 3523, 3443, 3443,
  4086, 3442, 3816, 3738, 3443, 3443, 3443, 3472, 3813, 3803, 3775, 3776, 3443, 3443, 3812, 3778, 3803, 3567, 3776,
  3776, 3804, 3484, 3443, 4070, 3523, 3523, 3773, 3775, 3776, 3776, 3776, 3776, 3443, 3443, 3443, 3445, 3443, 3443,
  3443, 3446, 3443, 3733, 3443, 3443, 3443, 3474, 3443, 3816, 3816, 3816, 3816, 3738, 3568, 3484, 3473, 3443, 3443,
  4103, 3443, 3443, 4110, 3443, 3443, 4155, 3443, 3443, 4163, 3443, 3443, 3443, 3922, 3813, 3493, 3493, 3582, 3774,
  3774, 3774, 3775, 3776, 3443, 4064, 3812, 3863, 3776, 3776, 3776, 3493, 3774, 3776, 3776, 3484, 3484, 3484, 3484,
  3443, 3443, 3817, 3812, 3812, 3776, 3776, 3776, 3776, 3804, 3443, 3443, 3443, 3486, 3443, 3947, 3804, 3443, 3812,
  3812, 3812, 3812, 3863, 3776, 3776, 4064, 3863, 3777, 3777, 3777, 3777, 3804, 3443, 3443, 3832, 3439, 3443, 3719,
  3442, 3923, 3450, 4059, 3489, 3584, 3820, 3631, 3579, 3587, 3606, 3488, 3819, 3611, 3614, 3578, 3616, 3587, 3588,
  3619, 3617, 3819, 3819, 3819, 3819, 3820, 3819, 3612, 3821, 3444, 3819, 3585, 3819, 3821, 3627, 3578, 3629, 3633,
  3819, 3630, 3820, 3634, 3635, 3636, 3635, 3638, 3640, 3673, 3642, 3642, 3672, 3672, 3672, 3672, 3645, 3661, 3663,
  3665, 3667, 3669, 3667, 3671, 3643, 3443, 3443, 3443, 3487, 3443, 4072, 3707, 3443, 3443, 3443, 3490, 3848, 3525,
  3477, 3738, 3482, 3443, 3443, 4169, 3443, 3443, 4171, 3623, 3918, 3443, 3443, 3443, 3491, 3832, 3443, 3443, 3443,
  3492, 3443, 3806, 3652, 4079, 3859, 4168, 3530, 3716, 3824, 3725, 3532, 3818, 3860, 3805, 3805, 4076, 3712, 3477,
  3549, 3712, 3598, 3781, 3443, 3443, 3444, 3710, 3950, 3521, 3842, 3723, 3742, 3741, 3744, 3746, 3747, 3748, 3750,
  3751, 3753, 3754, 3755, 3756, 3759, 3758, 3758, 3758, 3758, 3761, 3762, 3762, 3762, 3763, 3764, 3764, 3764, 3764,
  3766, 3768, 3443, 3443, 3442, 3555, 4075, 3443, 3443, 3443, 3554, 3783, 3786, 3443, 3443, 3444, 3955, 3443, 4161,
  3446, 3442, 3573, 3799, 3443, 3443, 3444, 4045, 3443, 3801, 4111, 3725, 3574, 3443, 3443, 3443, 3572, 3721, 3844,
  3443, 3443, 3446, 3734, 3527, 3443, 3522, 3443, 3443, 3443, 3593, 3443, 3443, 3443, 3475, 3492, 3738, 3443, 3443,
  3446, 4183, 3520, 3443, 3443, 3443, 3657, 3443, 3846, 3442, 3443, 3443, 3443, 3686, 3443, 3443, 3443, 3689, 4162,
  3443, 3443, 3443, 3698, 3443, 3809, 3443, 3794, 3443, 3443, 3443, 3562, 3443, 3946, 3866, 3858, 4001, 3443, 3770,
  3492, 3443, 3443, 3443, 3812, 3812, 3812, 3493, 3828, 3681, 3867, 3772, 3959, 3443, 4072, 4079, 3859, 4168, 3738,
  3443, 3521, 3443, 3443, 3443, 3700, 3874, 3521, 3443, 3443, 3471, 3557, 3732, 3603, 3726, 3621, 3681, 4078, 3795,
  3870, 3841, 3443, 3446, 4060, 3595, 3924, 3443, 3596, 3772, 3959, 3521, 3443, 3443, 3470, 3809, 4191, 3859, 4168,
  3725, 3443, 3443, 3443, 3533, 3877, 3521, 3443, 3441, 3443, 3499, 3443, 3443, 3499, 3492, 3866, 3591, 3521, 3621,
  3681, 4061, 3772, 3976, 3443, 3443, 3443, 3701, 3443, 3738, 3441, 3443, 3443, 3565, 3443, 4172, 4082, 3591, 3789,
  3443, 3443, 3443, 3708, 3557, 4036, 3870, 3443, 3443, 3473, 3443, 3443, 3443, 3440, 3827, 3681, 3591, 3789, 3790,
  3470, 3726, 3443, 3486, 3443, 3447, 3443, 3443, 3457, 3826, 4196, 3443, 3443, 3443, 3720, 3443, 3443, 4016, 3592,
  3443, 3443, 3443, 3477, 3718, 3443, 3443, 4172, 4036, 3592, 3827, 3681, 3591, 3443, 3472, 3730, 4071, 3600, 3688,
  3880, 3854, 3725, 3443, 3442, 3555, 4196, 3443, 3443, 3442, 3443, 3890, 3725, 3442, 3555, 3443, 3473, 3443, 3474,
  3569, 4106, 3688, 3942, 3724, 3443, 3470, 3443, 3446, 3446, 3443, 3443, 3443, 4046, 3443, 3862, 3816, 4084, 3728,
  3443, 3838, 3443, 3602, 3443, 3443, 3805, 3440, 3440, 3443, 3443, 3446, 3445, 3838, 3897, 4023, 3897, 3899, 3902,
  3900, 3904, 3906, 3909, 3908, 3909, 3915, 3915, 3915, 3915, 3911, 3909, 3909, 3909, 3909, 3913, 3913, 3909, 3909,
  3915, 3915, 3443, 3443, 3483, 3964, 3790, 4064, 3491, 3726, 3443, 3809, 3591, 3496, 3917, 3443, 3443, 3486, 3953,
  3928, 3443, 3443, 3443, 3738, 3933, 3443, 3443, 3443, 3787, 3443, 3443, 3443, 3522, 3855, 3443, 3443, 3486, 3496,
  3931, 3443, 3443, 3443, 3789, 3602, 3443, 3802, 3720, 3443, 3474, 3967, 3443, 3477, 3457, 3686, 4074, 3443, 3443,
  3443, 3790, 3443, 3443, 3528, 3953, 3443, 3443, 3492, 3823, 3443, 3945, 3692, 3599, 3683, 3960, 3443, 3443, 3443,
  3805, 3525, 3531, 3737, 3653, 4062, 3826, 3728, 3443, 3443, 3492, 3828, 3895, 3725, 3443, 3443, 3492, 4179, 3825,
  3958, 3960, 3443, 3480, 3443, 3443, 3680, 3697, 3893, 3549, 3443, 3443, 3494, 3476, 3790, 3470, 3727, 3443, 3481,
  3561, 3443, 3440, 3443, 3443, 3443, 3875, 3443, 3945, 3948, 3720, 3443, 3483, 4035, 3572, 3443, 3736, 3653, 4062,
  3959, 3725, 3694, 3825, 3958, 3720, 3443, 3893, 3443, 3443, 3494, 4184, 3602, 3923, 3443, 3443, 3443, 3734, 3701,
  3443, 3443, 3443, 3806, 3446, 3952, 3443, 3443, 3522, 4063, 3848, 3526, 3682, 3958, 3443, 3443, 3527, 3549, 3526,
  3957, 3789, 3443, 3484, 3484, 3443, 3440, 3443, 3781, 3443, 4166, 3490, 3646, 3830, 3958, 3790, 4167, 3443, 3443,
  3527, 3708, 4041, 3620, 3647, 3958, 3443, 3487, 3946, 3964, 3443, 3443, 3443, 3816, 3962, 3957, 3789, 3443, 3490,
  3848, 3526, 3693, 3487, 3946, 3957, 3443, 3443, 3443, 4041, 3443, 3553, 3964, 3443, 3443, 3532, 3499, 4041, 3443,
  4069, 3572, 3443, 3443, 3443, 4008, 3443, 3443, 3443, 3838, 3443, 3443, 4049, 3443, 3443, 3855, 3572, 3443, 4041,
  3483, 3572, 3443, 3483, 3443, 3443, 3443, 3589, 3572, 3483, 3572, 4041, 3443, 3443, 3443, 3809, 3555, 3473, 3473,
  3443, 3443, 3532, 3792, 3443, 3966, 3969, 4192, 3797, 3797, 3443, 3443, 3443, 3826, 3971, 3871, 3973, 3521, 3978,
  3549, 3789, 3443, 3491, 3491, 3443, 3443, 3443, 3532, 3826, 3443, 3443, 3832, 3838, 3442, 3738, 3878, 3980, 3604,
  3816, 3982, 3984, 3986, 3987, 3990, 3993, 3990, 3997, 3991, 3989, 3990, 3990, 3995, 3995, 3990, 3990, 3994, 3999,
  4006, 4006, 4000, 3443, 4006, 4006, 4006, 4006, 4153, 3443, 3443, 3443, 3832, 3444, 3443, 3549, 3443, 3492, 3656,
  3443, 3492, 3833, 3867, 3593, 3443, 3443, 3725, 4011, 4013, 3443, 3443, 3549, 3492, 3443, 3684, 3443, 3443, 3443,
  3847, 3443, 4018, 4175, 3725, 4019, 3725, 4022, 3443, 3492, 3850, 4082, 3771, 3852, 3443, 3443, 3446, 4186, 3443,
  4025, 4027, 3678, 3443, 4030, 4032, 3725, 3443, 4034, 3648, 3683, 3840, 3724, 3443, 3477, 3584, 3819, 3625, 3577,
  3577, 4038, 4073, 4176, 3443, 3492, 4172, 4082, 4067, 3870, 3655, 4174, 3657, 3443, 3495, 3443, 3492, 3495, 3443,
  3443, 3443, 4040, 3443, 3443, 3550, 3926, 3443, 4043, 3829, 4173, 3649, 3869, 3960, 3443, 3529, 4086, 3450, 3443,
  3497, 3810, 3594, 3443, 3769, 3443, 3443, 3555, 3443, 3443, 3443, 3726, 3726, 4020, 3443, 3443, 3443, 3855, 4045,
  3735, 3866, 3868, 3960, 3528, 3969, 4192, 3442, 3485, 3524, 3735, 3883, 4062, 3960, 3443, 3443, 3598, 3443, 3443,
  3443, 4048, 3494, 3498, 3531, 3440, 3443, 3443, 4064, 3975, 3443, 3528, 3564, 3555, 3607, 3728, 3855, 3443, 3493,
  3487, 3444, 3485, 3734, 4084, 4188, 3725, 3443, 3519, 3521, 3443, 3443, 4194, 3735, 3443, 3443, 4080, 3443, 3443,
  3443, 3494, 3443, 3443, 3443, 3495, 3443, 3443, 3443, 3499, 3473, 3443, 4063, 3443, 3443, 3443, 3887, 4048, 3494,
  4051, 4062, 3870, 3960, 3443, 3443, 3444, 3485, 4179, 4062, 3443, 3443, 3609, 3715, 3443, 3708, 3707, 3443, 3443,
  3495, 3492, 4187, 3443, 3443, 3443, 3893, 3810, 3738, 3443, 3718, 3443, 3443, 3651, 3443, 3924, 3443, 3443, 3443,
  4041, 3847, 4053, 3592, 3443, 3528, 3595, 3888, 3443, 3939, 3726, 3443, 3443, 3443, 3651, 3854, 3725, 3446, 4014,
  3532, 3592, 3443, 4056, 3809, 3446, 3486, 3443, 3443, 3487, 3580, 3659, 3658, 3659, 4058, 4089, 4092, 4091, 4092,
  4094, 4092, 4092, 4092, 4092, 4092, 4096, 4098, 4098, 4098, 4098, 3443, 3805, 3443, 3709, 3891, 3443, 3726, 3443,
  4015, 3443, 3853, 3443, 3446, 3600, 4002, 3443, 3443, 3675, 3677, 4100, 3443, 3443, 3445, 4028, 3443, 3443, 3443,
  4043, 4105, 4108, 3443, 3443, 3685, 3443, 3443, 3726, 3443, 4164, 3532, 3443, 3443, 3443, 4064, 3812, 3443, 3814,
  3443, 3443, 3690, 3938, 3443, 4002, 3443, 3443, 3443, 4102, 3444, 3443, 3443, 3443, 4172, 3479, 3443, 3458, 3443,
  3443, 3853, 3443, 3443, 3443, 3707, 3443, 3443, 4113, 3594, 3949, 3442, 3492, 3524, 3443, 3443, 3443, 3443, 4115,
  3717, 3728, 4154, 3443, 3443, 3576, 3443, 3718, 3724, 3443, 3443, 3443, 4190, 3839, 3872, 3725, 3443, 3528, 3920,
  3725, 4113, 3594, 3949, 3443, 3532, 3559, 3443, 3443, 4195, 3443, 3444, 3691, 3443, 3444, 3847, 3646, 3531, 3694,
  4041, 3592, 3443, 3826, 4164, 4165, 3443, 3443, 3853, 3728, 3600, 4118, 3872, 3443, 3532, 3580, 3856, 3477, 3594,
  3654, 3443, 3532, 3809, 3592, 3805, 3709, 3592, 3443, 3550, 3930, 3725, 3826, 4165, 3443, 3608, 3593, 3717, 3443,
  3443, 3708, 3730, 3732, 3603, 3687, 3888, 3443, 3443, 3726, 4087, 3708, 3557, 3732, 3603, 3687, 3788, 3943, 3725,
  3709, 3592, 3726, 3809, 4064, 3607, 3871, 3443, 4120, 3811, 3687, 3718, 3521, 3443, 3532, 3597, 3443, 3444, 4178,
  3622, 3600, 3654, 3443, 3443, 3866, 3591, 4065, 3597, 3443, 3443, 3739, 3935, 3527, 3726, 3809, 3443, 3556, 3443,
  3598, 3443, 3729, 3716, 4084, 3443, 3730, 3601, 3826, 3443, 3651, 3707, 3443, 3826, 3826, 3726, 3439, 3826, 3443,
  3443, 3769, 3650, 3443, 3947, 4084, 3443, 3443, 3439, 3826, 3443, 3826, 3443, 3486, 3443, 3590, 3443, 3486, 3654,
  3443, 3440, 3443, 3947, 3440, 3443, 3443, 3781, 3443, 3443, 3492, 3815, 3492, 3443, 3832, 3439, 3826, 3486, 3832,
  3549, 3832, 3442, 3443, 3478, 3549, 3598, 3598, 3731, 3731, 3731, 3443, 3593, 3816, 3816, 3816, 3812, 3812, 3443,
  3832, 4072, 4066, 4085, 3499, 4068, 4122, 3443, 4085, 3473, 3443, 3651, 3707, 3552, 3726, 3726, 4064, 3713, 3808,
  4064, 4124, 3807, 4003, 4004, 3808, 4116, 3738, 3816, 4083, 3784, 4054, 4126, 4128, 4130, 4129, 4130, 4132, 4134,
  4139, 4139, 4138, 4138, 4138, 4136, 4137, 4141, 4143, 4144, 4144, 4144, 4144, 4145, 4146, 4144, 4145, 4148, 4150,
  4152, 3831, 3443, 3443, 3443, 3809, 3726, 3486, 3787, 3608, 3443, 3443, 3443, 4072, 3859, 4168, 4157, 3443, 3443,
  3443, 3819, 3443, 4160, 3500, 3443, 3443, 3835, 3837, 3443, 3832, 4072, 3707, 3443, 3443, 3738, 3443, 3443, 3861,
  3443, 3709, 3443, 3443, 3443, 3865, 4078, 3443, 3847, 3476, 3443, 3443, 3443, 3728, 3443, 3443, 3847, 3938, 3707,
  3443, 3651, 4196, 3441, 3443, 3847, 3822, 3498, 4077, 4181, 3652, 3443, 3443, 3882, 3885, 3443, 3498, 4077, 3653,
  3443, 3443, 3443, 3524, 3735, 3600, 3654, 3457, 3443, 3443, 3831, 4085, 3847, 3938, 3443, 3443, 3937, 3558, 3737,
  3652, 3825, 3941, 3840, 3724, 3442, 3443, 4186, 3498, 4077, 3654, 3524, 3735, 4078, 3443, 3654, 3527, 3443, 3522,
  3443, 3441, 3443, 3446, 3734, 3894, 3443, 3443, 3443, 3945, 3810, 3734, 3443, 3443, 3443, 4081, 3443, 3443, 3443,
  4096, 524288, 0, -2147483648, 0, 0, 1, 0, 2, -2147483648, 65536, 134217728, -2147483648, 131074, 131088, 16908288,
  134283264, 65536, 65536, 0, 3, 131102, 1073872896, 1073872896, 131072, 131072, 8768, 10560, 1073872896, 386007040,
  386007040, 16384, 0, 6, 16, 0, 7, 128, 0, 8, 0, 9, 0, 12, 0, 16, 16, 32, 0, 24, 8, 1, 2, 0, 32, 32, 64, 0, 34, 128,
  256, 0, 39, 163856, 268599296, -1761476608, 117571584, 386007040, 163840, -1761476608, 117571584, 1459748864,
  386039808, 386007040, 117571584, 84017152, 84017152, 386007040, 1459748864, 147488, 81920, 301989888, 536870912, 0,
  64, 64, 128, 768, 1024, 0, 128, 1024, 1024, 2048, 0, 130, 8536096, 147488, -1073594336, 268582944, -2147336160,
  -2147336160, -1073594306, -1065205698, -1065205698, -1048428482, -1065205698, 386023456, 386023456, -947765186, 4096,
  0, 162, 2, 16, 512, 0, 256, 16, 768, 3072, 2359296, 14, 0, 608, 8256, 0, 704, 8405024, 8404992, 16, 4864, 4096,
  4194304, 0, 3616, 545521664, 12, 8, 136, 136, 65544, 33587202, 32, 8388640, 134234112, 8, 32776, 131080, 262152, 8,
  65536, 1048576, 8388608, 0, 32768, 65536, 262144, 1572864, 0, 4096, 32768, 131072, 524288, 16384, 32768, 131076,
  67108872, 8, 33554432, 0, 33824, 12, 152, 8, 1073741848, 262280, 393224, 131080, 8, 152, 24, 32, 384, 1024, 163840,
  41418752, 136, 262152, 131208, 262296, 1032335850, 24, 40, 1032335850, 1032335850, 1032585720, 1032585720, 2106327544,
  2106458616, 1032598008, 2106458618, 1032598008, 1032598010, 1032663546, 1067191770, 10, 56, 768, 8192, 65536, 1835008,
  0, 65536, 131072, 262144, 0, 192, 0, 224, 33587202, 33587202, 10, 26, 58, 35128330, 35130378, 35142666, 35142990,
  35142990, 35143006, 1108884814, 1108884830, 1032598010, 1032598010, 1032663544, 8192, 25165824, 805306368, 0, 110592,
  34603008, 2048, 8192, 262144, 8388608, 1310720, 0, 131072, 1572864, 2097152, 1, 6, 128, 2048, 12288, 131072, 16908288,
  59768832, 0, 163840, 3145728, 0, 262144, 131088, 268566528, 1073872896, -2147352576, 131072, 0, 4, 0, 5, 1082130432,
  0, 1048592, 5184, 4096, 131072, 33554432, 67108864, 134217728, 0, 12192, 545259520, 536870912, 1073741824, 0, 1048576,
  67108864, 0, 768, 4096, 4096, 8192, 64, 256, 1024, 12288, 32768, 0, 959, 545260544, 545259520, -2147483646, 545261568,
  547654696, 1573380, 1573380, 547130912, 68682244, 547130912, 547130912, 1444495876, 545558056, 545558056, 546606632,
  547130920, 545562216, 547130924, 547130924, 545562216, 547130924, 702328736, 702328736, 702328737, 702328737,
  702328748, 702328748, 702328745, 0, 1310720, 1835008, 4194304, 8388608, 8388640, 8388640, 8404992, 8404992, 16384,
  16416, 81952, 0, 1073741824, 1056, 32768, 1081344, 5184, 0, 2097152, 16777216, 0, 524288, 3104, 547618816, 512,
  1572864, 4194304, 536870912, -2147483648, 32768, 547094528, 68681728, 0, 8388608, 8404992, 0, 1024, 16384, 4608, 0,
  2048, 4096, 16384, 16384, 32, 192, 32768, 32768, 16384, 8, 8, 10, 8, 64, 262144, 262144, 1048576, 0, 384, 512, 1024,
  8192, 0, 512, 3072, 546570240, 547094528, 7776, 0, 16777216, 33554432, 134217728, 536870912, 1375813632, 32768,
  702283776, 545259520, 2, 4, 56, 896, 3072, 696254464, 0, 33554432, 268435456, 0, 33587202, 1835008, 8388608, 33554432,
  16777216, 16778240, 16384, 8404992, 32, 2048, 32768, 1835008, 6291456, 8388608, 16777216, 67108864, 536870912,
  1572864, 8388608, 134217728, 32, 32768, 2097152, 65536, 8388608, 256, 2048, 524288, 8192, 8388608, 65536, 33554432,
  536870912, 65536, 268435456, 8388608, 2, 1024, 262144, 134217728, 2, 142606336, 142639104, 142610432, 142610464,
  268435520, 142606336, 142645282, 1644494976, 1644511360, 1644494976, 1661272192, 1787140258, 1787140258, 1661272194,
  1787140258, 1787664546, 1787140258, -336085057, -336085057, 38912, 0, 40894464, 327680, 570425344, 344064, 0,
  67108864, -2147483648, 366592, 8388608, 704643072, 1073741824, 366592, 704643072, -1073741824, 890880, 1073741824,
  506880, 32505856, 63, 128, 32768, 8388608, 14680064, 16777216, 100663296, 536870912, 2, 32, 512, 4096, 262144,
  67108864, 1375813632, 32, 262144, 1073741824, 2, 56, 8192, 6291456, 16777216, 134217728, 1073741824, 32, 768, 8192,
  4194304, 2, 128, 163840, 1024, 1048576, 33554440, 1048576, 402653184, 134217728, 4096, 16777216, 536870912, 2,
  16777216, 32768, 1073774592, 32768, 1074299008, 10822240, 8725088, 9773664, 1083024096, -2138758560, 1083024064,
  1083024096, 1083024096, -2136661408, 1083024096, 1217241824, 1083024096, 1083024098, 1083024096, 1485677280,
  1083028192, 1224585201, 0, 100663296, 0, 36700160, 1064960, 1224585201, 1224585201, 4, 131072, 134227136, 73728,
  262144, 10485760, 0, 138412032, 2048, 1048576, 736, 106496, 786432, 1073741824, 736, 0, 142606336, 738, 142606336,
  411041792, 0, 235012096, 2033, 108544, 1835008, 148897792, 96, 512, 8192, 1048576, 512, 40960, 226, 0, 268435456, 1,
  496, 48, 192, 786432, 1, 16, 4194304, 256, 524288, 268436480, 32768, 16941056, 2048, 134217728, 100827138, 1, 8,
  32768, 1048576, 6291456, 0, 16384, 131072, 1048576, 4194304, 16, 8192, 8192, 16384, 65536, 786432, 0, 4160, 1024,
  32768, 262144, 2097152, 0, 8192, 32768, 524288, 1048576, 1048576, 2097152, -2147483648, 1, 262145, 1, 100827139,
  100827139, 65545, 100827139, 109215747, 235044867, 1731916567, 1731916567, 32768, 100794368, 109182976, 0, 369098752,
  4880, 57344, 131072, 658112512, 1073741824, 234881024, 0, 370671616, 2, 8, 2, 32768, 36700160, 1572864, 33554432, 4,
  768, 1179648, 5242880, 1048608, 16777216, 12583047, 12591239, 12583047, 163975, 1212551, 12587655, 29524097, 29524097,
  29524101, 29524101, 29524615, 30572679, 29524103, 29524103, 30572673, 29526151, 29524119, 30572711, 427471, 427471,
  1476047, 427471, 17204687, 427471, 30836175, 30836175, 29787599, 0, 402653184, 0, 100794368, 640, 0, 536936448, 23, 0,
  545259520, 0, 4194304, 134217728, 2048, 16384, 67108864, 268435456, -2147483648, 79, 384, 2048, 40960, 786432,
  8388608, 1073741824, 14, 64, 524288, 512, 16384, 4, 128, 524288, 4, 64, 6291456, 134217728, 512, 65536, 2097152,
  134217728, 2, 64, 268435456, 1073741824
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "QName",
  "NCName",
  "S",
  "S",
  "CommentContents",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "Wildcard",
  "EOF",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'after'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'invoke'",
  "'is'",
  "'item'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'modify'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'rename'",
  "'replace'",
  "'return'",
  "'revalidation'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'skip'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'transform'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'updating'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'with'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 4096,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 4096
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 4096 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 4095) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 4096, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 2153 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 4 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(66, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 47) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 18) then                 (: CommentContents :)
            let $state := p:consume(18, $input, $state)     (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(35, $input, $state)               (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consume(47, $input, $state)               (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S^WS :)
      let $state := p:consume(17, $input, $state)           (: S^WS :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  return $state
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(159, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(199, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionBody($input, $state)
      return $state
    else
      let $state := p:consume(115, $input, $state)          (: 'external' :)
      return $state
  return $state
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(204, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: ':=' :)
      let $state := p:consume(49, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(115, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(81, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: ':=' :)
          let $state := p:consume(49, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(207, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse CompatibilityAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompatibilityAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(201, $input, $state)              (: 'updating' :)
  return $state
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 31                               (: '%' :)
      and $state[$p:l1] != 201) then                        (: 'updating' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 201) then                (: 'updating' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-CompatibilityAnnotation($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Annotation($input, $state)
            return $state
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 204) then                      (: 'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'is' :)
      let $state := p:consume(137, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<<' :)
      let $state := p:consume(55, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(61, $input, $state)           (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 58) then                       (: '=' :)
      let $state := p:consume(58, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:consume(26, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<' :)
      let $state := p:consume(51, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '<=' :)
      let $state := p:consume(56, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: '>' :)
      let $state := p:consume(59, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(60, $input, $state)           (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 112) then                      (: 'eq' :)
      let $state := p:consume(112, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'ne' :)
      let $state := p:consume(151, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'lt' :)
      let $state := p:consume(144, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'le' :)
      let $state := p:consume(141, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'gt' :)
      let $state := p:consume(125, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(121, $input, $state)          (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TypeName($input, $state)
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '?' :)
      let $state := p:consume(62, $input, $state)           (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(174, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '@' :)
      let $state := p:consume(64, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(196, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'child' :)
      let $state := p:consume(86, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant' :)
      let $state := p:consume(99, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state := p:consume(77, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'self' :)
      let $state := p:consume(181, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descendant-or-self' :)
      let $state := p:consume(100, $input, $state)          (: 'descendant-or-self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'following-sibling' :)
      let $state := p:consume(118, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(117, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 77) then                           (: 'attribute' :)
      let $state := p:lookahead2W(180, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (86,                           (: 'child' :)
                              99,                           (: 'descendant' :)
                              100,                          (: 'descendant-or-self' :)
                              117,                          (: 'following' :)
                              118,                          (: 'following-sibling' :)
                              181)) then                    (: 'self' :)
      let $state := p:lookahead2W(178, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 12365                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12374                          (: 'child' '::' :)
          or $state[$p:lk] = 12387                          (: 'descendant' '::' :)
          or $state[$p:lk] = 12388                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 12405                          (: 'following' '::' :)
          or $state[$p:lk] = 12406                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 12469) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(196, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(43, $input, $state)               (: '..' :)
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (77,                                (: 'attribute' :)
                         88,                                (: 'comment' :)
                         105,                               (: 'document-node' :)
                         106,                               (: 'element' :)
                         150,                               (: 'namespace-node' :)
                         155,                               (: 'node' :)
                         172,                               (: 'processing-instruction' :)
                         179,                               (: 'schema-attribute' :)
                         180,                               (: 'schema-element' :)
                         190)) then                         (: 'text' :)
      let $state := p:lookahead2W(177, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8525                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8536                           (: 'comment' '(' :)
          or $state[$p:lk] = 8553                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8554                           (: 'element' '(' :)
          or $state[$p:lk] = 8598                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 8603                           (: 'node' '(' :)
          or $state[$p:lk] = 8620                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8627                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8628                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8638) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'parent' :)
      let $state := p:consume(164, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ancestor' :)
      let $state := p:consume(71, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'preceding-sibling' :)
      let $state := p:consume(169, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'preceding' :)
      let $state := p:consume(168, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(72, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(48, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(196, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (71,                                (: 'ancestor' :)
                         72,                                (: 'ancestor-or-self' :)
                         164,                               (: 'parent' :)
                         168,                               (: 'preceding' :)
                         169)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(178, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 43                             (: '..' :)
          or $state[$p:lk] = 12359                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 12360                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 12452                          (: 'parent' '::' :)
          or $state[$p:lk] = 12456                          (: 'preceding' '::' :)
          or $state[$p:lk] = 12457) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(174, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(66, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(67, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(177, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 33                               (: '(' :)
      and $state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 66) then                 (: '[' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 77) then                           (: 'attribute' :)
      let $state := p:lookahead2W(215, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 22349) then                    (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 24909) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 27725) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(125, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 30541) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(129, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34125) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(106, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 40525) then               (: 'attribute' 'only' :)
          let $state := p:lookahead3W(96, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47437) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 49485) then               (: 'attribute' 'transform' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'with' | '{' :)
          return $state
        else if ($state[$p:lk] = (19277,                    (: 'attribute' 'ascending' :)
                                  25933)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(153, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (23885,                    (: 'attribute' 'count' :)
                                  36685)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(73, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (28493,                    (: 'attribute' 'end' :)
                                  47693)) then              (: 'attribute' 'start' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (31565,                    (: 'attribute' 'group' :)
                                  41293)) then              (: 'attribute' 'order' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (21325,                    (: 'attribute' 'cast' :)
                                  21581,                    (: 'attribute' 'castable' :)
                                  49741)) then              (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (17741,                    (: 'attribute' 'after' :)
                                  18765,                    (: 'attribute' 'and' :)
                                  19021,                    (: 'attribute' 'as' :)
                                  20301,                    (: 'attribute' 'before' :)
                                  21069,                    (: 'attribute' 'case' :)
                                  26445,                    (: 'attribute' 'div' :)
                                  27469,                    (: 'attribute' 'else' :)
                                  28749,                    (: 'attribute' 'eq' :)
                                  29261,                    (: 'attribute' 'except' :)
                                  31053,                    (: 'attribute' 'ge' :)
                                  32077,                    (: 'attribute' 'gt' :)
                                  32333,                    (: 'attribute' 'idiv' :)
                                  34381,                    (: 'attribute' 'intersect' :)
                                  34637,                    (: 'attribute' 'into' :)
                                  35149,                    (: 'attribute' 'is' :)
                                  36173,                    (: 'attribute' 'le' :)
                                  36941,                    (: 'attribute' 'lt' :)
                                  37453,                    (: 'attribute' 'mod' :)
                                  37709,                    (: 'attribute' 'modify' :)
                                  38733,                    (: 'attribute' 'ne' :)
                                  41037,                    (: 'attribute' 'or' :)
                                  44877,                    (: 'attribute' 'return' :)
                                  45389,                    (: 'attribute' 'satisfies' :)
                                  49229,                    (: 'attribute' 'to' :)
                                  51021,                    (: 'attribute' 'union' :)
                                  53069,                    (: 'attribute' 'where' :)
                                  53581)) then              (: 'attribute' 'with' :)
          let $state := p:lookahead3W(211, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 106) then                     (: 'element' :)
      let $state := p:lookahead2W(214, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 22378) then                    (: 'element' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 24938) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 27754) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(125, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 30570) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(129, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34154) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(106, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 40554) then               (: 'element' 'only' :)
          let $state := p:lookahead3W(96, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 47466) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] eq 49514) then               (: 'element' 'transform' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'with' | '{' :)
          return $state
        else if ($state[$p:lk] = (19306,                    (: 'element' 'ascending' :)
                                  25962)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(153, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (23914,                    (: 'element' 'count' :)
                                  36714)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(73, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (28522,                    (: 'element' 'end' :)
                                  47722)) then              (: 'element' 'start' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (31594,                    (: 'element' 'group' :)
                                  41322)) then              (: 'element' 'order' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (21354,                    (: 'element' 'cast' :)
                                  21610,                    (: 'element' 'castable' :)
                                  49770)) then              (: 'element' 'treat' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (17770,                    (: 'element' 'after' :)
                                  18794,                    (: 'element' 'and' :)
                                  19050,                    (: 'element' 'as' :)
                                  20330,                    (: 'element' 'before' :)
                                  21098,                    (: 'element' 'case' :)
                                  26474,                    (: 'element' 'div' :)
                                  27498,                    (: 'element' 'else' :)
                                  28778,                    (: 'element' 'eq' :)
                                  29290,                    (: 'element' 'except' :)
                                  31082,                    (: 'element' 'ge' :)
                                  32106,                    (: 'element' 'gt' :)
                                  32362,                    (: 'element' 'idiv' :)
                                  34410,                    (: 'element' 'intersect' :)
                                  34666,                    (: 'element' 'into' :)
                                  35178,                    (: 'element' 'is' :)
                                  36202,                    (: 'element' 'le' :)
                                  36970,                    (: 'element' 'lt' :)
                                  37482,                    (: 'element' 'mod' :)
                                  37738,                    (: 'element' 'modify' :)
                                  38762,                    (: 'element' 'ne' :)
                                  41066,                    (: 'element' 'or' :)
                                  44906,                    (: 'element' 'return' :)
                                  45418,                    (: 'element' 'satisfies' :)
                                  49258,                    (: 'element' 'to' :)
                                  51050,                    (: 'element' 'union' :)
                                  53098,                    (: 'element' 'where' :)
                                  53610)) then              (: 'element' 'with' :)
          let $state := p:lookahead3W(211, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (149,                          (: 'namespace' :)
                              172)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(186, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'with' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = (22421,                         (: 'namespace' 'collation' :)
                             22444)) then                   (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (24981,                    (: 'namespace' 'default' :)
                                  25004)) then              (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (27797,                    (: 'namespace' 'empty' :)
                                  27820)) then              (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(125, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = (30613,                    (: 'namespace' 'for' :)
                                  30636)) then              (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(129, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = (34197,                    (: 'namespace' 'instance' :)
                                  34220)) then              (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(106, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = (40597,                    (: 'namespace' 'only' :)
                                  40620)) then              (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(96, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = (47509,                    (: 'namespace' 'stable' :)
                                  47532)) then              (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (49557,                    (: 'namespace' 'transform' :)
                                  49580)) then              (: 'processing-instruction' 'transform' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'with' | '{' :)
          return $state
        else if ($state[$p:lk] = (19349,                    (: 'namespace' 'ascending' :)
                                  26005,                    (: 'namespace' 'descending' :)
                                  19372,                    (: 'processing-instruction' 'ascending' :)
                                  26028)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(153, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (23957,                    (: 'namespace' 'count' :)
                                  36757,                    (: 'namespace' 'let' :)
                                  23980,                    (: 'processing-instruction' 'count' :)
                                  36780)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(73, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (28565,                    (: 'namespace' 'end' :)
                                  47765,                    (: 'namespace' 'start' :)
                                  28588,                    (: 'processing-instruction' 'end' :)
                                  47788)) then              (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (31637,                    (: 'namespace' 'group' :)
                                  41365,                    (: 'namespace' 'order' :)
                                  31660,                    (: 'processing-instruction' 'group' :)
                                  41388)) then              (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (21397,                    (: 'namespace' 'cast' :)
                                  21653,                    (: 'namespace' 'castable' :)
                                  49813,                    (: 'namespace' 'treat' :)
                                  21420,                    (: 'processing-instruction' 'cast' :)
                                  21676,                    (: 'processing-instruction' 'castable' :)
                                  49836)) then              (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (17813,                    (: 'namespace' 'after' :)
                                  18837,                    (: 'namespace' 'and' :)
                                  19093,                    (: 'namespace' 'as' :)
                                  20373,                    (: 'namespace' 'before' :)
                                  21141,                    (: 'namespace' 'case' :)
                                  26517,                    (: 'namespace' 'div' :)
                                  27541,                    (: 'namespace' 'else' :)
                                  28821,                    (: 'namespace' 'eq' :)
                                  29333,                    (: 'namespace' 'except' :)
                                  31125,                    (: 'namespace' 'ge' :)
                                  32149,                    (: 'namespace' 'gt' :)
                                  32405,                    (: 'namespace' 'idiv' :)
                                  34453,                    (: 'namespace' 'intersect' :)
                                  34709,                    (: 'namespace' 'into' :)
                                  35221,                    (: 'namespace' 'is' :)
                                  36245,                    (: 'namespace' 'le' :)
                                  37013,                    (: 'namespace' 'lt' :)
                                  37525,                    (: 'namespace' 'mod' :)
                                  37781,                    (: 'namespace' 'modify' :)
                                  38805,                    (: 'namespace' 'ne' :)
                                  41109,                    (: 'namespace' 'or' :)
                                  44949,                    (: 'namespace' 'return' :)
                                  45461,                    (: 'namespace' 'satisfies' :)
                                  49301,                    (: 'namespace' 'to' :)
                                  51093,                    (: 'namespace' 'union' :)
                                  53141,                    (: 'namespace' 'where' :)
                                  53653,                    (: 'namespace' 'with' :)
                                  17836,                    (: 'processing-instruction' 'after' :)
                                  18860,                    (: 'processing-instruction' 'and' :)
                                  19116,                    (: 'processing-instruction' 'as' :)
                                  20396,                    (: 'processing-instruction' 'before' :)
                                  21164,                    (: 'processing-instruction' 'case' :)
                                  26540,                    (: 'processing-instruction' 'div' :)
                                  27564,                    (: 'processing-instruction' 'else' :)
                                  28844,                    (: 'processing-instruction' 'eq' :)
                                  29356,                    (: 'processing-instruction' 'except' :)
                                  31148,                    (: 'processing-instruction' 'ge' :)
                                  32172,                    (: 'processing-instruction' 'gt' :)
                                  32428,                    (: 'processing-instruction' 'idiv' :)
                                  34476,                    (: 'processing-instruction' 'intersect' :)
                                  34732,                    (: 'processing-instruction' 'into' :)
                                  35244,                    (: 'processing-instruction' 'is' :)
                                  36268,                    (: 'processing-instruction' 'le' :)
                                  37036,                    (: 'processing-instruction' 'lt' :)
                                  37548,                    (: 'processing-instruction' 'mod' :)
                                  37804,                    (: 'processing-instruction' 'modify' :)
                                  38828,                    (: 'processing-instruction' 'ne' :)
                                  41132,                    (: 'processing-instruction' 'or' :)
                                  44972,                    (: 'processing-instruction' 'return' :)
                                  45484,                    (: 'processing-instruction' 'satisfies' :)
                                  49324,                    (: 'processing-instruction' 'to' :)
                                  51116,                    (: 'processing-instruction' 'union' :)
                                  53164,                    (: 'processing-instruction' 'where' :)
                                  53676)) then              (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(211, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (88,                           (: 'comment' :)
                              104,                          (: 'document' :)
                              162,                          (: 'ordered' :)
                              190,                          (: 'text' :)
                              200)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(185, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (109,                          (: 'empty-sequence' :)
                              127,                          (: 'if' :)
                              138,                          (: 'item' :)
                              189,                          (: 'switch' :)
                              198)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(176, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (71,                           (: 'ancestor' :)
                              72,                           (: 'ancestor-or-self' :)
                              86,                           (: 'child' :)
                              99,                           (: 'descendant' :)
                              100,                          (: 'descendant-or-self' :)
                              117,                          (: 'following' :)
                              118,                          (: 'following-sibling' :)
                              164,                          (: 'parent' :)
                              168,                          (: 'preceding' :)
                              169,                          (: 'preceding-sibling' :)
                              181)) then                    (: 'self' :)
      let $state := p:lookahead2W(182, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              14,                           (: QName^Token :)
                              69,                           (: 'after' :)
                              73,                           (: 'and' :)
                              74,                           (: 'as' :)
                              75,                           (: 'ascending' :)
                              79,                           (: 'before' :)
                              82,                           (: 'case' :)
                              83,                           (: 'cast' :)
                              84,                           (: 'castable' :)
                              87,                           (: 'collation' :)
                              91,                           (: 'copy' :)
                              93,                           (: 'count' :)
                              96,                           (: 'declare' :)
                              97,                           (: 'default' :)
                              98,                           (: 'delete' :)
                              101,                          (: 'descending' :)
                              103,                          (: 'div' :)
                              105,                          (: 'document-node' :)
                              107,                          (: 'else' :)
                              108,                          (: 'empty' :)
                              111,                          (: 'end' :)
                              112,                          (: 'eq' :)
                              113,                          (: 'every' :)
                              114,                          (: 'except' :)
                              116,                          (: 'first' :)
                              119,                          (: 'for' :)
                              120,                          (: 'function' :)
                              121,                          (: 'ge' :)
                              123,                          (: 'group' :)
                              125,                          (: 'gt' :)
                              126,                          (: 'idiv' :)
                              128,                          (: 'import' :)
                              132,                          (: 'insert' :)
                              133,                          (: 'instance' :)
                              134,                          (: 'intersect' :)
                              135,                          (: 'into' :)
                              136,                          (: 'invoke' :)
                              137,                          (: 'is' :)
                              139,                          (: 'last' :)
                              141,                          (: 'le' :)
                              143,                          (: 'let' :)
                              144,                          (: 'lt' :)
                              146,                          (: 'mod' :)
                              147,                          (: 'modify' :)
                              148,                          (: 'module' :)
                              150,                          (: 'namespace-node' :)
                              151,                          (: 'ne' :)
                              155,                          (: 'node' :)
                              158,                          (: 'only' :)
                              160,                          (: 'or' :)
                              161,                          (: 'order' :)
                              173,                          (: 'rename' :)
                              174,                          (: 'replace' :)
                              175,                          (: 'return' :)
                              177,                          (: 'satisfies' :)
                              179,                          (: 'schema-attribute' :)
                              180,                          (: 'schema-element' :)
                              184,                          (: 'some' :)
                              185,                          (: 'stable' :)
                              186,                          (: 'start' :)
                              192,                          (: 'to' :)
                              193,                          (: 'transform' :)
                              194,                          (: 'treat' :)
                              195,                          (: 'try' :)
                              199,                          (: 'union' :)
                              202,                          (: 'validate' :)
                              207,                          (: 'where' :)
                              209,                          (: 'with' :)
                              210)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(179, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4                              (: StringLiteral :)
          or $state[$p:lk] = 30                             (: '$' :)
          or $state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 33                             (: '(' :)
          or $state[$p:lk] = 42                             (: '.' :)
          or $state[$p:lk] = 51                             (: '<' :)
          or $state[$p:lk] = 52                             (: '<!--' :)
          or $state[$p:lk] = 57                             (: '<?' :)
          or $state[$p:lk] = 1357                           (: 'attribute' URIQualifiedName :)
          or $state[$p:lk] = 1386                           (: 'element' URIQualifiedName :)
          or $state[$p:lk] = 3661                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 3690                           (: 'element' QName^Token :)
          or $state[$p:lk] = 3989                           (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 4012                           (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 7173                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7182                           (: QName^Token '#' :)
          or $state[$p:lk] = 7237                           (: 'after' '#' :)
          or $state[$p:lk] = 7239                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7240                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7241                           (: 'and' '#' :)
          or $state[$p:lk] = 7242                           (: 'as' '#' :)
          or $state[$p:lk] = 7243                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7245                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7247                           (: 'before' '#' :)
          or $state[$p:lk] = 7250                           (: 'case' '#' :)
          or $state[$p:lk] = 7251                           (: 'cast' '#' :)
          or $state[$p:lk] = 7252                           (: 'castable' '#' :)
          or $state[$p:lk] = 7254                           (: 'child' '#' :)
          or $state[$p:lk] = 7255                           (: 'collation' '#' :)
          or $state[$p:lk] = 7256                           (: 'comment' '#' :)
          or $state[$p:lk] = 7259                           (: 'copy' '#' :)
          or $state[$p:lk] = 7261                           (: 'count' '#' :)
          or $state[$p:lk] = 7264                           (: 'declare' '#' :)
          or $state[$p:lk] = 7265                           (: 'default' '#' :)
          or $state[$p:lk] = 7266                           (: 'delete' '#' :)
          or $state[$p:lk] = 7267                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7268                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7269                           (: 'descending' '#' :)
          or $state[$p:lk] = 7271                           (: 'div' '#' :)
          or $state[$p:lk] = 7272                           (: 'document' '#' :)
          or $state[$p:lk] = 7273                           (: 'document-node' '#' :)
          or $state[$p:lk] = 7274                           (: 'element' '#' :)
          or $state[$p:lk] = 7275                           (: 'else' '#' :)
          or $state[$p:lk] = 7276                           (: 'empty' '#' :)
          or $state[$p:lk] = 7277                           (: 'empty-sequence' '#' :)
          or $state[$p:lk] = 7279                           (: 'end' '#' :)
          or $state[$p:lk] = 7280                           (: 'eq' '#' :)
          or $state[$p:lk] = 7281                           (: 'every' '#' :)
          or $state[$p:lk] = 7282                           (: 'except' '#' :)
          or $state[$p:lk] = 7284                           (: 'first' '#' :)
          or $state[$p:lk] = 7285                           (: 'following' '#' :)
          or $state[$p:lk] = 7286                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7287                           (: 'for' '#' :)
          or $state[$p:lk] = 7288                           (: 'function' '#' :)
          or $state[$p:lk] = 7289                           (: 'ge' '#' :)
          or $state[$p:lk] = 7291                           (: 'group' '#' :)
          or $state[$p:lk] = 7293                           (: 'gt' '#' :)
          or $state[$p:lk] = 7294                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7295                           (: 'if' '#' :)
          or $state[$p:lk] = 7296                           (: 'import' '#' :)
          or $state[$p:lk] = 7300                           (: 'insert' '#' :)
          or $state[$p:lk] = 7301                           (: 'instance' '#' :)
          or $state[$p:lk] = 7302                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7303                           (: 'into' '#' :)
          or $state[$p:lk] = 7304                           (: 'invoke' '#' :)
          or $state[$p:lk] = 7305                           (: 'is' '#' :)
          or $state[$p:lk] = 7306                           (: 'item' '#' :)
          or $state[$p:lk] = 7307                           (: 'last' '#' :)
          or $state[$p:lk] = 7309                           (: 'le' '#' :)
          or $state[$p:lk] = 7311                           (: 'let' '#' :)
          or $state[$p:lk] = 7312                           (: 'lt' '#' :)
          or $state[$p:lk] = 7314                           (: 'mod' '#' :)
          or $state[$p:lk] = 7315                           (: 'modify' '#' :)
          or $state[$p:lk] = 7316                           (: 'module' '#' :)
          or $state[$p:lk] = 7317                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7318                           (: 'namespace-node' '#' :)
          or $state[$p:lk] = 7319                           (: 'ne' '#' :)
          or $state[$p:lk] = 7323                           (: 'node' '#' :)
          or $state[$p:lk] = 7326                           (: 'only' '#' :)
          or $state[$p:lk] = 7328                           (: 'or' '#' :)
          or $state[$p:lk] = 7329                           (: 'order' '#' :)
          or $state[$p:lk] = 7330                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7332                           (: 'parent' '#' :)
          or $state[$p:lk] = 7336                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7337                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7340                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7341                           (: 'rename' '#' :)
          or $state[$p:lk] = 7342                           (: 'replace' '#' :)
          or $state[$p:lk] = 7343                           (: 'return' '#' :)
          or $state[$p:lk] = 7345                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7347                           (: 'schema-attribute' '#' :)
          or $state[$p:lk] = 7348                           (: 'schema-element' '#' :)
          or $state[$p:lk] = 7349                           (: 'self' '#' :)
          or $state[$p:lk] = 7352                           (: 'some' '#' :)
          or $state[$p:lk] = 7353                           (: 'stable' '#' :)
          or $state[$p:lk] = 7354                           (: 'start' '#' :)
          or $state[$p:lk] = 7357                           (: 'switch' '#' :)
          or $state[$p:lk] = 7358                           (: 'text' '#' :)
          or $state[$p:lk] = 7360                           (: 'to' '#' :)
          or $state[$p:lk] = 7361                           (: 'transform' '#' :)
          or $state[$p:lk] = 7362                           (: 'treat' '#' :)
          or $state[$p:lk] = 7363                           (: 'try' '#' :)
          or $state[$p:lk] = 7366                           (: 'typeswitch' '#' :)
          or $state[$p:lk] = 7367                           (: 'union' '#' :)
          or $state[$p:lk] = 7368                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7370                           (: 'validate' '#' :)
          or $state[$p:lk] = 7375                           (: 'where' '#' :)
          or $state[$p:lk] = 7377                           (: 'with' '#' :)
          or $state[$p:lk] = 7378                           (: 'xquery' '#' :)
          or $state[$p:lk] = 8453                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8462                           (: QName^Token '(' :)
          or $state[$p:lk] = 8517                           (: 'after' '(' :)
          or $state[$p:lk] = 8519                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8520                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8521                           (: 'and' '(' :)
          or $state[$p:lk] = 8522                           (: 'as' '(' :)
          or $state[$p:lk] = 8523                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8527                           (: 'before' '(' :)
          or $state[$p:lk] = 8530                           (: 'case' '(' :)
          or $state[$p:lk] = 8531                           (: 'cast' '(' :)
          or $state[$p:lk] = 8532                           (: 'castable' '(' :)
          or $state[$p:lk] = 8534                           (: 'child' '(' :)
          or $state[$p:lk] = 8535                           (: 'collation' '(' :)
          or $state[$p:lk] = 8539                           (: 'copy' '(' :)
          or $state[$p:lk] = 8541                           (: 'count' '(' :)
          or $state[$p:lk] = 8544                           (: 'declare' '(' :)
          or $state[$p:lk] = 8545                           (: 'default' '(' :)
          or $state[$p:lk] = 8546                           (: 'delete' '(' :)
          or $state[$p:lk] = 8547                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8548                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8549                           (: 'descending' '(' :)
          or $state[$p:lk] = 8551                           (: 'div' '(' :)
          or $state[$p:lk] = 8552                           (: 'document' '(' :)
          or $state[$p:lk] = 8555                           (: 'else' '(' :)
          or $state[$p:lk] = 8556                           (: 'empty' '(' :)
          or $state[$p:lk] = 8559                           (: 'end' '(' :)
          or $state[$p:lk] = 8560                           (: 'eq' '(' :)
          or $state[$p:lk] = 8561                           (: 'every' '(' :)
          or $state[$p:lk] = 8562                           (: 'except' '(' :)
          or $state[$p:lk] = 8564                           (: 'first' '(' :)
          or $state[$p:lk] = 8565                           (: 'following' '(' :)
          or $state[$p:lk] = 8566                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8567                           (: 'for' '(' :)
          or $state[$p:lk] = 8568                           (: 'function' '(' :)
          or $state[$p:lk] = 8569                           (: 'ge' '(' :)
          or $state[$p:lk] = 8571                           (: 'group' '(' :)
          or $state[$p:lk] = 8573                           (: 'gt' '(' :)
          or $state[$p:lk] = 8574                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8576                           (: 'import' '(' :)
          or $state[$p:lk] = 8580                           (: 'insert' '(' :)
          or $state[$p:lk] = 8581                           (: 'instance' '(' :)
          or $state[$p:lk] = 8582                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8583                           (: 'into' '(' :)
          or $state[$p:lk] = 8584                           (: 'invoke' '(' :)
          or $state[$p:lk] = 8585                           (: 'is' '(' :)
          or $state[$p:lk] = 8587                           (: 'last' '(' :)
          or $state[$p:lk] = 8589                           (: 'le' '(' :)
          or $state[$p:lk] = 8591                           (: 'let' '(' :)
          or $state[$p:lk] = 8592                           (: 'lt' '(' :)
          or $state[$p:lk] = 8594                           (: 'mod' '(' :)
          or $state[$p:lk] = 8595                           (: 'modify' '(' :)
          or $state[$p:lk] = 8596                           (: 'module' '(' :)
          or $state[$p:lk] = 8597                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8599                           (: 'ne' '(' :)
          or $state[$p:lk] = 8606                           (: 'only' '(' :)
          or $state[$p:lk] = 8608                           (: 'or' '(' :)
          or $state[$p:lk] = 8609                           (: 'order' '(' :)
          or $state[$p:lk] = 8610                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8612                           (: 'parent' '(' :)
          or $state[$p:lk] = 8616                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8617                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8621                           (: 'rename' '(' :)
          or $state[$p:lk] = 8622                           (: 'replace' '(' :)
          or $state[$p:lk] = 8623                           (: 'return' '(' :)
          or $state[$p:lk] = 8625                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8629                           (: 'self' '(' :)
          or $state[$p:lk] = 8632                           (: 'some' '(' :)
          or $state[$p:lk] = 8633                           (: 'stable' '(' :)
          or $state[$p:lk] = 8634                           (: 'start' '(' :)
          or $state[$p:lk] = 8640                           (: 'to' '(' :)
          or $state[$p:lk] = 8641                           (: 'transform' '(' :)
          or $state[$p:lk] = 8642                           (: 'treat' '(' :)
          or $state[$p:lk] = 8643                           (: 'try' '(' :)
          or $state[$p:lk] = 8647                           (: 'union' '(' :)
          or $state[$p:lk] = 8648                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8650                           (: 'validate' '(' :)
          or $state[$p:lk] = 8655                           (: 'where' '(' :)
          or $state[$p:lk] = 8657                           (: 'with' '(' :)
          or $state[$p:lk] = 8658                           (: 'xquery' '(' :)
          or $state[$p:lk] = 18253                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 18282                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 18509                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 18538                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 19789                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 19818                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 22093                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 22122                          (: 'element' 'child' :)
          or $state[$p:lk] = 22605                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 22634                          (: 'element' 'comment' :)
          or $state[$p:lk] = 23373                          (: 'attribute' 'copy' :)
          or $state[$p:lk] = 23402                          (: 'element' 'copy' :)
          or $state[$p:lk] = 24653                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 24682                          (: 'element' 'declare' :)
          or $state[$p:lk] = 25165                          (: 'attribute' 'delete' :)
          or $state[$p:lk] = 25194                          (: 'element' 'delete' :)
          or $state[$p:lk] = 25421                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 25450                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 25677                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 25706                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 26701                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 26730                          (: 'element' 'document' :)
          or $state[$p:lk] = 26957                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 26986                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 27213                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 27242                          (: 'element' 'element' :)
          or $state[$p:lk] = 27981                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 28010                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 29005                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 29034                          (: 'element' 'every' :)
          or $state[$p:lk] = 29773                          (: 'attribute' 'first' :)
          or $state[$p:lk] = 29802                          (: 'element' 'first' :)
          or $state[$p:lk] = 30029                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 30058                          (: 'element' 'following' :)
          or $state[$p:lk] = 30285                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 30314                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 30797                          (: 'attribute' 'function' :)
          or $state[$p:lk] = 30826                          (: 'element' 'function' :)
          or $state[$p:lk] = 32589                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 32618                          (: 'element' 'if' :)
          or $state[$p:lk] = 32845                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 32874                          (: 'element' 'import' :)
          or $state[$p:lk] = 33869                          (: 'attribute' 'insert' :)
          or $state[$p:lk] = 33898                          (: 'element' 'insert' :)
          or $state[$p:lk] = 34893                          (: 'attribute' 'invoke' :)
          or $state[$p:lk] = 34922                          (: 'element' 'invoke' :)
          or $state[$p:lk] = 35405                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 35434                          (: 'element' 'item' :)
          or $state[$p:lk] = 35661                          (: 'attribute' 'last' :)
          or $state[$p:lk] = 35690                          (: 'element' 'last' :)
          or $state[$p:lk] = 37965                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 37994                          (: 'element' 'module' :)
          or $state[$p:lk] = 38221                          (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 38250                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 38477                          (: 'attribute' 'namespace-node' :)
          or $state[$p:lk] = 38506                          (: 'element' 'namespace-node' :)
          or $state[$p:lk] = 39757                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 39786                          (: 'element' 'node' :)
          or $state[$p:lk] = 41549                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 41578                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 42061                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 42090                          (: 'element' 'parent' :)
          or $state[$p:lk] = 43085                          (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 43114                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 43341                          (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 43370                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 44109                          (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 44138                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 44365                          (: 'attribute' 'rename' :)
          or $state[$p:lk] = 44394                          (: 'element' 'rename' :)
          or $state[$p:lk] = 44621                          (: 'attribute' 'replace' :)
          or $state[$p:lk] = 44650                          (: 'element' 'replace' :)
          or $state[$p:lk] = 45901                          (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 45930                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 46157                          (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 46186                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 46413                          (: 'attribute' 'self' :)
          or $state[$p:lk] = 46442                          (: 'element' 'self' :)
          or $state[$p:lk] = 47181                          (: 'attribute' 'some' :)
          or $state[$p:lk] = 47210                          (: 'element' 'some' :)
          or $state[$p:lk] = 48461                          (: 'attribute' 'switch' :)
          or $state[$p:lk] = 48490                          (: 'element' 'switch' :)
          or $state[$p:lk] = 48717                          (: 'attribute' 'text' :)
          or $state[$p:lk] = 48746                          (: 'element' 'text' :)
          or $state[$p:lk] = 49997                          (: 'attribute' 'try' :)
          or $state[$p:lk] = 50026                          (: 'element' 'try' :)
          or $state[$p:lk] = 50765                          (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 50794                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 51277                          (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 51306                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 51789                          (: 'attribute' 'validate' :)
          or $state[$p:lk] = 51818                          (: 'element' 'validate' :)
          or $state[$p:lk] = 53837                          (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 53866                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 54349                          (: 'attribute' '{' :)
          or $state[$p:lk] = 54360                          (: 'comment' '{' :)
          or $state[$p:lk] = 54376                          (: 'document' '{' :)
          or $state[$p:lk] = 54378                          (: 'element' '{' :)
          or $state[$p:lk] = 54421                          (: 'namespace' '{' :)
          or $state[$p:lk] = 54434                          (: 'ordered' '{' :)
          or $state[$p:lk] = 54444                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 54462                          (: 'text' '{' :)
          or $state[$p:lk] = 54472                          (: 'unordered' '{' :)
          or $state[$p:lk] = 13911373                       (: 'attribute' 'after' '{' :)
          or $state[$p:lk] = 13911402                       (: 'element' 'after' '{' :)
          or $state[$p:lk] = 13911445                       (: 'namespace' 'after' '{' :)
          or $state[$p:lk] = 13911468                       (: 'processing-instruction' 'after' '{' :)
          or $state[$p:lk] = 13912397                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 13912426                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 13912469                       (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 13912492                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 13912653                       (: 'attribute' 'as' '{' :)
          or $state[$p:lk] = 13912682                       (: 'element' 'as' '{' :)
          or $state[$p:lk] = 13912725                       (: 'namespace' 'as' '{' :)
          or $state[$p:lk] = 13912748                       (: 'processing-instruction' 'as' '{' :)
          or $state[$p:lk] = 13912909                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 13912938                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 13912981                       (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 13913004                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 13913933                       (: 'attribute' 'before' '{' :)
          or $state[$p:lk] = 13913962                       (: 'element' 'before' '{' :)
          or $state[$p:lk] = 13914005                       (: 'namespace' 'before' '{' :)
          or $state[$p:lk] = 13914028                       (: 'processing-instruction' 'before' '{' :)
          or $state[$p:lk] = 13914701                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 13914730                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 13914773                       (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 13914796                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 13914957                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 13914986                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 13915029                       (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 13915052                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 13915213                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 13915242                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 13915285                       (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 13915308                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 13915981                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 13916010                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 13916053                       (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 13916076                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 13917517                       (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 13917546                       (: 'element' 'count' '{' :)
          or $state[$p:lk] = 13917589                       (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 13917612                       (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 13918541                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 13918570                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 13918613                       (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 13918636                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 13919565                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 13919594                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 13919637                       (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 13919660                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 13920077                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 13920106                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 13920149                       (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 13920172                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 13921101                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 13921130                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 13921173                       (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 13921196                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 13921357                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 13921386                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 13921429                       (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 13921452                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 13922125                       (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 13922154                       (: 'element' 'end' '{' :)
          or $state[$p:lk] = 13922197                       (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 13922220                       (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 13922381                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 13922410                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 13922453                       (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 13922476                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 13922893                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 13922922                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 13922965                       (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 13922988                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 13924173                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 13924202                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 13924245                       (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 13924268                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 13924685                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 13924714                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 13924757                       (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 13924780                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 13925197                       (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 13925226                       (: 'element' 'group' '{' :)
          or $state[$p:lk] = 13925269                       (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 13925292                       (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 13925709                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 13925738                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 13925781                       (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 13925804                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 13925965                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 13925994                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 13926037                       (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 13926060                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 13927757                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 13927786                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 13927829                       (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 13927852                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 13928013                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 13928042                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 13928085                       (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 13928108                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 13928269                       (: 'attribute' 'into' '{' :)
          or $state[$p:lk] = 13928298                       (: 'element' 'into' '{' :)
          or $state[$p:lk] = 13928341                       (: 'namespace' 'into' '{' :)
          or $state[$p:lk] = 13928364                       (: 'processing-instruction' 'into' '{' :)
          or $state[$p:lk] = 13928781                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 13928810                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 13928853                       (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 13928876                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 13929805                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 13929834                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 13929877                       (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 13929900                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 13930317                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 13930346                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 13930389                       (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 13930412                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 13930573                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 13930602                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 13930645                       (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 13930668                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 13931085                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 13931114                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 13931157                       (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 13931180                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 13931341                       (: 'attribute' 'modify' '{' :)
          or $state[$p:lk] = 13931370                       (: 'element' 'modify' '{' :)
          or $state[$p:lk] = 13931413                       (: 'namespace' 'modify' '{' :)
          or $state[$p:lk] = 13931436                       (: 'processing-instruction' 'modify' '{' :)
          or $state[$p:lk] = 13932365                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 13932394                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 13932437                       (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 13932460                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 13934157                       (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 13934186                       (: 'element' 'only' '{' :)
          or $state[$p:lk] = 13934229                       (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 13934252                       (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 13934669                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 13934698                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 13934741                       (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 13934764                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 13934925                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 13934954                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 13934997                       (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 13935020                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 13938509                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 13938538                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 13938581                       (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 13938604                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 13939021                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 13939050                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 13939093                       (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 13939116                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 13941069                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 13941098                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 13941141                       (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 13941164                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 13941325                       (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 13941354                       (: 'element' 'start' '{' :)
          or $state[$p:lk] = 13941397                       (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 13941420                       (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 13942861                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 13942890                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 13942933                       (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 13942956                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 13943117                       (: 'attribute' 'transform' '{' :)
          or $state[$p:lk] = 13943146                       (: 'element' 'transform' '{' :)
          or $state[$p:lk] = 13943189                       (: 'namespace' 'transform' '{' :)
          or $state[$p:lk] = 13943212                       (: 'processing-instruction' 'transform' '{' :)
          or $state[$p:lk] = 13943373                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 13943402                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 13943445                       (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 13943468                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 13944653                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 13944682                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 13944725                       (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 13944748                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 13946701                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 13946730                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 13946773                       (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 13946796                       (: 'processing-instruction' 'where' '{' :)
          or $state[$p:lk] = 13947213                       (: 'attribute' 'with' '{' :)
          or $state[$p:lk] = 13947242                       (: 'element' 'with' '{' :)
          or $state[$p:lk] = 13947285                       (: 'namespace' 'with' '{' :)
          or $state[$p:lk] = 13947308) then                 (: 'processing-instruction' 'with' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PostfixExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 44                                 (: '/' :)
    and $state[$p:l1] != 45) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '/' :)
          let $state := p:consume(44, $input, $state)       (: '/' :)
          return $state
        else
          let $state := p:consume(45, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(205, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '/' :)
      let $state := p:consume(44, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(216, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' | '>' |
                                                               '>=' | '>>' | '@' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 24                         (: EOF :)
              or $state[$p:l1] = 25                         (: '!' :)
              or $state[$p:l1] = 26                         (: '!=' :)
              or $state[$p:l1] = 36                         (: ')' :)
              or $state[$p:l1] = 37                         (: '*' :)
              or $state[$p:l1] = 38                         (: '+' :)
              or $state[$p:l1] = 39                         (: ',' :)
              or $state[$p:l1] = 40                         (: '-' :)
              or $state[$p:l1] = 50                         (: ';' :)
              or $state[$p:l1] = 55                         (: '<<' :)
              or $state[$p:l1] = 56                         (: '<=' :)
              or $state[$p:l1] = 58                         (: '=' :)
              or $state[$p:l1] = 59                         (: '>' :)
              or $state[$p:l1] = 60                         (: '>=' :)
              or $state[$p:l1] = 61                         (: '>>' :)
              or $state[$p:l1] = 67                         (: ']' :)
              or $state[$p:l1] = 214                        (: '|' :)
              or $state[$p:l1] = 215                        (: '||' :)
              or $state[$p:l1] = 216) then                  (: '}' :)
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 45) then                       (: '//' :)
      let $state := p:consume(45, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(205, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: '!' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(206, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(193, $input, $state)           (: URIQualifiedName | QName^Token | S | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:consume(16, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:consume(16, $input, $state)           (: S :)
      let $state := p:lookahead1(1, $input, $state)         (: PragmaContents :)
      let $state := p:consume(19, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:consume(29, $input, $state)               (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(75, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(212, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 216) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'lax' :)
      let $state := p:consume(140, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(187, $input, $state)          (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(202, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(134, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 212) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 197) then                  (: 'type' :)
          let $state := p:consume(197, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(194, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 202) then                          (: 'validate' :)
      let $state := p:lookahead2W(190, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'lax' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'strict' | 'to' | 'transform' | 'treat' | 'type' |
                                                               'union' | 'where' | 'with' | '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 36042                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 48074                          (: 'validate' 'strict' :)
          or $state[$p:lk] = 50634                          (: 'validate' 'type' :)
          or $state[$p:lk] = 54474) then                    (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SimpleMapExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(207, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
    return
      if ($state[$p:l1] != 38                               (: '+' :)
      and $state[$p:l1] != 40) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 40) then                 (: '-' :)
            let $state := p:consume(40, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(38, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse TransformWithExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TransformWithExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'transform' :)
      let $state := p:consume(193, $input, $state)          (: 'transform' :)
      let $state := p:lookahead1W(64, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      let $state := p:consume(209, $input, $state)          (: 'with' :)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | ('(' ':') | '{' :)
      let $state := p:consume(212, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(212, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 216) then                 (: '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          return $state
        else
          $state
      let $state := p:consume(216, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TransformWithExpr($input, $state)
  let $state := p:lookahead1W(171, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'cast' :)
      let $state := p:consume(83, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(169, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'castable' :)
      let $state := p:consume(84, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 194) then                      (: 'treat' :)
      let $state := p:consume(194, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(199, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'union' | 'where' | 'with' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 133) then                      (: 'instance' :)
      let $state := p:consume(133, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(157, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(199, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(166, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 114                              (: 'except' :)
      and $state[$p:l1] != 134) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 134) then                (: 'intersect' :)
            let $state := p:consume(134, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(114, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(207, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 199                                (: 'union' :)
    and $state[$p:l1] != 214) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 199) then                  (: 'union' :)
          let $state := p:consume(199, $input, $state)      (: 'union' :)
          return $state
        else
          let $state := p:consume(214, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37                                 (: '*' :)
    and $state[$p:l1] != 103                                (: 'div' :)
    and $state[$p:l1] != 126                                (: 'idiv' :)
    and $state[$p:l1] != 146) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: '*' :)
          let $state := p:consume(37, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 103) then                  (: 'div' :)
          let $state := p:consume(103, $input, $state)      (: 'div' :)
          return $state
        else if ($state[$p:l1] = 126) then                  (: 'idiv' :)
          let $state := p:consume(126, $input, $state)      (: 'idiv' :)
          return $state
        else
          let $state := p:consume(146, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '+' :)
    and $state[$p:l1] != 40) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '+' :)
          let $state := p:consume(38, $input, $state)       (: '+' :)
          return $state
        else
          let $state := p:consume(40, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: 'to' :)
      let $state := p:consume(192, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 215) then                          (: '||' :)
      $state
    else
      let $state := p:consume(215, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 55                             (: '<<' :)
          or $state[$p:l1] = 56                             (: '<=' :)
          or $state[$p:l1] = 58                             (: '=' :)
          or $state[$p:l1] = 59                             (: '>' :)
          or $state[$p:l1] = 60                             (: '>=' :)
          or $state[$p:l1] = 61                             (: '>>' :)
          or $state[$p:l1] = 112                            (: 'eq' :)
          or $state[$p:l1] = 121                            (: 'ge' :)
          or $state[$p:l1] = 125                            (: 'gt' :)
          or $state[$p:l1] = 137                            (: 'is' :)
          or $state[$p:l1] = 141                            (: 'le' :)
          or $state[$p:l1] = 144                            (: 'lt' :)
          or $state[$p:l1] = 151) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 112                        (: 'eq' :)
              or $state[$p:l1] = 121                        (: 'ge' :)
              or $state[$p:l1] = 125                        (: 'gt' :)
              or $state[$p:l1] = 141                        (: 'le' :)
              or $state[$p:l1] = 144                        (: 'lt' :)
              or $state[$p:l1] = 151) then                  (: 'ne' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 55                         (: '<<' :)
              or $state[$p:l1] = 61                         (: '>>' :)
              or $state[$p:l1] = 137) then                  (: 'is' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 73) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(73, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 160) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(160, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CopyModifyExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifyExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: S^WS | ('(' ':') | ',' | 'modify' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:consume(30, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(194, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(27, $input, $state)     (: S^WS | ('(' ':') | ':=' :)
        let $state := p:consume(49, $input, $state)         (: ':=' :)
        let $state := p:lookahead1W(207, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-CopyModifyExpr-1($input, $state)
};

(:~
 : Parse CopyModifyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(91, $input, $state)               (: 'copy' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(49, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-CopyModifyExpr-1($input, $state)
  let $state := p:consume(147, $input, $state)              (: 'modify' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(175, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Annotation($input, $state)
        return p:parse-InlineFunctionExpr-1($input, $state)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(120, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(199, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionBody($input, $state)
  return $state
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(16, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  return $state
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 120) then                          (: 'function' :)
      let $state := p:lookahead2W(69, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 8568) then                     (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InlineFunctionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamedFunctionRef($input, $state)
      return $state
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(172, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(160, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: '{' :)
      let $state := p:consume(212, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(216, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(212, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 216) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(88, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(160, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: '{' :)
      let $state := p:consume(212, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrefixExpr($input, $state)
      let $state := p:consume(216, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URIExpr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(197, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: '{' :)
      let $state := p:consume(212, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(216, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(212, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 216) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(106, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(197, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: '{' :)
      let $state := p:consume(212, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(216, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(212, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 216) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(104, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 104) then                      (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(57, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:consume(16, $input, $state)           (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:consume(21, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:consume(63, $input, $state)               (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(52, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(2, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(20, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:consume(41, $input, $state)               (: '-->' :)
  return $state
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(53, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(4, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(22, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:consume(68, $input, $state)               (: ']]>' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 52                             (: '<!--' :)
          or $state[$p:l1] = 57) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<![CDATA[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: '{{' :)
      let $state := p:consume(213, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 217) then                      (: '}}' :)
      let $state := p:consume(217, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(139, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(140, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27) then                       (: '"' :)
      let $state := p:consume(27, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(27, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(32, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(32, $input, $state)           (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(19, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 16) then                         (: S :)
        $state
      else
        let $state := p:consume(16, $input, $state)         (: S :)
        let $state := p:lookahead1(195, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 16                      (: S :)
               and $state[$p:l1] != 46                      (: '/>' :)
               and $state[$p:l1] != 59) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 16) then             (: S :)
                let $state := p:consume(16, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:consume(58, $input, $state)     (: '=' :)
            let $state := p:lookahead1(18, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 16) then             (: S :)
                let $state := p:consume(16, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(145, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 54) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(51, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '/>' :)
      let $state := p:consume(46, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(59, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(54, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 16) then                   (: S :)
          let $state := p:consume(16, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:consume(59, $input, $state)           (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 52) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 52                             (: '<!--' :)
          or $state[$p:l1] = 57) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(200, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(162, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(62, $input, $state)               (: '?' :)
  return $state
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(210, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(213, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse FunctionEQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ArgumentList($input, $state)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(42, $input, $state)               (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(209, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 149) then                          (: 'namespace' :)
      let $state := p:lookahead2W(164, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '{' :)
      return $state
    else if ($state[$p:l1] eq 172) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(163, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '{' :)
      return $state
    else if ($state[$p:l1] = (77,                           (: 'attribute' :)
                              106)) then                    (: 'element' :)
      let $state := p:lookahead2W(198, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (88,                           (: 'comment' :)
                              190)) then                    (: 'text' :)
      let $state := p:lookahead2W(70, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (104,                          (: 'document' :)
                              162,                          (: 'ordered' :)
                              200)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              14,                           (: QName^Token :)
                              69,                           (: 'after' :)
                              71,                           (: 'ancestor' :)
                              72,                           (: 'ancestor-or-self' :)
                              73,                           (: 'and' :)
                              74,                           (: 'as' :)
                              75,                           (: 'ascending' :)
                              79,                           (: 'before' :)
                              82,                           (: 'case' :)
                              83,                           (: 'cast' :)
                              84,                           (: 'castable' :)
                              86,                           (: 'child' :)
                              87,                           (: 'collation' :)
                              91,                           (: 'copy' :)
                              93,                           (: 'count' :)
                              96,                           (: 'declare' :)
                              97,                           (: 'default' :)
                              98,                           (: 'delete' :)
                              99,                           (: 'descendant' :)
                              100,                          (: 'descendant-or-self' :)
                              101,                          (: 'descending' :)
                              103,                          (: 'div' :)
                              107,                          (: 'else' :)
                              108,                          (: 'empty' :)
                              111,                          (: 'end' :)
                              112,                          (: 'eq' :)
                              113,                          (: 'every' :)
                              114,                          (: 'except' :)
                              116,                          (: 'first' :)
                              117,                          (: 'following' :)
                              118,                          (: 'following-sibling' :)
                              119,                          (: 'for' :)
                              121,                          (: 'ge' :)
                              123,                          (: 'group' :)
                              125,                          (: 'gt' :)
                              126,                          (: 'idiv' :)
                              128,                          (: 'import' :)
                              132,                          (: 'insert' :)
                              133,                          (: 'instance' :)
                              134,                          (: 'intersect' :)
                              135,                          (: 'into' :)
                              136,                          (: 'invoke' :)
                              137,                          (: 'is' :)
                              139,                          (: 'last' :)
                              141,                          (: 'le' :)
                              143,                          (: 'let' :)
                              144,                          (: 'lt' :)
                              146,                          (: 'mod' :)
                              147,                          (: 'modify' :)
                              148,                          (: 'module' :)
                              151,                          (: 'ne' :)
                              158,                          (: 'only' :)
                              160,                          (: 'or' :)
                              161,                          (: 'order' :)
                              164,                          (: 'parent' :)
                              168,                          (: 'preceding' :)
                              169,                          (: 'preceding-sibling' :)
                              173,                          (: 'rename' :)
                              174,                          (: 'replace' :)
                              175,                          (: 'return' :)
                              177,                          (: 'satisfies' :)
                              181,                          (: 'self' :)
                              184,                          (: 'some' :)
                              185,                          (: 'stable' :)
                              186,                          (: 'start' :)
                              192,                          (: 'to' :)
                              193,                          (: 'transform' :)
                              194,                          (: 'treat' :)
                              195,                          (: 'try' :)
                              199,                          (: 'union' :)
                              202,                          (: 'validate' :)
                              207,                          (: 'where' :)
                              209,                          (: 'with' :)
                              210)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(69, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 42) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8453                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8462                           (: QName^Token '(' :)
          or $state[$p:lk] = 8517                           (: 'after' '(' :)
          or $state[$p:lk] = 8519                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8520                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8521                           (: 'and' '(' :)
          or $state[$p:lk] = 8522                           (: 'as' '(' :)
          or $state[$p:lk] = 8523                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8527                           (: 'before' '(' :)
          or $state[$p:lk] = 8530                           (: 'case' '(' :)
          or $state[$p:lk] = 8531                           (: 'cast' '(' :)
          or $state[$p:lk] = 8532                           (: 'castable' '(' :)
          or $state[$p:lk] = 8534                           (: 'child' '(' :)
          or $state[$p:lk] = 8535                           (: 'collation' '(' :)
          or $state[$p:lk] = 8539                           (: 'copy' '(' :)
          or $state[$p:lk] = 8541                           (: 'count' '(' :)
          or $state[$p:lk] = 8544                           (: 'declare' '(' :)
          or $state[$p:lk] = 8545                           (: 'default' '(' :)
          or $state[$p:lk] = 8546                           (: 'delete' '(' :)
          or $state[$p:lk] = 8547                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8548                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8549                           (: 'descending' '(' :)
          or $state[$p:lk] = 8551                           (: 'div' '(' :)
          or $state[$p:lk] = 8552                           (: 'document' '(' :)
          or $state[$p:lk] = 8555                           (: 'else' '(' :)
          or $state[$p:lk] = 8556                           (: 'empty' '(' :)
          or $state[$p:lk] = 8559                           (: 'end' '(' :)
          or $state[$p:lk] = 8560                           (: 'eq' '(' :)
          or $state[$p:lk] = 8561                           (: 'every' '(' :)
          or $state[$p:lk] = 8562                           (: 'except' '(' :)
          or $state[$p:lk] = 8564                           (: 'first' '(' :)
          or $state[$p:lk] = 8565                           (: 'following' '(' :)
          or $state[$p:lk] = 8566                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8567                           (: 'for' '(' :)
          or $state[$p:lk] = 8569                           (: 'ge' '(' :)
          or $state[$p:lk] = 8571                           (: 'group' '(' :)
          or $state[$p:lk] = 8573                           (: 'gt' '(' :)
          or $state[$p:lk] = 8574                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8576                           (: 'import' '(' :)
          or $state[$p:lk] = 8580                           (: 'insert' '(' :)
          or $state[$p:lk] = 8581                           (: 'instance' '(' :)
          or $state[$p:lk] = 8582                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8583                           (: 'into' '(' :)
          or $state[$p:lk] = 8584                           (: 'invoke' '(' :)
          or $state[$p:lk] = 8585                           (: 'is' '(' :)
          or $state[$p:lk] = 8587                           (: 'last' '(' :)
          or $state[$p:lk] = 8589                           (: 'le' '(' :)
          or $state[$p:lk] = 8591                           (: 'let' '(' :)
          or $state[$p:lk] = 8592                           (: 'lt' '(' :)
          or $state[$p:lk] = 8594                           (: 'mod' '(' :)
          or $state[$p:lk] = 8595                           (: 'modify' '(' :)
          or $state[$p:lk] = 8596                           (: 'module' '(' :)
          or $state[$p:lk] = 8597                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8599                           (: 'ne' '(' :)
          or $state[$p:lk] = 8606                           (: 'only' '(' :)
          or $state[$p:lk] = 8608                           (: 'or' '(' :)
          or $state[$p:lk] = 8609                           (: 'order' '(' :)
          or $state[$p:lk] = 8610                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8612                           (: 'parent' '(' :)
          or $state[$p:lk] = 8616                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8617                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8621                           (: 'rename' '(' :)
          or $state[$p:lk] = 8622                           (: 'replace' '(' :)
          or $state[$p:lk] = 8623                           (: 'return' '(' :)
          or $state[$p:lk] = 8625                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8629                           (: 'self' '(' :)
          or $state[$p:lk] = 8632                           (: 'some' '(' :)
          or $state[$p:lk] = 8633                           (: 'stable' '(' :)
          or $state[$p:lk] = 8634                           (: 'start' '(' :)
          or $state[$p:lk] = 8640                           (: 'to' '(' :)
          or $state[$p:lk] = 8641                           (: 'transform' '(' :)
          or $state[$p:lk] = 8642                           (: 'treat' '(' :)
          or $state[$p:lk] = 8643                           (: 'try' '(' :)
          or $state[$p:lk] = 8647                           (: 'union' '(' :)
          or $state[$p:lk] = 8648                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8650                           (: 'validate' '(' :)
          or $state[$p:lk] = 8655                           (: 'where' '(' :)
          or $state[$p:lk] = 8657                           (: 'with' '(' :)
          or $state[$p:lk] = 8658) then                     (: 'xquery' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 54434) then                    (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 54472) then                    (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 105                            (: 'document-node' :)
          or $state[$p:lk] = 109                            (: 'empty-sequence' :)
          or $state[$p:lk] = 120                            (: 'function' :)
          or $state[$p:lk] = 127                            (: 'if' :)
          or $state[$p:lk] = 138                            (: 'item' :)
          or $state[$p:lk] = 150                            (: 'namespace-node' :)
          or $state[$p:lk] = 155                            (: 'node' :)
          or $state[$p:lk] = 179                            (: 'schema-attribute' :)
          or $state[$p:lk] = 180                            (: 'schema-element' :)
          or $state[$p:lk] = 189                            (: 'switch' :)
          or $state[$p:lk] = 198                            (: 'typeswitch' :)
          or $state[$p:lk] = 7173                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7182                           (: QName^Token '#' :)
          or $state[$p:lk] = 7237                           (: 'after' '#' :)
          or $state[$p:lk] = 7239                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7240                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7241                           (: 'and' '#' :)
          or $state[$p:lk] = 7242                           (: 'as' '#' :)
          or $state[$p:lk] = 7243                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7245                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7247                           (: 'before' '#' :)
          or $state[$p:lk] = 7250                           (: 'case' '#' :)
          or $state[$p:lk] = 7251                           (: 'cast' '#' :)
          or $state[$p:lk] = 7252                           (: 'castable' '#' :)
          or $state[$p:lk] = 7254                           (: 'child' '#' :)
          or $state[$p:lk] = 7255                           (: 'collation' '#' :)
          or $state[$p:lk] = 7256                           (: 'comment' '#' :)
          or $state[$p:lk] = 7259                           (: 'copy' '#' :)
          or $state[$p:lk] = 7261                           (: 'count' '#' :)
          or $state[$p:lk] = 7264                           (: 'declare' '#' :)
          or $state[$p:lk] = 7265                           (: 'default' '#' :)
          or $state[$p:lk] = 7266                           (: 'delete' '#' :)
          or $state[$p:lk] = 7267                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7268                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7269                           (: 'descending' '#' :)
          or $state[$p:lk] = 7271                           (: 'div' '#' :)
          or $state[$p:lk] = 7272                           (: 'document' '#' :)
          or $state[$p:lk] = 7274                           (: 'element' '#' :)
          or $state[$p:lk] = 7275                           (: 'else' '#' :)
          or $state[$p:lk] = 7276                           (: 'empty' '#' :)
          or $state[$p:lk] = 7279                           (: 'end' '#' :)
          or $state[$p:lk] = 7280                           (: 'eq' '#' :)
          or $state[$p:lk] = 7281                           (: 'every' '#' :)
          or $state[$p:lk] = 7282                           (: 'except' '#' :)
          or $state[$p:lk] = 7284                           (: 'first' '#' :)
          or $state[$p:lk] = 7285                           (: 'following' '#' :)
          or $state[$p:lk] = 7286                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7287                           (: 'for' '#' :)
          or $state[$p:lk] = 7289                           (: 'ge' '#' :)
          or $state[$p:lk] = 7291                           (: 'group' '#' :)
          or $state[$p:lk] = 7293                           (: 'gt' '#' :)
          or $state[$p:lk] = 7294                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7296                           (: 'import' '#' :)
          or $state[$p:lk] = 7300                           (: 'insert' '#' :)
          or $state[$p:lk] = 7301                           (: 'instance' '#' :)
          or $state[$p:lk] = 7302                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7303                           (: 'into' '#' :)
          or $state[$p:lk] = 7304                           (: 'invoke' '#' :)
          or $state[$p:lk] = 7305                           (: 'is' '#' :)
          or $state[$p:lk] = 7307                           (: 'last' '#' :)
          or $state[$p:lk] = 7309                           (: 'le' '#' :)
          or $state[$p:lk] = 7311                           (: 'let' '#' :)
          or $state[$p:lk] = 7312                           (: 'lt' '#' :)
          or $state[$p:lk] = 7314                           (: 'mod' '#' :)
          or $state[$p:lk] = 7315                           (: 'modify' '#' :)
          or $state[$p:lk] = 7316                           (: 'module' '#' :)
          or $state[$p:lk] = 7317                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7319                           (: 'ne' '#' :)
          or $state[$p:lk] = 7326                           (: 'only' '#' :)
          or $state[$p:lk] = 7328                           (: 'or' '#' :)
          or $state[$p:lk] = 7329                           (: 'order' '#' :)
          or $state[$p:lk] = 7330                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7332                           (: 'parent' '#' :)
          or $state[$p:lk] = 7336                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7337                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7340                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7341                           (: 'rename' '#' :)
          or $state[$p:lk] = 7342                           (: 'replace' '#' :)
          or $state[$p:lk] = 7343                           (: 'return' '#' :)
          or $state[$p:lk] = 7345                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7349                           (: 'self' '#' :)
          or $state[$p:lk] = 7352                           (: 'some' '#' :)
          or $state[$p:lk] = 7353                           (: 'stable' '#' :)
          or $state[$p:lk] = 7354                           (: 'start' '#' :)
          or $state[$p:lk] = 7358                           (: 'text' '#' :)
          or $state[$p:lk] = 7360                           (: 'to' '#' :)
          or $state[$p:lk] = 7361                           (: 'transform' '#' :)
          or $state[$p:lk] = 7362                           (: 'treat' '#' :)
          or $state[$p:lk] = 7363                           (: 'try' '#' :)
          or $state[$p:lk] = 7367                           (: 'union' '#' :)
          or $state[$p:lk] = 7368                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7370                           (: 'validate' '#' :)
          or $state[$p:lk] = 7375                           (: 'where' '#' :)
          or $state[$p:lk] = 7377                           (: 'with' '#' :)
          or $state[$p:lk] = 7378) then                     (: 'xquery' '#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionItemExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UpdatingFunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UpdatingFunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(207, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-UpdatingFunctionCall-1($input, $state)
};

(:~
 : Parse UpdatingFunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UpdatingFunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'invoke' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'updating' :)
  let $state := p:consume(201, $input, $state)              (: 'updating' :)
  let $state := p:lookahead1W(204, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               '$' | '%' | '(' | ('(' ':') | '.' | '<' | '<!--' | '<?' |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(209, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-UpdatingFunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(174, $input, $state)              (: 'replace' :)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 203) then                      (: 'value' :)
      let $state := p:consume(203, $input, $state)          (: 'value' :)
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(157, $input, $state)          (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(155, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'with' :)
  let $state := p:consume(209, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(173, $input, $state)              (: 'rename' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(155, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(74, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NewNameExpr($input, $state)
  return $state
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(98, $input, $state)               (: 'delete' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'node' :)
      let $state := p:consume(155, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(156, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'after' :)
      let $state := p:consume(69, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'before' :)
      let $state := p:consume(79, $input, $state)           (: 'before' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 74) then                   (: 'as' :)
          let $state := p:consume(74, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(98, $input, $state)   (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 116) then              (: 'first' :)
              let $state := p:consume(116, $input, $state)  (: 'first' :)
              return $state
            else
              let $state := p:consume(139, $input, $state)  (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:consume(135, $input, $state)          (: 'into' :)
      return $state
  return $state
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(132, $input, $state)              (: 'insert' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'node' :)
      let $state := p:consume(155, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(156, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SourceExpr($input, $state)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | ('(' ':') | 'after' | 'as' | 'before' | 'into' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: Wildcard :)
      let $state := p:consume(23, $input, $state)           (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 214) then                        (: '|' :)
        $state
      else
        let $state := p:consume(214, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(196, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(196, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorList($input, $state)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(195, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(212, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryTargetExpr($input, $state)
  let $state := p:consume(216, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(35, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(155, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'after' | 'as' | 'ascending' | 'before' | 'case' |
                                                               'catch' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'end' | 'for' |
                                                               'group' | 'into' | 'let' | 'modify' | 'only' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               'with' | '}' :)
    return
      if ($state[$p:l1] != 85) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(127, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(191, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:consume(107, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(110, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 214) then                        (: '|' :)
        $state
      else
        let $state := p:consume(214, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(199, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(201, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(199, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceTypeUnion($input, $state)
  let $state := p:consume(175, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 82) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(198, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(175, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(82, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(207, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 82) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:consume(175, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ']' | '}' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(207, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 82) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(189, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(175, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(80, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:consume(30, $input, $state)         (: '$' :)
        let $state := p:lookahead1W(194, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-VarName($input, $state)
        let $state := p:lookahead1W(86, $input, $state)     (: S^WS | ('(' ':') | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 74) then                 (: 'as' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(46, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:consume(129, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(207, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'some' :)
      let $state := p:consume(184, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(113, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(129, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(177, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(175, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(93, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75                             (: 'ascending' :)
          or $state[$p:l1] = 101) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 75) then                   (: 'ascending' :)
          let $state := p:consume(75, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(101, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(150, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 108) then                      (: 'empty' :)
      let $state := p:consume(108, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 122) then                  (: 'greatest' :)
          let $state := p:consume(122, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(142, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:consume(87, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(207, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 161) then                      (: 'order' :)
      let $state := p:consume(161, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(81, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(161, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(81, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingVariable.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingVariable($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49                             (: ':=' :)
          or $state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 74) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:consume(49, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:consume(87, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(123, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(81, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(207, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119                            (: 'for' :)
          or $state[$p:l1] = 143) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 207) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(183, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(208, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(129, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'only' :)
      let $state := p:consume(158, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(111, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(206, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 171) then                      (: 'previous' :)
      let $state := p:consume(171, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'next' :)
      let $state := p:consume(152, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(186, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(206, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(196, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(208, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(129, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111                            (: 'end' :)
          or $state[$p:l1] = 158) then                      (: 'only' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(119, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 196) then                      (: 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TumblingWindowClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(49, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LetBinding($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(143, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(76, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(70, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(108, $input, $state)              (: 'empty' :)
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(74, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(199, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'allowing' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(129, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ForBinding($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(119, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'for' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7799) then                     (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 143) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(144, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 175) then                         (: 'return' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'for' :)
      let $state := p:lookahead2W(189, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'sliding' |
                                                               'stable' | 'start' | 'to' | 'transform' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | 'with' | '|' | '||' |
                                                               '}' :)
      return $state
    else if ($state[$p:l1] eq 136) then                     (: 'invoke' :)
      let $state := p:lookahead2W(184, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'updating' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 173) then                     (: 'rename' :)
      let $state := p:lookahead2W(183, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 174) then                     (: 'replace' :)
      let $state := p:lookahead2W(188, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'value' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 195) then                     (: 'try' :)
      let $state := p:lookahead2W(185, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (98,                           (: 'delete' :)
                              132)) then                    (: 'insert' :)
      let $state := p:lookahead2W(187, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'node' | 'nodes' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (127,                          (: 'if' :)
                              189,                          (: 'switch' :)
                              198)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(179, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (91,                           (: 'copy' :)
                              113,                          (: 'every' :)
                              143,                          (: 'let' :)
                              184)) then                    (: 'some' :)
      let $state := p:lookahead2W(181, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7799                           (: 'for' '$' :)
          or $state[$p:lk] = 7823                           (: 'let' '$' :)
          or $state[$p:lk] = 46967                          (: 'for' 'sliding' :)
          or $state[$p:lk] = 50295) then                    (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7793                           (: 'every' '$' :)
          or $state[$p:lk] = 7864) then                     (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8637) then                     (: 'switch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8646) then                     (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8575) then                     (: 'if' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 54467) then                    (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39812                          (: 'insert' 'node' :)
          or $state[$p:lk] = 40068) then                    (: 'insert' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39778                          (: 'delete' 'node' :)
          or $state[$p:lk] = 40034) then                    (: 'delete' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39853) then                    (: 'rename' 'node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39854                          (: 'replace' 'node' :)
          or $state[$p:lk] = 52142) then                    (: 'replace' 'value' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51592) then                    (: 'invoke' 'updating' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UpdatingFunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 7771) then                     (: 'copy' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyModifyExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(199, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '?' :)
      let $state := p:consume(62, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(38, $input, $state)           (: '+' :)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 109) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(175, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'external' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'in' | 'instance' | 'intersect' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'union' | 'where' | 'with' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8557) then                     (: 'empty-sequence' '(' :)
      let $state := p:consume(109, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(33, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(36, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(173, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'allowing' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'before' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | 'with' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37                         (: '*' :)
              or $state[$p:l1] = 38                         (: '+' :)
              or $state[$p:l1] = 62) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(199, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(202, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(74, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(199, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(37, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(128, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: '(' :)
      let $state := p:consume(33, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(128, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      let $state := p:parse-Annotation-1($input, $state)
      let $state := p:consume(36, $input, $state)           (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 120) then                          (: 'function' :)
      let $state := p:lookahead2W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8568) then                     (: 'function' '(' :)
          let $state := p:lookahead3W(203, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2433400) then                  (: 'function' '(' '*' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyFunctionTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(155, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(150, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(88, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(172, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(162, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'with' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(179, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(200, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(194, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(180, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(194, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(106, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(200, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(194, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(77, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 62) then               (: '?' :)
              let $state := p:consume(62, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(105, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 106) then                  (: 'element' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'namespace-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamespaceNodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (77,                                (: 'attribute' :)
                         88,                                (: 'comment' :)
                         105,                               (: 'document-node' :)
                         106,                               (: 'element' :)
                         120,                               (: 'function' :)
                         138,                               (: 'item' :)
                         150,                               (: 'namespace-node' :)
                         155,                               (: 'node' :)
                         172,                               (: 'processing-instruction' :)
                         179,                               (: 'schema-attribute' :)
                         180,                               (: 'schema-element' :)
                         190)) then                         (: 'text' :)
      let $state := p:lookahead2W(175, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'external' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'in' | 'instance' | 'intersect' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'union' | 'where' | 'with' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8525                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8536                           (: 'comment' '(' :)
          or $state[$p:lk] = 8553                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8554                           (: 'element' '(' :)
          or $state[$p:lk] = 8598                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 8603                           (: 'node' '(' :)
          or $state[$p:lk] = 8620                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8627                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8628                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8638) then                     (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8586) then                     (: 'item' '(' :)
      let $state := p:consume(138, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(33, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(36, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 8568) then                     (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedItemType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(90, $input, $state)               (: 'context' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(138, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(199, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: ':=' :)
      let $state := p:consume(49, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(207, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(115, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(81, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: ':=' :)
          let $state := p:consume(49, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(207, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(128, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(148, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(67, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace' :)
      let $state := p:consume(149, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(159, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' | 'with' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(58, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state := p:consume(76, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace' :)
      let $state := p:consume(149, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(159, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' | 'with' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(58, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(106, $input, $state)          (: 'element' :)
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(149, $input, $state)          (: 'namespace' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(128, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(178, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(114, $input, $state)          (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 4) then                       (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state := p:consume(76, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 128) then                          (: 'import' :)
      let $state := p:lookahead2W(101, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 45696) then                    (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  return $state
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(149, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(159, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' | 'with' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(58, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'decimal-separator' :)
      let $state := p:consume(95, $input, $state)           (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'grouping-separator' :)
      let $state := p:consume(124, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'infinity' :)
      let $state := p:consume(130, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'minus-sign' :)
      let $state := p:consume(145, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'NaN' :)
      let $state := p:consume(65, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'percent' :)
      let $state := p:consume(167, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'per-mille' :)
      let $state := p:consume(166, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 211) then                      (: 'zero-digit' :)
      let $state := p:consume(211, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'digit' :)
      let $state := p:consume(102, $input, $state)          (: 'digit' :)
      return $state
    else
      let $state := p:consume(165, $input, $state)          (: 'pattern-separator' :)
      return $state
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: QName^Token :)
      let $state := p:consume(14, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'after' :)
      let $state := p:consume(69, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ancestor' :)
      let $state := p:consume(71, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(72, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'and' :)
      let $state := p:consume(73, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ascending' :)
      let $state := p:consume(75, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'before' :)
      let $state := p:consume(79, $input, $state)           (: 'before' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'case' :)
      let $state := p:consume(82, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'cast' :)
      let $state := p:consume(83, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'castable' :)
      let $state := p:consume(84, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'child' :)
      let $state := p:consume(86, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:consume(87, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'copy' :)
      let $state := p:consume(91, $input, $state)           (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:consume(93, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'declare' :)
      let $state := p:consume(96, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'delete' :)
      let $state := p:consume(98, $input, $state)           (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant' :)
      let $state := p:consume(99, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descendant-or-self' :)
      let $state := p:consume(100, $input, $state)          (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'descending' :)
      let $state := p:consume(101, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'div' :)
      let $state := p:consume(103, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'document' :)
      let $state := p:consume(104, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'else' :)
      let $state := p:consume(107, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty' :)
      let $state := p:consume(108, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'end' :)
      let $state := p:consume(111, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'eq' :)
      let $state := p:consume(112, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'every' :)
      let $state := p:consume(113, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'except' :)
      let $state := p:consume(114, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'first' :)
      let $state := p:consume(116, $input, $state)          (: 'first' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'following' :)
      let $state := p:consume(117, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'following-sibling' :)
      let $state := p:consume(118, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'for' :)
      let $state := p:consume(119, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'ge' :)
      let $state := p:consume(121, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'group' :)
      let $state := p:consume(123, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'gt' :)
      let $state := p:consume(125, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'idiv' :)
      let $state := p:consume(126, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'import' :)
      let $state := p:consume(128, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'insert' :)
      let $state := p:consume(132, $input, $state)          (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'instance' :)
      let $state := p:consume(133, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'intersect' :)
      let $state := p:consume(134, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'into' :)
      let $state := p:consume(135, $input, $state)          (: 'into' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'invoke' :)
      let $state := p:consume(136, $input, $state)          (: 'invoke' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'is' :)
      let $state := p:consume(137, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'last' :)
      let $state := p:consume(139, $input, $state)          (: 'last' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'le' :)
      let $state := p:consume(141, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'let' :)
      let $state := p:consume(143, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'lt' :)
      let $state := p:consume(144, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'mod' :)
      let $state := p:consume(146, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'modify' :)
      let $state := p:consume(147, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'module' :)
      let $state := p:consume(148, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace' :)
      let $state := p:consume(149, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'ne' :)
      let $state := p:consume(151, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'only' :)
      let $state := p:consume(158, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'or' :)
      let $state := p:consume(160, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'order' :)
      let $state := p:consume(161, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'ordered' :)
      let $state := p:consume(162, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'parent' :)
      let $state := p:consume(164, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'preceding' :)
      let $state := p:consume(168, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'preceding-sibling' :)
      let $state := p:consume(169, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'rename' :)
      let $state := p:consume(173, $input, $state)          (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'replace' :)
      let $state := p:consume(174, $input, $state)          (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'return' :)
      let $state := p:consume(175, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'satisfies' :)
      let $state := p:consume(177, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'self' :)
      let $state := p:consume(181, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'some' :)
      let $state := p:consume(184, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'stable' :)
      let $state := p:consume(185, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'start' :)
      let $state := p:consume(186, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'to' :)
      let $state := p:consume(192, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'transform' :)
      let $state := p:consume(193, $input, $state)          (: 'transform' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'treat' :)
      let $state := p:consume(194, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 195) then                      (: 'try' :)
      let $state := p:consume(195, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'union' :)
      let $state := p:consume(199, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'unordered' :)
      let $state := p:consume(200, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'validate' :)
      let $state := p:consume(202, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 207) then                      (: 'where' :)
      let $state := p:consume(207, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'with' :)
      let $state := p:consume(209, $input, $state)          (: 'with' :)
      return $state
    else
      let $state := p:consume(210, $input, $state)          (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(191, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state := p:consume(77, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'comment' :)
      let $state := p:consume(88, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'document-node' :)
      let $state := p:consume(105, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:consume(106, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'empty-sequence' :)
      let $state := p:consume(109, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'function' :)
      let $state := p:consume(120, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'if' :)
      let $state := p:consume(127, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'item' :)
      let $state := p:consume(138, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'namespace-node' :)
      let $state := p:consume(150, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'node' :)
      let $state := p:consume(155, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'processing-instruction' :)
      let $state := p:consume(172, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'schema-attribute' :)
      let $state := p:consume(179, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'schema-element' :)
      let $state := p:consume(180, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'switch' :)
      let $state := p:consume(189, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'text' :)
      let $state := p:consume(190, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 198) then                      (: 'typeswitch' :)
      let $state := p:consume(198, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(192, $input, $state)           (: URIQualifiedName | QName^Token | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'last' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(151, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 50) then                          (: ';' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(29, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(58, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: 'decimal-format' :)
      let $state := p:consume(94, $input, $state)           (: 'decimal-format' :)
      let $state := p:lookahead1W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
    else
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(94, $input, $state)           (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return $state
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 131) then                      (: 'inherit' :)
      let $state := p:consume(131, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(153, $input, $state)          (: 'no-inherit' :)
      return $state
  return $state
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 170) then                      (: 'preserve' :)
      let $state := p:consume(170, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(154, $input, $state)          (: 'no-preserve' :)
      return $state
  return $state
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(92, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(39, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  return $state
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'revalidation' :)
  let $state := p:consume(176, $input, $state)              (: 'revalidation' :)
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 187) then                      (: 'strict' :)
      let $state := p:consume(187, $input, $state)          (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'lax' :)
      let $state := p:consume(140, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(182, $input, $state)          (: 'skip' :)
      return $state
  return $state
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(161, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(108, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 122) then                      (: 'greatest' :)
      let $state := p:consume(122, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'least' :)
      return $state
  return $state
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(163, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 162) then                      (: 'ordered' :)
      let $state := p:consume(162, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(200, $input, $state)          (: 'unordered' :)
      return $state
  return $state
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(89, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 188) then                      (: 'strip' :)
      let $state := p:consume(188, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(170, $input, $state)          (: 'preserve' :)
      return $state
  return $state
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(78, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(87, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(80, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 170) then                      (: 'preserve' :)
      let $state := p:consume(170, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(188, $input, $state)          (: 'strip' :)
      return $state
  return $state
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 96) then                           (: 'declare' :)
      let $state := p:lookahead2W(143, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' | 'revalidation' :)
      let $state :=
        if ($state[$p:lk] eq 24928) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(124, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20576) then                    (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5726560) then                  (: 'declare' 'default' 'collation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 20064) then                    (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 22880) then                    (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 41824) then                    (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10576224) then                 (: 'declare' 'default' 'order' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 45152) then                    (: 'declare' 'revalidation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RevalidationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23648) then                    (: 'declare' 'copy-namespaces' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DecimalFormatDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:consume(106, $input, $state)          (: 'element' :)
      return $state
    else
      let $state := p:consume(120, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(149, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(208, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 96) then                         (: 'declare' :)
        let $state := p:lookahead2W(165, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'base-uri' |
                                                               'boundary-space' | 'cast' | 'castable' | 'construction' |
                                                               'context' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'div' | 'eq' | 'except' | 'function' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'namespace' | 'ne' | 'option' | 'or' |
                                                               'ordering' | 'revalidation' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'updating' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] eq 128) then                   (: 'import' :)
        let $state := p:lookahead2W(158, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'schema' | 'to' | 'transform' |
                                                               'treat' | 'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 20064                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 20576                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 22880                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 23648                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 24160                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 24928                            (: 'declare' 'default' :)
      and $state[$p:lk] != 38016                            (: 'import' 'module' :)
      and $state[$p:lk] != 38240                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 41824                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 45152                            (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 45696) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 96) then                     (: 'declare' :)
            let $state := p:lookahead2W(147, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' | 'revalidation' :)
            let $state :=
              if ($state[$p:lk] eq 24928) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(138, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 6971744                  (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 7889248) then            (: 'declare' 'default' 'function' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 38240) then              (: 'declare' 'namespace' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 128) then                (: 'import' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(208, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 96) then                         (: 'declare' :)
        let $state := p:lookahead2W(161, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'context' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                               'option' | 'or' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'updating' | 'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 8032                             (: 'declare' '%' :)
      and $state[$p:lk] != 23136                            (: 'declare' 'context' :)
      and $state[$p:lk] != 30816                            (: 'declare' 'function' :)
      and $state[$p:lk] != 40800                            (: 'declare' 'option' :)
      and $state[$p:lk] != 51552                            (: 'declare' 'updating' :)
      and $state[$p:lk] != 52320) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 96) then                     (: 'declare' :)
            let $state := p:lookahead2W(142, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'updating' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 23136) then              (: 'declare' 'context' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 40800) then              (: 'declare' 'option' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return $state
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: NCName^Token :)
      let $state := p:consume(15, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'after' :)
      let $state := p:consume(69, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'and' :)
      let $state := p:consume(73, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:consume(74, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ascending' :)
      let $state := p:consume(75, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'before' :)
      let $state := p:consume(79, $input, $state)           (: 'before' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'case' :)
      let $state := p:consume(82, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'cast' :)
      let $state := p:consume(83, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'castable' :)
      let $state := p:consume(84, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:consume(87, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:consume(93, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'descending' :)
      let $state := p:consume(101, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'div' :)
      let $state := p:consume(103, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'else' :)
      let $state := p:consume(107, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty' :)
      let $state := p:consume(108, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'end' :)
      let $state := p:consume(111, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'eq' :)
      let $state := p:consume(112, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'except' :)
      let $state := p:consume(114, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'for' :)
      let $state := p:consume(119, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'ge' :)
      let $state := p:consume(121, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'group' :)
      let $state := p:consume(123, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'gt' :)
      let $state := p:consume(125, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'idiv' :)
      let $state := p:consume(126, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'instance' :)
      let $state := p:consume(133, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'intersect' :)
      let $state := p:consume(134, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'into' :)
      let $state := p:consume(135, $input, $state)          (: 'into' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'is' :)
      let $state := p:consume(137, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'le' :)
      let $state := p:consume(141, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'let' :)
      let $state := p:consume(143, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'lt' :)
      let $state := p:consume(144, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'mod' :)
      let $state := p:consume(146, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'modify' :)
      let $state := p:consume(147, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'ne' :)
      let $state := p:consume(151, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'only' :)
      let $state := p:consume(158, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'or' :)
      let $state := p:consume(160, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'order' :)
      let $state := p:consume(161, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'return' :)
      let $state := p:consume(175, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'satisfies' :)
      let $state := p:consume(177, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'stable' :)
      let $state := p:consume(185, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'start' :)
      let $state := p:consume(186, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'to' :)
      let $state := p:consume(192, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'transform' :)
      let $state := p:consume(193, $input, $state)          (: 'transform' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'treat' :)
      let $state := p:consume(194, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'union' :)
      let $state := p:consume(199, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 207) then                      (: 'where' :)
      let $state := p:consume(207, $input, $state)          (: 'where' :)
      return $state
    else
      let $state := p:consume(209, $input, $state)          (: 'with' :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(148, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(149, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(159, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'where' | 'with' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(58, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  return $state
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(50, $input, $state)               (: ';' :)
  return $state
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(210, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 110) then                      (: 'encoding' :)
      let $state := p:consume(110, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(205, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:lookahead1W(85, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 110) then                  (: 'encoding' :)
          let $state := p:consume(110, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(17, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 210) then                          (: 'xquery' :)
      let $state := p:lookahead2W(157, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'encoding' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 28370                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 52690) then                    (: 'xquery' 'version' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 148) then                          (: 'module' :)
      let $state := p:lookahead2W(156, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'or' | 'to' | 'transform' |
                                                               'treat' | 'union' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 38292) then                    (: 'module' 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  return $state
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(207, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'last' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(24, $input, $state)               (: EOF :)
  return $state
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 9),
    0, 0, 0,
    subsequence($state, 13)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] lt 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 17) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 6)
    else
    (
      p:matchW($input, $state[$p:e1], $set),
      0, 0, 0
    )
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] ne 0) then
      subsequence($state, $p:l3, 3)
    else
      p:matchW($input, $state[$p:e2], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:b0, 8),
    $match,
    subsequence($state, 13)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false())
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
