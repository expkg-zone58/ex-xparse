xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Sep 15, 2022 22:23 (UTC+01) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: BaseX.ebnf -ll 2 -backtrack -name XQuery -xquery :)

(:~
 : The parser that was generated for the XQuery grammar.
 :)
module namespace p="XQuery";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the lexer state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the lexer state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the lexer state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the lexer state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the lexer state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 10;

(:~
 : The index of the lexer state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 11;

(:~
 : The index of the lexer state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 12;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  70, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 40, 41,
  42, 43, 44, 45, 46, 47, 48, 49, 30, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 38,
  38
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 355, 371,
  387, 423, 423, 423, 415, 339, 331, 339, 331, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 440, 440, 440, 440, 440, 440, 440, 324, 339, 339, 339, 339, 339, 339, 339, 339, 401, 423, 423, 424, 422,
  423, 423, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 338, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 70, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 38, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
  30, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  38, 38, 38, 30, 30, 38, 38, 38, 38, 38, 38, 38, 69, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 38, 30, 38, 30, 30, 38
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 94212, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
  207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
  230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 18176, 18192, 18216, 18216, 18216, 18214, 18216, 18216, 18216, 18218, 18234, 18216, 18216, 18198, 18216, 18245,
  18261, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413,
  18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567,
  19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553,
  18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807,
  33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558,
  34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132,
  24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880,
  19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536,
  19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 41173, 19900, 19914, 20023,
  19960, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 26210, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535,
  19413, 18724, 19796, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459,
  18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993,
  18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933,
  18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535,
  23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131,
  19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296,
  29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649,
  18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 19857, 19999, 20023, 20023, 20023, 20020, 20023, 20023, 20040, 20060, 19879, 20022, 20023, 20023,
  34076, 20076, 22317, 20023, 20023, 20489, 20023, 20023, 21194, 20112, 42633, 19280, 20023, 20023, 20023, 19274, 29145,
  18535, 19413, 18537, 19419, 20129, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423,
  18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879,
  30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759,
  33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962,
  18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104,
  37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875,
  19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618,
  19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20145, 20881, 20023, 20023, 20023, 20181, 20023, 20023, 20882, 42232, 19879, 20202, 20228,
  20242, 20263, 20282, 21365, 20023, 20023, 20489, 20318, 20023, 21194, 20335, 42633, 19280, 20023, 20023, 20023, 19274,
  29145, 18535, 19413, 18537, 19419, 42612, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396,
  18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315,
  40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 20353, 18681, 18701, 18721, 20570, 18740, 19113,
  18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940,
  18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774,
  19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266,
  29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588,
  19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 19857, 36272, 20023, 20023, 20023, 20369, 20023, 20023, 36273, 34947, 19879, 20023,
  27189, 20393, 20412, 20426, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023,
  19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380,
  18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023,
  35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740,
  19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918,
  18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068,
  19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703,
  19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553,
  19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023, 20462, 20023, 20023, 20023, 20468, 20484,
  34625, 20023, 20023, 41447, 20505, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023,
  20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364,
  18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023,
  20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570,
  18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896,
  18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050,
  19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241,
  23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535,
  19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 22173,
  18875, 20023, 20023, 20023, 20023, 23841, 22058, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023,
  20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884,
  18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 20559, 19602, 18487, 18518, 18534, 19113, 22229, 20023,
  20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721,
  20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968,
  18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084,
  19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021,
  19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537,
  19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20600, 20023, 20023, 20023, 20621, 20023, 20023, 23584,
  20640, 19879, 20623, 20023, 20023, 36737, 20656, 21962, 20023, 20023, 20489, 20023, 20023, 21194, 20692, 42633, 19280,
  20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 18642, 18314, 18333, 35441, 20023, 20023, 23463, 20023,
  19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229,
  20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701,
  18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946,
  18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772,
  19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584,
  38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493,
  19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20713, 20757, 20757, 20757, 20740, 20757, 20757,
  20724, 20773, 20752, 20795, 20789, 20811, 20854, 20868, 21365, 20023, 20023, 19863, 20023, 20023, 21194, 20023, 42633,
  19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 28414, 20023, 20023, 23463,
  20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113,
  22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681,
  18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924,
  18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066,
  19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193,
  20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458,
  19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 36880, 20023, 20023, 20023, 20898, 20023,
  20023, 38301, 42232, 20910, 20944, 20954, 20960, 20931, 20976, 21365, 20023, 20023, 20697, 20023, 20023, 21194, 20023,
  42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 29131, 20023, 20023,
  23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534,
  19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658,
  18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902,
  18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048,
  19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225,
  19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705,
  19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812,
  19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20165, 20023, 20023, 20023, 29143,
  20023, 20023, 20023, 42232, 19879, 21011, 21015, 21031, 21059, 21073, 21365, 20023, 20023, 20489, 20023, 20023, 21194,
  20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023,
  20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 21109, 19602, 18487, 18518,
  18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535,
  18658, 21137, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467,
  18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869,
  19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209,
  19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435,
  19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399,
  19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023,
  29143, 20023, 20023, 20023, 42232, 19879, 42286, 42291, 21153, 41885, 21181, 21365, 20023, 20023, 20489, 20023, 20023,
  21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441,
  20023, 20023, 23521, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487,
  18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705,
  18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116,
  18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032,
  35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189,
  19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442,
  19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790,
  19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 42510, 20023, 20023,
  20023, 21217, 21258, 20023, 42513, 42232, 21276, 21332, 21336, 21230, 20023, 21352, 21365, 20023, 20023, 20489, 20023,
  20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333,
  35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602,
  18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685,
  18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860,
  19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431,
  19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221,
  19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385,
  19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749,
  19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21390, 20023, 20023,
  20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 42448, 42453, 21414, 42682, 21442, 21365, 20023, 20023, 20489,
  20023, 20023, 21194, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023,
  21536, 20396, 27692, 21553, 23521, 26431, 30734, 21617, 30200, 20023, 20023, 26229, 29194, 31584, 31584, 31584, 28157,
  25583, 25583, 26767, 21572, 34027, 20023, 20023, 20023, 20023, 19137, 41655, 31665, 21616, 30199, 20023, 30736, 27596,
  31584, 31584, 31584, 21742, 25582, 25583, 25583, 25584, 21590, 32911, 19469, 20023, 20023, 20023, 20023, 20023, 21613,
  30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023, 40753,
  26231, 32367, 30737, 32284, 21657, 31584, 25434, 22114, 25583, 25583, 28195, 20023, 20023, 25522, 21700, 30201, 29067,
  31584, 41194, 25576, 25583, 39901, 31932, 20023, 20023, 21675, 40151, 25949, 21659, 25583, 33264, 21699, 20023, 21717,
  34498, 21737, 21758, 38548, 20023, 27099, 39977, 30838, 31878, 36011, 21793, 40982, 36811, 40735, 21641, 19633, 37608,
  35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20023,
  20023, 20023, 20023, 29143, 20023, 20023, 20023, 21821, 19879, 20023, 20023, 20023, 30963, 21837, 21365, 20023, 20023,
  20489, 20023, 20023, 23393, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21876, 41323,
  20023, 20023, 20396, 20023, 20023, 23463, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 29194, 31584, 31584, 31584,
  28157, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 19137, 20023, 20023, 21616, 30199, 20023, 30736,
  27596, 31584, 31584, 31584, 21742, 25582, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023,
  26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023,
  20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201,
  29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023,
  30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365,
  37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857,
  21927, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 42564, 21903, 21917, 26488, 21949, 21365, 20023,
  20023, 20489, 20023, 20023, 21194, 42471, 42633, 19280, 21987, 20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419,
  19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483,
  18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599,
  29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787,
  20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732,
  18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633,
  19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733,
  19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577,
  19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  19857, 22005, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 24274, 19879, 22024, 20023, 20023, 37363, 22045, 19926,
  20023, 20023, 20489, 20023, 20023, 24268, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251,
  22083, 41323, 20023, 20023, 20396, 20023, 20023, 22271, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 29194, 31584,
  31584, 31584, 28157, 25583, 25583, 26250, 21572, 29587, 20023, 20023, 20023, 20023, 42185, 22283, 20023, 21616, 30199,
  20023, 30736, 27596, 31584, 31584, 31584, 21742, 25582, 25583, 25583, 25584, 21590, 28117, 20023, 20023, 20023, 20023,
  31137, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 32855, 22111, 25583, 25583, 25583, 21634, 22130, 20023,
  20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 30866, 25582, 25583, 25583, 28195, 20023, 20023, 20023,
  21700, 30201, 29067, 31584, 31584, 22149, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264,
  20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735,
  21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 19857, 18989, 20023, 20023, 20023, 22171, 22189, 20023, 24296, 42232, 22210, 38397, 22245, 22259, 20023, 22304,
  41590, 20023, 20023, 21933, 22342, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 20337, 23267, 23131,
  22646, 22359, 22440, 18314, 18333, 35184, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 29445,
  23071, 22386, 23207, 22428, 22674, 22456, 22414, 22482, 22947, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553,
  18583, 18599, 29619, 22531, 23272, 22576, 23267, 22591, 22626, 22506, 22642, 22466, 22662, 22947, 18759, 33933, 18807,
  33927, 23787, 20023, 18844, 18860, 19116, 35878, 22690, 23243, 22755, 22876, 22771, 22494, 23169, 22800, 22842, 23558,
  34057, 23732, 18984, 19005, 29431, 19032, 35869, 22865, 22892, 23216, 23011, 22370, 22908, 22515, 22938, 37131, 19132,
  24371, 42633, 19153, 30416, 22980, 22966, 23102, 23181, 22996, 23364, 38021, 19241, 23703, 19266, 30424, 22400, 22922,
  23302, 19733, 19317, 19369, 23032, 23062, 23046, 23138, 19458, 23087, 23118, 23154, 22815, 23197, 22705, 23232, 22846,
  23259, 22849, 23288, 23318, 22546, 23353, 22784, 22560, 23380, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 19857, 39918, 20023, 20023, 20023, 23416, 23427, 20023, 20023, 42232, 23450, 33522, 23486, 23492, 20023,
  23508, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535,
  19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459,
  18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 23545, 30993,
  18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 23574, 18759, 33933,
  18807, 33927, 24091, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535,
  23604, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 23620, 19050, 19068, 19774, 19104, 37131,
  19132, 24371, 42633, 19153, 29867, 19221, 19189, 23636, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296,
  29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649,
  18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 20023, 23652, 20990, 20995, 23673,
  34162, 23719, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 23748, 20023, 20023, 19274, 29145,
  18535, 19413, 18537, 19682, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423,
  18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879,
  30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759,
  33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962,
  18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104,
  37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875,
  19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618,
  19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 23767, 20023, 21315, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 21290, 23803,
  21304, 20023, 23819, 37269, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 23857, 20023, 20023, 19274,
  29145, 18535, 19413, 18537, 19659, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396,
  18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315,
  40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113,
  18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940,
  18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774,
  19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266,
  29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588,
  19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 23878, 23781, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 24433,
  24438, 23916, 20023, 23932, 21850, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 23948, 20023, 20023,
  19274, 29145, 18535, 19413, 18537, 19419, 21121, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380,
  18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023,
  35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740,
  19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918,
  18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068,
  19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703,
  19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553,
  19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 23969, 20023, 20023, 20023, 20023, 23985, 20023, 20023, 20023, 42232, 19879,
  30999, 24419, 20023, 36498, 24014, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 42489, 42633, 19280, 20023, 20023,
  20023, 19274, 29145, 18535, 19413, 18743, 19507, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364,
  18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023,
  20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570,
  18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896,
  18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050,
  19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241,
  23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535,
  19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232,
  19879, 20023, 20023, 20023, 34351, 24056, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023,
  20023, 20023, 19274, 29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884,
  18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023,
  20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721,
  20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968,
  18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084,
  19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021,
  19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537,
  19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023,
  42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617,
  20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023,
  30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023,
  20023, 20023, 20023, 20023, 25661, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583,
  25583, 25584, 21590, 30665, 20023, 20023, 20023, 20023, 31137, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584,
  33348, 25579, 25583, 25583, 25583, 21634, 22130, 20023, 20023, 20023, 24130, 26231, 32367, 30737, 32284, 31584, 31584,
  29792, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 22149, 25583, 25584, 34025,
  20023, 39668, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099,
  31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143, 20023, 20023,
  20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700,
  21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023,
  20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027,
  20023, 20023, 20023, 20023, 20023, 25661, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584, 26748, 27478,
  25583, 25583, 25584, 21590, 30665, 20023, 20023, 20023, 20023, 31137, 20023, 26232, 30200, 21700, 33101, 31584, 31584,
  31584, 33348, 25579, 25583, 25583, 25583, 21634, 22130, 20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584,
  31584, 29792, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 22149, 25583, 25584,
  34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023,
  27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143, 20023,
  20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023,
  21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023,
  20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572,
  34027, 20023, 20023, 20023, 20023, 20023, 25661, 24151, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584, 26748,
  27478, 25583, 25583, 25584, 21590, 30665, 20023, 20023, 20023, 20023, 31137, 20023, 26232, 30200, 21700, 33101, 31584,
  31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 22130, 20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284,
  31584, 31584, 29792, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 22149, 25583,
  25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548,
  20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576,
  37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143,
  20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023, 20023, 20023,
  20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023, 20396, 20023,
  20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250,
  21572, 34027, 20023, 20023, 20023, 20023, 20023, 25661, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584,
  26748, 27478, 25583, 25583, 25584, 21590, 30665, 20023, 20023, 20023, 20023, 31137, 24168, 26232, 30200, 21700, 33101,
  31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 22130, 20023, 20023, 20023, 20023, 26231, 32367, 30737,
  32284, 31584, 31584, 29792, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 22149,
  25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968,
  38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961,
  40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023,
  29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023, 20023,
  23330, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023, 20396,
  20023, 20023, 23330, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583,
  26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 25661, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584,
  31584, 26748, 27478, 25583, 25583, 25584, 21590, 30665, 20023, 20023, 20023, 20023, 31137, 20023, 26232, 30200, 21700,
  33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 22130, 20023, 20023, 20023, 20023, 26231, 32367,
  30737, 32284, 31584, 31584, 29792, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584,
  22149, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584,
  41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697,
  26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023,
  20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023,
  20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023,
  20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583,
  25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 30736, 27596, 31584,
  31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 26232, 30200,
  21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023, 20023, 26231,
  32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584,
  31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261,
  31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370,
  29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023,
  20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489,
  20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 21770, 20023,
  20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867,
  25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 30736, 27596,
  31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 26232,
  30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023, 20023,
  26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067,
  31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735,
  27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608,
  35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023,
  20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 25482, 40376, 20023, 20023,
  20489, 20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323,
  20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584,
  39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 30736,
  27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023,
  26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023,
  20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201,
  29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023,
  30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365,
  37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085,
  20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24188, 32370, 21701, 26108, 21574, 37068, 40376, 20023,
  20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491,
  41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 24222, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584,
  31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023,
  30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023,
  20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023,
  20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700,
  30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023,
  20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641,
  35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  24085, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 32010, 24241, 24255, 40376,
  20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251,
  21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584,
  31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199,
  20023, 30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023,
  20023, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023,
  20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023,
  21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264,
  20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735,
  21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 24085, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068,
  40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777,
  26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196,
  31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616,
  30199, 20023, 30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023,
  20023, 20023, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023,
  20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023,
  38038, 21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583,
  33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638,
  40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 24290, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574,
  37068, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584,
  32777, 26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229,
  25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023,
  20023, 20023, 20023, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634,
  20023, 20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023,
  20023, 20023, 21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659,
  25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732,
  21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 38197, 24312, 24326,
  38240, 24347, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145,
  18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 30570, 19884, 18364, 18380, 18396, 18423,
  18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 24387, 19113, 22229, 20023, 20023, 20023, 35315, 40879,
  30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759,
  33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962,
  18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104,
  37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875,
  19296, 29880, 19301, 19733, 24405, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618,
  19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 20023, 20023,
  20023, 20023, 23841, 21365, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274,
  29145, 18535, 19413, 18537, 19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396,
  18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315,
  40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113,
  18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940,
  18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774,
  19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266,
  29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588,
  19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 24454, 24492, 20023, 20023, 20023, 24510, 20023, 20023, 20023, 42232, 24524, 20676,
  24545, 24551, 18317, 24567, 24596, 20023, 20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023,
  19274, 29145, 18535, 19413, 18537, 19419, 24621, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380,
  18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023,
  35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740,
  19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918,
  18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068,
  19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703,
  19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553,
  19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 24637, 24659, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879,
  20023, 20023, 20023, 37714, 24677, 24772, 20023, 20023, 20489, 20023, 20023, 21194, 27891, 42633, 19280, 20023, 20023,
  20023, 19274, 29145, 18535, 19413, 24389, 19419, 24806, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364,
  18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023,
  20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570,
  18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896,
  18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050,
  19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241,
  23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535,
  19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 24822, 20023, 20023, 24841, 24867, 20023, 24851, 24901,
  24917, 24931, 24941, 24957, 24973, 24987, 42316, 25022, 42180, 20489, 24702, 25495, 25041, 25065, 25088, 25139, 42171,
  24580, 24690, 25175, 25212, 25235, 25272, 38183, 25299, 25344, 20023, 27356, 20396, 24331, 20023, 25405, 22326, 30734,
  21617, 25188, 28435, 30026, 21721, 25422, 31584, 31584, 36931, 39867, 25583, 25583, 25454, 21572, 34027, 34940, 36039,
  33157, 30610, 20023, 25661, 20023, 29661, 25159, 42159, 25547, 25563, 26061, 31584, 37581, 25600, 38365, 25583, 37339,
  28629, 25616, 30665, 25632, 32555, 20023, 20023, 25652, 20023, 34827, 25688, 33685, 25704, 25730, 24756, 36196, 33348,
  22720, 34643, 36314, 25583, 25763, 25799, 24885, 20023, 32106, 19973, 26231, 32367, 30737, 32284, 31584, 39286, 25834,
  25582, 25583, 29324, 28195, 25876, 20158, 25901, 25920, 30201, 25941, 31584, 25968, 22149, 35830, 25584, 25987, 26008,
  20023, 30733, 40151, 29348, 36378, 37332, 34015, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584,
  26907, 31878, 41611, 33484, 26026, 21638, 26053, 21641, 26077, 38659, 35370, 29697, 26961, 40576, 37256, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 26102, 20023, 20023, 29143, 20023, 20023, 20023,
  26124, 26140, 28517, 26165, 26180, 21574, 40265, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617,
  20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023,
  30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023,
  20023, 20023, 20023, 26208, 32214, 20023, 21616, 37913, 20023, 26226, 27596, 31584, 31584, 31098, 26748, 27478, 25583,
  25583, 26248, 21590, 30665, 20023, 20023, 20023, 20023, 31137, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584,
  33348, 25579, 25583, 25583, 25583, 21634, 22130, 20023, 20023, 35717, 20023, 38327, 25513, 30737, 26267, 31584, 31584,
  29792, 26290, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 22149, 25583, 25584, 34025,
  20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099,
  31584, 26907, 31878, 41611, 41969, 40732, 21638, 29198, 26311, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 21043, 20023, 20023, 29143, 24643, 20023,
  20023, 42232, 26339, 26353, 26366, 26382, 26398, 26412, 40376, 20023, 24172, 20605, 20023, 25406, 20023, 20023, 21700,
  21617, 20023, 20023, 24661, 26230, 34393, 25971, 32777, 25283, 26447, 26481, 34744, 20023, 20396, 32004, 29086, 20023,
  20023, 26504, 25152, 30200, 26534, 26551, 26572, 34433, 26590, 31584, 31584, 28102, 26626, 25583, 26250, 21572, 29936,
  20023, 20023, 38390, 20023, 34321, 25661, 26649, 26679, 30199, 20023, 30736, 27596, 34896, 33342, 26703, 26748, 34279,
  25256, 41035, 25584, 21590, 30665, 20023, 20023, 26725, 20023, 32205, 20023, 26232, 30200, 21700, 33101, 31584, 31584,
  41903, 33348, 25579, 25583, 25583, 31711, 21634, 22130, 20023, 20023, 20023, 30676, 26231, 32367, 30737, 32284, 31584,
  26743, 29792, 25582, 25583, 26764, 28195, 20023, 20023, 26783, 21700, 31310, 26803, 36159, 31584, 22149, 39875, 25584,
  26830, 20023, 20023, 30733, 26846, 25949, 26871, 35792, 33264, 20023, 41987, 30735, 27261, 31584, 26904, 28822, 20023,
  27099, 31584, 26907, 31878, 41611, 41969, 40732, 35374, 26924, 26952, 35365, 37608, 35370, 29697, 26961, 42032, 37256,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20266, 20023, 20023, 29143, 39455,
  20023, 26986, 42232, 27010, 27024, 27034, 27050, 27066, 27080, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023,
  21700, 38827, 27118, 20023, 27115, 37889, 22343, 36941, 36780, 26251, 27134, 41323, 26535, 25357, 28369, 27150, 33515,
  20023, 20023, 33428, 33759, 27168, 21971, 27205, 27240, 27277, 25739, 39294, 32307, 28786, 22735, 40935, 28572, 21572,
  34027, 20023, 20023, 27334, 20023, 27355, 25661, 20023, 21616, 30199, 20023, 30736, 38924, 31584, 31584, 31584, 26748,
  27478, 25583, 25583, 25584, 27372, 27399, 27426, 20023, 33058, 37526, 31137, 20023, 26232, 30200, 21700, 41677, 27443,
  31584, 31584, 27463, 21457, 25583, 25583, 26633, 21634, 22130, 20023, 20023, 20023, 20023, 27495, 32367, 30737, 27517,
  31584, 27538, 29792, 27556, 35753, 25583, 28195, 42007, 20023, 27575, 41348, 27592, 29067, 27612, 27633, 22149, 27653,
  25584, 34025, 36637, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20669, 30735, 27261, 31584, 27669, 27318,
  20023, 27099, 31584, 26907, 31878, 41611, 41969, 31883, 26086, 33541, 40567, 35365, 37608, 35370, 29697, 26961, 40576,
  37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20024, 27689, 20023, 29143,
  18774, 18789, 40056, 21165, 27708, 27722, 27732, 27748, 27764, 27778, 40376, 22610, 27807, 27842, 37081, 27877, 23685,
  23657, 37281, 27913, 34468, 27941, 27991, 27955, 28028, 28087, 40423, 28144, 28181, 28220, 30465, 28243, 25860, 33968,
  28263, 25847, 39348, 30734, 21617, 30234, 30445, 20023, 19944, 25196, 32398, 35564, 36203, 39867, 28283, 28305, 28317,
  21572, 28204, 25531, 28333, 23529, 28357, 28385, 28430, 28451, 25102, 28510, 28467, 28498, 28533, 28549, 28588, 28604,
  28645, 28691, 28721, 28736, 28771, 28838, 28854, 31545, 20023, 31324, 28128, 31137, 28889, 28930, 41216, 34816, 28967,
  33328, 31584, 28993, 26610, 20826, 29014, 40018, 32748, 29034, 22130, 29083, 22826, 29102, 29161, 26231, 29189, 29214,
  29230, 39261, 29246, 29262, 32783, 28165, 29297, 38992, 20023, 37783, 20295, 21700, 37392, 29340, 29364, 37305, 29403,
  23900, 33258, 34025, 27216, 29461, 23751, 29477, 29507, 29544, 29574, 32476, 29612, 29635, 29651, 26518, 41618, 26881,
  29684, 39689, 29721, 25952, 26907, 29764, 29780, 34536, 35358, 29808, 25219, 29853, 29896, 29931, 35370, 37555, 29952,
  40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 29978, 20023,
  29998, 21556, 30023, 20044, 30042, 30058, 30072, 30082, 30098, 30114, 30128, 40376, 20023, 22222, 20489, 20023, 20023,
  18279, 20023, 21700, 21617, 20023, 26555, 26556, 25381, 22343, 32408, 30163, 26251, 30179, 41323, 25666, 20023, 20396,
  25672, 20023, 40284, 20023, 27093, 30195, 30200, 20023, 25671, 30217, 25196, 30250, 31584, 31584, 39086, 25583, 25583,
  26250, 30269, 34027, 20023, 20023, 20023, 20023, 20023, 25661, 20023, 21616, 30199, 20023, 30316, 27596, 31584, 31584,
  36294, 26748, 27478, 25583, 32082, 25584, 21590, 30665, 20023, 20023, 19564, 20023, 31137, 20023, 26232, 30200, 21700,
  30338, 31584, 38136, 31584, 33348, 25579, 25583, 30364, 25583, 21634, 22130, 20023, 30383, 20023, 20023, 26231, 30402,
  24225, 32284, 31584, 26037, 29792, 25582, 25583, 32526, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584,
  22149, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 30440, 20023, 30735, 27261, 31584,
  41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 40452,
  26961, 30930, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023,
  20023, 29143, 20023, 30461, 20023, 42232, 30481, 30495, 30505, 30521, 30537, 30551, 40376, 20023, 20023, 20489, 20023,
  20023, 20023, 35603, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 34308, 20023, 20023,
  20396, 20023, 20023, 20023, 20023, 30586, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583,
  25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 30607, 21616, 30199, 20023, 30736, 38094, 31584,
  31584, 31584, 27522, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 41826, 20023, 38454, 20023, 20023, 26232, 30200,
  41601, 30626, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 30652, 20023, 20023, 20023, 20023, 20023, 26231,
  32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 30710, 30731, 30201, 29067, 31584,
  31584, 25576, 25583, 25584, 34025, 30753, 27410, 30779, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 38815, 29491,
  31567, 38978, 30813, 20023, 39154, 30854, 30882, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370,
  29697, 21805, 30918, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023,
  20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 30979,
  20023, 20023, 20023, 25025, 21700, 21618, 20023, 20023, 21093, 28675, 20446, 31015, 31033, 28012, 31060, 40872, 20023,
  27152, 20396, 31516, 27427, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31095, 39867,
  25583, 33391, 26250, 21572, 34027, 20023, 20023, 31114, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 26994, 40109,
  31584, 31584, 31584, 39755, 27478, 25583, 25583, 30367, 21590, 34027, 31134, 20023, 20023, 20023, 20023, 20023, 26232,
  30200, 21700, 36099, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 41330, 20023, 20023,
  26231, 32367, 30737, 32284, 31584, 41526, 25434, 25582, 25583, 28813, 28195, 20023, 20023, 20023, 21700, 30201, 29067,
  31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 32882, 30735,
  35270, 31584, 41968, 26465, 20023, 36077, 37000, 26907, 31153, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608,
  35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023,
  20023, 38014, 20023, 29143, 18828, 39448, 18822, 31174, 31190, 31204, 31230, 31214, 31246, 31260, 40376, 20023, 20023,
  30763, 18270, 20023, 20023, 20023, 31295, 31346, 33290, 35508, 36862, 31366, 31382, 31425, 31444, 31462, 31478, 40049,
  20023, 20023, 41073, 20023, 24529, 31512, 20023, 30734, 34203, 38334, 31532, 20023, 26229, 20531, 31583, 31601, 39041,
  33205, 27673, 25583, 31618, 21572, 34027, 29275, 31662, 18434, 31681, 21398, 20023, 36261, 21616, 35918, 32711, 42419,
  27596, 31584, 37018, 32415, 35240, 27478, 25583, 31697, 41809, 21590, 34027, 20023, 20023, 36687, 31732, 19166, 20023,
  26232, 30200, 21700, 33101, 31748, 31584, 31584, 33348, 23893, 25583, 25583, 25583, 21634, 20023, 19330, 31765, 19841,
  29748, 31791, 25389, 19342, 31811, 40518, 31584, 25434, 25582, 29911, 25583, 29558, 20089, 35072, 20023, 42391, 31830,
  26855, 36140, 34567, 28617, 41475, 31866, 37636, 20023, 41772, 20518, 31899, 39649, 26814, 38686, 31922, 20023, 31948,
  30007, 27261, 31584, 41968, 38548, 31967, 27099, 31584, 26907, 31878, 39748, 41969, 20915, 31989, 40735, 21641, 35365,
  37608, 32026, 29697, 26961, 40576, 34803, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085,
  20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 20023,
  20023, 20489, 20023, 20023, 32061, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491,
  41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584,
  31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023,
  30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023,
  20023, 26232, 30200, 21700, 33101, 31584, 38116, 31584, 33348, 25579, 25583, 32081, 25583, 21634, 20023, 20023, 20023,
  20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700,
  30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023,
  20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641,
  35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  24085, 20023, 20023, 24877, 20023, 29143, 20023, 32098, 21989, 21242, 32122, 32136, 32146, 32162, 32178, 32192, 40376,
  36643, 20023, 20489, 20023, 22288, 25006, 35603, 21700, 32230, 20023, 21316, 22194, 32251, 32272, 32303, 32323, 26251,
  21491, 22095, 25000, 20023, 37104, 37157, 25812, 25992, 23953, 23588, 21617, 32364, 20023, 25000, 24114, 35927, 32386,
  27637, 32431, 32461, 27310, 40130, 37485, 32512, 32552, 32571, 20023, 20023, 20023, 32588, 20023, 20023, 24201, 30199,
  20023, 30736, 27596, 32607, 32631, 24748, 27522, 32651, 21467, 41547, 25584, 21590, 34027, 33702, 32686, 20023, 20023,
  32710, 32727, 26232, 25115, 21700, 33101, 31584, 31814, 38511, 33348, 25579, 25583, 28751, 32745, 21634, 33560, 20023,
  20023, 23400, 20023, 41114, 32367, 30737, 32764, 31584, 31584, 25434, 22155, 25583, 25583, 28195, 32799, 20023, 42371,
  32819, 32871, 21683, 31584, 31584, 27290, 25583, 25584, 34025, 30685, 20023, 30694, 40151, 25949, 21659, 25583, 33264,
  20023, 32694, 30735, 27261, 33985, 41968, 40906, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735,
  21641, 30636, 32906, 32927, 29697, 36823, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 24085, 20023, 20023, 37189, 20023, 32953, 20023, 24712, 20023, 21426, 32969, 32983, 32993, 33009, 33025, 33039,
  40376, 23015, 20023, 20489, 20023, 26010, 20023, 20023, 21700, 33074, 20023, 24152, 23015, 33095, 23016, 33117, 38623,
  26251, 33140, 41323, 20023, 27819, 20396, 20023, 32065, 20023, 33156, 30734, 21617, 30200, 20023, 36396, 27791, 25196,
  33173, 37588, 40483, 25468, 25583, 26459, 33191, 33244, 33280, 18407, 20377, 20023, 20023, 21086, 20023, 20023, 21616,
  30199, 20023, 30736, 27596, 33314, 36460, 31584, 26748, 33364, 33389, 33407, 25584, 21590, 34027, 40385, 40394, 20023,
  20023, 33424, 24605, 26232, 30200, 21700, 33101, 37505, 31584, 39031, 40524, 33444, 33464, 28289, 25583, 21634, 20023,
  20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023,
  20023, 21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34722, 20023, 20023, 30733, 40151, 25949, 21659, 25583,
  33264, 20023, 20023, 30735, 36767, 31584, 33483, 41929, 20023, 27099, 31584, 26907, 39598, 41611, 33500, 33538, 21638,
  40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 24085, 20023, 20023, 19173, 20023, 33557, 20023, 24027, 33576, 33586, 33602, 33616, 33626, 33642, 33658,
  33672, 40376, 24825, 33701, 20489, 28660, 36872, 20023, 20023, 33718, 33744, 24360, 33780, 33796, 33812, 19250, 33849,
  33865, 39854, 33881, 41323, 27180, 20023, 35118, 33897, 39125, 35605, 33913, 29060, 21617, 32235, 27576, 33949, 29173,
  25196, 27447, 31584, 33984, 39867, 34859, 29018, 26250, 34001, 34043, 20023, 34371, 34092, 20023, 20023, 19477, 20023,
  30791, 30199, 31273, 30736, 34109, 34593, 31584, 31584, 34138, 39806, 25583, 25583, 30896, 21590, 34027, 20023, 20023,
  20023, 34178, 20023, 21201, 34198, 38834, 34219, 30797, 31584, 31584, 34245, 34264, 28006, 25583, 28795, 32670, 21634,
  33298, 34343, 34367, 34387, 20023, 34409, 34449, 34484, 34552, 34583, 29522, 25434, 21887, 21512, 31075, 29048, 23434,
  34616, 31409, 36001, 36418, 39641, 32849, 31584, 25576, 34641, 38528, 34659, 20439, 20023, 39418, 37211, 34680, 34696,
  39824, 34712, 34738, 20023, 25072, 27261, 34760, 26970, 35472, 20023, 34789, 35405, 34851, 31878, 31850, 29962, 34875,
  29705, 34912, 34928, 35365, 37608, 35370, 35485, 34963, 40576, 29735, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 24085, 20023, 20023, 20004, 20023, 29143, 20624, 22008, 20023, 42232, 34989, 35003, 35013, 35029,
  35045, 35059, 30291, 35088, 35112, 35134, 35170, 35200, 20023, 30300, 35221, 35256, 26323, 29117, 35304, 28482, 35331,
  35390, 34512, 35427, 35457, 35501, 20023, 20023, 35536, 20023, 42098, 35524, 34461, 35636, 29668, 30200, 20023, 20023,
  26229, 35552, 31017, 31602, 40488, 39867, 39570, 31716, 40945, 21572, 34027, 31158, 20023, 40078, 20023, 35580, 35596,
  29596, 21616, 36440, 19016, 25925, 27596, 31584, 25747, 31584, 35621, 27478, 33448, 25583, 40351, 35658, 32348, 20023,
  35694, 35714, 20023, 20023, 20023, 26232, 30200, 38258, 33101, 31584, 35733, 31584, 33348, 25579, 29387, 25583, 25583,
  21634, 20023, 20023, 33962, 41638, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 26192, 35752, 25583, 25583, 28195,
  20023, 35769, 20023, 21700, 27501, 28914, 41723, 32287, 40122, 39817, 38693, 41864, 20023, 20023, 22950, 40151, 35280,
  21659, 35789, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 35808, 35642, 31584, 35828, 36852, 34229, 33228,
  22029, 35846, 40735, 21641, 35365, 37608, 35370, 34526, 33218, 40576, 31396, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143, 20023, 27897, 21537, 24040, 35894, 39490, 35943,
  35958, 35974, 35988, 40376, 20023, 23695, 28400, 20023, 20023, 20023, 20023, 28904, 21617, 20023, 36027, 20023, 40327,
  22343, 31585, 32777, 21520, 21491, 41323, 36903, 20023, 20396, 20023, 18791, 32803, 36055, 36071, 36093, 30200, 20023,
  36115, 26229, 25196, 36133, 36156, 36175, 31632, 40250, 29915, 31044, 36219, 41063, 20023, 28227, 20023, 34068, 38292,
  40278, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 38378,
  31951, 20023, 20023, 38215, 20023, 36249, 41235, 24206, 21700, 33101, 31584, 36289, 31584, 29528, 36310, 32536, 25583,
  25583, 21634, 20023, 36330, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 41947, 31584, 26936, 25582, 32045, 25583,
  28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 36350, 30733, 33833,
  25949, 21659, 25583, 30902, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 39532, 36371,
  41969, 31556, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370,
  21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 36394, 21700, 36412, 18288, 18294, 18297,
  36434, 18298, 36456, 36476, 26295, 21491, 39628, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200,
  20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584, 27617, 27478, 25583, 25583, 25584, 21590,
  34027, 20023, 20023, 20023, 20023, 20023, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583,
  25583, 25583, 21634, 20023, 20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583,
  25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733,
  40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 34890, 21597, 38548, 20023, 27099, 31584, 26907, 31878,
  41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20113, 36514, 36531, 20186, 20023, 36537, 42232, 36554,
  36568, 36578, 36594, 36610, 36624, 40376, 20023, 28873, 20489, 37642, 36659, 36682, 25818, 36703, 38067, 26727, 25369,
  36729, 36753, 36796, 20543, 34122, 40829, 36839, 36896, 20023, 20023, 31118, 30954, 21374, 34153, 26425, 22067, 30226,
  30200, 20023, 30715, 30591, 36919, 28998, 33175, 31584, 28564, 41027, 31496, 27559, 36964, 36980, 20023, 19935, 30564,
  35773, 20023, 37462, 20023, 21616, 41701, 20023, 19941, 39225, 36999, 37016, 31428, 32445, 37034, 31456, 25583, 37055,
  21590, 34027, 20023, 37097, 19572, 37120, 37147, 37181, 26232, 37205, 37227, 37243, 31584, 40209, 37297, 34600, 25579,
  31079, 32937, 33408, 37321, 24781, 20023, 38472, 37355, 36515, 26231, 32367, 37379, 37408, 31584, 31584, 25434, 21502,
  25583, 25583, 29417, 36538, 37442, 37460, 21700, 30201, 29067, 31584, 31584, 37478, 25583, 40304, 34025, 36983, 20023,
  30733, 27975, 37501, 37426, 25583, 41854, 20023, 37521, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907,
  36489, 35231, 37542, 40732, 21638, 37571, 37604, 37624, 37608, 35370, 30826, 37658, 32336, 37256, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 37685, 37706, 37730, 37747, 37763, 29837,
  37799, 37813, 37823, 37839, 37855, 37869, 21860, 20023, 20023, 24069, 20023, 20023, 39198, 20023, 25904, 37905, 31279,
  28267, 37929, 24466, 25783, 37945, 37968, 22739, 37984, 41323, 38000, 20023, 20396, 38716, 38037, 20023, 20023, 27339,
  38054, 33079, 37778, 41754, 38083, 25123, 38110, 38132, 31584, 25328, 38152, 25583, 26250, 38168, 34027, 38213, 30386,
  35205, 38231, 20023, 20023, 20023, 21616, 30199, 34182, 30736, 27596, 31584, 31584, 31584, 26748, 27478, 25583, 25583,
  25584, 21590, 34027, 20023, 38256, 38274, 38283, 32729, 32591, 26232, 39484, 38317, 32834, 31584, 40799, 35288, 38350,
  38413, 25583, 31646, 27301, 38434, 38450, 38470, 37690, 20023, 20023, 26574, 34835, 30737, 38488, 41278, 38507, 25434,
  25582, 28804, 38527, 28195, 20023, 37165, 20023, 25885, 30201, 29067, 39943, 26601, 25249, 32041, 38544, 34025, 20023,
  21777, 38564, 19353, 25949, 21659, 25583, 21475, 42106, 20023, 38587, 38610, 38491, 41968, 36233, 38639, 38571, 31584,
  26907, 35673, 33728, 34973, 40732, 21638, 24721, 38655, 30348, 42088, 38675, 29697, 26961, 40576, 37256, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 23832, 29143, 20023, 20023, 38709,
  19983, 38732, 38746, 38756, 38772, 38788, 38802, 20212, 24494, 38850, 20489, 20023, 31973, 38866, 28247, 21700, 38911,
  36666, 31330, 38882, 38898, 38963, 39017, 39057, 39073, 39102, 39118, 32491, 39141, 24135, 39170, 20023, 41504, 39190,
  39374, 31350, 33827, 39413, 28951, 39214, 39241, 31584, 39277, 39310, 28043, 26908, 41309, 37039, 39326, 35858, 39364,
  34664, 37444, 26663, 20023, 20023, 35812, 35907, 39398, 39434, 39471, 39506, 39548, 36948, 39995, 26748, 39564, 34294,
  25583, 39586, 39614, 39665, 39684, 27224, 42661, 39705, 39722, 32890, 39382, 27252, 39738, 27925, 39952, 39771, 34248,
  39791, 39840, 39891, 25583, 29312, 21634, 22602, 39917, 41002, 24790, 20023, 36713, 26687, 30737, 39934, 39968, 39993,
  25434, 40011, 40034, 25583, 28195, 40072, 23337, 20023, 40094, 40146, 40172, 40199, 31584, 40235, 40300, 33467, 34025,
  32496, 20023, 40320, 40151, 42062, 41256, 40343, 28054, 40367, 20023, 30735, 40410, 37952, 41968, 40439, 28865, 40468,
  40504, 40540, 31878, 41611, 41969, 40732, 21638, 40735, 37669, 25714, 38947, 40183, 40556, 26961, 40576, 35345, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20096, 29143, 20023, 22133,
  20023, 40592, 40608, 40622, 40635, 40651, 40667, 40681, 40376, 20023, 20023, 18880, 20023, 25636, 20023, 20023, 21700,
  21617, 20023, 29281, 20023, 26230, 40728, 39256, 34773, 26251, 21491, 41323, 40751, 20023, 20396, 20023, 20023, 20023,
  40769, 25438, 21617, 30200, 20023, 40775, 31906, 25196, 40797, 31584, 31584, 40815, 25583, 25583, 28755, 40858, 30942,
  32572, 30141, 20023, 40781, 20023, 36355, 25049, 32256, 27968, 28071, 30736, 24476, 32635, 40219, 32615, 26748, 27478,
  40895, 40922, 25584, 21590, 34027, 28341, 20023, 20023, 20023, 20023, 33052, 38594, 30200, 21700, 33101, 33124, 31584,
  31584, 26709, 40961, 25583, 25583, 25583, 21634, 40977, 39174, 20023, 20023, 20023, 26231, 32367, 25504, 32284, 31584,
  31584, 25434, 25582, 25583, 25583, 28705, 20023, 20023, 35678, 21700, 30201, 26149, 31584, 31584, 38937, 25583, 25584,
  34025, 40998, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023,
  27099, 36186, 41018, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 28977, 25775, 35370, 29697, 39001, 41051, 37256,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20023, 29143, 21260,
  19088, 20023, 41089, 41105, 28941, 21701, 41130, 41146, 41160, 40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023,
  21700, 21617, 20023, 20023, 20023, 26230, 22343, 41189, 39519, 26251, 21491, 41323, 20023, 29823, 20396, 20023, 20023,
  20023, 20023, 30734, 41210, 33764, 20023, 20023, 41232, 25196, 41251, 41272, 31584, 40842, 27479, 25583, 26250, 41294,
  34027, 20023, 20023, 20023, 20023, 30147, 20023, 20023, 31795, 30199, 41346, 30736, 27596, 31584, 24739, 31584, 26748,
  27478, 38418, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 26232, 30200, 21700, 33101, 31584,
  31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284,
  31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 37731, 20023, 21700, 30201, 29067, 31584, 31584, 25576, 25583,
  25584, 34025, 39706, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548,
  18443, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576,
  37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023, 20247, 29143,
  20023, 27826, 20319, 23998, 41364, 41378, 41388, 41404, 41420, 41434, 40376, 20023, 20023, 20489, 20023, 20023, 20023,
  20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 30253, 32777, 27383, 41463, 41497, 20023, 20023, 20396, 20023,
  20023, 20023, 36117, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867, 25583, 25583, 26250,
  21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584, 31584,
  26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 35154, 20023, 26232, 30200, 21700, 33101,
  31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 34093, 20023, 20023, 20023, 26231, 32367, 30737,
  32284, 41520, 35736, 25434, 25582, 41542, 41481, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584, 25576,
  25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584, 41968,
  38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697, 26961,
  40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24290, 20023, 20023, 20023, 20023,
  29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 34327, 41563, 41577, 40376, 20023, 20023, 20489, 41634, 20023,
  41654, 20023, 31840, 41671, 18342, 18348, 29982, 41693, 23862, 41717, 42075, 26251, 21491, 41323, 20023, 20023, 41739,
  20023, 41770, 41788, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 24730, 39867, 25583, 25583,
  25314, 21572, 30282, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 30736, 27596, 31584, 31584,
  31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 26232, 30200, 21700,
  33101, 31584, 31584, 31584, 35411, 41804, 25583, 25583, 25583, 21634, 23470, 20023, 20023, 20023, 20023, 26231, 32367,
  30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067, 31584, 31584,
  25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261, 31584,
  41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370, 29697,
  26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023, 20023,
  20023, 29143, 20023, 20023, 20023, 42232, 24107, 32370, 21701, 26108, 21574, 37068, 40376, 41825, 20023, 20489, 20023,
  20023, 26787, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 31775, 27540, 32777, 33373, 41842, 39341, 20023, 20023,
  20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 26274, 29379, 25583,
  25583, 20838, 21572, 34027, 41880, 20023, 35698, 20023, 20023, 20023, 20023, 21616, 34424, 20023, 30736, 27596, 37420,
  31584, 41901, 26748, 41919, 25583, 31490, 25584, 21590, 34027, 36334, 20023, 20023, 20023, 20023, 20023, 30322, 30200,
  21700, 33101, 31749, 41945, 31584, 33348, 25579, 32663, 25583, 25583, 41963, 20023, 20023, 41985, 20023, 20023, 26231,
  32367, 40156, 32284, 39775, 31584, 42003, 25582, 26888, 25583, 42023, 20023, 20023, 35096, 21700, 30201, 29067, 31584,
  31584, 25576, 25583, 25584, 28064, 20023, 20023, 37882, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735, 27261,
  31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608, 35370,
  29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 24085, 20023, 20023,
  20023, 20023, 29143, 20023, 20023, 20023, 42232, 42048, 32370, 21701, 26108, 21574, 37068, 40376, 20023, 20023, 20489,
  20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777, 26251, 21491, 41323, 20023,
  20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 25196, 31584, 31584, 31584, 39867,
  25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616, 30199, 20023, 30736, 27596,
  31584, 31584, 31584, 26748, 27478, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 26232,
  30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023, 20023, 20023, 20023, 20023,
  26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023, 20023, 21700, 30201, 29067,
  31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583, 33264, 20023, 20023, 30735,
  27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638, 40735, 21641, 35365, 37608,
  35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857, 20023,
  20023, 20023, 20023, 42122, 42208, 42230, 42147, 42131, 42201, 42228, 42257, 42212, 42248, 42273, 42307, 20023, 20023,
  20489, 20023, 20023, 21194, 42332, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19763, 18537, 19419, 42351,
  18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483, 18514,
  18630, 19602, 18487, 18518, 18534, 42367, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599, 29619,
  18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787, 20023,
  18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732, 18984,
  19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633, 19153,
  29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733, 19317,
  19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577, 19698,
  19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 19857,
  20023, 20023, 20023, 20023, 29143, 20023, 20023, 42387, 42232, 19879, 27856, 27861, 42407, 20023, 42435, 21365, 20023,
  20023, 20489, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 42469, 20023, 19274, 29145, 18535, 19413, 18537, 19419,
  19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598, 18483,
  18514, 18503, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583, 18599,
  29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927, 23787,
  20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057, 23732,
  18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371, 42633,
  19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301, 19733,
  19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675, 20577,
  19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  19857, 20023, 20023, 20023, 20023, 29143, 42487, 20023, 20023, 42335, 42505, 20302, 42529, 42535, 20023, 42551, 21365,
  20023, 20023, 20489, 20023, 20023, 21194, 42580, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535, 19413, 18537,
  19419, 19519, 18314, 18333, 35441, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459, 18567, 19598,
  18483, 18514, 42600, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993, 18553, 18583,
  18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933, 18807, 33927,
  23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535, 23558, 34057,
  23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131, 19132, 24371,
  42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296, 29880, 19301,
  19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649, 18536, 19675,
  20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 19857, 20023, 20023, 20023, 20023, 29143, 20023, 20023, 20023, 42232, 19879, 20023, 20023, 20023, 20023, 40694,
  40376, 20023, 20023, 20489, 20023, 20023, 20023, 20023, 21700, 21617, 20023, 20023, 20023, 26230, 22343, 31584, 32777,
  26251, 21491, 41323, 20023, 20023, 20396, 20023, 20023, 20023, 20023, 30734, 21617, 30200, 20023, 20023, 26229, 29194,
  31584, 31584, 31584, 28157, 25583, 25583, 26250, 21572, 34027, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 21616,
  30199, 20023, 30736, 27596, 31584, 31584, 31584, 21742, 25582, 25583, 25583, 25584, 21590, 34027, 20023, 20023, 20023,
  20023, 20023, 20023, 26232, 30200, 21700, 33101, 31584, 31584, 31584, 33348, 25579, 25583, 25583, 25583, 21634, 20023,
  20023, 20023, 20023, 20023, 26231, 32367, 30737, 32284, 31584, 31584, 25434, 25582, 25583, 25583, 28195, 20023, 20023,
  20023, 21700, 30201, 29067, 31584, 31584, 25576, 25583, 25584, 34025, 20023, 20023, 30733, 40151, 25949, 21659, 25583,
  33264, 20023, 20023, 30735, 27261, 31584, 41968, 38548, 20023, 27099, 31584, 26907, 31878, 41611, 41969, 40732, 21638,
  40735, 21641, 35365, 37608, 35370, 29697, 26961, 40576, 37256, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 42628, 20023, 42632, 40707, 40712, 42649, 42584,
  42677, 21194, 20023, 20023, 20023, 20023, 20023, 21194, 20023, 42633, 19280, 20023, 20023, 20023, 19274, 29145, 18535,
  19413, 18537, 19419, 18665, 18314, 18333, 35148, 20023, 20023, 23463, 20023, 19884, 18364, 18380, 18396, 18423, 18459,
  18567, 19598, 18483, 18514, 18630, 19602, 18487, 18518, 18534, 19113, 22229, 20023, 20023, 20023, 35315, 40879, 30993,
  18553, 18583, 18599, 29619, 18615, 18685, 18705, 18535, 18658, 18681, 18701, 18721, 20570, 18740, 19113, 18759, 33933,
  18807, 33927, 23787, 20023, 18844, 18860, 19116, 18467, 18902, 18924, 18946, 18968, 18896, 18918, 18940, 18962, 18535,
  23558, 34057, 23732, 18984, 19005, 29431, 19032, 35869, 19048, 19066, 19772, 19084, 19050, 19068, 19774, 19104, 37131,
  19132, 24371, 42633, 19153, 29867, 19221, 19189, 19209, 19225, 19193, 20584, 38021, 19241, 23703, 19266, 29875, 19296,
  29880, 19301, 19733, 19317, 19369, 19385, 19442, 19435, 19705, 19458, 19493, 19537, 19535, 19553, 19588, 19618, 19649,
  18536, 19675, 20577, 19698, 19721, 19749, 19790, 19399, 19812, 19828, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023, 20023,
  20023, 20023, 20023, 0, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 73986, 73986, 73986, 73986, 0, 0, 78085, 78085, 73986,
  73986, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 0, 78085, 0, 73986, 78085, 73986, 78085,
  316, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085,
  45056, 49152, 78085, 78085, 78085, 78085, 40960, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085, 78085,
  78085, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 73986, 0, 0, 78085, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 633,
  0, 0, 0, 0, 0, 0, 0, 0, 666, 0, 0, 0, 0, 0, 0, 0, 0, 736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 736, 0, 0, 0, 496, 0, 0,
  2469888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290816, 0, 0, 2719744, 0, 0, 0, 0, 0, 0, 2871296, 0, 0, 0, 0, 0, 0,
  0, 0, 737, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 2158592, 2158592, 2158592, 2158592, 2158592, 2621440, 2158592,
  2158592, 2686976, 2158592, 2703360, 2158592, 2158592, 2756608, 2777088, 2797568, 2158592, 2834432, 2158592, 2883584,
  2158592, 2158592, 2158592, 3067904, 2158592, 2158592, 2158592, 0, 0, 0, 0, 2621440, 0, 2686976, 2703360, 0, 0,
  2756608, 2777088, 2797568, 0, 2834432, 2883584, 0, 0, 0, 0, 0, 0, 0, 1307, 0, 0, 0, 0, 0, 1311, 0, 0, 0, 0, 2883584,
  2441216, 0, 0, 0, 0, 2777088, 0, 2883584, 0, 0, 0, 0, 0, 0, 0, 1336, 1337, 0, 0, 0, 0, 0, 0, 0, 0, 2364, 2365, 0, 0,
  0, 0, 0, 0, 0, 2719744, 0, 0, 2883584, 0, 0, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  2158592, 3158016, 2158592, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2711552, 2162688, 2162688, 2756608, 2162688,
  2777088, 2797568, 2162688, 2162688, 2834432, 2162688, 2162688, 2883584, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 0, 0, 0, 853, 0, 0, 856, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 3067904, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 0, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 2428928, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  2580480, 2158592, 2158592, 2613248, 2158592, 2658304, 2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2162688,
  2441216, 2449408, 2162688, 2158592, 2158592, 2785280, 2809856, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  2158592, 2158592, 2428928, 0, 0, 2580480, 0, 0, 0, 0, 2809856, 0, 0, 0, 0, 2809856, 0, 0, 0, 0, 0, 2809856, 2158592,
  2158592, 2158592, 2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 2162688, 2162688, 2428928, 2162688, 0, 0, 0, 0, 0, 0,
  0, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 2, 6, 0, 0, 0, 0, 0, 0, 265, 2441216,
  2449408, 2162688, 2162688, 3080192, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2441216, 2449408, 0, 2162688, 2428928, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2580480, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2613248, 2162688, 2162688, 2162688, 2658304, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2785280, 2809856, 2162688, 2162688, 2785280, 2809856, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 912, 0, 2801664, 2162688, 2801664,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 245760, 0, 0, 2473984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2596864, 0, 0, 2760704, 0, 0, 0, 0, 324, 0, 325, 0, 0, 0,
  0, 0, 0, 283, 325, 286, 324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1012, 0, 3141632, 0, 0, 3158016, 0, 0, 0, 0, 0,
  0, 0, 0, 2875392, 0, 2768896, 0, 0, 0, 0, 351, 0, 0, 0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2158592, 2473984, 2478080, 2158592, 2158592, 2158592, 2158592, 2596864, 2158592, 2158592, 2158592, 2707456, 2158592,
  2158592, 2875392, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2478080, 0, 0, 2707456, 0,
  0, 0, 0, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 316, 0, 625, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2473984,
  2478080, 2162688, 2162688, 2162688, 2519040, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2596864,
  2162688, 2162688, 2162688, 2162688, 2162688, 2596864, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2707456,
  2162688, 2162688, 2162688, 2162688, 2162688, 2760704, 2162688, 2162688, 2162688, 2854912, 2162688, 2760704, 2162688,
  2162688, 2162688, 2854912, 2875392, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2994176, 3018752, 2162688, 2162688, 2162688, 3051520, 2994176, 3018752, 2162688, 2162688, 2162688, 3051520, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3158016, 2162688, 0, 0, 0, 0, 0, 2121728, 0, 0, 0, 0,
  3043328, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200704, 267, 268, 0, 2527232, 2695168, 0, 3145728, 0, 0, 0, 0, 0, 0,
  2572288, 0, 0, 0, 0, 0, 0, 0, 1428, 0, 0, 0, 0, 0, 0, 651264, 0, 2887680, 2158592, 2158592, 2158592, 3026944, 3076096,
  3096576, 3145728, 0, 0, 0, 0, 0, 0, 3076096, 3096576, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2490368, 2162688,
  2162688, 2527232, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2600960, 2162688, 2600960, 2625536, 2162688,
  2162688, 2162688, 2695168, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2887680, 2162688,
  2162688, 2162688, 2162688, 3145728, 2162688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 3145728, 2162688,
  2437120, 2437120, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 3158016, 2158592, 0, 0, 3153920, 0, 2813952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2113536, 0, 0, 0,
  2158592, 2158592, 2158592, 2158592, 2633728, 2158592, 2158592, 2961408, 2158592, 3022848, 0, 0, 2633728, 0, 0, 0, 0,
  0, 0, 1661, 0, 0, 0, 0, 0, 0, 0, 0, 0, 293, 294, 0, 0, 0, 0, 0, 2813952, 2818048, 2162688, 2162688, 2908160, 2162688,
  2162688, 2953216, 2162688, 2961408, 2162688, 2162688, 3022848, 3047424, 2162688, 2162688, 2162688, 2162688, 3174400,
  2162688, 2162688, 2162688, 3174400, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2547712, 2162688, 2162688, 2162688, 2162688, 2633728, 2162688, 2162688, 2715648, 2736128, 2162688, 2162688,
  2752512, 2813952, 2818048, 2162688, 2162688, 0, 0, 2891776, 0, 0, 0, 3014656, 0, 2539520, 0, 0, 0, 0, 0, 0, 0, 0, 749,
  0, 632, 772, 0, 0, 0, 496, 2543616, 2158592, 2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2158592, 2158592,
  2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592,
  2158592, 2162688, 2162688, 2162688, 2162688, 2891776, 2162688, 2162688, 2957312, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2457600, 2691072, 0, 0, 0, 0, 2936832, 0, 0,
  3084288, 0, 2940928, 3129344, 2416640, 0, 0, 0, 0, 0, 0, 1867, 0, 1869, 0, 0, 1871, 0, 1873, 0, 0, 0, 0, 0, 0, 0, 400,
  1942, 400, 400, 400, 400, 400, 0, 409600, 0, 0, 0, 0, 0, 0, 0, 410000, 400, 0, 0, 0, 0, 2723840, 0, 0, 0, 0, 0, 0,
  2158592, 2482176, 2158592, 2158592, 2740224, 2158592, 2158592, 2482176, 2740224, 0, 0, 0, 0, 0, 2158592, 2158592,
  2158592, 0, 2420736, 2162688, 2162688, 2162688, 0, 0, 0, 0, 2424832, 2162688, 2162688, 2162688, 2162688, 2981888,
  2424832, 2162688, 2162688, 2162688, 0, 0, 2162688, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3121152, 2420736,
  2162688, 2162688, 2482176, 2162688, 2162688, 2162688, 2584576, 2162688, 2162688, 2682880, 2740224, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2494464, 0, 0, 0, 2826240, 0, 2973696, 0, 0, 0, 3100672, 0, 0, 0, 0, 0,
  0, 0, 1612, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1376, 0, 0, 0, 0, 0, 0, 0, 0, 2916352, 0, 2445312, 0, 2445312, 2494464,
  2158592, 2744320, 2973696, 2744320, 0, 2158592, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 245760, 2162688, 2162688, 2162688, 2162688, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408,
  3100672, 2162688, 2445312, 2453504, 2494464, 2162688, 2162688, 2162688, 2162688, 2650112, 2744320, 2826240, 2928640,
  2162688, 2973696, 2162688, 2162688, 2162688, 2162688, 2162688, 3100672, 2162688, 2162688, 0, 0, 0, 0, 0, 2846720, 0,
  0, 0, 0, 0, 0, 0, 1634, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1636, 0, 0, 0, 0, 0, 0, 0, 2805760, 0, 3178496, 2560000, 2560000,
  0, 2162688, 2551808, 2560000, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2621440,
  2162688, 2162688, 2162688, 2162688, 2686976, 2162688, 2703360, 2162688, 2711552, 2162688, 2162688, 2162688, 2162688,
  3092480, 2162688, 2551808, 2560000, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3092480,
  0, 0, 0, 0, 496, 2498, 496, 496, 496, 496, 496, 496, 496, 496, 520, 2507, 0, 0, 0, 0, 2850816, 0, 0, 0, 0, 0, 0,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 241664, 2162688, 2162688,
  2162688, 2162688, 2502656, 0, 0, 0, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 237568, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 0, 2162688, 2162688, 2588672, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3121152, 2162688, 2162688, 2162688,
  2162688, 0, 2588672, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2465792, 0, 2531328, 2985984, 0,
  0, 0, 0, 0, 0, 0, 2895872, 0, 0, 3108864, 0, 2682880, 0, 2641920, 2609152, 2162688, 2162688, 2605056, 2162688,
  2830336, 2162688, 2162688, 2162688, 2985984, 2162688, 2162688, 2605056, 2162688, 2830336, 2162688, 2162688, 2162688,
  0, 0, 2163541, 0, 2162688, 2163544, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  3026944, 2162688, 2162688, 3076096, 2162688, 3096576, 2162688, 2162688, 2162688, 2162688, 2985984, 2523136, 0, 0, 0,
  0, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 912, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2981888, 2535424, 0, 0, 2912256, 2162688, 2654208, 2932736, 2162688, 2162688,
  2654208, 2932736, 2162688, 2637824, 2699264, 2555904, 2162688, 2555904, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2945024, 2945024, 0, 0, 0, 0, 0, 0, 1894, 0, 0, 0, 0, 0, 0, 0, 0, 1902, 0, 2, 3, 94212, 5, 6, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 2179694, 2179694, 2179694, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2158592, 2441216, 2158592, 2158592, 111009, 111009, 111009, 111009, 111009, 111009, 417, 417, 111009, 111009, 111009,
  111009, 111009, 417, 111009, 111009, 111009, 417, 111009, 417, 417, 417, 417, 417, 0, 417, 0, 0, 0, 0, 0, 0, 263, 264,
  265, 0, 0, 0, 0, 0, 0, 0, 0, 1322, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 1082, 0, 0, 111009,
  111009, 111009, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 1906, 0, 0, 1909, 0, 0, 0, 0, 0, 0, 0, 365, 307, 0, 0,
  0, 0, 0, 45056, 49152, 118784, 0, 0, 264, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295, 296, 297, 298, 0, 0, 316, 264,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0,
  264, 264, 0, 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 264, 119153, 49152, 264, 264, 0, 0, 264, 0, 0, 2, 2, 3, 94212, 5, 6, 0,
  0, 0, 0, 0, 0, 2047, 0, 0, 0, 0, 0, 0, 0, 0, 0, 309, 310, 0, 0, 0, 0, 0, 32768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 299, 2162688, 2162688, 2162688, 2162688, 0, 2, 6, 0, 0, 0, 264, 0, 0, 0, 2441216, 2449408, 0, 2, 2183418, 94212,
  5, 6, 254, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 2057, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 0, 0, 0, 0, 0, 0, 316, 0,
  122880, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 122880, 0, 122880, 0, 122880, 122880, 122880,
  122880, 122880, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0, 0, 576, 0, 0, 122880, 0, 0, 122880, 0, 0, 0, 0, 122880,
  122880, 122880, 122880, 122880, 0, 122880, 122880, 122880, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 311, 312, 313,
  314, 315, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 281, 282, 0, 0, 0, 122880, 122880, 0, 0, 0, 2, 2,
  2183418, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2073, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1102198, 1102198, 1102198, 1102198,
  1102198, 1102198, 147456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 311, 0, 672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 2163484, 2162688, 2162688, 3080192, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 0, 1516, 0, 0, 1521, 0, 316, 0, 0, 0, 131072, 131072, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1323, 0, 0, 0, 0, 0,
  0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 0, 0, 0, 0, 131072, 0, 0, 131072, 0, 131072, 131072,
  131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2189, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 682, 0, 496, 0, 316, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 135168,
  0, 0, 45056, 49152, 0, 135168, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 135168, 135168, 0,
  0, 135168, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2214, 0, 0, 0, 0, 0, 2219, 400, 400, 400, 0, 0, 0, 1129, 0,
  0, 0, 0, 1133, 496, 496, 496, 496, 496, 815, 496, 496, 496, 496, 830, 832, 496, 496, 842, 496, 2162688, 0, 0, 0, 1197,
  0, 0, 1200, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 3080192, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 0, 0, 0,
  2514944, 0, 0, 2543616, 2592768, 0, 0, 139264, 0, 0, 265, 139264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 316, 624,
  0, 0, 316, 265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 328, 265, 265, 0, 0, 0, 0, 0, 0, 0, 265, 0, 0, 0, 265,
  45056, 139637, 265, 265, 0, 0, 265, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  290816, 290816, 290816, 290816, 290816, 290816, 0, 0, 0, 0, 36864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 204800,
  0, 0, 0, 0, 262, 262, 0, 0, 262, 262, 143622, 262, 262, 262, 262, 262, 262, 262, 143622, 262, 143622, 262, 262, 262,
  262, 262, 262, 262, 262, 262, 317, 262, 143622, 262, 262, 262, 262, 262, 143622, 321, 262, 262, 262, 262, 262, 40960,
  262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 143681, 262, 262, 262, 262, 262,
  262, 262, 143681, 262, 143622, 262, 143681, 45056, 49152, 262, 143622, 262, 143622, 143622, 143622, 262, 262, 143622,
  143622, 143622, 143622, 143622, 143622, 143622, 143622, 262, 262, 262, 262, 262, 262, 143622, 143622, 143622, 262,
  143622, 262, 262, 262, 262, 262, 0, 262, 0, 0, 262, 0, 0, 0, 0, 520, 520, 520, 520, 520, 520, 520, 1800, 520, 520,
  520, 520, 520, 1255, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 262, 262, 262, 143622, 262, 143622, 143622,
  143622, 143622, 143622, 143622, 143681, 143681, 143681, 143681, 143681, 143622, 143622, 143622, 0, 0, 2, 2, 3, 94212,
  5, 6, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 155648, 155648,
  0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 2445, 0, 0, 0, 0, 155648, 0, 0, 155648, 0, 0, 0,
  0, 0, 155648, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648,
  155648, 155648, 155648, 155648, 155648, 155648, 155648, 0, 155648, 0, 0, 0, 0, 0, 0, 155648, 155648, 155648, 0, 0, 2,
  2, 0, 94212, 5, 6, 126976, 0, 0, 0, 0, 0, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603,
  221603, 221603, 221603, 221603, 221603, 221603, 221603, 0, 0, 159744, 0, 159744, 159744, 159744, 159744, 159744,
  159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744,
  159744, 159744, 159744, 159744, 159744, 159744, 159744, 0, 159744, 0, 0, 0, 0, 0, 0, 274, 275, 276, 277, 278, 279,
  280, 0, 0, 0, 90631, 0, 0, 0, 159744, 0, 0, 0, 0, 90631, 90631, 90631, 90631, 90631, 90631, 90631, 159744, 159744,
  90631, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 565248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 0, 0, 0,
  2162688, 0, 0, 0, 853, 0, 90112, 856, 2162688, 2441216, 2449408, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 2, 0,
  176128, 294912, 0, 0, 0, 0, 0, 2441216, 2449408, 90112, 2162688, 2428928, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2580480, 163840, 163840, 163840, 163840, 163840,
  163840, 163840, 163840, 163840, 163840, 0, 163840, 0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 163840,
  163840, 163840, 163840, 163840, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2105344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1676, 0, 1678, 0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 0, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 0, 167936, 0, 0, 0, 0, 0, 0, 332, 355, 0, 0, 0, 0, 0, 0, 45056, 49152, 167936, 167936,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 327, 0, 167936, 0, 0, 0, 40960, 167936, 167936, 0, 0, 167936, 0, 167936, 0,
  167936, 0, 0, 0, 0, 0, 250276, 250276, 250276, 250276, 250276, 249856, 249856, 249856, 249856, 250276, 250276, 250276,
  249856, 250276, 249856, 249856, 249856, 249856, 249856, 0, 249856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 590,
  0, 0, 0, 0, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 0, 0, 167936, 167936, 167936, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2105344, 264, 265,
  0, 0, 0, 0, 0, 0, 0, 0, 1006, 0, 1008, 0, 0, 0, 0, 0, 0, 2, 3, 251, 5, 6, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1366, 0,
  0, 0, 1368, 0, 0, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 0, 172032, 0, 0, 0,
  0, 0, 0, 337, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 172032, 172032, 172032, 172032, 172032, 53494, 53494, 2, 2, 3, 0, 5,
  6, 0, 568, 0, 0, 0, 0, 520, 520, 520, 520, 520, 1798, 520, 520, 520, 520, 520, 520, 520, 1545, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 410096, 496, 496, 410120, 520, 520, 0, 0, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496,
  0, 520, 520, 520, 520, 520, 520, 520, 520, 1998, 520, 520, 520, 520, 520, 520, 520, 2010, 520, 520, 520, 520, 520,
  520, 520, 520, 905, 520, 520, 520, 496, 496, 0, 0, 956, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 357, 0, 0, 1000,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 320, 0, 0, 0, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520,
  520, 520, 520, 520, 496, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520,
  2345, 520, 520, 520, 0, 1683, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  731, 496, 520, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 496,
  1960, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 0, 0, 2210, 0, 0, 0, 0, 2215, 0,
  0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496, 496, 2119, 496, 2288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  400, 0, 0, 0, 2303, 2304, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 1123, 496, 496, 496, 496, 2326,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 0, 91311, 0, 496, 496, 496, 496, 2338, 520, 520, 520,
  520, 520, 520, 2344, 520, 520, 520, 520, 246, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2203, 0, 0, 0, 0, 0, 496, 496, 496,
  520, 2423, 520, 520, 520, 520, 520, 520, 2429, 520, 520, 520, 0, 0, 0, 0, 496, 496, 2553, 2554, 496, 496, 520, 520,
  2557, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 180769, 180769, 0, 0, 180769, 53494, 53494, 2, 2, 3,
  94212, 5, 6, 0, 0, 0, 0, 0, 0, 2105344, 264, 265, 196608, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0, 575, 0, 0, 0,
  184320, 520, 520, 496, 496, 496, 496, 496, 496, 496, 496, 0, 520, 520, 520, 520, 520, 520, 1997, 520, 520, 520, 520,
  2001, 520, 2003, 520, 188834, 188834, 188834, 188834, 188834, 188834, 0, 0, 188834, 188834, 188834, 188834, 188834, 0,
  188834, 188834, 188834, 0, 188834, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2179695,
  151552, 2179695, 0, 0, 188834, 188834, 188834, 188834, 0, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2105344, 264,
  21054, 0, 0, 0, 0, 0, 0, 0, 0, 1093, 0, 0, 0, 0, 1097, 1098, 0, 0, 192512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  355, 0, 0, 0, 263, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 263, 0, 263, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 496, 2442, 496, 496, 496, 359, 359, 0, 0, 359, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2105344, 572,
  573, 0, 0, 0, 0, 0, 0, 0, 0, 1054, 1055, 0, 0, 400, 400, 400, 400, 663, 520, 520, 496, 496, 496, 496, 496, 496, 496,
  496, 0, 520, 520, 520, 520, 246, 2, 6, 0, 0, 0, 0, 935, 939, 0, 0, 0, 1788, 0, 0, 0, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 2004, 1601, 0, 1603, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 344, 0, 0, 496,
  496, 496, 1988, 0, 1990, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1999, 520, 520, 520, 520, 520, 0, 318, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 370, 0, 0, 268, 268, 268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 668, 590, 0, 0, 0,
  0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 268, 0, 0, 0, 0, 0, 0, 601, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2613248, 0, 0, 0, 0, 0,
  200704, 200704, 200971, 200704, 200971, 200704, 200972, 200704, 200704, 200971, 200704, 200704, 200704, 200972,
  200704, 200704, 200704, 200704, 200704, 200704, 200704, 200704, 200704, 200704, 0, 200704, 0, 0, 0, 0, 0, 0, 663,
  1021, 0, 0, 0, 0, 0, 0, 0, 1028, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 652, 0, 0, 0, 0, 0, 0, 200704, 200971, 200704,
  0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2105344, 21051, 265, 0, 0, 0, 0, 0, 0, 0, 0, 1038, 0, 0, 0, 1042, 0, 0,
  0, 151552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 2163543, 2163543, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 0, 2163543, 2163543, 2163543, 2163543, 2491223, 2163543, 2163543, 2528087,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2601815, 2163484, 2712348, 2163484, 2163484, 2757404, 2163484,
  2777884, 2798364, 2163484, 2163484, 2835228, 2163484, 2163484, 2884380, 2163484, 2163484, 2163484, 2163484, 2892572,
  2163484, 2163484, 2958108, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 2163543,
  3068759, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163484, 2163484, 0, 0, 0, 853, 0, 0,
  856, 2163543, 2442071, 2450263, 2163543, 2163543, 2163543, 2163543, 2163543, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 2441216,
  2449408, 2757463, 2163543, 2777943, 2798423, 2163543, 2163543, 2835287, 2163543, 2163543, 2884439, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 3081047, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163484, 0, 2163543, 2163543, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543,
  2163543, 2163543, 2163543, 2163543, 2597719, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2708311, 2163543,
  2163543, 2163543, 2163543, 2614103, 2163543, 2163543, 2163543, 2659159, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163543, 3027799, 2163543, 2163543, 3076951, 2163543, 3097431, 2163543, 2163543, 2163543, 2158592, 2158592,
  2158592, 2158592, 2158592, 2158592, 0, 0, 0, 0, 0, 0, 2162688, 2163484, 2429724, 2163484, 2163484, 2605852, 2163484,
  2831132, 2163484, 2163484, 2163484, 2986780, 2163543, 2163543, 2605911, 2163543, 2831191, 2163543, 2163543, 2982743,
  2535424, 0, 0, 2912256, 2163484, 2655004, 2933532, 2163484, 2163543, 2655063, 2933591, 2163543, 2637824, 2614044,
  2163484, 2163484, 2163484, 2659100, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2786076,
  2810652, 2163484, 2163484, 3080988, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 0, 0, 0,
  0, 0, 0, 0, 1855, 0, 0, 0, 0, 0, 0, 0, 0, 587, 588, 0, 0, 0, 0, 0, 0, 0, 2163543, 2429783, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2581335, 2163543, 2786135, 2810711,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2163484, 2163484, 0, 0, 2802460, 2163543, 2802519, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163543, 2163543, 2163543, 2163543, 2163543, 2622295, 2163543, 2163543, 2163543, 2163543, 2687831, 2163543,
  2704215, 2163543, 2712407, 2163543, 2163543, 2163484, 2474780, 2478876, 2163484, 2163484, 2163484, 2519836, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2597660, 2163484, 2163484, 3093276, 2163543, 2552663, 2560855,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 3093335, 0, 0, 0, 0, 520, 520, 520, 520, 1797,
  520, 1799, 520, 520, 520, 1802, 520, 520, 520, 1221, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 798,
  496, 0, 0, 2876188, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2994972, 3019548,
  2163484, 2163484, 2163484, 3052316, 0, 0, 0, 0, 2163543, 2163543, 2163543, 2474839, 2478935, 2163543, 2163543,
  2163543, 2519895, 2163543, 2163543, 2163543, 0, 0, 0, 0, 2425628, 2163484, 2163484, 2163484, 2163484, 2982684,
  2425687, 2163543, 2163543, 2995031, 3019607, 2163543, 2163543, 2163543, 3052375, 2163543, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2163543, 3158871, 2163543, 2163543, 3101527, 2163484, 2163543, 0, 0, 0, 0, 0, 2846720, 0,
  0, 0, 0, 0, 0, 0, 1882, 0, 0, 0, 0, 0, 1887, 0, 0, 2163484, 2163543, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 0, 0, 0,
  0, 0, 0, 0, 2163484, 2163484, 2163484, 2163484, 2491164, 2163484, 2163484, 2528028, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163484, 3158812, 2163484, 0, 0, 0, 0, 0, 2121728, 2163484, 2601756, 2626332,
  2163484, 2163484, 2163484, 2695964, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2888476,
  2626391, 2163543, 2163543, 2163543, 2696023, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543,
  2888535, 2163543, 2163543, 2163543, 2499415, 2540375, 2544471, 2163543, 2163543, 2593623, 2163543, 2163543, 2163543,
  2163543, 2163543, 2163543, 2892631, 3146583, 2163543, 2437916, 2437975, 2163484, 2163484, 2163484, 2163484, 2163543,
  2163543, 2163543, 2163543, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 2222, 2814748, 2818844, 2163484, 2163484,
  2908956, 2163484, 2163484, 2954012, 2163484, 2962204, 2163484, 2163484, 3023644, 3048220, 2163484, 2163484, 2163484,
  2548508, 2163484, 2163484, 2163484, 2163484, 2634524, 2163484, 2163484, 2716444, 2736924, 2163484, 2163484, 2753308,
  2909015, 2163543, 2163543, 2954071, 2163543, 2962263, 2163543, 2163543, 3023703, 3048279, 2163543, 2163543, 2163543,
  2163543, 3175255, 2163484, 2163484, 3146524, 2163484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 591, 0, 0, 0, 496, 2158592,
  2158592, 2482176, 2740224, 0, 0, 0, 0, 0, 2158592, 2158592, 2158592, 0, 2421532, 2163484, 2163484, 2163484, 3121948,
  2421591, 2163543, 2163543, 2483031, 2163543, 2163543, 2163543, 2585431, 2163543, 2163543, 2683735, 2741079, 2482972,
  2163484, 2163484, 2163484, 2585372, 2163484, 2163484, 2683676, 2741020, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2622236, 2163484, 2163484, 2163484, 2163484, 2687772, 2163484, 2704156, 0, 0, 2916352, 0,
  2445312, 0, 2445312, 2494464, 2158592, 2744320, 2973696, 2744320, 0, 2158592, 0, 2163484, 2163484, 3175196, 0, 0, 0,
  0, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2548567, 2446108, 2454300, 2495260,
  2163484, 2163484, 2163484, 2163484, 2650908, 2745116, 2827036, 2929436, 2163484, 2974492, 2163484, 2163484, 2163484,
  0, 0, 2163484, 854, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 3122007,
  2163484, 2163484, 2163543, 2163543, 0, 3101468, 2163543, 2446167, 2454359, 2495319, 2163543, 2163543, 2163543,
  2163543, 2650967, 2745175, 2827095, 2929495, 2163543, 2974551, 2163543, 2761559, 2163543, 2163543, 2163543, 2855767,
  2876247, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2634583, 2163543, 2163543,
  2716503, 2736983, 2163543, 2163543, 2753367, 2814807, 2818903, 2163543, 2163543, 0, 2805760, 0, 3178496, 2560000,
  2560000, 0, 2163484, 2552604, 2560796, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484,
  3068700, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 3027740, 2163484, 2163484,
  3076892, 2163484, 3097372, 2163484, 0, 0, 0, 0, 2850816, 0, 0, 0, 0, 0, 0, 2163484, 2163484, 2163484, 2163484,
  2163484, 2708252, 2163484, 2163484, 2163484, 2163484, 2163484, 2761500, 2163484, 2163484, 2163484, 2855708, 2502656,
  0, 0, 0, 0, 0, 0, 0, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2581276, 2163484, 2163484, 2163484, 2163484, 0, 0, 0, 0,
  2163484, 2163484, 2589468, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2958167,
  2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 2457600,
  2589527, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2163543, 2465792, 0, 2531328, 2985984, 0, 0, 0, 0, 0,
  0, 664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2061, 0, 0, 0, 0, 0, 2163543, 2986839, 2523136, 0, 0, 0, 0, 2163484, 2163484,
  2163484, 2163484, 2163484, 2163484, 2163543, 2163543, 2163543, 0, 0, 0, 0, 2514944, 0, 0, 2543616, 2592768, 0, 0,
  2699264, 2556700, 2163484, 2556759, 2163543, 2163484, 2163543, 2163484, 2163543, 2163484, 2163543, 2945820, 2945879,
  0, 0, 0, 0, 0, 0, 2106007, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1898, 0, 0, 0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  217088, 0, 0, 217088, 217088, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2049, 0, 0, 0, 2051, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0,
  0, 0, 217088, 0, 0, 0, 0, 0, 0, 2109440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1858, 0, 0, 0, 0, 0, 217088, 217088, 217088,
  217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 217088, 0, 217088, 0,
  0, 0, 0, 0, 0, 217088, 217088, 217088, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 2109440, 1020, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 57344, 0, 0, 0, 28672, 0, 0, 2658304, 0, 2785280, 0, 0, 0, 0, 0, 0, 2486272,
  0, 0, 0, 0, 0, 0, 0, 0, 2600960, 2162688, 2162688, 2162688, 264, 0, 0, 0, 264, 0, 265, 0, 0, 0, 265, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 400, 400, 400, 1061, 264, 0, 265, 0, 0, 0, 2486272, 0, 0, 0, 0, 0, 0, 0, 0, 2600960, 2162688,
  2162688, 3145728, 2162688, 0, 853, 0, 0, 0, 853, 0, 856, 0, 0, 0, 856, 2162688, 2162688, 3174400, 853, 0, 856, 0,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2547712, 0, 0, 0, 0, 221567, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 680, 0, 0, 0, 0, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 221603, 0,
  221603, 0, 0, 0, 0, 0, 0, 664, 0, 0, 667, 0, 0, 0, 0, 0, 0, 0, 602, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2920448, 0, 0, 0,
  2158592, 2158592, 2158592, 221727, 221727, 221603, 221603, 221740, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0,
  2646016, 0, 2781184, 0, 0, 0, 0, 0, 0, 3125248, 0, 0, 237568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 2221, 400,
  0, 2, 3, 94212, 5, 6, 0, 0, 249856, 0, 0, 0, 0, 249856, 0, 0, 0, 0, 0, 258048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  3088384, 0, 0, 0, 0, 250276, 250276, 250276, 250276, 250276, 250276, 249856, 249856, 250276, 250276, 250276, 250276,
  250276, 249856, 250276, 250276, 0, 0, 250276, 250276, 250276, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 305, 306,
  307, 308, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 114688, 0, 241664, 0, 262144, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 793, 0, 0, 0, 496, 0, 2, 3, 94212, 5, 6, 0, 0, 0, 258048, 0, 0, 0, 0, 258048, 0, 0, 0, 0, 520, 520, 1796, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 2158, 520, 520, 520, 520, 520, 258469, 258469, 258469, 258469, 258469,
  258469, 258469, 258469, 258469, 258469, 0, 258469, 0, 0, 0, 258048, 0, 0, 258469, 258469, 258469, 0, 0, 2, 2, 3,
  94212, 0, 6, 0, 0, 274432, 0, 0, 0, 253952, 266240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 945, 0, 0, 0, 0, 0, 2, 3, 94212,
  2195708, 6, 0, 0, 0, 0, 256, 0, 0, 0, 0, 256, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270336, 0, 0, 0, 0, 0, 311, 0, 0,
  312, 0, 311, 0, 0, 0, 45056, 49152, 270336, 270336, 0, 0, 270336, 0, 0, 2, 2, 3, 94212, 2195708, 6, 0, 0, 0, 0, 0,
  334, 0, 0, 0, 338, 339, 341, 294, 0, 0, 0, 0, 0, 357, 0, 0, 0, 0, 357, 0, 0, 0, 45056, 49152, 278528, 278528, 0, 0,
  278528, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 616, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 53494, 2, 3, 94212, 5, 6,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3088384, 0, 57344, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400,
  1061, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 1904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 980, 0, 316, 316, 0, 1380, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 591, 0, 0, 0, 1669, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 607, 0, 0, 0, 0, 0,
  0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 390, 0, 400, 400, 400, 1400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  0, 0, 1707, 0, 0, 1046, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1946, 400, 521, 518, 518, 518, 518,
  518, 518, 518, 518, 521, 521, 521, 521, 521, 521, 521, 518, 518, 521, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0,
  0, 663, 359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 53495, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 268, 0, 0, 0, 0, 0, 286720, 286720, 286720, 286720, 286720, 286720, 0, 0, 286720, 286720, 286720, 286720, 286720,
  0, 286720, 286720, 286720, 0, 286720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 993, 0, 0, 0, 0, 286720, 286720, 286720,
  286720, 286720, 0, 0, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 732, 0, 0, 0, 0, 741, 0, 0, 0, 0, 0, 0, 0, 2715648, 0, 0,
  3039232, 0, 0, 0, 3022848, 0, 303104, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2162688, 2162688, 2162688, 2162688, 2162688, 2162688, 0, 913, 2691072, 0, 0, 0, 0, 2936832, 0, 0, 3084288, 0, 2940928,
  3129344, 2416640, 229376, 0, 0, 0, 0, 0, 270336, 270336, 0, 0, 0, 0, 0, 0, 270336, 0, 0, 0, 0, 0, 258469, 258469,
  258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 258469, 0,
  248, 3, 94212, 5, 253, 0, 0, 0, 0, 0, 257, 0, 0, 0, 0, 0, 0, 702, 400, 400, 718, 400, 400, 400, 400, 400, 400, 0, 0,
  0, 1453, 0, 0, 1133, 496, 496, 496, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593, 0, 0, 316, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 290816, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1009, 0, 0, 0, 0, 290816, 290816,
  290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 290816, 0,
  290816, 0, 0, 0, 0, 0, 0, 290816, 290816, 290816, 0, 0, 248, 248, 3, 94212, 5, 4297271, 0, 0, 0, 0, 0, 733, 0, 0, 733,
  0, 0, 0, 0, 757, 0, 0, 569, 0, 0, 0, 0, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 1674, 0, 0, 0, 0, 0, 0, 1681,
  2162688, 2162688, 2162688, 2162688, 0, 248, 4297271, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408, 0, 249, 3, 94212, 5, 6, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 274, 0, 0, 0, 0, 0, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 624, 0, 544, 544,
  0, 0, 544, 0, 0, 4264502, 249, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 764, 627, 0, 0, 0, 768, 0, 0, 0, 627, 0, 0, 0, 0, 0, 0,
  634, 0, 0, 0, 0, 0, 0, 0, 337, 292, 0, 0, 0, 0, 0, 0, 0, 0, 2469, 496, 496, 496, 496, 496, 496, 496, 1184, 496, 496,
  496, 496, 496, 496, 496, 496, 1478, 496, 496, 496, 496, 496, 496, 496, 496, 1495, 496, 496, 496, 496, 496, 496, 496,
  496, 1754, 496, 496, 496, 496, 496, 496, 496, 0, 0, 570, 0, 0, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0, 0, 1856, 0,
  0, 0, 0, 0, 0, 0, 0, 1896, 0, 0, 1899, 0, 0, 0, 0, 2162688, 2162688, 2162688, 2162688, 0, 932, 6, 0, 0, 299008, 0, 0,
  0, 0, 2441216, 2449408, 0, 269, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 592, 0, 594, 0, 316, 0, 0, 0, 0, 0, 0, 0,
  270, 0, 0, 0, 0, 0, 0, 0, 270, 269, 0, 269, 269, 270, 270, 0, 0, 0, 0, 0, 269, 0, 270, 0, 269, 269, 270, 0, 0, 0, 0,
  0, 0, 0, 291, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1870, 0, 0, 0, 0, 1874, 0, 0, 0, 0, 361, 363, 270, 0, 0, 0, 0, 270, 0, 368,
  0, 45056, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 269, 0, 398, 401, 401, 401, 401, 401, 422, 422, 422, 422, 422,
  445, 445, 445, 445, 445, 445, 460, 464, 445, 445, 445, 445, 445, 460, 471, 445, 445, 445, 445, 464, 445, 464, 464,
  464, 464, 464, 497, 516, 497, 497, 497, 497, 522, 497, 497, 497, 497, 541, 541, 541, 541, 546, 546, 546, 546, 546,
  546, 546, 548, 548, 557, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 945, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 668, 0,
  0, 0, 0, 668, 0, 580, 581, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 682, 0, 0, 0, 0, 659, 0, 0, 0, 0, 665, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1388, 0, 1390, 0, 0, 0, 0, 0, 673, 0, 0, 0, 0, 577, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2310, 400, 400, 2312,
  2313, 400, 0, 0, 686, 0, 0, 689, 0, 0, 0, 0, 0, 696, 0, 0, 0, 400, 1397, 1398, 400, 400, 400, 400, 400, 1404, 400,
  400, 1406, 400, 400, 400, 400, 400, 400, 1700, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 1138,
  400, 703, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 726, 400, 400, 400, 400, 400, 400, 1069, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 1417, 400, 400, 0, 0, 0, 0, 0, 0, 0, 774, 0, 0, 400, 400, 703, 400, 400, 781, 726, 400,
  400, 400, 400, 400, 400, 1081, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 496, 0, 627, 0, 0, 0,
  659, 627, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 2471, 496, 496, 496, 496, 496, 496, 800, 496, 496, 496, 496, 496, 496,
  496, 826, 496, 831, 496, 834, 496, 496, 496, 0, 1786, 0, 1792, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1546, 520,
  520, 520, 520, 520, 520, 846, 496, 496, 0, 764, 496, 0, 520, 520, 520, 860, 520, 520, 520, 520, 520, 520, 895, 520,
  520, 520, 520, 520, 496, 496, 0, 0, 0, 520, 915, 496, 496, 800, 496, 920, 834, 496, 496, 0, 520, 520, 860, 520, 520,
  520, 1252, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 1206,
  520, 520, 1215, 520, 928, 894, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 934, 938, 0, 0, 0, 0, 0, 960, 0, 962, 0, 0, 964,
  965, 0, 0, 0, 0, 0, 0, 747, 0, 0, 0, 0, 755, 0, 0, 0, 0, 0, 0, 776, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0,
  1932, 0, 0, 0, 0, 0, 0, 1014, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 656, 400, 400, 400, 1127, 0, 1107, 0, 0,
  1014, 0, 0, 1133, 496, 496, 496, 496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 1062, 520, 1250, 520, 520,
  520, 1253, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 1209,
  520, 520, 496, 496, 520, 53494, 53813, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 646, 0, 0, 649, 0, 0, 0, 0, 0, 0, 0, 0,
  1941, 400, 400, 400, 400, 400, 400, 400, 400, 1931, 0, 0, 0, 0, 0, 0, 0, 0, 2074, 0, 0, 0, 0, 0, 0, 0, 0, 1308, 0, 0,
  0, 0, 0, 1312, 0, 1432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1444, 400, 400, 400, 1448, 400, 400, 0, 0,
  0, 0, 0, 1454, 1133, 496, 496, 496, 0, 0, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 496, 496, 1506, 496, 496, 496, 496, 1510, 496, 496, 496, 496, 1515, 1517, 1520, 91311, 1522, 496, 1586, 520,
  496, 496, 496, 496, 1590, 496, 496, 496, 520, 520, 520, 520, 1597, 0, 0, 0, 1608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  653, 0, 0, 0, 0, 1656, 0, 0, 0, 0, 0, 1662, 0, 0, 0, 0, 0, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 951, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1695, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1705, 1706, 0, 0, 1708, 400, 1723, 400, 400,
  400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2505, 520, 520, 496, 496, 1735,
  496, 1737, 496, 496, 496, 1740, 496, 496, 496, 496, 496, 496, 496, 1153, 496, 496, 496, 496, 496, 496, 496, 496, 1479,
  496, 496, 1483, 496, 496, 496, 496, 496, 520, 496, 496, 1846, 496, 496, 496, 496, 520, 520, 1850, 520, 520, 520, 520,
  520, 520, 2513, 520, 0, 0, 0, 0, 0, 0, 0, 0, 616, 0, 0, 0, 0, 0, 0, 496, 1601, 0, 1603, 0, 0, 1854, 0, 0, 0, 0, 0, 0,
  1860, 0, 0, 0, 0, 0, 1003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 679, 0, 0, 0, 0, 0, 496, 1986, 496, 496, 0, 0, 1988, 0, 0, 0,
  0, 0, 1990, 0, 0, 0, 0, 0, 1019, 664, 0, 0, 0, 0, 0, 0, 970, 0, 0, 973, 974, 0, 0, 0, 977, 0, 0, 0, 0, 316, 316, 0, 0,
  0, 2043, 0, 0, 0, 0, 0, 2048, 0, 0, 0, 0, 0, 0, 0, 0, 2087, 0, 0, 0, 0, 0, 0, 400, 0, 0, 2069, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 699, 0, 400, 0, 0, 2081, 2082, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 1441, 400, 651664, 400, 400, 2107,
  0, 0, 0, 0, 400, 400, 2112, 400, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2386,
  496, 496, 496, 2132, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 835, 496, 496, 2171, 496, 520,
  2174, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1025, 0, 0, 0, 0, 0, 2185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 655,
  0, 0, 2434, 0, 0, 0, 0, 2437, 0, 0, 2440, 0, 496, 496, 496, 496, 496, 496, 1979, 496, 496, 496, 496, 1983, 496, 496,
  496, 496, 0, 0, 2463, 0, 0, 2466, 2467, 0, 496, 496, 496, 496, 496, 496, 496, 496, 1466, 496, 496, 496, 496, 496, 496,
  496, 2493, 0, 0, 2496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 2453, 520, 520, 520, 520, 520, 520,
  520, 0, 0, 0, 0, 271, 272, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 496, 496, 496, 496, 0, 0, 0, 362, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 45056, 49152, 0, 0, 375, 0, 40960, 0, 0, 375, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496,
  2118, 496, 496, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 472, 362, 362, 362, 362, 362,
  362, 362, 362, 362, 362, 496, 362, 496, 496, 496, 496, 0, 0, 0, 0, 1989, 0, 1518, 0, 0, 0, 1991, 0, 0, 1361, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 683, 0, 0, 0, 1378, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 520, 1571, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 0, 0,
  496, 496, 1950, 1951, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1187, 496, 496, 496, 496, 496, 496, 0, 520, 520,
  1994, 1995, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 909, 496, 496, 0, 0, 2477, 496, 520, 520, 520, 520,
  2483, 520, 2485, 520, 2487, 520, 0, 0, 0, 0, 0, 0, 734, 0, 0, 0, 0, 0, 745, 0, 0, 614, 0, 279, 376, 377, 40960, 377,
  384, 376, 377, 384, 274, 384, 0, 384, 402, 402, 402, 402, 402, 423, 423, 423, 438, 441, 446, 446, 459, 446, 446, 446,
  446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 473, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446,
  498, 446, 498, 498, 498, 498, 523, 498, 498, 498, 498, 498, 498, 498, 498, 523, 523, 523, 523, 523, 523, 523, 550,
  550, 559, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1035, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1040, 0, 0, 0, 0, 0,
  0, 520, 520, 496, 496, 496, 496, 496, 835, 496, 496, 0, 520, 520, 520, 520, 520, 1236, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 2356, 496, 2357, 520, 0, 520, 895, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  188834, 188834, 188834, 188834, 188834, 188834, 0, 1047, 0, 0, 0, 0, 0, 0, 0, 0, 1056, 0, 400, 1059, 400, 400, 0, 0,
  0, 0, 0, 0, 0, 400, 400, 400, 0, 496, 496, 2322, 1089, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 955, 0, 0, 0,
  1056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 666, 0, 0, 0, 666, 1089, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 1927, 496, 496, 1144, 496, 1149, 496, 496, 496, 496, 496, 1155, 496, 496, 496, 496, 496, 496,
  2135, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1779, 496, 496, 0, 0, 0, 0, 0, 1520, 1217, 520, 520, 520, 520, 520,
  1223, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1838, 520, 1840, 520, 520, 520, 0, 1381, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1393, 0, 0, 0, 0, 0, 724992, 1350, 0, 0, 0, 0, 0, 0, 0, 1358, 0, 1396, 400, 400, 400, 400, 400, 400, 1403,
  400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 1933, 0, 0, 0, 0, 0, 496, 496, 496, 496, 1492, 1493, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 0, 0, 0, 0, 1787, 1520, 0, 1631, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 747, 748,
  496, 496, 496, 496, 1977, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 1520, 91311, 0, 520, 520, 2021,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 1040, 0, 0, 0, 2070, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 669, 0, 0, 0, 0, 2108, 0, 2110, 0, 400, 400, 400, 2113, 400, 0, 496, 496, 496, 496, 496, 496, 2253,
  496, 496, 496, 496, 496, 496, 496, 520, 520, 496, 2172, 520, 520, 2175, 0, 0, 0, 2179, 0, 0, 0, 0, 0, 0, 2183, 400,
  400, 400, 2225, 400, 0, 0, 0, 2229, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 2117, 496, 496, 2120, 496, 496,
  2250, 2251, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 2340, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 2013, 520, 520, 520, 520, 520, 496, 2336, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1231, 0, 2462, 0, 0, 0, 0, 0, 0, 496, 496, 496, 2472, 496, 496, 496, 496, 0, 0, 0, 1786, 0, 0, 0,
  0, 0, 1792, 0, 0, 496, 496, 520, 520, 520, 2482, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 496, 496, 496, 496, 496,
  496, 520, 520, 520, 520, 2341, 2342, 2343, 520, 520, 520, 520, 520, 0, 0, 0, 282, 350, 0, 0, 282, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1439, 400, 400, 400, 400, 400, 400, 0, 0, 326, 0, 40960, 0, 0, 326, 0, 0, 386, 0, 391, 399, 403, 403, 403, 403,
  403, 424, 424, 424, 424, 442, 447, 447, 447, 447, 447, 447, 447, 465, 447, 447, 447, 447, 447, 447, 403, 447, 447,
  447, 447, 465, 447, 465, 465, 465, 465, 465, 499, 465, 499, 499, 499, 499, 524, 499, 499, 499, 499, 499, 499, 499,
  499, 524, 524, 524, 524, 524, 524, 524, 499, 499, 524, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1051, 0, 0,
  0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 0, 496, 0, 740, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 740, 0, 0, 0, 0, 0,
  0, 520, 520, 496, 496, 496, 817, 496, 496, 496, 496, 0, 520, 520, 520, 877, 0, 984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 968, 0, 1076, 400, 400, 1078, 400, 400, 400, 400, 400, 400, 400, 1085, 0, 0, 0, 0, 0, 0, 946, 947, 948, 0, 0,
  0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 131072, 1100, 0, 965, 0, 0, 0, 0, 0, 0, 1104, 964, 0, 0, 0, 0, 0, 0, 0,
  2190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1627, 0, 0, 0, 0, 1630, 0, 0, 0, 0, 955, 1112, 0, 0, 400, 400, 400, 400, 1119, 400,
  400, 400, 400, 400, 400, 400, 1701, 1702, 400, 400, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 0, 496, 496, 496, 1124, 400,
  400, 0, 0, 0, 0, 0, 0, 0, 0, 1133, 1135, 496, 496, 496, 0, 0, 0, 0, 520, 520, 520, 2146, 520, 520, 520, 520, 520, 520,
  1834, 520, 1836, 520, 520, 520, 520, 520, 520, 520, 1224, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2355, 520, 496,
  496, 520, 520, 0, 0, 1330, 1331, 0, 1333, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1057, 400, 400, 1060, 400, 1360, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 969, 496, 520, 520, 496, 496, 496, 496, 496, 496, 496, 1593, 520, 520, 520, 520,
  520, 520, 899, 520, 520, 520, 520, 520, 496, 496, 0, 0, 520, 520, 1600, 0, 1601, 0, 0, 0, 0, 0, 1603, 0, 0, 0, 0, 0,
  0, 0, 2201, 0, 0, 0, 0, 2205, 0, 0, 0, 1606, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1013, 496, 496, 496, 1736,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1158, 496, 496, 496, 496, 496, 496, 496, 1776, 496, 1778,
  496, 496, 496, 0, 0, 0, 0, 0, 1520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1232,
  0, 0, 1917, 1918, 0, 1920, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 2106, 0, 0, 0, 496, 1949,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 1518, 1520, 91311, 1523, 496, 1974, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 843, 496, 0, 520, 1993, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 1264, 496, 0, 2067, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1099, 400, 400, 400, 2098, 400, 400,
  400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 496, 496, 496, 496, 2124, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 0, 1519, 1520, 91311, 1524, 496, 496, 496, 2133, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1170, 496, 496, 496, 2151, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2160,
  496, 496, 2337, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1228, 520, 520, 520, 284, 285, 286,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 995, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 286, 285, 0, 0, 392, 285, 404, 404, 404,
  404, 404, 425, 435, 425, 425, 425, 448, 448, 448, 448, 448, 448, 461, 466, 448, 448, 448, 448, 448, 461, 404, 448,
  448, 448, 448, 466, 448, 466, 466, 492, 466, 492, 500, 466, 500, 500, 500, 500, 525, 500, 500, 500, 500, 500, 500,
  500, 500, 525, 525, 525, 525, 525, 525, 525, 500, 500, 525, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1113,
  0, 400, 400, 400, 400, 400, 400, 400, 1122, 400, 0, 0, 597, 0, 0, 0, 0, 0, 0, 0, 605, 606, 0, 0, 0, 0, 0, 0, 961, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 311, 0, 0, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 0, 0, 0,
  1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066,
  1094066, 1094066, 1094066, 0, 642, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 654, 0, 0, 0, 0, 0, 1105920, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 340, 0, 0, 0, 345, 340, 400, 400, 705, 400, 400, 713, 400, 719, 400, 722, 400, 725, 400, 400, 400, 400,
  400, 400, 400, 1728, 400, 400, 0, 0, 0, 1731, 496, 496, 0, 0, 0, 746, 0, 0, 0, 0, 0, 630, 0, 0, 0, 0, 759, 0, 0, 765,
  0, 746, 400, 777, 400, 400, 400, 400, 782, 400, 400, 400, 400, 400, 400, 1413, 400, 400, 400, 400, 400, 0, 0, 0, 0,
  2230, 0, 0, 0, 0, 400, 400, 738, 0, 761, 0, 0, 0, 765, 0, 0, 0, 0, 0, 0, 0, 765, 0, 0, 0, 0, 520, 1795, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 907, 520, 496, 496, 0, 0, 746, 765, 0, 0, 746, 761, 765, 0, 0, 791, 0, 0, 0, 791,
  795, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 1205, 520, 520, 520, 520, 520, 520, 2281, 520, 520, 496, 496, 496,
  520, 520, 520, 0, 2177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1313, 0, 0, 0, 0, 0, 0, 496, 496, 803, 496, 496, 814, 496, 823,
  496, 827, 496, 496, 833, 836, 840, 496, 0, 0, 0, 853, 91311, 1133, 856, 1202, 1204, 520, 520, 520, 520, 1212, 520,
  520, 520, 1284, 1601, 0, 0, 0, 0, 1290, 1603, 0, 0, 0, 0, 0, 0, 0, 1647, 0, 1648, 0, 0, 0, 1652, 0, 0, 883, 520, 887,
  520, 520, 893, 896, 900, 520, 520, 520, 520, 496, 496, 0, 0, 0, 853, 0, 0, 856, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 2012, 520, 2014, 520, 2016, 520, 520, 0, 520, 520, 496, 917, 496, 496, 496, 921, 840, 496, 0, 520, 925, 520,
  520, 496, 520, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1296, 0, 1298, 0, 520, 929, 900,
  520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 937984, 0, 0, 0, 0, 0, 0, 0, 0, 958, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 681, 0, 0, 0, 0, 0, 0, 1001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 756, 0, 0, 0, 520, 1218, 520, 520, 520, 1222, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1826, 520, 520, 520, 1830, 520, 1233, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 1241, 520, 520, 520, 520, 520, 1254, 520, 520, 520, 520, 1261, 520, 520, 496, 496, 0, 1314, 1315, 0,
  1317, 1318, 0, 0, 1321, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1614, 0, 0, 0, 0, 0, 0, 0, 1346, 0, 1348, 0, 0, 0, 0, 0, 1353, 0,
  1355, 0, 0, 0, 0, 0, 0, 975, 0, 0, 0, 0, 0, 0, 316, 316, 0, 0, 0, 0, 0, 1364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1369, 0, 0,
  0, 0, 615, 0, 0, 0, 0, 0, 0, 316, 316, 316, 0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 2179694, 2179694, 0, 0, 1372,
  0, 0, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1094, 0, 0, 0, 0, 0, 0, 0, 1383, 1384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1395, 1422, 0, 0, 1425, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1298, 1425, 0, 0, 0, 0, 621, 600, 400, 400, 778, 400, 780, 400,
  400, 728, 400, 787, 0, 0, 0, 1434, 0, 0, 0, 1438, 872448, 0, 1440, 400, 400, 1410, 400, 400, 400, 1412, 400, 400, 400,
  400, 400, 400, 0, 0, 0, 0, 375, 362, 362, 362, 362, 362, 362, 400, 1446, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 1133,
  1455, 496, 1456, 496, 1458, 496, 496, 496, 496, 496, 496, 496, 1467, 496, 496, 496, 496, 1471, 496, 0, 0, 1196, 853,
  91311, 1133, 856, 520, 520, 520, 520, 520, 520, 520, 520, 1259, 520, 520, 520, 520, 496, 496, 0, 496, 496, 1474, 496,
  496, 496, 496, 496, 496, 1480, 1482, 496, 496, 496, 496, 1487, 1488, 496, 1490, 1491, 496, 496, 496, 496, 496, 496,
  1498, 496, 1500, 496, 496, 496, 0, 0, 0, 0, 520, 2144, 520, 520, 2147, 520, 520, 520, 520, 520, 1576, 520, 520, 520,
  520, 1580, 520, 520, 520, 520, 1585, 496, 496, 496, 1507, 496, 496, 496, 496, 496, 496, 1514, 0, 0, 1520, 91311, 0, 0,
  0, 0, 629, 0, 0, 632, 0, 0, 0, 0, 637, 0, 639, 0, 0, 0, 0, 682, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400, 731,
  1520, 1525, 520, 1526, 520, 1528, 520, 520, 520, 520, 520, 520, 520, 1537, 520, 520, 496, 520, 496, 496, 496, 496,
  520, 520, 520, 520, 0, 0, 0, 2041, 520, 520, 1541, 520, 520, 520, 1544, 520, 520, 520, 520, 520, 520, 1550, 1552, 520,
  520, 520, 1557, 1558, 520, 1560, 1561, 520, 520, 520, 520, 520, 520, 1568, 520, 520, 520, 1820, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 1263, 496, 496, 0, 1570, 520, 520, 520, 520, 520, 520, 1577, 520, 520, 520,
  520, 520, 520, 1584, 496, 0, 1085, 0, 853, 91311, 1133, 856, 1203, 520, 520, 520, 520, 520, 520, 520, 520, 1823, 520,
  520, 520, 520, 520, 520, 520, 520, 2011, 520, 520, 520, 520, 520, 520, 520, 520, 2026, 520, 520, 520, 520, 520, 520,
  520, 520, 2354, 520, 520, 496, 496, 520, 520, 0, 496, 520, 520, 1587, 496, 496, 1482, 1491, 496, 1592, 496, 1594, 520,
  520, 1552, 1561, 520, 1599, 520, 0, 1601, 0, 0, 0, 0, 0, 1603, 0, 0, 0, 0, 0, 0, 0, 2363, 0, 0, 0, 0, 0, 0, 0, 0, 603,
  604, 0, 0, 0, 0, 0, 0, 0, 0, 1668, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1680, 0, 0, 0, 0, 688, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 400, 400, 400, 400, 2114, 2115, 2116, 496, 496, 496, 496, 1682, 0, 0, 1685, 400, 400, 400, 400, 400, 400, 1691,
  400, 400, 400, 400, 400, 0, 327, 0, 360, 360, 0, 0, 0, 0, 0, 0, 0, 1103, 1037, 0, 0, 0, 0, 0, 0, 944, 400, 400, 400,
  400, 1726, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496, 2504, 496, 520, 520, 496, 496,
  496, 1762, 1763, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1157, 496, 496, 496, 496, 520, 1805, 520,
  1807, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1243, 520, 520, 520, 496, 520, 496, 496, 496, 496,
  1848, 496, 496, 520, 520, 520, 520, 1852, 520, 520, 496, 520, 496, 496, 496, 2034, 520, 520, 520, 2037, 0, 0, 0, 0, 0,
  0, 1052, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496, 496, 496, 496, 0, 0, 1864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1011, 0, 0, 1889, 1890, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 364544, 0, 0, 0, 0, 751, 752, 0, 0, 754, 0, 0, 0,
  0, 758, 0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2162688, 0, 0,
  1903, 0, 0, 0, 0, 0, 0, 0, 0, 1910, 0, 0, 0, 0, 0, 0, 979, 400, 400, 1117, 400, 400, 400, 1121, 400, 400, 400, 400,
  400, 1930, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 2473, 496, 2475, 496, 1007616, 1007616,
  0, 0, 0, 0, 520192, 1889, 0, 364944, 400, 400, 400, 400, 400, 1008016, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1956, 496, 1958, 496, 496, 496, 1976, 496, 496, 496, 496, 1981, 496, 496, 496, 496, 496, 496, 1985,
  1008112, 496, 496, 496, 827392, 0, 1988, 0, 0, 0, 0, 0, 1990, 0, 0, 0, 0, 0, 1305, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 625,
  0, 0, 0, 0, 0, 520, 2020, 520, 520, 520, 520, 2025, 520, 520, 520, 520, 520, 520, 2029, 1008136, 520, 520, 520, 1832,
  520, 520, 520, 1835, 520, 520, 520, 1839, 520, 520, 520, 520, 520, 2024, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  2030, 0, 0, 2109, 0, 0, 400, 400, 400, 400, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 2243, 496, 496, 496, 496,
  496, 2122, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2131, 496, 0, 335872, 0, 853, 91311, 1133, 856,
  520, 520, 520, 520, 520, 520, 520, 520, 1811, 520, 520, 520, 520, 520, 520, 520, 496, 496, 496, 1988, 0, 1990, 0, 520,
  520, 520, 520, 520, 520, 2149, 520, 520, 496, 520, 496, 496, 2033, 496, 520, 520, 2036, 520, 2038, 2039, 0, 0, 0, 0,
  0, 2158592, 2158592, 2158592, 2527232, 2158592, 2158592, 2600960, 2158592, 2695168, 2158592, 2158592, 2158592, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2163484, 2442012, 2450204, 2163484, 2197, 2198, 0, 2199, 0, 905216, 0, 0, 0, 2202, 0, 2204, 0, 0,
  0, 667648, 400, 400, 2224, 400, 2226, 2227, 0, 2228, 0, 0, 0, 2232, 0, 479232, 400, 400, 0, 0, 0, 0, 0, 0, 0, 400,
  400, 400, 0, 496, 2321, 496, 2235, 400, 0, 496, 496, 496, 2241, 496, 496, 496, 496, 496, 496, 496, 2246, 496, 496,
  496, 496, 496, 1978, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 1785, 0, 0, 1520, 496, 2249, 496, 496,
  496, 496, 496, 496, 2254, 2256, 496, 496, 2259, 2260, 520, 520, 496, 520, 496, 2032, 496, 496, 520, 2035, 520, 520, 0,
  0, 2040, 0, 520, 2264, 520, 520, 520, 520, 520, 520, 520, 2269, 520, 520, 2272, 520, 520, 520, 0, 1284, 0, 0, 0, 1290,
  0, 0, 0, 0, 0, 0, 0, 0, 1387, 0, 0, 0, 0, 0, 1394, 0, 0, 0, 0, 2291, 0, 0, 2293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2158592, 2158592, 2158592, 2158592, 2809856, 2158592, 0, 0, 0, 901120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 696320,
  1015808, 0, 0, 0, 0, 0, 0, 2307, 0, 0, 0, 400, 400, 400, 400, 400, 1402, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  1071, 400, 400, 400, 400, 400, 400, 520, 2348, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0,
  0, 0, 0, 496, 496, 496, 496, 496, 496, 520, 520, 520, 2454, 520, 520, 520, 520, 520, 520, 0, 0, 2371, 0, 0, 0, 0, 400,
  400, 400, 400, 400, 0, 0, 400, 0, 496, 496, 520, 520, 496, 520, 496, 520, 2572, 2573, 496, 520, 0, 0, 0, 0, 0, 1905,
  0, 0, 0, 0, 0, 0, 1911, 1912, 0, 0, 2398, 520, 520, 496, 520, 0, 0, 0, 0, 0, 0, 634880, 2405, 0, 0, 2408, 2409, 0, 0,
  0, 0, 400, 0, 496, 496, 496, 496, 2415, 496, 496, 496, 496, 0, 0, 1988, 0, 0, 0, 0, 0, 1990, 0, 0, 0, 496, 496, 496,
  496, 2450, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2460, 0, 0, 0, 0, 959, 0, 0, 0, 0, 0, 0, 0, 0, 967, 0, 0, 0,
  0, 319, 0, 302, 364, 366, 0, 0, 0, 319, 0, 45056, 49152, 496, 496, 520, 520, 2481, 520, 520, 520, 520, 520, 520, 520,
  2489, 2490, 0, 0, 0, 0, 0, 2158592, 2813952, 2158592, 2158592, 2158592, 0, 2162688, 2162688, 2162688, 2162688,
  2162688, 2498560, 2539520, 2543616, 2162688, 2162688, 2592768, 2162688, 2162688, 2162688, 2162688, 2162688, 2162688,
  2891776, 0, 0, 0, 0, 2497, 496, 496, 2499, 496, 2501, 496, 496, 496, 496, 2506, 520, 520, 520, 2007, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 1244, 520, 520, 520, 520, 2508, 520, 2510, 520, 520, 520, 520, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1299, 520, 520, 2547, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520,
  520, 2427, 520, 520, 520, 520, 520, 0, 0, 0, 0, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 769, 0, 0, 0, 0, 316, 0, 0,
  0, 0, 0, 0, 320, 0, 0, 0, 0, 0, 0, 0, 0, 2308, 0, 0, 400, 400, 400, 400, 400, 0, 0, 329, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1107, 0, 0, 0, 0, 320, 0, 0, 0, 0, 0, 0, 367, 0, 320, 0, 367, 45056, 49152, 0, 320, 0, 378, 40960, 378, 378,
  287, 378, 378, 0, 378, 0, 378, 405, 405, 405, 405, 405, 0, 0, 0, 320, 443, 378, 378, 378, 378, 378, 378, 378, 378,
  378, 378, 378, 378, 378, 378, 405, 378, 378, 378, 378, 484, 378, 484, 484, 493, 484, 493, 501, 484, 501, 501, 501,
  501, 526, 501, 501, 501, 501, 501, 501, 501, 501, 526, 526, 526, 526, 526, 526, 526, 501, 501, 526, 53494, 53494, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1319, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1367, 0, 0, 0, 0, 0, 496, 496, 496, 666, 0, 496,
  0, 520, 520, 520, 520, 520, 520, 520, 520, 878, 0, 520, 520, 916, 496, 496, 818, 496, 496, 496, 496, 0, 924, 520, 520,
  878, 1063, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 1109, 0,
  0, 0, 0, 400, 1116, 400, 400, 400, 400, 400, 400, 400, 1070, 400, 400, 400, 400, 400, 400, 400, 400, 1082, 400, 1084,
  0, 0, 0, 0, 0, 496, 496, 1145, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 839, 496, 496, 0, 520,
  520, 496, 1269, 496, 496, 496, 496, 496, 496, 520, 1277, 520, 520, 520, 0, 1285, 0, 0, 0, 1291, 0, 0, 0, 0, 0, 0, 0,
  264, 265, 0, 0, 0, 0, 0, 0, 578, 676, 677, 678, 0, 0, 0, 0, 0, 684, 0, 0, 0, 0, 1435, 0, 0, 0, 0, 0, 400, 400, 400,
  400, 400, 400, 400, 400, 1692, 400, 400, 400, 400, 400, 1724, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496,
  496, 496, 496, 496, 496, 2503, 496, 496, 520, 520, 520, 520, 1819, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 1583, 520, 496, 0, 0, 1878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1326, 0, 0, 400, 400, 1929, 400,
  400, 400, 400, 400, 0, 0, 0, 0, 0, 1936, 0, 0, 0, 0, 0, 2158592, 2813952, 2158592, 2158592, 2158592, 0, 2163484,
  2163484, 2163484, 2163484, 2163484, 2499356, 2540316, 2544412, 2163484, 2163484, 2593564, 2163484, 2163484, 0, 0, 0,
  0, 2292, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1095, 0, 0, 0, 0, 0, 0, 0, 331, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 952, 0,
  0, 0, 0, 0, 0, 379, 40960, 379, 379, 0, 379, 379, 0, 379, 393, 379, 406, 406, 406, 406, 406, 426, 426, 426, 426, 426,
  449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 406, 449, 449, 449, 449, 449, 449, 449, 449,
  449, 449, 449, 502, 449, 502, 502, 502, 502, 527, 502, 502, 502, 502, 502, 502, 502, 502, 527, 527, 527, 527, 527,
  527, 527, 502, 502, 527, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1041,
  0, 0, 0, 0, 0, 0, 0, 1048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1120, 400, 400, 400, 0, 0, 1382, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1357, 0, 0, 400, 400, 400, 1725, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496,
  496, 496, 2500, 496, 2502, 496, 496, 496, 520, 520, 496, 520, 496, 496, 496, 1847, 496, 496, 496, 520, 520, 520, 1851,
  520, 520, 520, 0, 1601, 0, 0, 0, 0, 0, 1603, 0, 0, 0, 0, 0, 0, 0, 1907, 1908, 0, 0, 0, 0, 0, 0, 0, 0, 2191, 0, 0, 0,
  0, 0, 0, 0, 0, 2216, 0, 0, 0, 0, 400, 400, 400, 0, 0, 0, 0, 2071, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1105, 0, 0, 0, 0,
  0, 2080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 2184, 0, 933888, 0, 2187, 0, 0, 0,
  0, 2192, 0, 0, 0, 0, 0, 0, 0, 618, 619, 620, 0, 316, 316, 316, 0, 0, 0, 0, 0, 0, 2212, 0, 0, 0, 0, 0, 2217, 0, 0, 400,
  400, 400, 400, 1401, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 1733, 520, 520, 2349, 520,
  520, 520, 520, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 496, 496, 496, 496, 2540, 496, 520, 520, 520,
  520, 520, 520, 520, 520, 2393, 520, 2394, 2395, 520, 520, 520, 496, 496, 496, 496, 2378, 496, 496, 496, 496, 496, 496,
  2384, 496, 496, 496, 496, 0, 1782, 1988, 0, 0, 0, 0, 1788, 1990, 0, 0, 0, 496, 520, 520, 520, 520, 520, 2390, 520,
  520, 520, 520, 520, 520, 2396, 520, 520, 520, 520, 1575, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 2284,
  496, 520, 2286, 520, 0, 2558, 520, 520, 0, 0, 0, 0, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 0, 0, 2562, 496,
  496, 496, 2564, 520, 520, 520, 0, 0, 0, 0, 1289, 0, 0, 0, 1295, 0, 0, 0, 0, 0, 0, 988, 0, 990, 0, 0, 0, 0, 0, 0, 0, 0,
  180582, 180769, 180769, 180769, 180769, 180769, 180769, 180769, 0, 612, 613, 0, 0, 0, 617, 0, 0, 0, 0, 316, 316, 316,
  0, 0, 0, 0, 0, 2379776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270336, 0, 0, 0, 0, 496, 801, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 1159, 496, 496, 847, 496, 0, 852, 496, 0, 520, 520, 520, 861, 520, 520, 520,
  520, 520, 520, 1256, 520, 520, 520, 520, 520, 520, 496, 1265, 0, 0, 520, 520, 496, 496, 801, 496, 496, 496, 496, 847,
  0, 520, 520, 861, 520, 520, 520, 2022, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1814, 1815, 520,
  1817, 496, 496, 1179, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1501, 496, 496, 0, 0, 0, 1332,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 981, 316, 316, 0, 0, 0, 1607, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1374, 0, 0,
  520, 2399, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1310, 651264, 0, 0, 0, 0, 0, 0, 289, 288, 0, 0, 0, 0, 0, 0,
  0, 288, 0, 45056, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 394, 0, 407, 407, 407, 407, 407, 427, 427, 427, 427,
  427, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 503, 450, 503, 503, 503, 503, 450, 450, 450, 450, 450, 450,
  462, 450, 450, 450, 450, 450, 450, 462, 474, 450, 528, 503, 503, 503, 503, 503, 503, 503, 503, 528, 528, 528, 528,
  528, 528, 528, 551, 551, 560, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  742, 0, 0, 0, 0, 0, 0, 685, 0, 0, 0, 0, 691, 0, 0, 0, 695, 0, 0, 0, 0, 400, 400, 400, 400, 400, 2099, 400, 400, 400,
  400, 0, 0, 0, 2104, 0, 0, 0, 0, 0, 892928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 593, 0, 0, 0, 0, 0, 400, 400, 706, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1074, 400, 1075, 400, 771, 0, 0, 0, 775, 0, 400, 400, 400, 400,
  400, 400, 400, 783, 400, 786, 0, 0, 767, 0, 0, 0, 0, 767, 0, 775, 0, 0, 0, 775, 0, 496, 496, 520, 520, 496, 520, 2570,
  2571, 496, 520, 496, 520, 0, 0, 0, 0, 0, 2072, 0, 0, 0, 0, 0, 0, 0, 2077, 0, 0, 496, 496, 804, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1502, 496, 496, 496, 848, 496, 0, 0, 496, 0, 520, 520, 520, 520, 864,
  520, 520, 520, 520, 520, 1543, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 908, 520, 496, 496, 0, 0, 0, 520,
  520, 496, 496, 496, 496, 496, 496, 922, 848, 0, 520, 520, 520, 520, 520, 1559, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1240, 520, 520, 520, 520, 520, 0, 0, 0, 1017, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 994, 0, 0, 0, 0, 0, 0,
  1090, 0, 0, 0, 0, 0, 0, 0, 0, 1096, 0, 0, 0, 0, 0, 1610, 1611, 0, 0, 0, 1615, 0, 0, 0, 0, 0, 0, 0, 2438, 2439, 0,
  851968, 496, 496, 496, 496, 496, 496, 2328, 496, 496, 496, 496, 2331, 496, 496, 496, 496, 1139, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 845, 1160, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 1174, 520, 520, 1251, 520, 520, 520, 520, 1257, 520, 520, 520, 520, 520, 496, 496, 0, 0,
  0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 1210, 520, 520, 520, 520, 1821, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1829, 520, 0, 0, 1316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1392, 0, 0, 0, 0, 1347, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1359, 520, 520, 1555, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1567, 520, 520, 520, 520, 1833,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1242, 520, 520, 520, 520, 0, 0, 0, 0, 1645, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1654, 1734, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1746, 1876, 0, 0,
  0, 1880, 0, 0, 0, 0, 1883, 0, 0, 0, 0, 0, 0, 0, 669, 0, 0, 0, 0, 0, 0, 0, 496, 1915, 0, 0, 0, 0, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1408, 0, 0, 1947, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1758, 496, 496, 400, 2096, 400, 400, 400, 400, 400, 400, 2101, 400, 0, 0, 0, 0, 0, 0, 0, 692, 0, 0, 0,
  0, 0, 0, 0, 400, 0, 496, 496, 496, 496, 496, 496, 2417, 496, 496, 520, 2161, 520, 520, 520, 520, 2164, 520, 520, 520,
  520, 2167, 520, 520, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 2443, 496, 496, 400, 2223, 400, 400,
  400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 1062, 400, 400, 400, 400, 400, 400, 520, 2276, 520, 520, 520, 520, 520, 520,
  520, 496, 496, 496, 520, 520, 520, 0, 0, 0, 0, 0, 0, 2181, 0, 0, 0, 0, 0, 2296, 2297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1617, 0, 0, 0, 2359, 0, 0, 0, 2362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 651, 0, 0, 0, 0, 0, 496, 2447, 2448, 2449,
  496, 520, 520, 520, 520, 2455, 520, 2457, 2458, 2459, 520, 0, 0, 0, 0, 987, 950, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0,
  518, 518, 518, 496, 496, 496, 496, 2522, 496, 2523, 496, 496, 496, 520, 520, 520, 2528, 520, 2529, 520, 520, 520,
  2154, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2015, 520, 520, 520, 0, 0, 0, 660, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1010, 0, 0, 0, 1818, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  1569, 0, 0, 330, 332, 0, 0, 0, 332, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1897, 0, 0, 0, 0, 0, 0, 0, 0, 0, 380, 40960, 380, 380,
  0, 380, 380, 387, 380, 0, 380, 408, 408, 408, 408, 408, 428, 428, 428, 428, 428, 451, 451, 451, 451, 451, 451, 451,
  451, 451, 451, 451, 451, 451, 451, 408, 451, 451, 451, 451, 451, 486, 451, 451, 451, 451, 451, 504, 451, 504, 504,
  504, 504, 529, 504, 504, 504, 504, 504, 504, 504, 504, 529, 529, 529, 529, 529, 529, 529, 504, 504, 529, 53494, 53494,
  2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1660, 0, 0, 0, 0, 0, 0, 0, 1374, 0, 0, 0, 0, 0, 0, 0, 0, 1378, 0, 0, 400, 400,
  400, 707, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 1087, 0, 0, 0, 590, 0, 0, 0, 0, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1407, 400, 0, 652, 0, 0, 0, 0, 0, 0, 0, 0, 0, 590, 0, 0, 0,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2139, 496, 496, 496, 496, 806, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1191, 496, 496, 496, 496, 496, 496, 850, 0, 496, 0, 520, 520, 520, 520,
  520, 866, 520, 520, 520, 0, 2560, 2561, 0, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 0, 1602, 0, 935, 0, 0, 0,
  1604, 0, 939, 0, 400, 400, 1077, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 1140,
  1146, 496, 496, 496, 496, 496, 496, 496, 496, 1156, 496, 496, 496, 496, 496, 1150, 496, 496, 496, 1154, 496, 496, 496,
  496, 496, 496, 818, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1497, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1180, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1192, 496, 496, 496, 496, 496, 1509, 496, 496, 1512, 496, 496, 0,
  0, 1520, 91311, 0, 496, 315392, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 1208, 1214, 520, 520, 520, 2277,
  2279, 520, 520, 2282, 2283, 496, 496, 2285, 520, 520, 2287, 0, 0, 0, 0, 944, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2193, 0,
  0, 2195, 0, 0, 520, 520, 496, 496, 1140, 496, 496, 1180, 496, 496, 520, 520, 1208, 520, 520, 520, 520, 2023, 520, 520,
  520, 520, 2027, 520, 520, 520, 520, 520, 520, 520, 1810, 520, 520, 1813, 520, 520, 520, 520, 520, 1248, 520, 520, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1629, 0, 0, 1300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1313, 0, 0, 1362,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1679, 0, 0, 496, 496, 1460, 1461, 496, 496, 496, 1465, 496, 496, 496, 496, 496,
  496, 496, 496, 1496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1475, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 1469, 496, 496, 496, 1520, 520, 520, 520, 520, 520, 1530, 1531, 520, 520, 520, 1535, 520, 520,
  520, 520, 520, 1808, 1809, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1837, 520, 520, 520, 520, 520, 520, 1619, 0,
  0, 0, 0, 0, 0, 1625, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2300, 0, 0, 0, 0, 0, 0, 1655, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1336, 0, 1667, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1032, 0, 520, 520, 1831, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 1841, 520, 520, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1955, 496,
  496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2000, 520, 2002, 520, 520, 0, 0, 0, 2044, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1026, 0, 0, 0, 0, 0, 0, 0, 2083, 0, 0, 0, 0, 0, 2089, 0, 0, 0, 0, 400, 400, 400, 400,
  400, 967056, 1727, 400, 400, 1073552, 0, 0, 0, 0, 1732, 496, 496, 496, 496, 496, 2125, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 0, 1782, 0, 0, 0, 1520, 2095, 400, 400, 400, 400, 400, 400, 400, 400, 400, 2102, 0, 0, 0, 0, 0, 0,
  0, 802816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1675, 0, 0, 0, 0, 0, 0, 520, 520, 2509, 520, 2511, 520, 520, 520, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1605, 2520, 496, 496, 496, 496, 496, 496, 496, 496, 2526, 520, 520, 520, 520, 520, 520, 520,
  1822, 520, 520, 520, 520, 520, 1828, 520, 520, 0, 316, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 322, 0, 0, 0, 0, 40960,
  0, 0, 0, 0, 0, 0, 0, 395, 0, 409, 409, 409, 409, 409, 429, 429, 437, 429, 429, 452, 452, 452, 452, 452, 452, 452, 452,
  452, 452, 452, 452, 452, 452, 475, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 505, 452, 505, 505, 505,
  505, 530, 505, 505, 505, 505, 542, 542, 542, 542, 547, 547, 547, 547, 547, 547, 547, 505, 505, 547, 53494, 53813, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1671, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1637, 0, 0, 0, 0, 0, 400, 400, 400, 708, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 1086, 0, 0, 0, 0, 591, 0, 0, 0, 0, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 0, 0, 0, 0, 496, 496, 496, 496, 496, 807, 496, 496, 819, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 1741, 496, 496, 496, 496, 496, 496, 0, 520, 520, 496, 496, 496, 819, 496, 496, 496, 496, 0, 520, 520, 520,
  879, 1030, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1344, 496, 1141, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1172, 496, 1249, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 0, 0,
  0, 853, 91311, 1133, 856, 520, 520, 520, 520, 1207, 520, 520, 520, 0, 2549, 2550, 0, 496, 496, 496, 496, 496, 496,
  520, 520, 520, 2424, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 520, 520, 496, 496, 1141, 496, 496, 496, 1274, 496,
  520, 520, 1209, 520, 520, 520, 520, 2163, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 496, 496, 520, 520,
  520, 0, 520, 1282, 520, 0, 0, 1286, 0, 0, 0, 1292, 0, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1857, 0, 1859,
  0, 0, 1862, 0, 496, 496, 496, 496, 1462, 496, 496, 496, 496, 496, 496, 496, 496, 1470, 496, 496, 496, 496, 496, 1738,
  496, 496, 496, 496, 496, 1743, 496, 1745, 496, 496, 496, 496, 496, 1476, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 0, 0, 0, 0, 0, 1520, 1520, 520, 520, 520, 520, 520, 520, 520, 1532, 520, 520, 520, 520, 520, 520, 520, 903, 520,
  520, 520, 520, 496, 496, 0, 0, 520, 1540, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1247,
  520, 1554, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1842, 0, 0, 0, 1658, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1058, 400, 400, 400, 0, 1790, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 1549, 520, 520, 1553, 520, 520, 1806, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2169, 520,
  496, 975344, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2432, 496, 2421, 496, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 2431, 520, 0, 0, 0, 0, 1002, 0, 1004, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  217088, 217088, 217088, 217088, 217088, 217088, 0, 0, 2435, 0, 0, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 496, 2474,
  496, 496, 0, 316, 293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1861, 0, 0, 0, 0, 0, 293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 338, 0, 0, 0, 0, 338, 0, 0, 0, 45056, 49152, 0, 0, 0, 0, 40960, 0, 0, 293, 0, 0, 388, 0, 0, 0, 410, 410, 410, 410,
  410, 430, 436, 436, 436, 430, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 470, 436, 436, 436, 410, 436, 481,
  470, 436, 485, 436, 485, 485, 485, 485, 485, 506, 485, 506, 506, 506, 506, 531, 506, 506, 506, 506, 506, 506, 506,
  506, 531, 531, 531, 531, 531, 531, 531, 506, 506, 531, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 1706, 0, 0,
  0, 0, 0, 1718, 0, 0, 0, 400, 595, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1618, 632, 0, 0, 0, 0, 0, 0, 0, 0, 694,
  0, 0, 0, 0, 0, 400, 0, 496, 496, 496, 496, 496, 2416, 496, 2418, 496, 701, 400, 400, 709, 400, 400, 717, 400, 400,
  400, 723, 400, 400, 400, 730, 400, 400, 400, 400, 1068, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0,
  0, 1088, 0, 749, 0, 629, 0, 0, 0, 0, 749, 0, 0, 0, 0, 732, 0, 0, 592, 0, 760, 0, 0, 632, 0, 0, 0, 749, 0, 0, 732, 592,
  770, 0, 732, 0, 772, 632, 0, 0, 0, 701, 400, 400, 779, 400, 400, 400, 400, 730, 400, 400, 400, 400, 1079, 1080, 400,
  400, 400, 400, 400, 0, 0, 0, 0, 0, 2231, 0, 0, 0, 400, 2234, 797, 496, 496, 808, 496, 496, 820, 496, 496, 496, 829,
  496, 496, 496, 496, 844, 496, 496, 496, 851, 0, 496, 0, 520, 520, 857, 520, 520, 868, 520, 520, 880, 0, 857, 520, 797,
  496, 496, 919, 496, 496, 496, 496, 0, 857, 520, 520, 927, 983, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 997, 0, 0, 0,
  946, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1043, 0, 0, 0, 0, 0, 2838528, 0, 0, 2854912, 0, 0, 0, 0, 0, 0, 0, 0, 3051520, 3055616,
  0, 0, 0, 0, 1101, 0, 0, 0, 1087, 0, 0, 0, 0, 0, 0, 1106, 0, 0, 0, 0, 0, 1881, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 992, 0, 0,
  0, 0, 0, 1175, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2335, 0, 520, 520, 496, 496,
  1270, 496, 496, 1273, 496, 496, 520, 520, 1278, 520, 520, 520, 520, 2278, 520, 520, 520, 520, 496, 496, 496, 520, 520,
  520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1281, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1297, 0, 0, 0, 0, 0,
  2887680, 0, 0, 0, 0, 3026944, 0, 0, 0, 0, 0, 0, 0, 1351, 0, 0, 0, 0, 0, 0, 0, 0, 264, 264, 264, 264, 264, 264, 264,
  264, 1329, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1875, 400, 400, 1447, 400, 400, 400, 1451, 0, 0, 0, 0, 0,
  1133, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 520, 520, 875, 520, 1505, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 0, 0, 1520, 91311, 0, 0, 0, 0, 1018, 0, 0, 0, 1022, 0, 0, 0, 0, 0, 0, 0, 0, 221727, 221727,
  221727, 221727, 221727, 221727, 221727, 221727, 0, 0, 1643, 1644, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1301, 0, 0, 0,
  0, 0, 1684, 0, 1686, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1072, 400, 400, 400, 400, 0, 0, 0, 1712,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 0, 496, 496, 496, 2414, 496, 496, 496, 496, 496, 496, 496, 1761, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1770, 496, 496, 496, 496, 496, 1775, 496, 496, 496, 496, 496, 496,
  0, 0, 0, 0, 0, 1520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1538, 520, 520, 520, 1542, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 1551, 520, 520, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 935, 939, 0, 0, 0, 0, 0,
  1365, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 515, 0, 515, 515, 515, 515, 0, 0, 0, 0, 1866, 0, 0, 1868, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 0, 0, 0, 1879, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1325, 0,
  0, 1328, 0, 0, 0, 1892, 0, 1893, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 792, 0, 0, 0, 0, 496, 0, 1916, 0, 0, 1919, 400, 400,
  400, 400, 400, 1924, 400, 400, 400, 1926, 400, 400, 400, 400, 1411, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0,
  1130, 1089, 0, 0, 1133, 1134, 1136, 496, 496, 400, 1928, 400, 400, 400, 400, 400, 400, 0, 0, 0, 1934, 0, 0, 0, 0, 0,
  0, 1036, 0, 0, 0, 0, 0, 0, 0, 0, 0, 738, 0, 743, 0, 746, 0, 0, 0, 0, 0, 1938, 0, 1940, 0, 0, 0, 400, 400, 400, 400,
  1945, 400, 400, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 0, 2320, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 862, 865,
  520, 872, 520, 520, 0, 2532, 0, 0, 2535, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 2425, 520, 520, 520, 520,
  520, 520, 520, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 1953, 496, 496, 496, 496, 1957, 496, 496, 496, 496, 496,
  2134, 496, 496, 496, 496, 2137, 496, 496, 496, 496, 2140, 1959, 496, 496, 496, 496, 496, 496, 496, 496, 1966, 496,
  496, 496, 496, 496, 496, 1464, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1780, 0, 0, 0, 0, 0, 1520, 2053, 0, 0, 0,
  0, 0, 0, 2058, 2059, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 135168, 0, 0, 0, 0, 0, 0, 520, 2152, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 1816, 520, 496, 496, 2173, 520, 520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1324, 0, 0, 0, 0, 400, 400, 2237, 496, 2239, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2247, 2248, 496, 496,
  496, 496, 2252, 496, 496, 496, 496, 496, 496, 496, 496, 520, 2262, 2275, 520, 520, 520, 520, 520, 520, 520, 520, 496,
  496, 496, 520, 520, 520, 0, 0, 0, 0, 0, 2180, 0, 0, 0, 0, 0, 0, 2289, 0, 0, 0, 569344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  950, 0, 0, 0, 0, 0, 496, 2323, 2324, 2325, 496, 496, 496, 496, 496, 496, 496, 496, 2332, 496, 496, 496, 0, 0, 496, 0,
  520, 520, 520, 520, 520, 520, 873, 520, 520, 2370, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 0, 496, 496,
  520, 520, 2568, 2569, 496, 520, 496, 520, 496, 520, 0, 0, 0, 0, 0, 1611, 0, 0, 1716, 0, 1717, 0, 0, 0, 0, 400, 400,
  1687, 1688, 400, 400, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 1935, 0, 0, 0, 496, 520, 520, 520, 520, 520, 520,
  2391, 520, 520, 520, 520, 520, 520, 520, 520, 1226, 520, 520, 520, 520, 520, 520, 520, 2433, 0, 0, 868352, 0, 0, 0, 0,
  0, 0, 0, 496, 496, 496, 2444, 496, 496, 496, 496, 496, 2327, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1468,
  496, 496, 496, 496, 496, 0, 0, 0, 2464, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 2476, 496, 2478, 520, 520, 520,
  520, 520, 520, 520, 2486, 520, 2488, 0, 0, 0, 0, 0, 0, 1306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 45056,
  49152, 2545, 520, 520, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 2426, 520, 2428, 520, 520,
  520, 520, 0, 0, 296, 298, 297, 40960, 297, 297, 298, 385, 297, 296, 297, 0, 297, 411, 411, 411, 411, 411, 431, 431,
  431, 439, 444, 453, 453, 453, 453, 453, 453, 453, 467, 453, 453, 453, 453, 453, 453, 411, 453, 453, 453, 453, 467,
  453, 467, 491, 467, 491, 467, 507, 491, 507, 507, 507, 507, 532, 507, 507, 507, 507, 507, 507, 507, 507, 532, 532,
  532, 532, 532, 532, 532, 507, 507, 532, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2056, 0, 0, 0, 0, 0, 0,
  2063, 2064, 0, 0, 0, 0, 0, 582, 583, 584, 585, 586, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 598,
  0, 600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 316, 316, 0, 0, 0, 0, 614, 0, 0, 0, 0, 0, 0, 621, 316, 316, 316, 0,
  0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1664, 0, 0, 0, 0, 0, 0, 626, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 638,
  0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0, 0, 0, 2179695, 0, 641, 0, 643, 0, 645, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1340, 0, 1342, 0, 0, 0, 0, 687, 745472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 0, 2412, 496, 496, 496, 496, 496, 496,
  496, 496, 1511, 496, 496, 496, 0, 0, 1520, 91311, 0, 400, 704, 400, 400, 712, 400, 400, 400, 721, 400, 400, 400, 400,
  728, 400, 400, 0, 0, 0, 0, 2317, 0, 0, 2318, 400, 400, 0, 496, 496, 496, 496, 2242, 496, 496, 496, 496, 496, 496, 496,
  496, 1767, 496, 496, 496, 496, 496, 496, 496, 0, 0, 0, 762, 0, 0, 0, 614, 0, 621, 758, 0, 0, 0, 0, 0, 0, 0, 2772992,
  0, 0, 0, 0, 2113536, 0, 0, 0, 645, 0, 614, 678, 789, 0, 0, 614, 0, 621, 0, 0, 678, 794, 0, 496, 2566, 520, 2567, 496,
  520, 496, 520, 496, 520, 496, 520, 0, 0, 0, 0, 0, 2436, 0, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2461, 496, 802, 805, 496, 812, 496, 496, 496, 825, 828, 496,
  496, 496, 837, 841, 496, 496, 496, 496, 496, 2379, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 1783, 0, 0, 0,
  1520, 520, 885, 888, 520, 520, 520, 897, 901, 520, 520, 520, 520, 496, 825, 0, 0, 0, 0, 0, 3067904, 0, 0, 0, 0, 0, 0,
  0, 316, 316, 0, 0, 520, 885, 496, 496, 918, 496, 496, 837, 841, 923, 0, 520, 520, 926, 520, 520, 520, 2350, 520, 520,
  520, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 496, 496, 2538, 2539, 496, 496, 520, 520, 2544, 520, 897,
  901, 931, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 735, 0, 0, 1015, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 316, 982, 400, 400, 400, 1128, 0, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496,
  496, 496, 1165, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1173, 0, 0, 0, 1363, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1370, 1371, 0, 1373, 0, 0, 0, 1375, 0, 674, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1027, 0, 496, 496, 496, 496,
  1508, 496, 496, 496, 496, 496, 496, 0, 0, 1520, 91311, 0, 0, 0, 0, 1050, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400,
  0, 0, 400, 0, 2376, 496, 520, 520, 496, 1588, 496, 651760, 496, 496, 496, 496, 520, 1595, 520, 651784, 520, 520, 520,
  807408, 807432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2075, 0, 0, 0, 0, 0, 0, 0, 1621, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1341, 0, 0, 0, 0, 0, 1632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1901, 0, 0, 496, 496, 1749, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 1984, 496, 496, 1523, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 2018, 0, 0, 0, 2055, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1356, 0, 0, 0, 520, 520, 2265, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2273, 2274, 520, 0, 0, 0, 2361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1391, 0, 0, 0, 496, 2388, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2159, 520, 2446,
  496, 496, 496, 496, 520, 2452, 520, 520, 520, 2456, 520, 520, 520, 520, 0, 0, 0, 1288, 0, 0, 0, 1294, 0, 0, 0, 0, 0,
  0, 0, 2887680, 0, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 2158592, 3158016, 2158592, 0, 0, 0,
  0, 2163484, 2163484, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 396, 0, 400, 400, 1399, 400, 400, 400, 400, 400, 400,
  1405, 400, 400, 400, 400, 400, 400, 400, 1414, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 1132, 1133, 496, 496, 496,
  496, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 476, 454, 454, 454, 454, 454, 454, 454,
  454, 454, 454, 508, 517, 508, 508, 508, 508, 533, 508, 508, 508, 508, 508, 508, 508, 508, 533, 533, 533, 533, 533,
  533, 533, 552, 552, 561, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2084, 2085, 0, 0, 2088, 0, 0, 0, 0, 0,
  400, 0, 496, 2413, 496, 496, 496, 496, 496, 496, 2419, 750, 0, 0, 0, 0, 0, 602, 753, 0, 0, 0, 602, 0, 0, 0, 0, 0, 0,
  1320, 0, 0, 0, 0, 0, 0, 0, 1327, 0, 1031, 0, 0, 949, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1045, 0, 0, 0, 1049, 0, 0, 0, 0,
  0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 2375, 496, 400, 400, 400, 1067, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 0, 1729, 0, 0, 496, 496, 0, 949, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1044, 0, 496,
  1142, 496, 496, 496, 496, 1152, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2128, 496, 496, 496, 496, 496, 496, 496,
  496, 1161, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2130, 496, 496, 1176, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1188, 496, 496, 496, 496, 496, 496, 2380, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1765,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1186, 496, 496, 496, 496, 1193, 496, 0, 520, 1267, 496, 496, 1142, 496,
  496, 496, 496, 496, 520, 520, 1210, 520, 520, 520, 520, 2351, 520, 520, 520, 520, 520, 520, 496, 909808, 520, 909832,
  2358, 1666, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1677, 0, 0, 0, 0, 0, 0, 1385, 1386, 0, 0, 1389, 0, 0, 0, 0, 0, 0, 0, 131072,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 1748, 496, 496, 1751, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1499,
  496, 496, 496, 496, 0, 1791, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1827, 520, 520, 520, 0,
  0, 0, 1865, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1616, 0, 0, 0, 0, 0, 0, 0, 2200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1377, 0, 0, 0, 0, 0, 0, 2410, 0, 0, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2255, 496, 496, 496, 496,
  520, 520, 0, 675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1108, 0, 400, 400, 400, 710, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 0, 2103, 0, 0, 0, 0, 0, 736, 0, 0, 0, 0, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 1418, 400, 0, 0, 0, 0, 496, 496, 496, 809, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1484, 496,
  496, 496, 496, 496, 849, 0, 0, 496, 0, 520, 520, 520, 520, 520, 869, 520, 520, 520, 496, 520, 0, 0, 0, 2403, 0, 0, 0,
  0, 0, 0, 0, 0, 270336, 270336, 270336, 270336, 270336, 270336, 270336, 270336, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1914, 0, 316, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2052, 0, 0, 300, 299, 40960,
  299, 299, 300, 299, 299, 0, 299, 0, 299, 412, 412, 412, 412, 412, 0, 0, 0, 0, 300, 299, 299, 299, 299, 299, 299, 299,
  299, 299, 299, 299, 299, 299, 299, 412, 299, 299, 299, 299, 299, 299, 299, 299, 299, 299, 495, 509, 299, 509, 509,
  509, 509, 534, 509, 509, 509, 509, 509, 509, 509, 509, 534, 534, 534, 534, 534, 534, 534, 509, 509, 534, 53494, 53494,
  2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 589, 590, 0, 0, 0, 0, 0, 0, 0, 644, 0, 0,
  647, 0, 0, 0, 0, 0, 0, 0, 0, 0, 739, 0, 744, 0, 0, 0, 0, 0, 658, 0, 0, 662, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1638, 0,
  0, 0, 0, 603, 0, 0, 0, 0, 0, 0, 0, 693, 0, 0, 0, 0, 0, 0, 400, 400, 1922, 400, 400, 400, 400, 1925, 400, 400, 400,
  679, 0, 0, 0, 763, 0, 0, 748, 0, 0, 0, 0, 0, 0, 0, 0, 265, 265, 265, 265, 265, 265, 265, 265, 0, 0, 773, 0, 0, 0, 400,
  400, 400, 400, 400, 400, 400, 784, 400, 400, 0, 0, 0, 974848, 0, 0, 0, 400, 400, 975248, 0, 496, 496, 496, 0, 0, 496,
  0, 520, 520, 520, 520, 520, 520, 520, 520, 877, 0, 0, 748, 0, 0, 0, 0, 748, 0, 0, 773, 0, 658, 0, 0, 496, 496, 496,
  496, 496, 2451, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 0, 0, 496, 2552, 496, 496, 496, 496, 520, 2556,
  520, 0, 914, 520, 496, 496, 496, 496, 832, 496, 842, 496, 0, 914, 520, 520, 520, 496, 520, 0, 2401, 0, 0, 2404, 0, 0,
  0, 0, 0, 0, 0, 767, 0, 620, 0, 0, 0, 0, 0, 0, 0, 648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 0, 892, 520,
  902, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 949, 0, 0, 0, 0, 954, 0, 400, 400, 1126, 0, 0, 1018, 0, 0, 0, 1131,
  0, 1133, 496, 496, 496, 496, 496, 1182, 496, 496, 496, 1185, 496, 496, 496, 496, 496, 496, 817, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1481, 496, 496, 496, 496, 496, 496, 0, 1266, 520, 496, 496, 496, 496, 1272, 496, 496, 1275,
  520, 520, 520, 520, 1280, 520, 520, 1283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2194, 0, 0, 1457, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2387, 496, 1473, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 1485, 496, 1520, 520, 520, 520, 1527, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  1262, 520, 496, 496, 0, 520, 1572, 520, 520, 520, 520, 520, 520, 520, 1579, 520, 520, 1582, 520, 520, 496, 496, 520,
  53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 630, 631, 0, 0, 0, 0, 636, 0, 0, 0, 640, 0, 0, 0, 0, 1622, 1623,
  1624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 978, 0, 0, 0, 316, 316, 0, 0, 1642, 0, 0, 0, 0, 1646, 0, 0, 0, 1649, 0, 0, 0, 0, 0,
  0, 0, 2818048, 0, 2879488, 0, 2961408, 0, 2977792, 0, 0, 0, 0, 1657, 0, 0, 0, 0, 0, 311296, 1663, 0, 0, 0, 0, 0, 0, 0,
  989, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2060, 0, 0, 0, 0, 2065, 0, 0, 0, 0, 0, 1670, 0, 1672, 1673, 0, 0, 0, 0, 0, 0, 0, 0,
  292, 0, 0, 0, 0, 0, 0, 0, 400, 1696, 400, 1697, 1698, 400, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 0, 0, 2233, 0, 400,
  400, 1709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1719, 1720, 0, 311696, 1722, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  0, 0, 1730, 0, 496, 496, 520, 520, 496, 520, 496, 520, 496, 520, 496, 520, 0, 0, 0, 0, 0, 0, 2105344, 264, 265, 0, 0,
  212992, 0, 0, 0, 0, 0, 0, 690, 0, 0, 0, 0, 697, 698, 0, 700, 400, 496, 1760, 496, 496, 496, 496, 496, 1766, 496, 496,
  496, 496, 496, 496, 496, 496, 2136, 496, 496, 496, 496, 496, 496, 496, 496, 520, 311792, 1845, 496, 496, 496, 496,
  496, 311816, 1849, 520, 520, 520, 520, 520, 520, 2266, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1564, 520,
  520, 520, 520, 520, 0, 0, 1891, 0, 0, 0, 0, 1895, 0, 0, 0, 0, 0, 0, 0, 0, 359, 359, 359, 359, 359, 359, 359, 359, 0,
  0, 1937, 0, 1939, 0, 0, 0, 0, 400, 400, 400, 1944, 400, 400, 400, 400, 400, 400, 2100, 400, 400, 400, 0, 0, 0, 0,
  2105, 0, 0, 0, 0, 496, 496, 496, 496, 496, 496, 496, 496, 1954, 496, 496, 496, 496, 496, 1463, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 2257, 496, 496, 496, 2261, 520, 0, 2054, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1343,
  0, 0, 2068, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1379, 0, 2141, 496, 496, 0, 0, 0, 0, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1260, 520, 520, 520, 496, 496, 0, 400, 2236, 0, 2238, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1744, 496, 496, 496, 0, 0, 0, 0, 2298, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1650, 0, 0, 0, 0, 2420, 496,
  496, 2422, 520, 520, 520, 520, 520, 520, 520, 520, 2430, 520, 520, 0, 0, 0, 0, 0, 496, 2537, 496, 496, 496, 2541, 520,
  2543, 520, 0, 0, 0, 0, 2465, 0, 0, 2468, 496, 2470, 496, 496, 496, 496, 496, 496, 1494, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1168, 496, 496, 496, 496, 496, 496, 496, 496, 520, 2480, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2494, 2495, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 520, 520, 520, 2176, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 635, 0, 0, 0, 0, 0, 520, 2546, 520, 2548, 0, 0, 2551, 496, 496, 496, 496, 496, 496, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 0, 0, 2491, 2492, 0, 301, 302, 303, 304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1885, 0,
  0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 319, 0, 0, 0, 0, 0, 0, 0, 0, 544, 544, 544, 544, 544, 544, 544, 544, 323, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2066, 302, 0, 0, 0, 319, 0, 336, 0, 301, 0, 0, 0, 0, 0, 346, 347, 0, 348, 0, 0, 0, 0,
  348, 0, 0, 352, 0, 0, 0, 319, 356, 0, 0, 0, 0, 1091, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2062, 0, 0, 0, 0, 0, 0, 0, 381,
  40960, 381, 381, 0, 381, 381, 366, 381, 0, 381, 413, 413, 413, 413, 413, 0, 0, 301, 0, 0, 455, 455, 455, 455, 455,
  455, 463, 468, 455, 455, 455, 455, 455, 463, 477, 463, 455, 455, 482, 468, 487, 468, 468, 468, 468, 468, 510, 468,
  510, 510, 510, 510, 535, 510, 510, 510, 510, 510, 510, 510, 510, 535, 535, 535, 535, 535, 535, 535, 553, 553, 562,
  53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 2213, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 716, 400, 400, 400, 400,
  400, 400, 702, 400, 400, 400, 400, 400, 718, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1415, 400, 400, 400, 0, 0,
  0, 0, 0, 742, 0, 0, 0, 0, 0, 0, 0, 0, 0, 756, 0, 742, 0, 756, 798, 496, 496, 496, 496, 496, 821, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 2329, 496, 496, 496, 496, 2334, 496, 496, 496, 496, 756, 0, 496, 0, 520, 520, 858, 520, 520,
  520, 520, 520, 881, 0, 858, 520, 798, 496, 496, 821, 496, 496, 496, 496, 0, 858, 520, 520, 881, 941, 0, 0, 943, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 0, 288, 289, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3133440, 0, 2727936, 0, 0, 0, 998,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2078, 1064, 400, 1066, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1073,
  400, 400, 400, 400, 400, 714, 400, 400, 400, 400, 724, 400, 400, 729, 400, 400, 0, 1091, 1110, 0, 0, 0, 0, 400, 400,
  400, 1073, 400, 400, 400, 400, 400, 400, 0, 0, 1452, 0, 0, 0, 1133, 496, 496, 496, 496, 496, 1147, 496, 496, 1151,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1756, 496, 496, 496, 496, 496, 496, 496, 496, 1162, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1757, 496, 496, 496, 520, 1219, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 1230, 0, 520, 520, 496, 496, 496, 1162, 496, 496, 496, 496, 520, 520, 520, 1230, 520, 520,
  886, 520, 891, 520, 894, 520, 520, 906, 520, 520, 496, 911, 0, 0, 0, 0, 0, 286720, 286720, 286720, 286720, 286720, 0,
  0, 0, 0, 0, 286720, 0, 1301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1653, 0, 1345, 0, 0, 0, 1349, 0, 0, 0, 1352, 0,
  0, 0, 0, 0, 0, 0, 0, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 286720, 0, 1620, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1721, 400, 0, 0, 0, 0, 1073152, 0, 0, 0, 1635, 0, 0, 0, 0, 0, 0, 0, 0, 761856, 0, 0, 0, 0, 0, 0, 0,
  0, 913408, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 155648, 0, 0, 0, 0, 0, 0, 0, 1710, 0, 0, 0, 0, 0, 0, 0, 966656, 0, 0, 0, 0,
  0, 400, 1921, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1083, 400, 0, 0, 0, 0, 0, 1772, 496, 1774, 496, 496, 496,
  496, 496, 496, 496, 1781, 0, 0, 0, 0, 1520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1536, 520, 520,
  520, 0, 0, 1288, 0, 0, 0, 0, 0, 1294, 0, 0, 0, 0, 0, 0, 1335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200704, 200704, 200704,
  200704, 200704, 200704, 0, 0, 0, 0, 1794, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1548, 520, 520, 520,
  520, 496, 520, 496, 496, 496, 496, 496, 967152, 1073648, 520, 520, 520, 520, 520, 967176, 1073672, 0, 1288, 0, 1294,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1651, 0, 0, 0, 0, 692224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1888, 0, 0,
  770048, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2333, 496, 496, 496, 496, 1975, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1769, 496, 496, 496, 2019, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 2170, 520, 520, 2162, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 496, 496, 520, 520, 0, 2208, 2209, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400, 400, 400, 0, 806912, 807312,
  0, 496, 0, 2302, 0, 0, 0, 0, 2306, 0, 0, 0, 0, 400, 400, 400, 400, 400, 1690, 400, 400, 400, 400, 400, 400, 400, 2315,
  0, 0, 0, 0, 0, 909312, 0, 400, 909712, 400, 2319, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 867, 520, 520,
  879, 0, 0, 2360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466944, 0, 2368, 2369, 496, 496, 2479, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 0, 0, 0, 0, 0, 2517, 2518, 0, 496, 2521, 496, 496, 496, 496, 496, 496, 496, 520, 2527, 520, 520, 520, 520,
  520, 520, 2267, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2166, 520, 520, 520, 520, 496, 0, 349, 0, 0, 0, 0,
  349, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 0, 0, 0, 0, 996, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 307, 0, 0, 0, 414, 414,
  414, 414, 414, 432, 432, 432, 432, 432, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 478,
  456, 456, 456, 483, 456, 488, 456, 456, 456, 456, 456, 511, 456, 511, 511, 511, 511, 536, 511, 511, 511, 511, 511,
  511, 511, 511, 536, 536, 536, 536, 536, 536, 536, 554, 554, 563, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0,
  2305, 0, 0, 0, 2309, 0, 2311, 400, 400, 400, 400, 400, 400, 716, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1703,
  400, 0, 0, 0, 0, 0, 0, 596, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 608, 609, 610, 0, 0, 0, 661, 0, 0, 0, 0, 0, 0, 576, 661,
  0, 670, 671, 576, 739, 0, 744, 0, 0, 0, 766, 0, 0, 0, 0, 576, 0, 0, 766, 576, 0, 0, 0, 766, 0, 0, 400, 400, 400, 400,
  400, 400, 727, 400, 400, 400, 400, 400, 715, 400, 720, 400, 400, 400, 400, 727, 400, 400, 400, 400, 400, 1450, 0, 0,
  0, 0, 1070389, 0, 1133, 496, 496, 496, 0, 0, 0, 0, 520, 520, 2145, 520, 520, 520, 520, 520, 520, 520, 2514, 0, 0, 0,
  0, 2516, 0, 0, 2519, 0, 766, 0, 788, 0, 744, 790, 0, 0, 0, 0, 0, 788, 0, 0, 496, 496, 496, 496, 520, 2339, 520, 520,
  520, 520, 520, 520, 520, 2346, 520, 520, 496, 520, 365040, 496, 496, 496, 365064, 520, 520, 520, 0, 0, 0, 0, 496, 496,
  496, 496, 2555, 496, 520, 520, 520, 799, 496, 496, 496, 496, 816, 822, 824, 496, 496, 496, 496, 496, 838, 496, 496,
  496, 496, 496, 1764, 496, 496, 496, 1768, 496, 496, 496, 496, 496, 496, 1183, 496, 496, 496, 496, 1189, 496, 496, 496,
  496, 496, 496, 496, 576, 0, 496, 0, 520, 520, 859, 520, 520, 520, 520, 876, 882, 884, 520, 520, 520, 520, 520, 898,
  520, 520, 520, 520, 520, 799, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 520, 1213, 520, 0, 859,
  520, 799, 496, 496, 822, 496, 838, 496, 496, 0, 859, 520, 520, 882, 520, 898, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1007, 0, 0, 0, 0, 0, 0, 0, 0, 957, 0, 0, 0, 0, 0, 0, 963, 0, 0, 966, 0, 0, 0, 0, 0, 2373, 400, 400, 2374,
  400, 400, 0, 0, 400, 0, 496, 0, 0, 985, 986, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1872, 0, 0, 0, 0, 1032, 0, 0, 0, 0,
  0, 1037, 0, 0, 0, 0, 0, 0, 0, 0, 575, 0, 0, 0, 0, 0, 0, 575, 986, 1103, 0, 1111, 0, 985, 1114, 1115, 400, 400, 1118,
  400, 400, 400, 400, 400, 400, 0, 581632, 0, 0, 0, 0, 1133, 496, 496, 496, 400, 1125, 400, 0, 765952, 0, 0, 0, 0, 0,
  966, 1133, 496, 496, 1137, 496, 496, 496, 496, 813, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1968, 496,
  1970, 496, 1972, 496, 496, 496, 1163, 496, 496, 1166, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1980, 496, 496,
  496, 496, 496, 496, 496, 496, 1167, 496, 496, 1169, 496, 1171, 496, 496, 1177, 1178, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 1194, 0, 520, 520, 1268, 496, 496, 1271, 496, 496, 496, 496, 1276, 520, 520, 1279,
  520, 520, 903, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1039, 0, 0, 0, 0, 0, 0, 0, 0, 1302, 1303, 0, 0, 0, 0, 0,
  1309, 0, 0, 0, 0, 0, 0, 0, 1053, 0, 0, 0, 0, 400, 400, 400, 400, 1689, 400, 400, 400, 400, 400, 400, 400, 1409, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 0, 1420, 1421, 0, 0, 0, 0, 1092, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2218, 0, 2220, 400, 400, 0, 0, 1424, 0, 0, 0, 0, 0, 0, 0, 1430, 0, 1430, 1420, 0, 0, 0, 0, 288, 333, 335, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 282, 282, 0, 326, 0, 0, 0, 0, 1433, 0, 0, 0, 1436, 0, 0, 0, 0, 400, 400, 1442, 400, 400, 400, 400, 400,
  1699, 400, 400, 400, 400, 400, 0, 0, 0, 0, 0, 454, 454, 454, 454, 454, 454, 1445, 400, 400, 400, 400, 400, 0, 0, 0, 0,
  0, 0, 1133, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 520, 870, 520, 520, 520, 496, 520, 2400, 0, 2402, 0, 0,
  0, 0, 0, 0, 2407, 0, 496, 1459, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1472, 1520, 520, 520,
  520, 520, 1529, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1227, 520, 520, 520, 520, 520, 520, 520, 1573, 1574,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 496, 520, 0, 0, 0, 0, 0, 0, 0, 0, 2406, 0, 0, 496, 520, 520,
  496, 496, 1589, 496, 496, 1591, 496, 496, 520, 520, 1596, 520, 520, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 936, 940, 0, 0,
  0, 0, 0, 2111, 400, 400, 400, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 2244, 496, 496, 496, 496, 1598, 520,
  520, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2206, 0, 0, 0, 0, 0, 0, 1609, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2366, 0,
  2367, 0, 0, 1641, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2196, 0, 0, 0, 0, 1659, 0, 0, 0, 0, 0, 0, 0, 577536, 0,
  0, 1665, 0, 0, 1711, 0, 1713, 0, 1714, 0, 0, 0, 0, 0, 0, 0, 0, 400, 2411, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1513, 496, 0, 0, 1520, 91311, 0, 496, 496, 496, 1750, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1969, 496, 496, 496, 496, 1773, 496, 496, 496, 1777, 496, 496, 496, 496, 0, 0, 0, 1786, 0, 1520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 1534, 520, 520, 520, 520, 520, 520, 2156, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  2270, 2271, 520, 520, 520, 520, 0, 0, 1792, 0, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1801, 520, 520, 520, 889,
  520, 520, 520, 520, 904, 520, 520, 520, 797, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 2157, 520, 520, 520, 520, 520, 520, 1804, 520, 520, 520, 520, 520, 520, 520, 520, 1812, 520, 520, 520, 520,
  520, 520, 520, 2165, 520, 520, 520, 520, 520, 520, 520, 496, 1863, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  217088, 1040384, 0, 0, 1948, 496, 496, 496, 496, 1952, 496, 496, 496, 496, 496, 496, 496, 2127, 496, 496, 496, 496,
  496, 496, 496, 496, 1739, 496, 496, 1742, 496, 496, 496, 496, 496, 496, 496, 496, 1961, 496, 496, 496, 1964, 1965,
  496, 496, 496, 496, 496, 496, 496, 2381, 496, 2382, 2383, 496, 496, 496, 496, 496, 1973, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1503, 1504, 0, 1992, 520, 520, 520, 520, 1996, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1824, 1825, 520, 520, 520, 520, 520, 520, 2005, 520, 520, 520, 2008, 2009, 520, 520, 520, 520,
  520, 520, 520, 2017, 520, 520, 930, 908, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 324, 324, 353, 0, 0, 0, 413696,
  2042, 0, 0, 2045, 2046, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 0, 0, 0, 0, 0, 2079, 0, 0, 0, 0, 0, 0, 2086, 0, 0, 0,
  2090, 0, 0, 0, 400, 400, 400, 400, 1449, 400, 0, 0, 0, 0, 0, 0, 1133, 496, 496, 496, 0, 0, 0, 0, 2143, 520, 520, 520,
  520, 520, 520, 520, 520, 1238, 520, 520, 520, 520, 520, 520, 1248, 400, 400, 2097, 400, 400, 400, 400, 400, 400, 400,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 1943, 400, 400, 400, 400, 0, 0, 0, 0, 1064960, 400, 400, 400, 400, 400, 0, 496,
  496, 496, 496, 496, 496, 2524, 2525, 496, 520, 520, 520, 520, 520, 520, 2530, 2121, 496, 2123, 496, 496, 496, 2126,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1752, 1753, 496, 1755, 496, 496, 496, 496, 496, 496, 1477, 496, 496, 496,
  496, 496, 496, 496, 1486, 496, 496, 2142, 496, 0, 0, 0, 0, 520, 520, 520, 520, 520, 2148, 520, 2150, 520, 520, 1220,
  520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1229, 520, 520, 549, 549, 558, 53494, 53494, 2, 2, 3, 94212, 5,
  6, 0, 0, 0, 0, 0, 1032, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 520, 520, 2153, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 2168, 520, 520, 496, 0, 0, 0, 2211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 400, 400,
  400, 400, 400, 400, 400, 785, 400, 2263, 520, 520, 520, 520, 520, 520, 2268, 520, 520, 520, 520, 520, 520, 520, 520,
  1578, 520, 520, 520, 520, 520, 520, 496, 0, 0, 2290, 0, 0, 0, 0, 0, 2294, 0, 0, 0, 0, 0, 0, 0, 264, 265, 0, 0, 0, 0,
  0, 0, 0, 0, 1613, 0, 0, 0, 0, 0, 0, 0, 0, 1626, 0, 1628, 0, 0, 0, 0, 0, 2314, 400, 0, 0, 2316, 0, 0, 0, 471040, 400,
  400, 400, 0, 496, 496, 496, 0, 0, 496, 0, 520, 520, 520, 520, 863, 520, 520, 874, 520, 2347, 520, 520, 520, 520, 2352,
  520, 520, 520, 520, 520, 496, 496, 520, 520, 0, 0, 0, 0, 0, 2536, 496, 496, 496, 496, 496, 2542, 520, 520, 0, 0, 0,
  2372, 0, 0, 400, 400, 400, 400, 400, 0, 0, 400, 0, 496, 496, 496, 496, 1181, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 496, 1190, 496, 496, 496, 496, 496, 496, 496, 2377, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2385, 496,
  496, 496, 496, 496, 1963, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 0, 0, 1784, 0, 0, 1520, 496, 520, 520,
  520, 520, 2389, 520, 520, 520, 520, 520, 520, 520, 520, 520, 2397, 2531, 520, 0, 0, 2533, 2534, 0, 496, 496, 496, 496,
  496, 496, 520, 520, 520, 520, 520, 2484, 520, 520, 520, 520, 0, 0, 0, 0, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0,
  0, 309, 0, 0, 0, 0, 0, 0, 0, 0, 309, 0, 0, 45056, 49152, 0, 309, 0, 0, 40960, 0, 0, 0, 0, 0, 389, 0, 0, 0, 415, 415,
  415, 415, 415, 433, 433, 433, 440, 440, 457, 457, 457, 433, 433, 433, 433, 433, 433, 457, 457, 433, 433, 433, 440,
  433, 457, 479, 433, 433, 433, 433, 457, 433, 489, 489, 489, 489, 489, 512, 489, 512, 512, 512, 512, 537, 512, 512,
  512, 512, 512, 512, 512, 512, 537, 537, 537, 537, 537, 537, 537, 512, 512, 537, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0,
  0, 0, 0, 0, 53494, 53494, 2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 106496, 106496, 106496, 106496, 106496, 106496, 106496,
  106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 0, 0, 653, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  496, 496, 496, 496, 496, 496, 496, 496, 0, 942, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1913, 0, 0, 0, 1033, 0,
  1034, 0, 0, 0, 0, 0, 0, 1034, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1354, 0, 0, 0, 0, 0, 496, 1143, 496, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 496, 1759, 496, 1195, 0, 0, 0, 853, 91311, 1133, 856, 520, 520, 520, 520, 520,
  1211, 520, 520, 520, 890, 892, 520, 520, 902, 520, 520, 520, 520, 910, 496, 0, 0, 0, 853, 91311, 1133, 856, 520, 520,
  520, 520, 520, 520, 520, 1216, 0, 520, 520, 496, 496, 1143, 496, 496, 496, 496, 496, 520, 520, 1211, 520, 520, 520,
  907, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2658304, 0, 2785280, 0, 0, 0, 1539, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1547, 520, 520, 520, 520, 520, 520, 2353, 520, 520, 520, 520, 496, 496, 520, 520, 0, 520, 520, 1556, 520,
  520, 520, 520, 520, 520, 520, 520, 520, 1566, 520, 520, 520, 520, 1235, 520, 520, 1237, 520, 1239, 520, 520, 520, 520,
  520, 520, 520, 1258, 520, 520, 520, 520, 520, 496, 496, 0, 0, 0, 0, 1793, 520, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 1803, 0, 0, 0, 0, 1853, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2441, 496, 496, 496, 496, 0, 0, 0, 2186, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1886, 0, 0, 0, 496, 520, 520, 520, 520, 520, 520, 520, 2392, 520, 520, 520, 520, 520, 520,
  520, 1225, 520, 520, 520, 520, 520, 520, 520, 520, 1562, 1563, 520, 520, 520, 520, 520, 520, 520, 2559, 520, 0, 0, 0,
  0, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 1287, 0, 0, 0, 1293, 0, 0, 0, 0, 0, 0, 0, 976, 0, 0, 0, 0, 0, 316,
  316, 0, 0, 0, 360, 0, 0, 0, 0, 0, 0, 0, 0, 360, 0, 0, 45056, 49152, 0, 360, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  400, 400, 400, 400, 1923, 400, 400, 400, 400, 400, 400, 0, 342, 0, 0, 0, 0, 0, 0, 0, 0, 513, 0, 513, 513, 513, 513,
  538, 513, 513, 513, 513, 513, 513, 513, 513, 538, 538, 538, 538, 538, 538, 538, 513, 513, 538, 53494, 53494, 2, 2, 3,
  94212, 5, 6, 0, 0, 0, 0, 0, 111009, 111009, 111009, 111009, 111009, 417, 417, 417, 417, 417, 111009, 496, 496, 496,
  810, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2138, 496, 496, 496, 496, 400, 1065, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 1704, 0, 0, 0, 0, 0, 0, 0, 1088, 0, 0, 0, 0, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 1693, 1694, 400, 496, 496, 496, 1148, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  496, 496, 2258, 496, 496, 520, 520, 496, 496, 496, 1164, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,
  1967, 496, 496, 496, 496, 496, 0, 520, 520, 496, 496, 496, 1164, 496, 496, 496, 496, 520, 520, 520, 1232, 520, 520,
  1234, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1245, 1246, 520, 520, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1884, 0, 0, 0, 0, 0, 0, 1423, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2093, 400, 0, 0, 0, 382, 40960, 382,
  382, 0, 382, 382, 312, 382, 0, 382, 416, 416, 416, 416, 416, 0, 0, 0, 0, 0, 458, 458, 458, 458, 458, 458, 458, 469,
  458, 458, 458, 458, 458, 458, 480, 458, 458, 458, 458, 469, 458, 490, 490, 490, 494, 490, 514, 490, 514, 514, 514,
  514, 539, 514, 514, 514, 514, 514, 514, 514, 514, 539, 539, 539, 539, 539, 539, 539, 555, 555, 564, 53494, 53494, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 135168,
  135168, 0, 520, 520, 496, 496, 496, 496, 496, 839, 496, 496, 0, 520, 520, 520, 520, 520, 2155, 520, 520, 520, 520,
  520, 520, 520, 520, 520, 520, 520, 2028, 520, 520, 520, 520, 520, 899, 520, 520, 53494, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1023, 0, 0, 0, 0, 0, 0, 496, 496, 496, 496, 1962, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1982, 496,
  496, 496, 496, 496, 520, 520, 2006, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 1565, 520, 520,
  520, 520, 540, 515, 515, 515, 515, 515, 515, 515, 515, 540, 540, 540, 540, 540, 540, 540, 515, 515, 540, 53494, 53494,
  2, 2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 151552, 2105344, 264, 265, 0, 208896, 0, 0, 0, 0, 0, 0, 0, 1715, 0, 0, 0, 0, 0,
  0, 0, 400, 0, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 2330, 496, 496, 496, 496, 496, 0, 0, 0, 628, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1900, 0, 0, 0, 657, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 225280, 400, 400, 400,
  711, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 573440, 0, 0, 0, 496, 496, 0, 737, 0, 0, 0, 0, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 1416, 400, 400, 1419, 0, 0, 0, 0, 496, 496, 496, 811, 496, 496, 496, 496,
  496, 496, 496, 496, 496, 496, 496, 496, 2129, 496, 496, 496, 496, 496, 0, 0, 972, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316,
  316, 0, 0, 0, 0, 1102, 0, 1057, 1091, 0, 0, 0, 0, 0, 0, 0, 1102, 0, 999, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2207, 0, 0, 0, 1016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1029, 1789, 0, 0, 0, 520, 520, 520, 520, 520, 520, 520, 520,
  520, 520, 520, 520, 1581, 520, 520, 520, 496, 579, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1019904, 0, 520, 520,
  496, 496, 496, 496, 496, 496, 843, 496, 0, 520, 520, 520, 520, 520, 2280, 520, 520, 520, 496, 496, 496, 520, 520, 520,
  0, 0, 2178, 0, 0, 0, 0, 0, 0, 2182, 0, 0, 0, 0, 0, 1304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163840, 163840, 163840,
  163840, 163840, 496, 1489, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1771, 496, 1520, 520,
  520, 520, 520, 520, 520, 520, 520, 1533, 520, 520, 520, 520, 520, 520, 520, 975368, 520, 520, 520, 496, 496, 520, 520,
  0, 1747, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 1971, 496, 1843, 1844, 496, 496,
  496, 496, 496, 496, 496, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 520, 0, 0, 1877, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2301, 0, 496, 496, 496, 1987, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2050, 0, 0, 0, 520, 2031, 496,
  520, 496, 496, 496, 496, 520, 520, 520, 520, 0, 0, 0, 0, 496, 496, 496, 2563, 520, 520, 520, 2565, 0, 0, 0, 0, 0,
  40960, 0, 0, 0, 0, 0, 0, 0, 397, 0, 400, 400, 0, 496, 496, 2240, 496, 496, 496, 496, 496, 496, 2245, 496, 496, 496, 0,
  0, 496, 0, 520, 520, 520, 520, 520, 871, 520, 520, 520, 520, 520, 2512, 520, 520, 0, 2515, 0, 0, 0, 0, 0, 0, 0, 1005,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 962560, 0, 1052672, 0, 2295, 0, 0, 1085440, 316, 0, 0, 1085440, 0, 0, 0, 0, 0, 1085440, 0,
  0, 0, 0, 0, 1085440, 0, 1085440, 0, 0, 0, 1085440, 1085811, 1085811, 0, 0, 1085440, 0, 0, 1085440, 0, 0, 0, 0, 0,
  1085440, 0, 0, 0, 0, 0, 0, 1427, 0, 1429, 0, 0, 1431, 0, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 0, 599, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1021, 1021, 0, 0, 0, 0, 0, 0, 0, 1085811, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1085440, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1085440, 0, 1085440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 49152, 0, 1085440, 1085440, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1085440, 0, 0, 0, 0, 0, 1085440, 1085440, 1085440, 0, 0, 0, 1085440, 1085440, 0, 0, 0,
  2, 4263936, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840,
  163840, 163840, 163840, 163840, 163840, 163840, 163840, 0, 0, 0, 307200, 0, 0, 2105344, 264, 265, 0, 0, 0, 0, 0, 0, 0,
  264, 265, 0, 0, 0, 0, 0, 577, 0, 0, 0, 1089536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1101824, 372, 372, 2162688,
  2162688, 2162688, 2162688, 0, 4263936, 6, 0, 0, 0, 0, 0, 0, 0, 2441216, 2449408, 2162688, 2162688, 2162688, 4263936,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2076, 0, 0, 0, 1093632, 0, 1093632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2091,
  2092, 0, 2094, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 1094066, 0, 1094066,
  0, 0, 0, 0, 0, 0, 1437, 0, 0, 0, 400, 400, 400, 400, 1443, 400, 0, 0, 1094066, 1094066, 1094066, 0, 0, 2, 2, 3, 94212,
  5, 6, 0, 0, 0, 0, 0, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032, 172032,
  172032, 172032, 172032, 172032, 0, 1097728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233472, 0, 0, 1101824, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245760, 0, 1102198, 0, 0, 0, 372, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 0, 0, 0,
  0, 0, 0, 0, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198, 1102198,
  1102198, 1102198, 1102198, 1102198, 1102198, 0, 1102198, 0, 0, 0, 0, 1101824, 374, 1102198, 1102198, 1102198, 0, 0, 2,
  2, 3, 94212, 5, 6, 0, 0, 0, 0, 0, 188834, 188834, 188834, 188834, 188834, 0, 0, 0, 0, 0, 188834, 0, 0, 0, 1110016, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106496, 0, 0, 0, 2162688, 0, 0, 0, 1198, 0, 0, 1201, 2162688, 2441216, 2449408,
  2162688, 2162688, 2162688, 2162688, 2162688, 0, 2, 6, 0, 0, 0, 0, 933, 937, 0, 2441216, 2449408, 0, 0, 0, 0, 106496,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2158592, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496,
  106496, 106496, 0, 106496, 0, 0, 0, 0, 0, 0, 1633, 0, 0, 0, 0, 0, 0, 1639, 0, 1640, 0, 0, 106496, 106496, 106496, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172032, 172032, 172032, 172032, 172032
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  724, 727, 729, 727, 733, 737, 741, 745, 749, 1487, 1486, 755, 765, 1665, 1117, 1944, 773, 777, 1486, 781, 1142, 787,
  767, 1486, 792, 796, 842, 825, 800, 804, 1486, 1464, 810, 849, 2286, 816, 796, 822, 825, 830, 834, 1486, 1754, 788,
  769, 840, 796, 879, 825, 882, 805, 1486, 2390, 846, 795, 1946, 824, 862, 1486, 2435, 853, 796, 860, 866, 1486, 873,
  856, 826, 1486, 894, 818, 898, 876, 885, 904, 1796, 761, 908, 917, 921, 925, 929, 931, 935, 938, 942, 946, 950, 954,
  1486, 888, 1486, 911, 958, 1486, 1486, 1486, 1013, 965, 1486, 1486, 2087, 1486, 1486, 1486, 1486, 1486, 1486, 966,
  1486, 1486, 1486, 1821, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1850, 1486, 1486, 1486, 1486,
  1486, 1486, 1486, 1486, 2081, 1486, 1486, 1486, 1486, 1486, 1486, 1801, 1486, 1486, 1486, 1486, 1486, 2284, 1486,
  1486, 1486, 2284, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 970, 1578, 1067, 974, 979, 983,
  987, 991, 995, 1486, 1486, 1002, 1006, 1010, 1017, 1040, 1026, 1030, 1486, 1486, 2447, 2062, 2044, 1132, 1074, 1486,
  1034, 1486, 1343, 1577, 1486, 975, 869, 1749, 1044, 1056, 1486, 1062, 1486, 1047, 1050, 1486, 1200, 1706, 1071, 1065,
  1486, 1078, 1486, 1574, 1671, 2452, 1085, 1091, 960, 1237, 1486, 1037, 1486, 1095, 1099, 1486, 1107, 1112, 1275, 1121,
  1087, 961, 1275, 1125, 1129, 1986, 1136, 1140, 1984, 1146, 1150, 1154, 2025, 2027, 1486, 1205, 1486, 1221, 1163, 1081,
  1167, 1171, 1481, 1175, 1115, 1450, 1180, 1905, 1184, 1392, 1414, 1902, 1696, 2028, 1448, 1224, 1188, 1194, 1323,
  1624, 1486, 1198, 1549, 1204, 1209, 2244, 836, 1215, 1228, 1232, 1236, 2003, 1241, 2326, 1617, 1247, 1252, 1256, 1260,
  1264, 1268, 1486, 1273, 2419, 1279, 1282, 1286, 1290, 1294, 1486, 1941, 2326, 1298, 1329, 1302, 1306, 1743, 2104,
  1312, 1316, 1320, 1663, 1333, 1340, 2366, 1358, 1362, 2426, 1366, 1370, 1374, 1378, 1382, 1386, 1157, 1486, 1390,
  1498, 1396, 1400, 1404, 1408, 1412, 2356, 1952, 1418, 1424, 1428, 1432, 1442, 1446, 1454, 1458, 1463, 1468, 1420,
  1472, 1708, 2469, 1476, 1480, 1666, 1485, 2111, 1218, 758, 1491, 1814, 1495, 2224, 751, 1486, 806, 1502, 2222, 1564,
  758, 1507, 1571, 1511, 1540, 1486, 1269, 1515, 1486, 1520, 1524, 1528, 1102, 1532, 1486, 1538, 1923, 1544, 1637, 1640,
  1548, 2198, 1924, 1470, 1553, 1559, 1563, 1568, 1584, 1891, 1588, 2114, 1592, 1603, 1607, 1611, 1621, 1630, 1634,
  1486, 1673, 1760, 1644, 1648, 1652, 1656, 1660, 1486, 1670, 2202, 2206, 1677, 1681, 1685, 1689, 1973, 1693, 1958,
  2200, 2204, 2363, 1703, 1712, 1716, 783, 1486, 812, 1326, 1918, 1720, 1724, 1336, 1856, 1728, 1732, 2059, 1486, 1807,
  2273, 1672, 1737, 1741, 1747, 1753, 1758, 1764, 1486, 1770, 1486, 2010, 1777, 1783, 1459, 1733, 1486, 1103, 1486,
  1789, 1934, 2436, 1779, 1516, 1486, 1793, 1800, 1437, 1805, 1811, 1820, 1825, 1834, 1831, 1438, 1838, 1844, 1773,
  1840, 1848, 1486, 1486, 1486, 1854, 1860, 1864, 1868, 1872, 1876, 1880, 1534, 1595, 1599, 1885, 1889, 2316, 1895,
  1899, 1909, 1486, 1913, 1597, 1917, 1922, 2002, 1928, 1932, 1938, 1993, 1950, 1956, 2038, 1962, 1966, 1971, 1977,
  1981, 1486, 1990, 1486, 1998, 2008, 2254, 2014, 2018, 2000, 2022, 1503, 2032, 1486, 2036, 2042, 2048, 2052, 2466,
  2056, 1346, 2066, 1349, 2071, 2125, 2075, 2079, 2085, 2091, 2095, 2099, 2108, 2118, 2122, 2129, 2133, 1354, 2137,
  2141, 2145, 2149, 2153, 2157, 2161, 2165, 2169, 1486, 1108, 2173, 2305, 2178, 2182, 2186, 2189, 1486, 2195, 2211,
  2215, 1190, 2219, 2228, 2232, 2344, 2236, 2441, 2242, 2248, 2252, 2267, 2258, 2262, 1579, 2271, 2067, 2277, 1486,
  2281, 2290, 2102, 1555, 2294, 1753, 1580, 2349, 2174, 2298, 1486, 2302, 2309, 2285, 2313, 2320, 2004, 2325, 1994,
  2330, 1058, 2334, 2381, 2338, 1486, 2342, 1486, 2348, 1699, 2354, 2360, 1243, 1486, 2370, 2374, 1308, 1827, 1022,
  2378, 1159, 2265, 2385, 1881, 2388, 2394, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 2191, 2398, 2402, 2406, 2410,
  2414, 1486, 1579, 2418, 2474, 2207, 1176, 1785, 2423, 998, 2430, 1486, 2480, 1486, 1486, 2434, 1486, 2459, 2440, 900,
  1486, 913, 2445, 2479, 1486, 1486, 2451, 1486, 2456, 1486, 997, 1486, 890, 2445, 2479, 1486, 1248, 1486, 2463, 1486,
  1767, 1486, 2238, 2473, 2478, 1210, 1486, 2484, 2350, 1486, 2321, 2485, 1486, 1614, 1486, 1020, 1052, 1352, 1211,
  1486, 1486, 1626, 1816, 1486, 1486, 1435, 1486, 1435, 1486, 1486, 1486, 1486, 1486, 1968, 2489, 4545, 2493, 2502,
  2502, 2502, 2502, 2497, 2502, 2514, 2502, 2501, 2507, 2511, 2503, 2518, 2521, 2525, 2532, 2536, 2528, 2540, 2544,
  2547, 4011, 2557, 3494, 3495, 3495, 2574, 2578, 3215, 3495, 2593, 3495, 2553, 3662, 3495, 2674, 2677, 2621, 3495,
  4554, 3012, 3012, 3012, 4425, 3495, 4554, 2649, 2605, 2606, 2668, 2612, 2619, 2687, 4342, 3495, 4412, 3495, 3495,
  2582, 2586, 4543, 3495, 3495, 3010, 3012, 4554, 3012, 4425, 3527, 2674, 2674, 2674, 2674, 2606, 2608, 2628, 2635,
  2640, 4343, 3495, 3495, 3495, 2576, 4540, 2600, 3495, 3495, 2584, 2588, 3013, 2660, 2674, 2674, 2676, 2606, 2674,
  2631, 2685, 2606, 2606, 2606, 2606, 2691, 2606, 2607, 2646, 2635, 2653, 2750, 3495, 3495, 2595, 2833, 3012, 2659,
  2674, 2674, 4385, 2606, 3012, 3495, 3495, 4673, 3012, 3012, 3014, 3012, 3015, 4671, 3562, 2674, 2674, 2675, 2682,
  2606, 2606, 2606, 2672, 2621, 2606, 2607, 2692, 3495, 2815, 3495, 3035, 3495, 4671, 4424, 3009, 2701, 2674, 2674,
  2615, 2666, 2606, 2606, 2673, 2636, 2606, 2711, 3495, 2727, 3495, 3495, 2597, 3495, 3495, 4672, 3015, 3561, 2606,
  2697, 3495, 3495, 2596, 2600, 3542, 2674, 2635, 2678, 2660, 2675, 2606, 3495, 2829, 3495, 3495, 2598, 3495, 2674,
  2636, 2622, 3529, 2693, 3529, 2693, 3530, 2718, 2720, 3626, 2724, 2742, 2746, 2749, 2749, 2749, 2642, 2754, 2758,
  2762, 2749, 2749, 2802, 2655, 2764, 2768, 2772, 2776, 2780, 2784, 2788, 2792, 2796, 2799, 2806, 2810, 2814, 3234,
  3516, 2824, 3495, 4809, 3407, 3495, 3495, 3495, 3082, 3931, 3495, 3495, 3495, 2974, 4031, 2857, 3495, 2863, 2886,
  3495, 3495, 3495, 3064, 2882, 3363, 2995, 3712, 2893, 2897, 2901, 2905, 2909, 2913, 2917, 2920, 2924, 2928, 3495,
  2932, 4293, 3004, 3495, 3495, 2599, 3495, 3495, 2943, 2951, 3714, 2815, 4305, 2957, 3495, 3350, 2963, 4238, 2968,
  3495, 2837, 3495, 2850, 4120, 2972, 2978, 3495, 2853, 3495, 3495, 4720, 3495, 2991, 3495, 4833, 2999, 3521, 2993,
  4552, 3003, 3495, 4572, 3021, 3495, 2959, 4330, 3495, 2984, 3495, 4520, 4738, 3495, 3360, 3495, 3052, 4611, 3495,
  3056, 3495, 3495, 2851, 3495, 3276, 4747, 3495, 3495, 2738, 4292, 3495, 4745, 3024, 3495, 3071, 3495, 3495, 2872,
  2879, 4239, 3495, 3495, 4613, 3495, 4211, 3023, 3495, 4184, 3072, 3495, 3118, 3122, 3125, 3495, 4126, 2819, 3495,
  3495, 3076, 3462, 3495, 2844, 3277, 3978, 3495, 4305, 2736, 3461, 3495, 3277, 2819, 3495, 3495, 3495, 3549, 3508,
  3495, 3495, 3495, 3147, 3495, 4245, 3083, 3495, 3152, 3495, 3495, 3009, 3012, 4126, 3463, 3495, 3277, 4127, 3461,
  3276, 3509, 3495, 4184, 3077, 3495, 3158, 3495, 3008, 3096, 2707, 3495, 2706, 3495, 4023, 3495, 3495, 2964, 3978,
  3250, 3249, 3495, 3088, 4617, 4616, 3391, 4615, 3495, 4618, 3393, 4617, 4609, 3495, 3495, 3092, 3495, 3495, 4582,
  4614, 3464, 3129, 3131, 3130, 3135, 3139, 3141, 3141, 3145, 3198, 3495, 3495, 3495, 3223, 4683, 4587, 3732, 3162,
  3172, 3495, 3176, 3181, 4803, 3243, 3495, 3495, 3016, 4504, 4261, 3495, 3715, 3260, 3402, 3406, 3495, 3495, 3063,
  3495, 3607, 3495, 3025, 3105, 3109, 3109, 3495, 3495, 3495, 3230, 3495, 3731, 4049, 3199, 3495, 3232, 3977, 3495,
  3246, 3114, 3495, 3203, 3209, 3219, 3193, 3495, 3282, 3293, 4442, 3495, 3495, 3298, 3302, 3495, 3495, 3495, 3278,
  3300, 3304, 3495, 3495, 3066, 4453, 3311, 3495, 3495, 3495, 3286, 3248, 3495, 3495, 3227, 2868, 3318, 2824, 3322,
  2550, 3495, 4442, 3716, 3294, 4430, 3495, 4068, 3329, 3495, 3495, 3495, 3289, 4069, 3330, 3495, 3495, 3089, 3495,
  4429, 3287, 3334, 3495, 3247, 3495, 3224, 4249, 2831, 3219, 3733, 3338, 3495, 4430, 3293, 4443, 3025, 3344, 3349,
  3418, 3354, 3495, 4619, 3732, 3400, 4429, 3367, 4003, 3345, 3495, 3495, 3090, 3090, 3354, 3495, 3390, 3220, 3485,
  3235, 3397, 4441, 3413, 4003, 3422, 3495, 3269, 3275, 3495, 3220, 3222, 3495, 3221, 3484, 3234, 3443, 3450, 4619,
  3495, 3284, 3370, 3438, 3485, 3933, 3456, 3968, 3031, 4611, 3495, 2986, 4020, 3495, 2987, 4021, 3495, 3026, 3495,
  3495, 4728, 4375, 3476, 3495, 3025, 3482, 3490, 3265, 3495, 3921, 3233, 3505, 4782, 4780, 2596, 3513, 2624, 2623,
  2596, 4039, 4178, 4177, 4037, 4176, 4175, 3436, 4039, 3520, 4669, 3525, 3250, 4666, 3250, 4606, 3232, 3534, 3495,
  3495, 3180, 3185, 3884, 3546, 3495, 4340, 3554, 3558, 3566, 3569, 3573, 3577, 3582, 3580, 3586, 3589, 3593, 3593,
  3594, 3598, 3495, 3495, 3191, 3495, 3826, 3495, 3820, 3495, 3439, 4303, 3439, 4250, 3495, 3425, 2596, 3605, 3495,
  4625, 2601, 4200, 3373, 3495, 3285, 3495, 3495, 4795, 3495, 4094, 3611, 4637, 2980, 3016, 3620, 3624, 3495, 3495,
  3225, 3495, 3495, 4565, 3630, 3495, 3495, 2564, 4014, 3495, 3495, 3495, 3313, 4598, 3495, 3495, 3495, 3416, 2552,
  3799, 3826, 3495, 3253, 3427, 3495, 3636, 3084, 4694, 3495, 2566, 2570, 3495, 3495, 3495, 3446, 2572, 3495, 3495,
  3495, 3495, 2561, 3779, 3666, 3437, 3963, 3671, 3495, 4709, 3495, 3313, 3495, 3540, 2580, 3495, 3495, 3495, 3500,
  2973, 4845, 4585, 3535, 3709, 3495, 3495, 3224, 3721, 3495, 3495, 3495, 3548, 3931, 3495, 2552, 3725, 3495, 4784,
  3485, 3253, 3427, 3495, 3729, 4272, 3287, 3737, 3495, 3495, 3287, 4291, 3288, 3738, 3495, 3495, 3288, 3720, 4554,
  3823, 3339, 3743, 3739, 3495, 3495, 3495, 3607, 3340, 3759, 3495, 3495, 3376, 3495, 3765, 3495, 3495, 3749, 3730,
  3495, 3495, 3235, 3495, 3770, 3495, 3535, 4614, 3495, 3700, 3495, 3357, 4612, 3689, 2867, 3495, 3495, 3495, 3025,
  4232, 3774, 2819, 3495, 3792, 3495, 4162, 3783, 3038, 3495, 4630, 3255, 3495, 3392, 4183, 2938, 2839, 2843, 4166,
  3495, 3231, 3229, 3495, 3255, 3285, 3284, 3495, 3256, 3231, 3230, 3254, 3229, 3495, 3495, 4428, 3495, 3495, 3446,
  3228, 3495, 3813, 3495, 3404, 3495, 3495, 3027, 3495, 3231, 3789, 3285, 3789, 3285, 3803, 3812, 3495, 3426, 3495,
  3753, 3495, 3495, 3676, 4426, 3495, 4337, 3832, 2831, 2815, 3841, 3845, 4529, 3853, 3857, 3861, 3863, 3867, 3871,
  3874, 3877, 3888, 3880, 3495, 3432, 3436, 3495, 3495, 3495, 2568, 3907, 3977, 3495, 3495, 3495, 3066, 3817, 3041,
  4563, 3025, 3911, 3495, 4097, 2889, 2859, 3917, 3972, 3925, 3929, 3938, 3263, 3500, 3942, 3956, 3495, 3967, 3495,
  3445, 3197, 3495, 3213, 3247, 2953, 3495, 4654, 3983, 3495, 3478, 2963, 3495, 4648, 2963, 4500, 3991, 3945, 3995,
  3944, 4820, 4631, 3436, 4001, 3495, 3495, 4418, 4008, 4029, 3495, 3494, 3979, 4035, 4822, 3110, 3495, 4793, 3495,
  3495, 3548, 4046, 3495, 3495, 4418, 4053, 3904, 3495, 3495, 3384, 3435, 4399, 3437, 3495, 3495, 3428, 3495, 3465,
  3495, 3495, 3495, 3684, 4556, 2938, 3495, 3495, 3486, 3495, 3495, 4839, 4057, 3495, 3495, 4808, 3495, 3495, 4840,
  3495, 3496, 3495, 3499, 3314, 4073, 3495, 3495, 3550, 3495, 2596, 4324, 3495, 3495, 3615, 4353, 3495, 4082, 4555,
  4041, 4304, 2973, 4248, 3495, 3527, 3529, 2678, 3808, 3495, 3495, 3495, 3746, 3495, 4444, 3495, 3495, 3644, 3495,
  3484, 3495, 4042, 3495, 3536, 3495, 3495, 3231, 3495, 3667, 3495, 3495, 3495, 3837, 3495, 4088, 3495, 3495, 3695,
  3083, 4564, 3495, 3495, 4796, 3495, 3485, 3895, 3439, 3496, 3495, 3498, 3497, 3495, 4246, 3495, 3971, 3970, 3969,
  3496, 3495, 3495, 3748, 3495, 3495, 4112, 3495, 3495, 3762, 3495, 4084, 2994, 3495, 3971, 4101, 4105, 3997, 4109,
  4118, 4124, 4131, 4135, 4138, 4145, 4147, 4142, 4151, 4155, 4156, 4156, 4160, 3495, 3495, 3495, 3898, 3495, 3972,
  3495, 4174, 3495, 4182, 3495, 3495, 3766, 3495, 4199, 4204, 2730, 4208, 3495, 4215, 4221, 3495, 3607, 3828, 3495,
  3205, 3495, 3168, 4227, 3495, 3913, 3101, 3495, 4290, 3495, 4024, 4243, 3495, 3495, 3495, 3905, 2846, 3495, 3495,
  3495, 3932, 3795, 4254, 4259, 4265, 3099, 3495, 4210, 3495, 3495, 3807, 4564, 3495, 3958, 3962, 3495, 3632, 3386,
  3495, 3249, 2674, 2674, 2614, 2664, 3500, 3960, 3495, 3495, 3883, 3799, 4506, 4506, 3495, 3495, 3906, 3976, 4025,
  3495, 4715, 4276, 4527, 3065, 3495, 3495, 3944, 3495, 4280, 3495, 3495, 3949, 4846, 3986, 3495, 3495, 3097, 3501,
  2816, 3495, 3252, 3250, 3495, 3088, 3495, 2952, 3046, 3962, 3495, 4271, 3495, 3495, 3495, 4004, 3044, 3048, 3495,
  3495, 3987, 3495, 3495, 3495, 4003, 4687, 4363, 4363, 3495, 3495, 4065, 3495, 4025, 3495, 4297, 2841, 4371, 3495,
  3495, 3785, 2816, 4319, 2818, 3251, 3495, 2704, 3495, 3495, 3495, 3152, 4019, 3339, 3495, 3483, 2986, 4310, 3495,
  3495, 4113, 3495, 2817, 3099, 3495, 3495, 4217, 3495, 4112, 3495, 4183, 4314, 2842, 3091, 3495, 3409, 4318, 3099,
  4618, 3495, 3642, 3646, 3495, 3493, 3452, 2979, 4323, 3495, 3495, 3495, 4191, 3098, 3100, 3495, 4114, 3408, 4553,
  4223, 3097, 2816, 4618, 3495, 3495, 4248, 3495, 4018, 4022, 3495, 3495, 4255, 3495, 3495, 4016, 4020, 3097, 2818,
  4642, 3600, 2946, 2875, 3065, 3409, 3495, 3650, 3495, 3495, 4427, 3444, 3835, 4334, 4618, 3495, 3654, 3654, 3495,
  3307, 3495, 3306, 4347, 3495, 3495, 3067, 4351, 3849, 3187, 3601, 2947, 4328, 4244, 4357, 3065, 3755, 3599, 3847,
  4361, 3495, 4367, 4391, 2845, 3231, 4383, 3495, 4728, 3495, 4727, 4389, 2844, 4078, 4059, 3495, 4061, 4395, 4610,
  4703, 4702, 4396, 4059, 4058, 4369, 4398, 4061, 4060, 4396, 4701, 4059, 2852, 4403, 4076, 4403, 4407, 4416, 4422,
  4425, 4435, 3495, 3495, 3495, 4230, 4653, 4448, 4457, 4575, 4461, 4465, 4469, 4473, 4477, 4481, 4485, 4489, 4491,
  3495, 3495, 4267, 4724, 3495, 4592, 4002, 3495, 3678, 3495, 3495, 3314, 3892, 3902, 3495, 3459, 3495, 3495, 3229,
  3495, 3248, 3495, 4170, 3236, 4495, 4499, 3066, 2589, 3495, 4510, 4518, 3495, 3682, 3682, 3495, 3688, 3693, 4524,
  4533, 3016, 4537, 4549, 3951, 3495, 4560, 4579, 3059, 3495, 3495, 4285, 3495, 4596, 3495, 3248, 3495, 3495, 3223,
  4170, 2820, 2939, 4499, 3472, 3747, 3495, 3495, 4289, 3495, 3616, 4623, 3495, 4629, 3495, 4635, 4641, 3495, 3696,
  3495, 3495, 4603, 3495, 4193, 4237, 3495, 3495, 4410, 3495, 4195, 3495, 3225, 3225, 3148, 4646, 4619, 3495, 3747,
  3495, 3495, 3495, 3011, 2733, 3703, 3237, 4659, 3658, 3017, 3495, 4512, 4234, 3495, 3225, 3225, 4090, 4646, 4619,
  3495, 3777, 2714, 4439, 4168, 4652, 4658, 3648, 4663, 3656, 4677, 3495, 3778, 4188, 2935, 4514, 3495, 3495, 3495,
  4398, 4692, 3495, 3495, 3495, 4428, 4688, 3024, 3226, 3223, 3390, 4169, 3798, 3471, 3378, 4698, 3495, 4707, 4378,
  4235, 3495, 3495, 4569, 3495, 4379, 4236, 3495, 3495, 3495, 4397, 3705, 3745, 3495, 3495, 4599, 3495, 3271, 3091,
  3090, 3495, 3805, 3078, 3495, 3469, 3495, 3025, 4451, 3083, 3495, 3211, 3246, 2952, 4791, 3746, 3155, 3495, 4713,
  4247, 3495, 3495, 4823, 4719, 3495, 4306, 3495, 3897, 3495, 3495, 4671, 3012, 3495, 3969, 3495, 3971, 2594, 4564,
  2595, 4737, 3495, 4732, 4736, 4734, 3325, 4742, 4300, 4751, 4754, 4755, 4759, 4763, 4767, 4773, 4769, 4777, 4814,
  3495, 3495, 3495, 4442, 2825, 3495, 4800, 3495, 3920, 3495, 3164, 4807, 3495, 3674, 3614, 3286, 3495, 3495, 3495,
  4554, 3495, 4827, 3495, 3495, 3495, 4591, 3238, 3238, 3495, 3495, 4680, 3495, 3228, 3495, 3495, 3495, 4682, 4832,
  4282, 4837, 3495, 3934, 3495, 4818, 4431, 3495, 4284, 3495, 3952, 4183, 3495, 3640, 3380, 4828, 3239, 3495, 3495,
  3495, 4788, 4003, 3495, 3495, 3495, 4813, 3495, 4430, 3495, 3495, 3495, 4844, 5165, 5336, 5499, 5606, 5018, 4861,
  4865, 4880, 4897, 4879, 4880, 4881, 4872, 4877, 4877, 4877, 4877, 4900, 4878, 4882, 4878, 4874, 4876, 4877, 4896,
  4877, 4878, 4870, 4882, 4902, 4904, 4906, 4915, 4908, 4908, 4909, 4912, 4911, 4910, 4908, 4920, 5141, 4923, 4914,
  4915, 4907, 4917, 4915, 4918, 4907, 4908, 4922, 4925, 4927, 4926, 4929, 4930, 4932, 4930, 4934, 4936, 5165, 5296,
  4856, 4856, 4968, 4942, 4856, 5252, 4856, 4883, 4954, 4856, 5223, 5639, 4856, 4855, 4856, 4856, 5019, 5502, 5005,
  5253, 5047, 5337, 4856, 4856, 5019, 5517, 5485, 5103, 5493, 4952, 4856, 4856, 5019, 5587, 5286, 5491, 5736, 5168,
  4856, 4856, 5498, 4976, 4856, 4970, 4856, 4856, 4856, 4886, 4958, 4856, 4856, 4856, 4887, 4978, 5348, 5348, 5348,
  5348, 5349, 5006, 4984, 5349, 5350, 5350, 4946, 5089, 5089, 5350, 5006, 5348, 5348, 4856, 4856, 5087, 5246, 4856,
  5344, 5349, 5350, 5350, 5006, 5089, 5273, 5350, 5528, 5348, 5348, 5348, 5348, 4985, 5106, 5106, 5106, 5045, 5528,
  5349, 5350, 5350, 5006, 5140, 5048, 5348, 4979, 5106, 5106, 5106, 5075, 5004, 4856, 4856, 5350, 5350, 5089, 5015,
  5346, 5346, 5348, 5348, 5350, 4856, 5348, 5528, 5350, 5350, 5350, 5350, 5348, 5348, 5348, 5049, 5350, 5088, 5015,
  5347, 5348, 5348, 5348, 5165, 5032, 5349, 5350, 5348, 5049, 4856, 5087, 5348, 5349, 5528, 5049, 5004, 4968, 5003,
  5087, 4856, 4856, 5087, 5336, 4856, 4856, 5348, 5349, 5049, 4856, 4856, 5606, 5635, 5087, 5528, 5349, 5349, 5049,
  4856, 4856, 5263, 5021, 4942, 4851, 4944, 4856, 4856, 5634, 4856, 4856, 5635, 5293, 5079, 4856, 4856, 4886, 4993,
  4955, 5024, 5109, 5071, 5065, 4862, 5118, 5106, 5106, 5106, 5106, 4943, 5110, 4981, 5107, 5058, 5070, 5060, 5064,
  5067, 4863, 5117, 5106, 5106, 5106, 5077, 5146, 5086, 5114, 5108, 5062, 5064, 5106, 5061, 5116, 5061, 4980, 4982,
  5120, 5122, 5123, 5124, 5125, 5126, 5128, 5132, 5135, 5137, 5130, 5136, 5131, 5134, 5131, 5131, 5130, 5125, 5125,
  5139, 4942, 5024, 5106, 5110, 5069, 5073, 5143, 5145, 5148, 5150, 5153, 5152, 5153, 5154, 5156, 4856, 4856, 4856,
  4942, 5079, 4856, 4856, 4856, 4946, 5224, 4856, 4856, 4856, 4948, 4856, 5663, 4856, 4856, 4851, 4856, 5092, 5224,
  4856, 5658, 5050, 4856, 4956, 5628, 5167, 4856, 5604, 4856, 4856, 4957, 5788, 5158, 4856, 4856, 4856, 4958, 4856,
  4856, 4886, 5094, 4856, 4856, 4853, 4856, 4856, 5223, 5163, 5296, 5247, 4856, 4856, 4856, 4970, 4856, 5281, 4856,
  4956, 5628, 5168, 5604, 4958, 4856, 5223, 5281, 5224, 5639, 5272, 5223, 5415, 5637, 4856, 4856, 5640, 4852, 5583,
  4856, 5638, 5046, 5189, 5189, 5189, 5190, 5191, 5192, 5195, 5194, 5197, 5198, 5198, 5199, 5202, 5198, 5198, 5201,
  5198, 5198, 5205, 5205, 5203, 5203, 5207, 5209, 5209, 5209, 5210, 5211, 5213, 5214, 5214, 5216, 5214, 5218, 5220,
  4886, 5091, 5333, 4856, 4856, 5644, 4856, 4856, 5650, 4856, 5252, 4856, 5231, 5237, 4856, 4856, 5650, 5050, 4956,
  5358, 4856, 4856, 4856, 4987, 4856, 4856, 5240, 4856, 4856, 4877, 5032, 5292, 4856, 4856, 4856, 4992, 4856, 5292,
  4856, 5256, 5378, 4856, 4856, 4856, 4998, 4856, 5258, 5241, 4856, 4856, 4856, 4999, 4856, 5475, 4856, 4856, 4884,
  5112, 5101, 4856, 5474, 5338, 4856, 4856, 4856, 5002, 5359, 5181, 5782, 5482, 5500, 5415, 5295, 5636, 5606, 4856,
  5275, 4856, 4856, 4856, 5004, 5004, 5004, 5004, 4856, 4856, 4856, 4893, 5097, 4856, 5509, 5278, 5168, 4856, 4856,
  4856, 5019, 4856, 4856, 4856, 5575, 5096, 5032, 5293, 5300, 5289, 4856, 4856, 5671, 5671, 5183, 5002, 4856, 4856,
  5673, 5100, 5102, 5271, 5667, 4856, 5360, 5360, 5096, 5032, 5498, 5233, 5606, 4856, 4856, 5729, 5168, 4856, 5735,
  5055, 4856, 4856, 4856, 5021, 5100, 5422, 5487, 5686, 4856, 4856, 5422, 5744, 4856, 4856, 4856, 5050, 5498, 5251,
  4856, 4856, 4856, 5043, 5567, 4856, 4856, 4856, 5055, 4856, 4856, 5055, 4987, 4856, 4856, 4856, 5078, 4856, 4856,
  4856, 5081, 5330, 5090, 5176, 5232, 5668, 4856, 4856, 4856, 5083, 5053, 5033, 5262, 5187, 5385, 4970, 5041, 5386,
  5306, 5309, 5311, 5312, 5312, 5314, 5316, 5318, 5319, 5319, 5319, 5319, 5322, 5319, 5322, 5321, 5321, 5324, 5324,
  5325, 5325, 5325, 5325, 5326, 5327, 4856, 4856, 4886, 5105, 5026, 4856, 5789, 5034, 4856, 4856, 5743, 4856, 4856,
  5784, 5241, 5341, 4858, 4856, 4856, 4886, 5175, 5339, 4856, 4989, 4964, 5343, 4856, 5355, 4858, 4971, 4857, 4856,
  5758, 4856, 5357, 4856, 4856, 4971, 5362, 5364, 4856, 4856, 4886, 5224, 4973, 5363, 4856, 4856, 4938, 5002, 5175,
  5410, 5296, 5079, 4856, 4856, 4856, 5332, 4856, 4856, 4938, 5353, 4856, 5367, 4856, 4856, 4938, 5743, 4856, 4856,
  4940, 4963, 5334, 4856, 4856, 4856, 5096, 4856, 4856, 4856, 5097, 4856, 4856, 4856, 5091, 4856, 4856, 4856, 5092,
  4856, 4856, 4856, 4947, 4856, 4856, 4946, 5416, 5668, 5168, 4856, 4856, 5789, 4856, 4856, 4856, 5087, 4856, 4856,
  4856, 4938, 4883, 4856, 4856, 4965, 4856, 5374, 4856, 4859, 4856, 4856, 5166, 5244, 5365, 5757, 4856, 4856, 4956,
  4856, 4972, 4856, 4856, 4856, 5159, 5336, 4952, 4988, 4990, 4856, 4856, 4959, 4856, 4856, 4856, 5329, 4967, 5103,
  4856, 5360, 5380, 4856, 4856, 4856, 5382, 5402, 5052, 5508, 5302, 5232, 5388, 4856, 4856, 4966, 5079, 4856, 5410,
  5296, 4856, 4856, 4968, 4856, 4856, 4856, 5252, 4856, 5092, 4856, 5166, 4856, 5390, 4856, 5056, 5751, 5054, 5178,
  5232, 5377, 4856, 5111, 5175, 5410, 5297, 5165, 5297, 4856, 4856, 4856, 5235, 5406, 5052, 5508, 5506, 5180, 5377,
  4856, 4856, 4856, 5244, 5090, 5176, 5032, 4856, 4877, 5735, 4856, 4856, 5735, 4856, 4856, 5727, 5185, 5360, 4987,
  4939, 4856, 4886, 5182, 4856, 4886, 5463, 4856, 4893, 5414, 5168, 4856, 4856, 5495, 4856, 4856, 5382, 5052, 5508,
  5506, 5377, 5018, 4856, 4856, 4856, 5251, 4856, 4856, 4856, 5300, 4856, 5409, 5166, 4856, 4856, 4974, 5302, 5376,
  4952, 4856, 4856, 4856, 4957, 5040, 4856, 5360, 5104, 4856, 4938, 4939, 4856, 5019, 5330, 5052, 5178, 5259, 4856,
  4938, 5031, 4856, 4856, 4856, 5291, 5019, 5412, 5177, 5506, 5180, 4856, 4856, 4856, 4937, 4856, 4856, 4939, 4938,
  4856, 4856, 5329, 5111, 5175, 5329, 5175, 4856, 4856, 4987, 5161, 5300, 4856, 5244, 4856, 4942, 4856, 4856, 5079,
  4856, 4856, 5671, 4856, 4856, 5421, 5675, 5180, 4856, 5021, 5168, 4856, 5160, 5179, 4856, 4856, 4987, 5515, 5174,
  5182, 4856, 4856, 4856, 5252, 4856, 4856, 4856, 5252, 5093, 4856, 4943, 4856, 4856, 4856, 4856, 4883, 4856, 4856,
  4856, 4884, 4987, 4856, 5300, 5166, 5159, 5336, 5079, 4856, 4856, 5175, 4856, 5092, 4856, 4943, 4856, 5270, 5428,
  4856, 4856, 4856, 5261, 4959, 5093, 4856, 5087, 5350, 5350, 5528, 5348, 5049, 5426, 4856, 4856, 4856, 5266, 5032,
  4943, 5498, 4856, 4856, 5003, 5087, 5295, 5297, 4856, 4856, 5003, 5490, 4856, 4856, 5430, 4856, 4856, 5432, 5394,
  4856, 5050, 5003, 5004, 5087, 5350, 5350, 5164, 4856, 5003, 5284, 5285, 5435, 5284, 5434, 5437, 5437, 5437, 5438,
  5439, 5441, 5445, 5444, 5445, 5445, 5445, 5445, 5443, 5445, 5445, 5446, 5447, 5447, 5450, 5449, 5449, 5449, 5449,
  5452, 5453, 4856, 4856, 4856, 5281, 4856, 4856, 5462, 5465, 4856, 4856, 5008, 4856, 5477, 4856, 4886, 4856, 4948,
  4856, 4856, 4856, 5732, 5481, 4856, 4856, 4888, 4890, 4892, 4856, 4856, 5017, 5606, 4889, 4891, 4856, 4856, 5019,
  5406, 4856, 5484, 5351, 5335, 4856, 5780, 4856, 4856, 5021, 5589, 5591, 5079, 4856, 4856, 5022, 4856, 4856, 5498,
  4856, 5504, 4856, 4856, 5029, 5415, 4856, 5473, 4946, 5300, 5567, 5635, 5021, 5182, 4856, 4856, 4937, 5484, 5103,
  5235, 4856, 4949, 4856, 4856, 5517, 5486, 5234, 4952, 4856, 5757, 4856, 4856, 5035, 4958, 5756, 4856, 4856, 4856,
  5295, 4856, 5404, 4856, 4856, 5035, 5267, 5251, 4886, 5103, 5235, 4856, 4958, 5166, 4856, 4946, 5650, 4886, 5519,
  5079, 4856, 4958, 5584, 4856, 4856, 4856, 4989, 4856, 5103, 5487, 5235, 5168, 4856, 4856, 5674, 5567, 5635, 5521,
  5235, 4856, 4856, 4856, 5300, 4856, 5390, 4967, 4997, 5234, 4952, 4856, 4856, 4856, 5466, 5021, 4856, 4856, 5394,
  4856, 4856, 4856, 4967, 5523, 5079, 4856, 4856, 5038, 4856, 4856, 5789, 5079, 4856, 4959, 5418, 4856, 4966, 5525,
  5079, 4856, 4968, 4943, 5166, 5297, 4856, 5789, 5079, 5789, 4886, 4856, 4856, 4856, 5466, 4856, 5266, 4856, 4856,
  5038, 4970, 5266, 4856, 4959, 4856, 4967, 5235, 4856, 4968, 4943, 5300, 4856, 4856, 4947, 5166, 5266, 4856, 5091,
  4856, 4856, 5574, 4856, 4856, 5050, 5091, 4938, 4883, 4856, 4959, 5527, 5307, 5263, 4856, 4998, 5458, 4856, 4943,
  5300, 5251, 5297, 4856, 4856, 5007, 4856, 5269, 5294, 5530, 4856, 5002, 4856, 4856, 5393, 4856, 4987, 4856, 4856,
  5268, 4943, 5293, 4856, 4856, 5078, 4942, 5079, 4856, 5368, 5532, 5741, 4960, 4961, 4961, 4961, 5534, 5536, 5538,
  5539, 5539, 5539, 5539, 5539, 5540, 5539, 5539, 5542, 5541, 5544, 5546, 5552, 5547, 5548, 5548, 5548, 5554, 5550,
  5549, 4856, 5003, 4856, 4942, 5674, 5554, 5554, 5554, 5554, 5079, 4939, 4958, 4998, 5394, 4856, 4856, 5267, 4856,
  4856, 5300, 5294, 5602, 4856, 4856, 4856, 5406, 5351, 5262, 5561, 5254, 4856, 4856, 5080, 5082, 4856, 5560, 5564,
  4856, 5019, 5160, 5246, 4856, 4856, 5607, 4856, 5726, 4856, 5563, 4856, 4856, 5093, 4856, 4856, 4856, 4963, 5626,
  4856, 5645, 5566, 5570, 5572, 4856, 4856, 5167, 4856, 4856, 5569, 5571, 5608, 4856, 4856, 4856, 5630, 4856, 5298,
  4856, 4884, 5580, 5654, 5667, 4856, 4856, 4856, 5511, 4885, 4856, 4856, 4856, 5360, 4856, 4856, 4856, 5020, 5262,
  5606, 4856, 4856, 4856, 5035, 4856, 5028, 5678, 5168, 4856, 5019, 5271, 4856, 4856, 5028, 4898, 4856, 5660, 5642,
  5084, 4856, 4856, 5168, 5604, 5351, 5605, 4856, 4856, 4856, 5382, 5174, 4957, 5466, 4856, 4986, 5393, 5605, 4856,
  4854, 4856, 4856, 5021, 5112, 5101, 4867, 5282, 4856, 4856, 4856, 5567, 4856, 5002, 5394, 5603, 4856, 4856, 5174,
  4856, 4856, 5641, 4856, 4856, 5175, 5092, 4856, 4856, 4998, 5498, 4856, 5527, 5307, 5606, 4856, 5019, 5391, 5301,
  4957, 5466, 4856, 5294, 5736, 4856, 4856, 4856, 5413, 5499, 4856, 4856, 4856, 5527, 5512, 4856, 5019, 5401, 5403,
  5054, 4957, 5466, 4856, 5394, 4856, 4958, 4856, 5006, 4856, 5351, 5606, 4856, 4856, 5250, 4856, 4856, 5221, 4856,
  4856, 5265, 5026, 4856, 5466, 5498, 4856, 5019, 5556, 5558, 4856, 5251, 5180, 4998, 4937, 5021, 5598, 4868, 4856,
  5567, 5248, 4856, 5019, 5596, 5492, 4856, 4856, 4856, 5417, 4856, 4856, 5276, 4856, 5055, 5251, 4856, 4856, 5293,
  5293, 5079, 5013, 5585, 5012, 5011, 5585, 5010, 5600, 5600, 5601, 5466, 5238, 5611, 5616, 5616, 5611, 5611, 5611,
  5611, 5617, 5611, 5619, 5612, 5613, 5614, 5622, 5621, 5621, 5621, 5621, 5624, 5625, 4856, 4856, 5297, 4856, 5753,
  5055, 4856, 4856, 5297, 4987, 4957, 5300, 5009, 4856, 4856, 4856, 5425, 5180, 4856, 4856, 5630, 5002, 4856, 4856,
  4856, 5422, 4856, 5632, 5634, 4856, 5019, 5740, 5391, 5287, 5162, 5229, 4856, 5647, 4856, 4856, 4856, 5471, 4942,
  5634, 4856, 5609, 4885, 4856, 5649, 4856, 4856, 4856, 5509, 5652, 5656, 4856, 4856, 5300, 5292, 4856, 5662, 4856,
  4856, 5360, 5002, 4884, 5653, 5657, 4856, 5019, 5740, 5407, 5005, 4897, 5047, 5229, 4856, 4856, 4856, 5685, 4856,
  5753, 5035, 4856, 4856, 4856, 5498, 4856, 4856, 4856, 4969, 4851, 4887, 4856, 4856, 4856, 5505, 5632, 5079, 4856,
  4856, 5372, 5168, 4856, 5665, 4856, 4856, 5382, 5384, 5181, 4856, 4856, 4856, 5523, 5021, 4938, 5018, 5168, 4856,
  5787, 4856, 4856, 5384, 4856, 4856, 4856, 5786, 4856, 5329, 4897, 4998, 4856, 4856, 4856, 5415, 4856, 5180, 5050,
  4856, 5020, 5091, 4969, 4851, 4856, 4856, 4856, 5293, 4856, 5101, 4867, 5282, 5297, 4856, 5180, 4937, 4956, 5078,
  4856, 4884, 4856, 4856, 4856, 5182, 4856, 4856, 5050, 5628, 5168, 4856, 5032, 4856, 5295, 5078, 4856, 4942, 5079,
  4938, 4958, 4998, 4856, 4856, 5106, 5106, 4856, 4856, 4856, 5680, 4996, 5282, 5352, 5283, 4856, 4856, 5396, 4856,
  5650, 5050, 4938, 5604, 5079, 5006, 4856, 4856, 5397, 5079, 5098, 5460, 5499, 4856, 5604, 4856, 5055, 4856, 4942,
  5419, 5079, 4856, 5021, 5174, 5029, 4897, 5002, 5106, 5006, 4856, 5001, 5345, 4942, 4943, 4856, 5223, 5002, 4856,
  5223, 5604, 4856, 4957, 4856, 4856, 4856, 5574, 5413, 5394, 4856, 5413, 5394, 4856, 4958, 5096, 5096, 4856, 4856,
  5223, 5224, 4968, 5096, 4968, 4856, 5671, 4938, 4968, 5004, 5004, 5004, 4968, 4856, 4856, 4856, 4939, 4856, 4856,
  4856, 4941, 5026, 4994, 5467, 5606, 4987, 4958, 5166, 4856, 4938, 4856, 4856, 4856, 5221, 4946, 5606, 5658, 4856,
  5021, 5749, 5267, 5251, 4856, 5264, 5682, 5753, 5659, 5170, 5169, 5688, 5684, 5171, 5172, 5172, 5172, 5690, 5692,
  5693, 5694, 5700, 5700, 5700, 5700, 5696, 5695, 5700, 5699, 5695, 5700, 5702, 5697, 5704, 5704, 5705, 5705, 5706,
  5706, 5706, 5706, 5707, 5708, 4856, 5180, 4856, 5710, 4945, 4856, 4856, 4856, 5579, 5712, 5168, 4856, 4856, 5397,
  5670, 4856, 5714, 4856, 4856, 5404, 5002, 4856, 5079, 4856, 5716, 4856, 4856, 5454, 4856, 4893, 5719, 5168, 4856,
  5032, 4856, 5606, 5091, 5039, 4893, 4856, 4856, 4894, 5721, 5168, 5723, 4856, 5035, 5036, 5037, 4958, 4856, 4856,
  4850, 4866, 4950, 5725, 5608, 4856, 5040, 4856, 4856, 4856, 5003, 4856, 4856, 5226, 5228, 5168, 4856, 5050, 4856,
  4856, 4856, 5332, 5225, 5227, 5229, 4856, 5050, 5280, 4856, 4856, 5659, 5684, 4856, 5225, 5730, 4856, 5051, 4856,
  4937, 4856, 4851, 4856, 5242, 4856, 4856, 5265, 5025, 5027, 5392, 5392, 5605, 4856, 4856, 5456, 5606, 4856, 4893,
  4995, 4898, 4856, 5093, 4856, 5006, 5006, 4856, 4856, 5096, 5032, 4856, 4856, 4856, 5006, 4856, 4856, 4856, 5018,
  5002, 5472, 4856, 4856, 5469, 5465, 5734, 4856, 4856, 4856, 5635, 4856, 5096, 5738, 4856, 4856, 5479, 4856, 4951,
  4856, 4856, 4856, 5677, 5743, 5605, 4856, 4856, 5489, 5335, 4957, 5300, 4856, 4856, 4856, 5577, 4947, 5180, 4856,
  4851, 4856, 5021, 5746, 4898, 4856, 5093, 4856, 5087, 5180, 4856, 4856, 5003, 5004, 5004, 5004, 5472, 4856, 5097,
  4856, 5096, 5507, 4856, 4856, 4856, 5042, 5174, 5407, 5030, 5335, 5416, 5416, 5168, 4856, 4856, 5497, 4856, 5029,
  5415, 5473, 4856, 5096, 5594, 5032, 4856, 4856, 5035, 5186, 4856, 4856, 5514, 5235, 5293, 5300, 4856, 5180, 4856,
  4937, 4856, 5249, 5423, 4856, 4856, 4970, 4856, 4970, 4856, 5100, 5163, 5032, 4856, 5093, 5095, 4969, 4856, 4856,
  4969, 4856, 4856, 4856, 5717, 5755, 4856, 5752, 4856, 5159, 4986, 5304, 5168, 4856, 4969, 4969, 5098, 5099, 5764,
  5764, 5764, 5760, 5764, 5764, 5762, 5763, 5764, 5765, 5760, 5766, 5768, 5773, 5770, 5770, 5770, 5771, 5771, 5772,
  5770, 5770, 5775, 5777, 5779, 4856, 5159, 5245, 5180, 4856, 4856, 4998, 4956, 4856, 5459, 5035, 4856, 5166, 4856,
  5180, 4856, 4856, 5222, 4856, 4856, 5395, 4856, 5399, 4856, 5166, 4856, 5370, 4856, 5786, 4856, 4856, 4856, 5747,
  5019, 5383, 4947, 4856, 4856, 4886, 4947, 4856, 4856, 5582, 4856, 4856, 4856, 5383, 5397, 4856, 4856, 4856, 5781,
  4940, 4856, 4856, 4856, 5783, 4856, 5398, 4856, 4856, 5593, 5490, 5736, 5019, 4956, 4856, 4856, 4856, 5299,
  1073872896, 131072, 0, -1073741824, 0, -126877696, 0, 0, -1509949440, 0, -1476395008, 262146, 262160, 524304, 524304,
  268566528, 131072, 131072, 262144, -2147483648, 33816576, 537133056, 262174, 262160, 268444864, 10560, 33816576,
  262144, 262144, 262160, 537133056, -2147221504, -2147221504, 262144, 0, 3, 0, 4, 0, 5, 16832, 688128, -1200619520, 0,
  6, -2147483648, 8768, 262144, 524288, -2147483648, 278528, 278528, 278544, 537149440, 278530, 537149440, 278530,
  772014080, 168034304, 168034304, 235143168, 235143168, 772014080, 235143168, -1375469568, 772014080, 772014080,
  772030464, -1375469568, 168034304, 32768, 168034304, 2392096, 294944, 163840, 537165856, -2147188704, 294944, 294944,
  -2147188674, -2145091522, -2145091522, -2111537090, -2145091522, 772046880, 772046880, -1910210498, 4096, 0, 8, 0, 12,
  0, 16, 0, 24, 0, 32, 0, 36, 0, 38, 536870912, -2147483648, 2, 16, 2, 0, 64, 0, 128, -1610079071, -1610079071, 14, 0,
  172, 0, 192, 16384, 0, 256, 0, 265, 0, 323, 129024, 128, 8256, 2129952, 2129920, 16, 48, 16, 84, 12, 2129920, 65536,
  1048576, 0, 40, 0, 44, 12, 8, 1024, 4096, 16384, 131072, 4194304, 0, 10496, 32, 2097152, 0, 16384, 16384, 32768, 0,
  331, 0, 448, 262145, 262145, 524292, 262145, 32, 2097184, 1024, 268435456, 0, 1, 0, 2, -2147483648, 1073774592, 16,
  256, 512, 1024, 8192, 16384, 262144, 16777216, 0, 4608, 0, 8192, 64, 64, 128, 128, 256, 257, 0, 10240, 131088, 16,
  1048576, 2097152, 2129920, 0, 4096, 2048, 4096, 4096, 8192, 0, 4352, 20, 24, 1048848, 272, 16, 165675008, 272, 272,
  65552, 272, 1572880, 20, 304, 48, 80, 48, 524304, 28, 17, 28, 16, 536870912, 0, 19504, 631242752, 0, 24576,
  -2147483648, 28, 0, 32768, 32, 32, 128, 0, 1024, 0, 1280, 0, 2048, 0, 3072, 3072, 16384, 65536, 131072, 1048576, 8,
  16, 16, 17, 16, 20, 16, 32, 3072, 2, 304, 524560, 1048592, 1048592, 268435472, 20, 372, -165649452, -165649452,
  -165649451, -701430800, -701430800, -164559888, -164535312, -164535312, -701430800, -164535308, -164535308,
  -164273168, -700906508, -164535308, -164273164, -164535308, -700906512, -701430800, 0, 32800, 163872, 20, 112, 21, 21,
  16, 53, 140511253, 140515349, 140539925, 140540605, 140540573, 140540573, -164535308, -164273164, -26141771,
  239075328, 0, 49152, 65536, 1572864, 2097152, 8388608, 4096, 65536, 0, -2147483648, 0, -2147483646, -2147483646,
  -2146938874, -2146938874, 4, 128, 512, 4096, 114688, 12582912, 134217728, 0, 512, 0, 516, 2105344, 2097152, 536870912,
  536870912, 941162496, 941162496, 805371937, 805371937, 847314977, 2031683649, 957941825, 957941827, 957941825,
  957941857, 957941857, 957941859, 957941857, 960047171, 960038977, 960038977, 957941857, 960038977, -1199980544,
  960174145, -1199980544, -1199980544, -1199718400, -1199718400, -1199717854, -1199717846, -1199717846, -1199717782,
  -1199717846, -1183201183, -1183201183, -1182938517, 0, 393216, 0, 524288, 0, 135, 323840, 3670016, 33554432,
  -2147483648, 526336, 16777216, 33554432, 134217728, 268435456, 536870912, 2105344, 0, 524292, 1638400, 939524096, 0,
  525312, 1, 65536, 8388608, 134217728, 1073741824, 8192, 262144, 33554432, 0, 131072, 524288, -1610612736, 1640448,
  939524096, 1640448, 16777216, 134217728, 8243200, 16777216, 268435456, 1073741824, 4, 8, 262144, 1048576, 65600,
  32768, 262144, 2097152, 2097152, 2097184, 0, 2013265920, 3745792, 6291456, 939524096, 196608, 0, 2097152, 25165824, 0,
  131328, 1024, 57344, 262144, 1048576, 939524096, 65536, 805306368, 0, 1048576, 8388608, 33554432, 67108864, 0, 59392,
  0, 65536, 2097152, 12582912, 4194304, 939524096, 67109121, 131072, 16777216, 257, 525312, 67174657, -1507782399,
  -1507782399, -2145386488, -1876951032, -2145386488, -2145386456, -2145381716, -1507782391, -1507782391, -432729847,
  -432729847, -1507782391, -432729847, -1344145085, -1344145085, -1344145077, -1344145077, 1, 4, 16, 132, 256, 1024,
  524288, 1048576, 4194304, -1207959552, 0, -1879048192, 257, 2166784, 2101760, 0, 2129920, 2097184, 2097184, 2129920,
  2129920, 32768, 32768, 131072, 2097152, -2147483648, 265, 2166784, -436207616, 0, 2629632, 0, 262144, 323, 14809088,
  -1358954496, 0, 3407872, 257, 131072, 536871040, 257, 69632, 8, 2097152, 265, 69632, 50331648, 201326592, 0, 3737600,
  1048576, 1073741824, 1, 2, 4, 32, 4740, 536871168, 201326592, 536870912, 1, 256, 4096, 4194304, 8388608, 0, 46, 0, 48,
  0, 62, 2, 64, 256, 2048, 8192, 2, 256, 8192, 1, 4096, 16777216, 2, 2048, 16384, 524288, 2097152, 33554432, 8192,
  536870912, 16, 1, 49152, 1048576, 33554432, 32768, 8388608, 1073741824, 32768, 134217728, 514, 8388608, 16384,
  1073741824, 17039368, 131328, 131328, 807043332, 807043332, 806912004, 806912004, 806928388, 806929412, 1880785156,
  1889173780, 1880785156, 1880785156, 1880795396, 1880795910, -1199914555, -1199914555, 1880795396, -126172731,
  -126172731, 0, 3872768, 1024, 8388608, 2, 512, 16384, 2097152, 256, 688128, 1880096768, 806354944, 0, 4194304,
  16777216, 4, 557056, 17408, 0, 6291456, 0, 7979008, -1207959552, 20, 1888485376, 0, 1880096768, 11008, 0, 7981056, 4,
  256, 16384, 4194304, 134217728, 4, 32768, 393216, 524288, 4194304, 402653184, 20, 1887436800, 6, 0, 8388608, 16777216,
  -1207959552, 4, 448, -134217728, 0, 12582912, 16777216, 8192, 114688, 1572864, 256, 131072, 1073741824, 4, 1048576,
  134217728, 4, 192, 1048576, 268435456, 4, 131072, 4, 268435456, 16384, 268435456, 256, 32768, 2129920, 50331648,
  16777216, 128, 1075839492, -2146819039, -2146950111, -2146917343, -1073208287, -1073077215, -1610062687, -1610062687,
  -1593285471, -1610062687, -1559731039, -1542953823, -1610062671, -1542953823, -1408736095, -1592859485, -1592859485,
  -1592857437, -1592859485, -1542953823, -1592859485, -1592857437, -1592857437, 1056, 8192, 655360, -2147483648, 1,
  1184, 8192, 1, 24576, -1610612736, 1200, 0, 33554432, 3, 1184, 57344, 17694720, -1610612736, 4, 512, 262144, 1, 160,
  1, 32, 19456, 24576, 0, 41943040, 0, 262145, 2, 160, 128, 57344, 393216, 16777216, 2, 16384, 8388608, 4, 262144,
  268435464, 4096, 2359297, 2359297, 0, 50331648, 0, 16777216, 1073741824, 0, -1610612736, 0, -1608515584, 539230225,
  539230225, 540278803, 540278803, 540311571, 539230225, 572784657, 540278803, -1608253423, 540278803, 94850083,
  94850083, 540279315, 631721011, 631721011, 0, 50855936, 8, 268435456, 1, 262144, 1, 16, 538968064, 0, 67108864,
  134217728, 134217728, 524288, 524288, 40960, 0, 160, 572522496, 0, 67633152, 3, 540016640, 294912, 0, 134217728, 3,
  19488, 458752, 2097152, 458752, 94371840, 0, 138412032, 0, 40960, 528, 0, 163577856, 3, 3145728, 25165824, 67108864,
  536870912, 603979776, 0, 536870912, 3, 32, 65536, 12582912, 4, 524288, 536870912, 2, 3072, 131104, 1048, -2147483646,
  0, 805306368, -2147483648, -2147483646, 8389656, 2650112, 271085568, 2650112, 141062144, -2146928634, -2146928634,
  -2144831482, -2146928634, -2144700378, -2140637178, -2144831482, -2144831482, -2077722618, -2144765946, -1593280506,
  -1593280506, -2109935225, -2109935225, -2109933177, -2109933177, 32, 131072, 20480, 524288, 28672, 2621440, 6815744,
  0, 939524096, 30720, 524288, 30720, 2621440, 6, 96256, 161792, 17301504, 0, 17303552, 135, 325888, -2147483648, 24576,
  524288, 6, 2048, 16777216, 536870912, 24576, 2097152, 6, 128, 4096, 1024, 4194304, 536870912, 4, 16384, 100663296,
  128, 8192, 17152, 17152, 0, 1073741824, 12288, 0, 1610612736, 0, 3477504, 15652, 15406, 15652, 15652, 15396, 15396,
  15406, 15406, 15422, 15406, 68, 68, 324, 68, 15406, 4164, 8260, 15716, 15716, 15460, 0, 1879048192, 0, 8241152, 0,
  1572864, 4, 64, 384, 0, 268435456
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "StringConstructorChars",
  "S",
  "S",
  "CommentContents",
  "PragmaContents",
  "Wildcard",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "EOF",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'=>'",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "']``'",
  "'``['",
  "'`{'",
  "'after'",
  "'all'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'any'",
  "'array'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'contains'",
  "'content'",
  "'context'",
  "'copy'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'diacritics'",
  "'different'",
  "'digit'",
  "'distance'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'entire'",
  "'eq'",
  "'every'",
  "'exactly'",
  "'except'",
  "'exponent-separator'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'from'",
  "'ft-option'",
  "'ftand'",
  "'ftnot'",
  "'ftor'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'insensitive'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'invoke'",
  "'is'",
  "'item'",
  "'language'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'levels'",
  "'lowercase'",
  "'lt'",
  "'map'",
  "'minus-sign'",
  "'mod'",
  "'modify'",
  "'module'",
  "'most'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'not'",
  "'occurs'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'paragraph'",
  "'paragraphs'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'phrase'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'relationship'",
  "'rename'",
  "'replace'",
  "'return'",
  "'revalidation'",
  "'same'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'score'",
  "'self'",
  "'sensitive'",
  "'sentence'",
  "'sentences'",
  "'skip'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'stemming'",
  "'stop'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'thesaurus'",
  "'times'",
  "'to'",
  "'transform'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'update'",
  "'updating'",
  "'uppercase'",
  "'using'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'weight'",
  "'when'",
  "'where'",
  "'wildcards'",
  "'window'",
  "'with'",
  "'without'",
  "'word'",
  "'words'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}`'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 4096,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 4096
    let $end := $end - $result idiv 512
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 512 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 4096 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 4095) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 4096, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings.
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 8
    let $i0 := $t * 2573 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 4 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(81, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 19) then                 (: CommentContents :)
            let $state := p:consume(19, $input, $state)     (: CommentContents :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(36, $input, $state)               (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consume(49, $input, $state)               (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: S^WS :)
      let $state := p:consume(18, $input, $state)           (: S^WS :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QueryBody($input, $state)
  return $state
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(190, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionBody($input, $state)
      return $state
    else
      let $state := p:consume(132, $input, $state)          (: 'external' :)
      return $state
  return $state
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(251, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(132, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(98, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse CompatibilityAnnotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompatibilityAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(246, $input, $state)              (: 'updating' :)
  return $state
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 32                               (: '%' :)
      and $state[$p:l1] != 246) then                        (: 'updating' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 246) then                (: 'updating' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-CompatibilityAnnotation($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Annotation($input, $state)
            return $state
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 251) then                      (: 'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:consume(57, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(64, $input, $state)           (: '>>' :)
      return $state
  return $state
};

(:~
 : Try parsing NodeComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:consume(57, $input, $state)           (: '<<' :)
      return $state
    else
      let $state := p:consume(64, $input, $state)           (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:consume(27, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:consume(53, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:consume(58, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(63, $input, $state)           (: '>=' :)
      return $state
  return $state
};

(:~
 : Try parsing GeneralComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:consume(27, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:consume(53, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:consume(58, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
    else
      let $state := p:consume(63, $input, $state)           (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
  return $state
};

(:~
 : Try parsing ValueComp.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(259, $input, $state)              (: 'without' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:consume(100, $input, $state)              (: 'content' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  return $state
};

(:~
 : Try parsing FTIgnoreOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTIgnoreOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(259, $input, $state)              (: 'without' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'content' :)
  let $state := p:consume(100, $input, $state)              (: 'content' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnionExpr($input, $state)
  return $state
};

(:~
 : Parse FTContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(112, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 226) then                  (: 'start' :)
          let $state := p:consume(226, $input, $state)      (: 'start' :)
          return $state
        else
          let $state := p:consume(125, $input, $state)      (: 'end' :)
          return $state
      return $state
    else
      let $state := p:consume(126, $input, $state)          (: 'entire' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:consume(100, $input, $state)          (: 'content' :)
      return $state
  return $state
};

(:~
 : Try parsing FTContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(112, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'start' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 226) then                  (: 'start' :)
          let $state := p:consume(226, $input, $state)      (: 'start' :)
          return $state
        else
          let $state := p:consume(125, $input, $state)      (: 'end' :)
          return $state
      return $state
    else
      let $state := p:consume(126, $input, $state)          (: 'entire' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'content' :)
      let $state := p:consume(100, $input, $state)          (: 'content' :)
      return $state
  return $state
};

(:~
 : Parse FTBigUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 220) then                      (: 'sentence' :)
      let $state := p:consume(220, $input, $state)          (: 'sentence' :)
      return $state
    else
      let $state := p:consume(195, $input, $state)          (: 'paragraph' :)
      return $state
  return $state
};

(:~
 : Try parsing FTBigUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTBigUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 220) then                      (: 'sentence' :)
      let $state := p:consume(220, $input, $state)          (: 'sentence' :)
      return $state
    else
      let $state := p:consume(195, $input, $state)          (: 'paragraph' :)
      return $state
  return $state
};

(:~
 : Parse FTScope.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: 'same' :)
      let $state := p:consume(212, $input, $state)          (: 'same' :)
      return $state
    else
      let $state := p:consume(114, $input, $state)          (: 'different' :)
      return $state
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTBigUnit($input, $state)
  return $state
};

(:~
 : Try parsing FTScope.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTScope($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 212) then                      (: 'same' :)
      let $state := p:consume(212, $input, $state)          (: 'same' :)
      return $state
    else
      let $state := p:consume(114, $input, $state)          (: 'different' :)
      return $state
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | ('(' ':') | 'paragraph' | 'sentence' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTBigUnit($input, $state)
  return $state
};

(:~
 : Parse FTDistance.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(116, $input, $state)              (: 'distance' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTRange($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnit($input, $state)
  return $state
};

(:~
 : Try parsing FTDistance.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTDistance($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(116, $input, $state)              (: 'distance' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTRange($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 261) then                      (: 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'sentences' :)
      let $state := p:consume(221, $input, $state)          (: 'sentences' :)
      return $state
    else
      let $state := p:consume(196, $input, $state)          (: 'paragraphs' :)
      return $state
  return $state
};

(:~
 : Try parsing FTUnit.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTUnit($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 261) then                      (: 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
    else if ($state[$p:l1] = 221) then                      (: 'sentences' :)
      let $state := p:consume(221, $input, $state)          (: 'sentences' :)
      return $state
    else
      let $state := p:consume(196, $input, $state)          (: 'paragraphs' :)
      return $state
  return $state
};

(:~
 : Parse FTWindow.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnit($input, $state)
  return $state
};

(:~
 : Try parsing FTWindow.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWindow($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTUnit($input, $state)
  return $state
};

(:~
 : Parse FTOrder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  return $state
};

(:~
 : Try parsing FTOrder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTOrder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  return $state
};

(:~
 : Parse FTPosFilter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 257) then                      (: 'window' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'distance' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 114                            (: 'different' :)
          or $state[$p:l1] = 212) then                      (: 'same' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScope($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FTPosFilter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTPosFilter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTOrder($input, $state)
      return $state
    else if ($state[$p:l1] = 257) then                      (: 'window' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWindow($input, $state)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'distance' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTDistance($input, $state)
      return $state
    else if ($state[$p:l1] = 114                            (: 'different' :)
          or $state[$p:l1] = 212) then                      (: 'same' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTScope($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTWeight.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(253, $input, $state)              (: 'weight' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing FTWeight.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWeight($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(253, $input, $state)              (: 'weight' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-FTExtensionSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTExtensionSelection (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTExtensionSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-FTExtensionSelection-1($input, $state)
};

(:~
 : Parse FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FTExtensionSelection-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(157, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing FTExtensionSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTExtensionSelection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTExtensionSelection-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(157, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTSelection($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse FTRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FTRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse FTTimes.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(187, $input, $state)              (: 'occurs' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTRange($input, $state)
  let $state := p:consume(235, $input, $state)              (: 'times' :)
  return $state
};

(:~
 : Try parsing FTTimes.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTTimes($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(187, $input, $state)              (: 'occurs' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'exactly' | 'from' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTRange($input, $state)
  let $state := p:consume(235, $input, $state)              (: 'times' :)
  return $state
};

(:~
 : Parse FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'any' :)
      let $state := p:consume(81, $input, $state)           (: 'any' :)
      let $state := p:lookahead1W(216, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'word' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 260) then                  (: 'word' :)
          let $state := p:consume(260, $input, $state)      (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'all' :)
      let $state := p:consume(76, $input, $state)           (: 'all' :)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:l1] eq 261) then                      (: 'words' :)
          let $state := p:lookahead2W(214, $input, $state)  (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 13061                      (: 'words' EOF :)
              or $state[$p:lk] = 14085                      (: 'words' '!=' :)
              or $state[$p:lk] = 19205                      (: 'words' ')' :)
              or $state[$p:lk] = 19717                      (: 'words' '*' :)
              or $state[$p:lk] = 20229                      (: 'words' '+' :)
              or $state[$p:lk] = 20741                      (: 'words' ',' :)
              or $state[$p:lk] = 21253                      (: 'words' '-' :)
              or $state[$p:lk] = 24837                      (: 'words' ':' :)
              or $state[$p:lk] = 26885                      (: 'words' ';' :)
              or $state[$p:lk] = 27397                      (: 'words' '<' :)
              or $state[$p:lk] = 29445                      (: 'words' '<<' :)
              or $state[$p:lk] = 29957                      (: 'words' '<=' :)
              or $state[$p:lk] = 30981                      (: 'words' '=' :)
              or $state[$p:lk] = 32005                      (: 'words' '>' :)
              or $state[$p:lk] = 32517                      (: 'words' '>=' :)
              or $state[$p:lk] = 33029                      (: 'words' '>>' :)
              or $state[$p:lk] = 36101                      (: 'words' ']' :)
              or $state[$p:lk] = 38661                      (: 'words' 'after' :)
              or $state[$p:lk] = 41221                      (: 'words' 'and' :)
              or $state[$p:lk] = 42757                      (: 'words' 'as' :)
              or $state[$p:lk] = 43269                      (: 'words' 'ascending' :)
              or $state[$p:lk] = 43781                      (: 'words' 'at' :)
              or $state[$p:lk] = 45317                      (: 'words' 'before' :)
              or $state[$p:lk] = 46853                      (: 'words' 'case' :)
              or $state[$p:lk] = 47365                      (: 'words' 'cast' :)
              or $state[$p:lk] = 47877                      (: 'words' 'castable' :)
              or $state[$p:lk] = 49413                      (: 'words' 'collation' :)
              or $state[$p:lk] = 50949                      (: 'words' 'contains' :)
              or $state[$p:lk] = 53509                      (: 'words' 'count' :)
              or $state[$p:lk] = 55557                      (: 'words' 'default' :)
              or $state[$p:lk] = 57605                      (: 'words' 'descending' :)
              or $state[$p:lk] = 58629                      (: 'words' 'different' :)
              or $state[$p:lk] = 59653                      (: 'words' 'distance' :)
              or $state[$p:lk] = 60165                      (: 'words' 'div' :)
              or $state[$p:lk] = 62213                      (: 'words' 'else' :)
              or $state[$p:lk] = 62725                      (: 'words' 'empty' :)
              or $state[$p:lk] = 64261                      (: 'words' 'end' :)
              or $state[$p:lk] = 64773                      (: 'words' 'entire' :)
              or $state[$p:lk] = 65285                      (: 'words' 'eq' :)
              or $state[$p:lk] = 66821                      (: 'words' 'except' :)
              or $state[$p:lk] = 69893                      (: 'words' 'for' :)
              or $state[$p:lk] = 73477                      (: 'words' 'ge' :)
              or $state[$p:lk] = 74501                      (: 'words' 'group' :)
              or $state[$p:lk] = 75525                      (: 'words' 'gt' :)
              or $state[$p:lk] = 76037                      (: 'words' 'idiv' :)
              or $state[$p:lk] = 80133                      (: 'words' 'instance' :)
              or $state[$p:lk] = 80645                      (: 'words' 'intersect' :)
              or $state[$p:lk] = 81157                      (: 'words' 'into' :)
              or $state[$p:lk] = 82181                      (: 'words' 'is' :)
              or $state[$p:lk] = 84741                      (: 'words' 'le' :)
              or $state[$p:lk] = 85765                      (: 'words' 'let' :)
              or $state[$p:lk] = 87301                      (: 'words' 'lt' :)
              or $state[$p:lk] = 88837                      (: 'words' 'mod' :)
              or $state[$p:lk] = 89349                      (: 'words' 'modify' :)
              or $state[$p:lk] = 91909                      (: 'words' 'ne' :)
              or $state[$p:lk] = 97029                      (: 'words' 'only' :)
              or $state[$p:lk] = 98053                      (: 'words' 'or' :)
              or $state[$p:lk] = 98565                      (: 'words' 'order' :)
              or $state[$p:lk] = 99077                      (: 'words' 'ordered' :)
              or $state[$p:lk] = 100613                     (: 'words' 'paragraphs' :)
              or $state[$p:lk] = 107781                     (: 'words' 'return' :)
              or $state[$p:lk] = 108805                     (: 'words' 'same' :)
              or $state[$p:lk] = 109317                     (: 'words' 'satisfies' :)
              or $state[$p:lk] = 113413                     (: 'words' 'sentences' :)
              or $state[$p:lk] = 115461                     (: 'words' 'stable' :)
              or $state[$p:lk] = 115973                     (: 'words' 'start' :)
              or $state[$p:lk] = 120581                     (: 'words' 'times' :)
              or $state[$p:lk] = 121093                     (: 'words' 'to' :)
              or $state[$p:lk] = 121605                     (: 'words' 'transform' :)
              or $state[$p:lk] = 122117                     (: 'words' 'treat' :)
              or $state[$p:lk] = 124677                     (: 'words' 'union' :)
              or $state[$p:lk] = 130821                     (: 'words' 'where' :)
              or $state[$p:lk] = 131845                     (: 'words' 'window' :)
              or $state[$p:lk] = 132357                     (: 'words' 'with' :)
              or $state[$p:lk] = 132869                     (: 'words' 'without' :)
              or $state[$p:lk] = 133893                     (: 'words' 'words' :)
              or $state[$p:lk] = 136453                     (: 'words' '|' :)
              or $state[$p:lk] = 136965                     (: 'words' '||' :)
              or $state[$p:lk] = 137477                     (: 'words' '}' :)
              or $state[$p:lk] = 137989) then               (: 'words' '}`' :)
          let $state := p:memoized($state, 23)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:consume(261, $input, $state)  (: 'words' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 71429                      (: 'words' 'ftand' :)
              or $state[$p:lk] = 72453                      (: 'words' 'ftor' :)
              or $state[$p:lk] = 95493                      (: 'words' 'not' :)
              or $state[$p:lk] = 96005                      (: 'words' 'occurs' :)
              or $state[$p:lk] = 127237                     (: 'words' 'using' :)
              or $state[$p:lk] = 129797) then               (: 'words' 'weight' :)
          let $state := p:consume(261, $input, $state)      (: 'words' :)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(201, $input, $state)          (: 'phrase' :)
      return $state
  return $state
};

(:~
 : Try parsing FTAnyallOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTAnyallOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'any' :)
      let $state := p:consume(81, $input, $state)           (: 'any' :)
      let $state := p:lookahead1W(216, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'word' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 260) then                  (: 'word' :)
          let $state := p:consume(260, $input, $state)      (: 'word' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'all' :)
      let $state := p:consume(76, $input, $state)           (: 'all' :)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:l1] eq 261) then                      (: 'words' :)
          let $state := p:lookahead2W(214, $input, $state)  (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
          return $state
        else
          ($state[$p:l1], subsequence($state, $p:lk + 1))
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = 13061                      (: 'words' EOF :)
              or $state[$p:lk] = 14085                      (: 'words' '!=' :)
              or $state[$p:lk] = 19205                      (: 'words' ')' :)
              or $state[$p:lk] = 19717                      (: 'words' '*' :)
              or $state[$p:lk] = 20229                      (: 'words' '+' :)
              or $state[$p:lk] = 20741                      (: 'words' ',' :)
              or $state[$p:lk] = 21253                      (: 'words' '-' :)
              or $state[$p:lk] = 24837                      (: 'words' ':' :)
              or $state[$p:lk] = 26885                      (: 'words' ';' :)
              or $state[$p:lk] = 27397                      (: 'words' '<' :)
              or $state[$p:lk] = 29445                      (: 'words' '<<' :)
              or $state[$p:lk] = 29957                      (: 'words' '<=' :)
              or $state[$p:lk] = 30981                      (: 'words' '=' :)
              or $state[$p:lk] = 32005                      (: 'words' '>' :)
              or $state[$p:lk] = 32517                      (: 'words' '>=' :)
              or $state[$p:lk] = 33029                      (: 'words' '>>' :)
              or $state[$p:lk] = 36101                      (: 'words' ']' :)
              or $state[$p:lk] = 38661                      (: 'words' 'after' :)
              or $state[$p:lk] = 41221                      (: 'words' 'and' :)
              or $state[$p:lk] = 42757                      (: 'words' 'as' :)
              or $state[$p:lk] = 43269                      (: 'words' 'ascending' :)
              or $state[$p:lk] = 43781                      (: 'words' 'at' :)
              or $state[$p:lk] = 45317                      (: 'words' 'before' :)
              or $state[$p:lk] = 46853                      (: 'words' 'case' :)
              or $state[$p:lk] = 47365                      (: 'words' 'cast' :)
              or $state[$p:lk] = 47877                      (: 'words' 'castable' :)
              or $state[$p:lk] = 49413                      (: 'words' 'collation' :)
              or $state[$p:lk] = 50949                      (: 'words' 'contains' :)
              or $state[$p:lk] = 53509                      (: 'words' 'count' :)
              or $state[$p:lk] = 55557                      (: 'words' 'default' :)
              or $state[$p:lk] = 57605                      (: 'words' 'descending' :)
              or $state[$p:lk] = 58629                      (: 'words' 'different' :)
              or $state[$p:lk] = 59653                      (: 'words' 'distance' :)
              or $state[$p:lk] = 60165                      (: 'words' 'div' :)
              or $state[$p:lk] = 62213                      (: 'words' 'else' :)
              or $state[$p:lk] = 62725                      (: 'words' 'empty' :)
              or $state[$p:lk] = 64261                      (: 'words' 'end' :)
              or $state[$p:lk] = 64773                      (: 'words' 'entire' :)
              or $state[$p:lk] = 65285                      (: 'words' 'eq' :)
              or $state[$p:lk] = 66821                      (: 'words' 'except' :)
              or $state[$p:lk] = 69893                      (: 'words' 'for' :)
              or $state[$p:lk] = 73477                      (: 'words' 'ge' :)
              or $state[$p:lk] = 74501                      (: 'words' 'group' :)
              or $state[$p:lk] = 75525                      (: 'words' 'gt' :)
              or $state[$p:lk] = 76037                      (: 'words' 'idiv' :)
              or $state[$p:lk] = 80133                      (: 'words' 'instance' :)
              or $state[$p:lk] = 80645                      (: 'words' 'intersect' :)
              or $state[$p:lk] = 81157                      (: 'words' 'into' :)
              or $state[$p:lk] = 82181                      (: 'words' 'is' :)
              or $state[$p:lk] = 84741                      (: 'words' 'le' :)
              or $state[$p:lk] = 85765                      (: 'words' 'let' :)
              or $state[$p:lk] = 87301                      (: 'words' 'lt' :)
              or $state[$p:lk] = 88837                      (: 'words' 'mod' :)
              or $state[$p:lk] = 89349                      (: 'words' 'modify' :)
              or $state[$p:lk] = 91909                      (: 'words' 'ne' :)
              or $state[$p:lk] = 97029                      (: 'words' 'only' :)
              or $state[$p:lk] = 98053                      (: 'words' 'or' :)
              or $state[$p:lk] = 98565                      (: 'words' 'order' :)
              or $state[$p:lk] = 99077                      (: 'words' 'ordered' :)
              or $state[$p:lk] = 100613                     (: 'words' 'paragraphs' :)
              or $state[$p:lk] = 107781                     (: 'words' 'return' :)
              or $state[$p:lk] = 108805                     (: 'words' 'same' :)
              or $state[$p:lk] = 109317                     (: 'words' 'satisfies' :)
              or $state[$p:lk] = 113413                     (: 'words' 'sentences' :)
              or $state[$p:lk] = 115461                     (: 'words' 'stable' :)
              or $state[$p:lk] = 115973                     (: 'words' 'start' :)
              or $state[$p:lk] = 120581                     (: 'words' 'times' :)
              or $state[$p:lk] = 121093                     (: 'words' 'to' :)
              or $state[$p:lk] = 121605                     (: 'words' 'transform' :)
              or $state[$p:lk] = 122117                     (: 'words' 'treat' :)
              or $state[$p:lk] = 124677                     (: 'words' 'union' :)
              or $state[$p:lk] = 130821                     (: 'words' 'where' :)
              or $state[$p:lk] = 131845                     (: 'words' 'window' :)
              or $state[$p:lk] = 132357                     (: 'words' 'with' :)
              or $state[$p:lk] = 132869                     (: 'words' 'without' :)
              or $state[$p:lk] = 133893                     (: 'words' 'words' :)
              or $state[$p:lk] = 136453                     (: 'words' '|' :)
              or $state[$p:lk] = 136965                     (: 'words' '||' :)
              or $state[$p:lk] = 137477                     (: 'words' '}' :)
              or $state[$p:lk] = 137989) then               (: 'words' '}`' :)
          let $state := p:memoized($state, 23)
          return
            if ($state[$p:lk] != 0) then
              $state
            else
              let $backtrack := $state
              let $state := p:strip-result($state)
              let $state := p:consume(261, $input, $state)  (: 'words' :)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -1, -1)
                else
                  p:memoize($backtrack, $state, 23, $backtrack[$p:e0], -2, -2)
        else
          $state
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:lk] = -1
              or $state[$p:lk] = 71429                      (: 'words' 'ftand' :)
              or $state[$p:lk] = 72453                      (: 'words' 'ftor' :)
              or $state[$p:lk] = 95493                      (: 'words' 'not' :)
              or $state[$p:lk] = 96005                      (: 'words' 'occurs' :)
              or $state[$p:lk] = 127237                     (: 'words' 'using' :)
              or $state[$p:lk] = 129797) then               (: 'words' 'weight' :)
          let $state := p:consume(261, $input, $state)      (: 'words' :)
          return $state
        else
          $state
      return $state
    else
      let $state := p:consume(201, $input, $state)          (: 'phrase' :)
      return $state
  return $state
};

(:~
 : Parse FTWordsValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
  return $state
};

(:~
 : Try parsing FTWordsValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWordsValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
  return $state
};

(:~
 : Parse FTWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTWordsValue($input, $state)
  let $state := p:lookahead1W(219, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'all' | 'and' | 'any' | 'as' |
                                                               'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'different' | 'distance' |
                                                               'div' | 'else' | 'empty' | 'end' | 'entire' | 'eq' |
                                                               'except' | 'for' | 'ftand' | 'ftor' | 'ge' | 'group' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'not' | 'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'phrase' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76                             (: 'all' :)
          or $state[$p:l1] = 81                             (: 'any' :)
          or $state[$p:l1] = 201) then                      (: 'phrase' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTAnyallOption($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTWordsValue($input, $state)
  let $state := p:lookahead1W(219, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'all' | 'and' | 'any' | 'as' |
                                                               'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'different' | 'distance' |
                                                               'div' | 'else' | 'empty' | 'end' | 'entire' | 'eq' |
                                                               'except' | 'for' | 'ftand' | 'ftor' | 'ge' | 'group' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'into' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' |
                                                               'not' | 'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'phrase' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76                             (: 'all' :)
          or $state[$p:l1] = 81                             (: 'any' :)
          or $state[$p:l1] = 201) then                      (: 'phrase' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTAnyallOption($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTExtensionSelection($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWords($input, $state)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 187) then                  (: 'occurs' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Try parsing FTPrimary.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTPrimary($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTSelection($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTExtensionSelection($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWords($input, $state)
      let $state := p:lookahead1W(214, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'occurs' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 187) then                  (: 'occurs' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTTimes($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTPrimary($input, $state)
  let $state := p:lookahead1W(213, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 248) then                      (: 'using' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 253) then                      (: 'weight' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWeight($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTPrimaryWithOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTPrimaryWithOptions($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTPrimary($input, $state)
  let $state := p:lookahead1W(213, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 248) then                      (: 'using' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTMatchOptions($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 253) then                      (: 'weight' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWeight($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'ftnot' :)
      let $state := p:consume(140, $input, $state)          (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(145, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTPrimaryWithOptions($input, $state)
  return $state
};

(:~
 : Try parsing FTUnaryNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTUnaryNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 140) then                      (: 'ftnot' :)
      let $state := p:consume(140, $input, $state)          (: 'ftnot' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(145, $input, $state)          (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTPrimaryWithOptions($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMildNot-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 186) then                        (: 'not' :)
        $state
      else
        let $state := p:consume(186, $input, $state)        (: 'not' :)
        let $state := p:lookahead1W(52, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:consume(151, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(153, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTUnaryNot($input, $state)
        return p:parse-FTMildNot-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMildNot (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMildNot-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(211, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 186) then                        (: 'not' :)
        $state
      else
        let $state := p:consume(186, $input, $state)        (: 'not' :)
        let $state := p:lookahead1W(52, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:consume(151, $input, $state)        (: 'in' :)
        let $state := p:lookahead1W(153, $input, $state)    (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTUnaryNot($input, $state)
        return p:try-FTMildNot-1($input, $state)
};

(:~
 : Parse FTMildNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTUnaryNot($input, $state)
  let $state := p:parse-FTMildNot-1($input, $state)
  return $state
};

(:~
 : Try parsing FTMildNot.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMildNot($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTUnaryNot($input, $state)
  let $state := p:try-FTMildNot-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnd-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 139) then                          (: 'ftand' :)
      $state
    else
      let $state := p:consume(139, $input, $state)          (: 'ftand' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTMildNot($input, $state)
      return p:parse-FTAnd-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTAnd (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTAnd-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 139) then                          (: 'ftand' :)
      $state
    else
      let $state := p:consume(139, $input, $state)          (: 'ftand' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTMildNot($input, $state)
      return p:try-FTAnd-1($input, $state)
};

(:~
 : Parse FTAnd.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTMildNot($input, $state)
  let $state := p:parse-FTAnd-1($input, $state)
  return $state
};

(:~
 : Try parsing FTAnd.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTAnd($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTMildNot($input, $state)
  let $state := p:try-FTAnd-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 141) then                          (: 'ftor' :)
      $state
    else
      let $state := p:consume(141, $input, $state)          (: 'ftor' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTAnd($input, $state)
      return p:parse-FTOr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTOr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTOr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 141) then                          (: 'ftor' :)
      $state
    else
      let $state := p:consume(141, $input, $state)          (: 'ftor' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTAnd($input, $state)
      return p:try-FTOr-1($input, $state)
};

(:~
 : Parse FTOr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTAnd($input, $state)
  let $state := p:parse-FTOr-1($input, $state)
  return $state
};

(:~
 : Try parsing FTOr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTOr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTAnd($input, $state)
  let $state := p:try-FTOr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(199, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'paragraphs' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 85                               (: 'at' :)
      and $state[$p:l1] != 114                              (: 'different' :)
      and $state[$p:l1] != 116                              (: 'distance' :)
      and $state[$p:l1] != 126                              (: 'entire' :)
      and $state[$p:l1] != 193                              (: 'ordered' :)
      and $state[$p:l1] != 212                              (: 'same' :)
      and $state[$p:l1] != 257) then                        (: 'window' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTPosFilter($input, $state)
        return p:parse-FTSelection-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTSelection (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTSelection-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(199, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'paragraphs' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 85                               (: 'at' :)
      and $state[$p:l1] != 114                              (: 'different' :)
      and $state[$p:l1] != 116                              (: 'distance' :)
      and $state[$p:l1] != 126                              (: 'entire' :)
      and $state[$p:l1] != 193                              (: 'ordered' :)
      and $state[$p:l1] != 212                              (: 'same' :)
      and $state[$p:l1] != 257) then                        (: 'window' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTPosFilter($input, $state)
        return p:try-FTSelection-1($input, $state)
};

(:~
 : Parse FTSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTOr($input, $state)
  let $state := p:parse-FTSelection-1($input, $state)
  return $state
};

(:~
 : Try parsing FTSelection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTSelection($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTOr($input, $state)
  let $state := p:try-FTSelection-1($input, $state)
  return $state
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TypeName($input, $state)
  return $state
};

(:~
 : Try parsing SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TypeName($input, $state)
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(187, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing SingleType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(187, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ArrowFunctionSpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrowFunctionSpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ArrowFunctionSpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrowFunctionSpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarRef($input, $state)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(35, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(221, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1(12, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:consume(20, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(6, $input, $state)             (: '#)' :)
  let $state := p:consume(30, $input, $state)               (: '#)' :)
  return $state
};

(:~
 : Try parsing Pragma.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(35, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(221, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1(12, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:consume(20, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(6, $input, $state)             (: '#)' :)
  let $state := p:consume(30, $input, $state)               (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:try-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ExtensionExpr-1($input, $state)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Predicate($input, $state)
        return p:try-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PredicateList-1($input, $state)
  return $state
};

(:~
 : Try parsing PredicateList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: '@' :)
      let $state := p:consume(67, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NodeTest($input, $state)
  return $state
};

(:~
 : Try parsing AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: '@' :)
      let $state := p:consume(67, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Try parsing ForwardAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(196, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25686                          (: 'attribute' '::' :)
          or $state[$p:lk] = 25695                          (: 'child' '::' :)
          or $state[$p:lk] = 25710                          (: 'descendant' '::' :)
          or $state[$p:lk] = 25711                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 25734                          (: 'following' '::' :)
          or $state[$p:lk] = 25735                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 25818) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ForwardStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(196, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 25686                          (: 'attribute' '::' :)
          or $state[$p:lk] = 25695                          (: 'child' '::' :)
          or $state[$p:lk] = 25710                          (: 'descendant' '::' :)
          or $state[$p:lk] = 25711                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 25734                          (: 'following' '::' :)
          or $state[$p:lk] = 25735                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 25818) then                    (: 'self' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForwardAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(44, $input, $state)               (: '..' :)
  return $state
};

(:~
 : Try parsing AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(44, $input, $state)               (: '..' :)
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(193, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing NodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(193, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-KindTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Try parsing ReverseAxis.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ReverseStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '..' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AbbrevReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReverseAxis($input, $state)
      let $state := p:lookahead1W(224, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (78,                                (: 'ancestor' :)
                         79,                                (: 'ancestor-or-self' :)
                         197,                               (: 'parent' :)
                         202,                               (: 'preceding' :)
                         203)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 44                             (: '..' :)
          or $state[$p:lk] = 25678                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 25679                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 25797                          (: 'parent' '::' :)
          or $state[$p:lk] = 25802                          (: 'preceding' '::' :)
          or $state[$p:lk] = 25803) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(191, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PredicateList($input, $state)
  return $state
};

(:~
 : Try parsing AxisStep.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (78,                                (: 'ancestor' :)
                         79,                                (: 'ancestor-or-self' :)
                         197,                               (: 'parent' :)
                         202,                               (: 'preceding' :)
                         203)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(194, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 44                             (: '..' :)
          or $state[$p:lk] = 25678                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 25679                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 25797                          (: 'parent' '::' :)
          or $state[$p:lk] = 25802                          (: 'preceding' '::' :)
          or $state[$p:lk] = 25803) then                    (: 'preceding-sibling' '::' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReverseStep($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(191, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Lookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Lookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-KeySpecifier($input, $state)
  return $state
};

(:~
 : Try parsing Lookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Lookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-KeySpecifier($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Try parsing Predicate.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(197, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 65                               (: '?' :)
      and $state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 69) then                 (: '[' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '(' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Lookup($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(197, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 65                               (: '?' :)
      and $state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 69) then                 (: '[' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Predicate($input, $state)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '(' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-ArgumentList($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Lookup($input, $state)
            return $state
        return p:try-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing PostfixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpr($input, $state)
  let $state := p:try-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(243, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 120) then                     (: 'element' :)
      let $state := p:lookahead2W(242, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (177,                          (: 'namespace' :)
                              206)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(206, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              232,                          (: 'text' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (123,                          (: 'empty-sequence' :)
                              149,                          (: 'if' :)
                              161,                          (: 'item' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(192, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(201, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              119,                          (: 'document-node' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              136,                          (: 'for' :)
                              142,                          (: 'function' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              178,                          (: 'namespace-node' :)
                              179,                          (: 'ne' :)
                              184,                          (: 'node' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              215,                          (: 'schema-attribute' :)
                              216,                          (: 'schema-element' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41046                          (: 'attribute' 'and' :)
          or $state[$p:lk] = 41080                          (: 'element' 'and' :)
          or $state[$p:lk] = 41137                          (: 'namespace' 'and' :)
          or $state[$p:lk] = 41166                          (: 'processing-instruction' 'and' :)
          or $state[$p:lk] = 42582                          (: 'attribute' 'as' :)
          or $state[$p:lk] = 42616                          (: 'element' 'as' :)
          or $state[$p:lk] = 42673                          (: 'namespace' 'as' :)
          or $state[$p:lk] = 42702                          (: 'processing-instruction' 'as' :)
          or $state[$p:lk] = 43094                          (: 'attribute' 'ascending' :)
          or $state[$p:lk] = 43128                          (: 'element' 'ascending' :)
          or $state[$p:lk] = 43185                          (: 'namespace' 'ascending' :)
          or $state[$p:lk] = 43214                          (: 'processing-instruction' 'ascending' :)
          or $state[$p:lk] = 46678                          (: 'attribute' 'case' :)
          or $state[$p:lk] = 46712                          (: 'element' 'case' :)
          or $state[$p:lk] = 46769                          (: 'namespace' 'case' :)
          or $state[$p:lk] = 46798                          (: 'processing-instruction' 'case' :)
          or $state[$p:lk] = 47190                          (: 'attribute' 'cast' :)
          or $state[$p:lk] = 47224                          (: 'element' 'cast' :)
          or $state[$p:lk] = 47281                          (: 'namespace' 'cast' :)
          or $state[$p:lk] = 47310                          (: 'processing-instruction' 'cast' :)
          or $state[$p:lk] = 47702                          (: 'attribute' 'castable' :)
          or $state[$p:lk] = 47736                          (: 'element' 'castable' :)
          or $state[$p:lk] = 47793                          (: 'namespace' 'castable' :)
          or $state[$p:lk] = 47822                          (: 'processing-instruction' 'castable' :)
          or $state[$p:lk] = 49238                          (: 'attribute' 'collation' :)
          or $state[$p:lk] = 49272                          (: 'element' 'collation' :)
          or $state[$p:lk] = 49329                          (: 'namespace' 'collation' :)
          or $state[$p:lk] = 49358                          (: 'processing-instruction' 'collation' :)
          or $state[$p:lk] = 53334                          (: 'attribute' 'count' :)
          or $state[$p:lk] = 53368                          (: 'element' 'count' :)
          or $state[$p:lk] = 53425                          (: 'namespace' 'count' :)
          or $state[$p:lk] = 53454                          (: 'processing-instruction' 'count' :)
          or $state[$p:lk] = 55382                          (: 'attribute' 'default' :)
          or $state[$p:lk] = 55416                          (: 'element' 'default' :)
          or $state[$p:lk] = 55473                          (: 'namespace' 'default' :)
          or $state[$p:lk] = 55502                          (: 'processing-instruction' 'default' :)
          or $state[$p:lk] = 57430                          (: 'attribute' 'descending' :)
          or $state[$p:lk] = 57464                          (: 'element' 'descending' :)
          or $state[$p:lk] = 57521                          (: 'namespace' 'descending' :)
          or $state[$p:lk] = 57550                          (: 'processing-instruction' 'descending' :)
          or $state[$p:lk] = 59990                          (: 'attribute' 'div' :)
          or $state[$p:lk] = 60024                          (: 'element' 'div' :)
          or $state[$p:lk] = 60081                          (: 'namespace' 'div' :)
          or $state[$p:lk] = 60110                          (: 'processing-instruction' 'div' :)
          or $state[$p:lk] = 62038                          (: 'attribute' 'else' :)
          or $state[$p:lk] = 62072                          (: 'element' 'else' :)
          or $state[$p:lk] = 62129                          (: 'namespace' 'else' :)
          or $state[$p:lk] = 62158                          (: 'processing-instruction' 'else' :)
          or $state[$p:lk] = 62550                          (: 'attribute' 'empty' :)
          or $state[$p:lk] = 62584                          (: 'element' 'empty' :)
          or $state[$p:lk] = 62641                          (: 'namespace' 'empty' :)
          or $state[$p:lk] = 62670                          (: 'processing-instruction' 'empty' :)
          or $state[$p:lk] = 64086                          (: 'attribute' 'end' :)
          or $state[$p:lk] = 64120                          (: 'element' 'end' :)
          or $state[$p:lk] = 64177                          (: 'namespace' 'end' :)
          or $state[$p:lk] = 64206                          (: 'processing-instruction' 'end' :)
          or $state[$p:lk] = 65110                          (: 'attribute' 'eq' :)
          or $state[$p:lk] = 65144                          (: 'element' 'eq' :)
          or $state[$p:lk] = 65201                          (: 'namespace' 'eq' :)
          or $state[$p:lk] = 65230                          (: 'processing-instruction' 'eq' :)
          or $state[$p:lk] = 66646                          (: 'attribute' 'except' :)
          or $state[$p:lk] = 66680                          (: 'element' 'except' :)
          or $state[$p:lk] = 66737                          (: 'namespace' 'except' :)
          or $state[$p:lk] = 66766                          (: 'processing-instruction' 'except' :)
          or $state[$p:lk] = 69718                          (: 'attribute' 'for' :)
          or $state[$p:lk] = 69752                          (: 'element' 'for' :)
          or $state[$p:lk] = 69809                          (: 'namespace' 'for' :)
          or $state[$p:lk] = 69838                          (: 'processing-instruction' 'for' :)
          or $state[$p:lk] = 73302                          (: 'attribute' 'ge' :)
          or $state[$p:lk] = 73336                          (: 'element' 'ge' :)
          or $state[$p:lk] = 73393                          (: 'namespace' 'ge' :)
          or $state[$p:lk] = 73422                          (: 'processing-instruction' 'ge' :)
          or $state[$p:lk] = 74326                          (: 'attribute' 'group' :)
          or $state[$p:lk] = 74360                          (: 'element' 'group' :)
          or $state[$p:lk] = 74417                          (: 'namespace' 'group' :)
          or $state[$p:lk] = 74446                          (: 'processing-instruction' 'group' :)
          or $state[$p:lk] = 75350                          (: 'attribute' 'gt' :)
          or $state[$p:lk] = 75384                          (: 'element' 'gt' :)
          or $state[$p:lk] = 75441                          (: 'namespace' 'gt' :)
          or $state[$p:lk] = 75470                          (: 'processing-instruction' 'gt' :)
          or $state[$p:lk] = 75862                          (: 'attribute' 'idiv' :)
          or $state[$p:lk] = 75896                          (: 'element' 'idiv' :)
          or $state[$p:lk] = 75953                          (: 'namespace' 'idiv' :)
          or $state[$p:lk] = 75982                          (: 'processing-instruction' 'idiv' :)
          or $state[$p:lk] = 79958                          (: 'attribute' 'instance' :)
          or $state[$p:lk] = 79992                          (: 'element' 'instance' :)
          or $state[$p:lk] = 80049                          (: 'namespace' 'instance' :)
          or $state[$p:lk] = 80078                          (: 'processing-instruction' 'instance' :)
          or $state[$p:lk] = 80470                          (: 'attribute' 'intersect' :)
          or $state[$p:lk] = 80504                          (: 'element' 'intersect' :)
          or $state[$p:lk] = 80561                          (: 'namespace' 'intersect' :)
          or $state[$p:lk] = 80590                          (: 'processing-instruction' 'intersect' :)
          or $state[$p:lk] = 82006                          (: 'attribute' 'is' :)
          or $state[$p:lk] = 82040                          (: 'element' 'is' :)
          or $state[$p:lk] = 82097                          (: 'namespace' 'is' :)
          or $state[$p:lk] = 82126                          (: 'processing-instruction' 'is' :)
          or $state[$p:lk] = 84566                          (: 'attribute' 'le' :)
          or $state[$p:lk] = 84600                          (: 'element' 'le' :)
          or $state[$p:lk] = 84657                          (: 'namespace' 'le' :)
          or $state[$p:lk] = 84686                          (: 'processing-instruction' 'le' :)
          or $state[$p:lk] = 85590                          (: 'attribute' 'let' :)
          or $state[$p:lk] = 85624                          (: 'element' 'let' :)
          or $state[$p:lk] = 85681                          (: 'namespace' 'let' :)
          or $state[$p:lk] = 85710                          (: 'processing-instruction' 'let' :)
          or $state[$p:lk] = 87126                          (: 'attribute' 'lt' :)
          or $state[$p:lk] = 87160                          (: 'element' 'lt' :)
          or $state[$p:lk] = 87217                          (: 'namespace' 'lt' :)
          or $state[$p:lk] = 87246                          (: 'processing-instruction' 'lt' :)
          or $state[$p:lk] = 88662                          (: 'attribute' 'mod' :)
          or $state[$p:lk] = 88696                          (: 'element' 'mod' :)
          or $state[$p:lk] = 88753                          (: 'namespace' 'mod' :)
          or $state[$p:lk] = 88782                          (: 'processing-instruction' 'mod' :)
          or $state[$p:lk] = 89174                          (: 'attribute' 'modify' :)
          or $state[$p:lk] = 89208                          (: 'element' 'modify' :)
          or $state[$p:lk] = 91734                          (: 'attribute' 'ne' :)
          or $state[$p:lk] = 91768                          (: 'element' 'ne' :)
          or $state[$p:lk] = 91825                          (: 'namespace' 'ne' :)
          or $state[$p:lk] = 91854                          (: 'processing-instruction' 'ne' :)
          or $state[$p:lk] = 96854                          (: 'attribute' 'only' :)
          or $state[$p:lk] = 96888                          (: 'element' 'only' :)
          or $state[$p:lk] = 96945                          (: 'namespace' 'only' :)
          or $state[$p:lk] = 96974                          (: 'processing-instruction' 'only' :)
          or $state[$p:lk] = 97878                          (: 'attribute' 'or' :)
          or $state[$p:lk] = 97912                          (: 'element' 'or' :)
          or $state[$p:lk] = 97969                          (: 'namespace' 'or' :)
          or $state[$p:lk] = 97998                          (: 'processing-instruction' 'or' :)
          or $state[$p:lk] = 98390                          (: 'attribute' 'order' :)
          or $state[$p:lk] = 98424                          (: 'element' 'order' :)
          or $state[$p:lk] = 98481                          (: 'namespace' 'order' :)
          or $state[$p:lk] = 98510                          (: 'processing-instruction' 'order' :)
          or $state[$p:lk] = 107606                         (: 'attribute' 'return' :)
          or $state[$p:lk] = 107640                         (: 'element' 'return' :)
          or $state[$p:lk] = 107697                         (: 'namespace' 'return' :)
          or $state[$p:lk] = 107726                         (: 'processing-instruction' 'return' :)
          or $state[$p:lk] = 109142                         (: 'attribute' 'satisfies' :)
          or $state[$p:lk] = 109176                         (: 'element' 'satisfies' :)
          or $state[$p:lk] = 109233                         (: 'namespace' 'satisfies' :)
          or $state[$p:lk] = 109262                         (: 'processing-instruction' 'satisfies' :)
          or $state[$p:lk] = 115286                         (: 'attribute' 'stable' :)
          or $state[$p:lk] = 115320                         (: 'element' 'stable' :)
          or $state[$p:lk] = 115377                         (: 'namespace' 'stable' :)
          or $state[$p:lk] = 115406                         (: 'processing-instruction' 'stable' :)
          or $state[$p:lk] = 115798                         (: 'attribute' 'start' :)
          or $state[$p:lk] = 115832                         (: 'element' 'start' :)
          or $state[$p:lk] = 115889                         (: 'namespace' 'start' :)
          or $state[$p:lk] = 115918                         (: 'processing-instruction' 'start' :)
          or $state[$p:lk] = 120918                         (: 'attribute' 'to' :)
          or $state[$p:lk] = 120952                         (: 'element' 'to' :)
          or $state[$p:lk] = 121009                         (: 'namespace' 'to' :)
          or $state[$p:lk] = 121038                         (: 'processing-instruction' 'to' :)
          or $state[$p:lk] = 121430                         (: 'attribute' 'transform' :)
          or $state[$p:lk] = 121464                         (: 'element' 'transform' :)
          or $state[$p:lk] = 121942                         (: 'attribute' 'treat' :)
          or $state[$p:lk] = 121976                         (: 'element' 'treat' :)
          or $state[$p:lk] = 122033                         (: 'namespace' 'treat' :)
          or $state[$p:lk] = 122062                         (: 'processing-instruction' 'treat' :)
          or $state[$p:lk] = 124502                         (: 'attribute' 'union' :)
          or $state[$p:lk] = 124536                         (: 'element' 'union' :)
          or $state[$p:lk] = 124593                         (: 'namespace' 'union' :)
          or $state[$p:lk] = 124622                         (: 'processing-instruction' 'union' :)
          or $state[$p:lk] = 125526                         (: 'attribute' 'update' :)
          or $state[$p:lk] = 125560                         (: 'element' 'update' :)
          or $state[$p:lk] = 130646                         (: 'attribute' 'where' :)
          or $state[$p:lk] = 130680                         (: 'element' 'where' :)
          or $state[$p:lk] = 130737                         (: 'namespace' 'where' :)
          or $state[$p:lk] = 130766                         (: 'processing-instruction' 'where' :)
          or $state[$p:lk] = 132182                         (: 'attribute' 'with' :)
          or $state[$p:lk] = 132216) then                   (: 'element' 'with' :)
      let $state := p:memoized($state, 19)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PostfixExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 1                                   (: IntegerLiteral :)
     or $state[$p:lk] = 2                                   (: DecimalLiteral :)
     or $state[$p:lk] = 3                                   (: DoubleLiteral :)
     or $state[$p:lk] = 4                                   (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 32                                  (: '%' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 43                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 65                                  (: '?' :)
     or $state[$p:lk] = 69                                  (: '[' :)
     or $state[$p:lk] = 73                                  (: '``[' :)
     or $state[$p:lk] = 82                                  (: 'array' :)
     or $state[$p:lk] = 171                                 (: 'map' :)
     or $state[$p:lk] = 2646                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 2680                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 7345                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 7374                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 7766                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 7800                                (: 'element' QName^Token :)
     or $state[$p:lk] = 14853                               (: URIQualifiedName '#' :)
     or $state[$p:lk] = 14863                               (: QName^Token '#' :)
     or $state[$p:lk] = 14926                               (: 'ancestor' '#' :)
     or $state[$p:lk] = 14927                               (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 14928                               (: 'and' '#' :)
     or $state[$p:lk] = 14931                               (: 'as' '#' :)
     or $state[$p:lk] = 14932                               (: 'ascending' '#' :)
     or $state[$p:lk] = 14933                               (: 'at' '#' :)
     or $state[$p:lk] = 14934                               (: 'attribute' '#' :)
     or $state[$p:lk] = 14939                               (: 'case' '#' :)
     or $state[$p:lk] = 14940                               (: 'cast' '#' :)
     or $state[$p:lk] = 14941                               (: 'castable' '#' :)
     or $state[$p:lk] = 14943                               (: 'child' '#' :)
     or $state[$p:lk] = 14944                               (: 'collation' '#' :)
     or $state[$p:lk] = 14945                               (: 'comment' '#' :)
     or $state[$p:lk] = 14950                               (: 'copy' '#' :)
     or $state[$p:lk] = 14952                               (: 'count' '#' :)
     or $state[$p:lk] = 14955                               (: 'declare' '#' :)
     or $state[$p:lk] = 14956                               (: 'default' '#' :)
     or $state[$p:lk] = 14957                               (: 'delete' '#' :)
     or $state[$p:lk] = 14958                               (: 'descendant' '#' :)
     or $state[$p:lk] = 14959                               (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 14960                               (: 'descending' '#' :)
     or $state[$p:lk] = 14965                               (: 'div' '#' :)
     or $state[$p:lk] = 14966                               (: 'document' '#' :)
     or $state[$p:lk] = 14967                               (: 'document-node' '#' :)
     or $state[$p:lk] = 14968                               (: 'element' '#' :)
     or $state[$p:lk] = 14969                               (: 'else' '#' :)
     or $state[$p:lk] = 14970                               (: 'empty' '#' :)
     or $state[$p:lk] = 14971                               (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 14973                               (: 'end' '#' :)
     or $state[$p:lk] = 14975                               (: 'eq' '#' :)
     or $state[$p:lk] = 14976                               (: 'every' '#' :)
     or $state[$p:lk] = 14978                               (: 'except' '#' :)
     or $state[$p:lk] = 14982                               (: 'following' '#' :)
     or $state[$p:lk] = 14983                               (: 'following-sibling' '#' :)
     or $state[$p:lk] = 14984                               (: 'for' '#' :)
     or $state[$p:lk] = 14990                               (: 'function' '#' :)
     or $state[$p:lk] = 14991                               (: 'ge' '#' :)
     or $state[$p:lk] = 14993                               (: 'group' '#' :)
     or $state[$p:lk] = 14995                               (: 'gt' '#' :)
     or $state[$p:lk] = 14996                               (: 'idiv' '#' :)
     or $state[$p:lk] = 14997                               (: 'if' '#' :)
     or $state[$p:lk] = 14998                               (: 'import' '#' :)
     or $state[$p:lk] = 15003                               (: 'insert' '#' :)
     or $state[$p:lk] = 15004                               (: 'instance' '#' :)
     or $state[$p:lk] = 15005                               (: 'intersect' '#' :)
     or $state[$p:lk] = 15007                               (: 'invoke' '#' :)
     or $state[$p:lk] = 15008                               (: 'is' '#' :)
     or $state[$p:lk] = 15009                               (: 'item' '#' :)
     or $state[$p:lk] = 15013                               (: 'le' '#' :)
     or $state[$p:lk] = 15015                               (: 'let' '#' :)
     or $state[$p:lk] = 15018                               (: 'lt' '#' :)
     or $state[$p:lk] = 15021                               (: 'mod' '#' :)
     or $state[$p:lk] = 15022                               (: 'modify' '#' :)
     or $state[$p:lk] = 15023                               (: 'module' '#' :)
     or $state[$p:lk] = 15025                               (: 'namespace' '#' :)
     or $state[$p:lk] = 15026                               (: 'namespace-node' '#' :)
     or $state[$p:lk] = 15027                               (: 'ne' '#' :)
     or $state[$p:lk] = 15032                               (: 'node' '#' :)
     or $state[$p:lk] = 15037                               (: 'only' '#' :)
     or $state[$p:lk] = 15039                               (: 'or' '#' :)
     or $state[$p:lk] = 15040                               (: 'order' '#' :)
     or $state[$p:lk] = 15041                               (: 'ordered' '#' :)
     or $state[$p:lk] = 15045                               (: 'parent' '#' :)
     or $state[$p:lk] = 15050                               (: 'preceding' '#' :)
     or $state[$p:lk] = 15051                               (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 15054                               (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 15056                               (: 'rename' '#' :)
     or $state[$p:lk] = 15057                               (: 'replace' '#' :)
     or $state[$p:lk] = 15058                               (: 'return' '#' :)
     or $state[$p:lk] = 15061                               (: 'satisfies' '#' :)
     or $state[$p:lk] = 15063                               (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 15064                               (: 'schema-element' '#' :)
     or $state[$p:lk] = 15066                               (: 'self' '#' :)
     or $state[$p:lk] = 15072                               (: 'some' '#' :)
     or $state[$p:lk] = 15073                               (: 'stable' '#' :)
     or $state[$p:lk] = 15074                               (: 'start' '#' :)
     or $state[$p:lk] = 15079                               (: 'switch' '#' :)
     or $state[$p:lk] = 15080                               (: 'text' '#' :)
     or $state[$p:lk] = 15084                               (: 'to' '#' :)
     or $state[$p:lk] = 15085                               (: 'transform' '#' :)
     or $state[$p:lk] = 15086                               (: 'treat' '#' :)
     or $state[$p:lk] = 15087                               (: 'try' '#' :)
     or $state[$p:lk] = 15090                               (: 'typeswitch' '#' :)
     or $state[$p:lk] = 15091                               (: 'union' '#' :)
     or $state[$p:lk] = 15092                               (: 'unordered' '#' :)
     or $state[$p:lk] = 15093                               (: 'update' '#' :)
     or $state[$p:lk] = 15097                               (: 'validate' '#' :)
     or $state[$p:lk] = 15103                               (: 'where' '#' :)
     or $state[$p:lk] = 15106                               (: 'with' '#' :)
     or $state[$p:lk] = 15110                               (: 'xquery' '#' :)
     or $state[$p:lk] = 17413                               (: URIQualifiedName '(' :)
     or $state[$p:lk] = 17423                               (: QName^Token '(' :)
     or $state[$p:lk] = 17486                               (: 'ancestor' '(' :)
     or $state[$p:lk] = 17487                               (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 17488                               (: 'and' '(' :)
     or $state[$p:lk] = 17491                               (: 'as' '(' :)
     or $state[$p:lk] = 17492                               (: 'ascending' '(' :)
     or $state[$p:lk] = 17493                               (: 'at' '(' :)
     or $state[$p:lk] = 17499                               (: 'case' '(' :)
     or $state[$p:lk] = 17500                               (: 'cast' '(' :)
     or $state[$p:lk] = 17501                               (: 'castable' '(' :)
     or $state[$p:lk] = 17503                               (: 'child' '(' :)
     or $state[$p:lk] = 17504                               (: 'collation' '(' :)
     or $state[$p:lk] = 17510                               (: 'copy' '(' :)
     or $state[$p:lk] = 17512                               (: 'count' '(' :)
     or $state[$p:lk] = 17515                               (: 'declare' '(' :)
     or $state[$p:lk] = 17516                               (: 'default' '(' :)
     or $state[$p:lk] = 17517                               (: 'delete' '(' :)
     or $state[$p:lk] = 17518                               (: 'descendant' '(' :)
     or $state[$p:lk] = 17519                               (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 17520                               (: 'descending' '(' :)
     or $state[$p:lk] = 17525                               (: 'div' '(' :)
     or $state[$p:lk] = 17526                               (: 'document' '(' :)
     or $state[$p:lk] = 17529                               (: 'else' '(' :)
     or $state[$p:lk] = 17530                               (: 'empty' '(' :)
     or $state[$p:lk] = 17533                               (: 'end' '(' :)
     or $state[$p:lk] = 17535                               (: 'eq' '(' :)
     or $state[$p:lk] = 17536                               (: 'every' '(' :)
     or $state[$p:lk] = 17538                               (: 'except' '(' :)
     or $state[$p:lk] = 17542                               (: 'following' '(' :)
     or $state[$p:lk] = 17543                               (: 'following-sibling' '(' :)
     or $state[$p:lk] = 17544                               (: 'for' '(' :)
     or $state[$p:lk] = 17550                               (: 'function' '(' :)
     or $state[$p:lk] = 17551                               (: 'ge' '(' :)
     or $state[$p:lk] = 17553                               (: 'group' '(' :)
     or $state[$p:lk] = 17555                               (: 'gt' '(' :)
     or $state[$p:lk] = 17556                               (: 'idiv' '(' :)
     or $state[$p:lk] = 17558                               (: 'import' '(' :)
     or $state[$p:lk] = 17563                               (: 'insert' '(' :)
     or $state[$p:lk] = 17564                               (: 'instance' '(' :)
     or $state[$p:lk] = 17565                               (: 'intersect' '(' :)
     or $state[$p:lk] = 17567                               (: 'invoke' '(' :)
     or $state[$p:lk] = 17568                               (: 'is' '(' :)
     or $state[$p:lk] = 17573                               (: 'le' '(' :)
     or $state[$p:lk] = 17575                               (: 'let' '(' :)
     or $state[$p:lk] = 17578                               (: 'lt' '(' :)
     or $state[$p:lk] = 17581                               (: 'mod' '(' :)
     or $state[$p:lk] = 17582                               (: 'modify' '(' :)
     or $state[$p:lk] = 17583                               (: 'module' '(' :)
     or $state[$p:lk] = 17585                               (: 'namespace' '(' :)
     or $state[$p:lk] = 17587                               (: 'ne' '(' :)
     or $state[$p:lk] = 17597                               (: 'only' '(' :)
     or $state[$p:lk] = 17599                               (: 'or' '(' :)
     or $state[$p:lk] = 17600                               (: 'order' '(' :)
     or $state[$p:lk] = 17601                               (: 'ordered' '(' :)
     or $state[$p:lk] = 17605                               (: 'parent' '(' :)
     or $state[$p:lk] = 17610                               (: 'preceding' '(' :)
     or $state[$p:lk] = 17611                               (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 17616                               (: 'rename' '(' :)
     or $state[$p:lk] = 17617                               (: 'replace' '(' :)
     or $state[$p:lk] = 17618                               (: 'return' '(' :)
     or $state[$p:lk] = 17621                               (: 'satisfies' '(' :)
     or $state[$p:lk] = 17626                               (: 'self' '(' :)
     or $state[$p:lk] = 17632                               (: 'some' '(' :)
     or $state[$p:lk] = 17633                               (: 'stable' '(' :)
     or $state[$p:lk] = 17634                               (: 'start' '(' :)
     or $state[$p:lk] = 17644                               (: 'to' '(' :)
     or $state[$p:lk] = 17645                               (: 'transform' '(' :)
     or $state[$p:lk] = 17646                               (: 'treat' '(' :)
     or $state[$p:lk] = 17647                               (: 'try' '(' :)
     or $state[$p:lk] = 17651                               (: 'union' '(' :)
     or $state[$p:lk] = 17652                               (: 'unordered' '(' :)
     or $state[$p:lk] = 17653                               (: 'update' '(' :)
     or $state[$p:lk] = 17657                               (: 'validate' '(' :)
     or $state[$p:lk] = 17663                               (: 'where' '(' :)
     or $state[$p:lk] = 17666                               (: 'with' '(' :)
     or $state[$p:lk] = 17670                               (: 'xquery' '(' :)
     or $state[$p:lk] = 40022                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 40056                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 40534                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 40568                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 43606                               (: 'attribute' 'at' :)
     or $state[$p:lk] = 43640                               (: 'element' 'at' :)
     or $state[$p:lk] = 44118                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 44152                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 48726                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 48760                               (: 'element' 'child' :)
     or $state[$p:lk] = 49750                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 49784                               (: 'element' 'comment' :)
     or $state[$p:lk] = 52310                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 52344                               (: 'element' 'copy' :)
     or $state[$p:lk] = 54870                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 54904                               (: 'element' 'declare' :)
     or $state[$p:lk] = 55894                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 55928                               (: 'element' 'delete' :)
     or $state[$p:lk] = 56406                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 56440                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 56918                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 56952                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 60502                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 60536                               (: 'element' 'document' :)
     or $state[$p:lk] = 61014                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 61048                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 61526                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 61560                               (: 'element' 'element' :)
     or $state[$p:lk] = 63062                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 63096                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 65622                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 65656                               (: 'element' 'every' :)
     or $state[$p:lk] = 68694                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 68728                               (: 'element' 'following' :)
     or $state[$p:lk] = 69206                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 69240                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 72790                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 72824                               (: 'element' 'function' :)
     or $state[$p:lk] = 76374                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 76408                               (: 'element' 'if' :)
     or $state[$p:lk] = 76886                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 76920                               (: 'element' 'import' :)
     or $state[$p:lk] = 79446                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 79480                               (: 'element' 'insert' :)
     or $state[$p:lk] = 81494                               (: 'attribute' 'invoke' :)
     or $state[$p:lk] = 81528                               (: 'element' 'invoke' :)
     or $state[$p:lk] = 82518                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 82552                               (: 'element' 'item' :)
     or $state[$p:lk] = 89686                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 89720                               (: 'element' 'module' :)
     or $state[$p:lk] = 90710                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 90744                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 91222                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 91256                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 94294                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 94328                               (: 'element' 'node' :)
     or $state[$p:lk] = 98902                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 98936                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 100950                              (: 'attribute' 'parent' :)
     or $state[$p:lk] = 100984                              (: 'element' 'parent' :)
     or $state[$p:lk] = 103510                              (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 103544                              (: 'element' 'preceding' :)
     or $state[$p:lk] = 104022                              (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 104056                              (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 105558                              (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 105592                              (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 106582                              (: 'attribute' 'rename' :)
     or $state[$p:lk] = 106616                              (: 'element' 'rename' :)
     or $state[$p:lk] = 107094                              (: 'attribute' 'replace' :)
     or $state[$p:lk] = 107128                              (: 'element' 'replace' :)
     or $state[$p:lk] = 110166                              (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 110200                              (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 110678                              (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 110712                              (: 'element' 'schema-element' :)
     or $state[$p:lk] = 111702                              (: 'attribute' 'self' :)
     or $state[$p:lk] = 111736                              (: 'element' 'self' :)
     or $state[$p:lk] = 114774                              (: 'attribute' 'some' :)
     or $state[$p:lk] = 114808                              (: 'element' 'some' :)
     or $state[$p:lk] = 118358                              (: 'attribute' 'switch' :)
     or $state[$p:lk] = 118392                              (: 'element' 'switch' :)
     or $state[$p:lk] = 118870                              (: 'attribute' 'text' :)
     or $state[$p:lk] = 118904                              (: 'element' 'text' :)
     or $state[$p:lk] = 122454                              (: 'attribute' 'try' :)
     or $state[$p:lk] = 122488                              (: 'element' 'try' :)
     or $state[$p:lk] = 123990                              (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 124024                              (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 125014                              (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 125048                              (: 'element' 'unordered' :)
     or $state[$p:lk] = 127574                              (: 'attribute' 'validate' :)
     or $state[$p:lk] = 127608                              (: 'element' 'validate' :)
     or $state[$p:lk] = 134230                              (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 134264                              (: 'element' 'xquery' :)
     or $state[$p:lk] = 135254                              (: 'attribute' '{' :)
     or $state[$p:lk] = 135265                              (: 'comment' '{' :)
     or $state[$p:lk] = 135286                              (: 'document' '{' :)
     or $state[$p:lk] = 135288                              (: 'element' '{' :)
     or $state[$p:lk] = 135345                              (: 'namespace' '{' :)
     or $state[$p:lk] = 135361                              (: 'ordered' '{' :)
     or $state[$p:lk] = 135374                              (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 135400                              (: 'text' '{' :)
     or $state[$p:lk] = 135412) then                        (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PostfixExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing StepExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 86) then                           (: 'attribute' :)
      let $state := p:lookahead2W(243, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 120) then                     (: 'element' :)
      let $state := p:lookahead2W(242, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'contains' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'invoke' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' |
                                                               'sentences' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'times' | 'to' | 'transform' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'words' | 'xquery' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (177,                          (: 'namespace' :)
                              206)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(206, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              232,                          (: 'text' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (123,                          (: 'empty-sequence' :)
                              149,                          (: 'if' :)
                              161,                          (: 'item' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(192, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              95,                           (: 'child' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              218)) then                    (: 'self' :)
      let $state := p:lookahead2W(201, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              119,                          (: 'document-node' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              136,                          (: 'for' :)
                              142,                          (: 'function' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              178,                          (: 'namespace-node' :)
                              179,                          (: 'ne' :)
                              184,                          (: 'node' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              215,                          (: 'schema-attribute' :)
                              216,                          (: 'schema-element' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 41046                          (: 'attribute' 'and' :)
          or $state[$p:lk] = 41080                          (: 'element' 'and' :)
          or $state[$p:lk] = 41137                          (: 'namespace' 'and' :)
          or $state[$p:lk] = 41166                          (: 'processing-instruction' 'and' :)
          or $state[$p:lk] = 42582                          (: 'attribute' 'as' :)
          or $state[$p:lk] = 42616                          (: 'element' 'as' :)
          or $state[$p:lk] = 42673                          (: 'namespace' 'as' :)
          or $state[$p:lk] = 42702                          (: 'processing-instruction' 'as' :)
          or $state[$p:lk] = 43094                          (: 'attribute' 'ascending' :)
          or $state[$p:lk] = 43128                          (: 'element' 'ascending' :)
          or $state[$p:lk] = 43185                          (: 'namespace' 'ascending' :)
          or $state[$p:lk] = 43214                          (: 'processing-instruction' 'ascending' :)
          or $state[$p:lk] = 46678                          (: 'attribute' 'case' :)
          or $state[$p:lk] = 46712                          (: 'element' 'case' :)
          or $state[$p:lk] = 46769                          (: 'namespace' 'case' :)
          or $state[$p:lk] = 46798                          (: 'processing-instruction' 'case' :)
          or $state[$p:lk] = 47190                          (: 'attribute' 'cast' :)
          or $state[$p:lk] = 47224                          (: 'element' 'cast' :)
          or $state[$p:lk] = 47281                          (: 'namespace' 'cast' :)
          or $state[$p:lk] = 47310                          (: 'processing-instruction' 'cast' :)
          or $state[$p:lk] = 47702                          (: 'attribute' 'castable' :)
          or $state[$p:lk] = 47736                          (: 'element' 'castable' :)
          or $state[$p:lk] = 47793                          (: 'namespace' 'castable' :)
          or $state[$p:lk] = 47822                          (: 'processing-instruction' 'castable' :)
          or $state[$p:lk] = 49238                          (: 'attribute' 'collation' :)
          or $state[$p:lk] = 49272                          (: 'element' 'collation' :)
          or $state[$p:lk] = 49329                          (: 'namespace' 'collation' :)
          or $state[$p:lk] = 49358                          (: 'processing-instruction' 'collation' :)
          or $state[$p:lk] = 53334                          (: 'attribute' 'count' :)
          or $state[$p:lk] = 53368                          (: 'element' 'count' :)
          or $state[$p:lk] = 53425                          (: 'namespace' 'count' :)
          or $state[$p:lk] = 53454                          (: 'processing-instruction' 'count' :)
          or $state[$p:lk] = 55382                          (: 'attribute' 'default' :)
          or $state[$p:lk] = 55416                          (: 'element' 'default' :)
          or $state[$p:lk] = 55473                          (: 'namespace' 'default' :)
          or $state[$p:lk] = 55502                          (: 'processing-instruction' 'default' :)
          or $state[$p:lk] = 57430                          (: 'attribute' 'descending' :)
          or $state[$p:lk] = 57464                          (: 'element' 'descending' :)
          or $state[$p:lk] = 57521                          (: 'namespace' 'descending' :)
          or $state[$p:lk] = 57550                          (: 'processing-instruction' 'descending' :)
          or $state[$p:lk] = 59990                          (: 'attribute' 'div' :)
          or $state[$p:lk] = 60024                          (: 'element' 'div' :)
          or $state[$p:lk] = 60081                          (: 'namespace' 'div' :)
          or $state[$p:lk] = 60110                          (: 'processing-instruction' 'div' :)
          or $state[$p:lk] = 62038                          (: 'attribute' 'else' :)
          or $state[$p:lk] = 62072                          (: 'element' 'else' :)
          or $state[$p:lk] = 62129                          (: 'namespace' 'else' :)
          or $state[$p:lk] = 62158                          (: 'processing-instruction' 'else' :)
          or $state[$p:lk] = 62550                          (: 'attribute' 'empty' :)
          or $state[$p:lk] = 62584                          (: 'element' 'empty' :)
          or $state[$p:lk] = 62641                          (: 'namespace' 'empty' :)
          or $state[$p:lk] = 62670                          (: 'processing-instruction' 'empty' :)
          or $state[$p:lk] = 64086                          (: 'attribute' 'end' :)
          or $state[$p:lk] = 64120                          (: 'element' 'end' :)
          or $state[$p:lk] = 64177                          (: 'namespace' 'end' :)
          or $state[$p:lk] = 64206                          (: 'processing-instruction' 'end' :)
          or $state[$p:lk] = 65110                          (: 'attribute' 'eq' :)
          or $state[$p:lk] = 65144                          (: 'element' 'eq' :)
          or $state[$p:lk] = 65201                          (: 'namespace' 'eq' :)
          or $state[$p:lk] = 65230                          (: 'processing-instruction' 'eq' :)
          or $state[$p:lk] = 66646                          (: 'attribute' 'except' :)
          or $state[$p:lk] = 66680                          (: 'element' 'except' :)
          or $state[$p:lk] = 66737                          (: 'namespace' 'except' :)
          or $state[$p:lk] = 66766                          (: 'processing-instruction' 'except' :)
          or $state[$p:lk] = 69718                          (: 'attribute' 'for' :)
          or $state[$p:lk] = 69752                          (: 'element' 'for' :)
          or $state[$p:lk] = 69809                          (: 'namespace' 'for' :)
          or $state[$p:lk] = 69838                          (: 'processing-instruction' 'for' :)
          or $state[$p:lk] = 73302                          (: 'attribute' 'ge' :)
          or $state[$p:lk] = 73336                          (: 'element' 'ge' :)
          or $state[$p:lk] = 73393                          (: 'namespace' 'ge' :)
          or $state[$p:lk] = 73422                          (: 'processing-instruction' 'ge' :)
          or $state[$p:lk] = 74326                          (: 'attribute' 'group' :)
          or $state[$p:lk] = 74360                          (: 'element' 'group' :)
          or $state[$p:lk] = 74417                          (: 'namespace' 'group' :)
          or $state[$p:lk] = 74446                          (: 'processing-instruction' 'group' :)
          or $state[$p:lk] = 75350                          (: 'attribute' 'gt' :)
          or $state[$p:lk] = 75384                          (: 'element' 'gt' :)
          or $state[$p:lk] = 75441                          (: 'namespace' 'gt' :)
          or $state[$p:lk] = 75470                          (: 'processing-instruction' 'gt' :)
          or $state[$p:lk] = 75862                          (: 'attribute' 'idiv' :)
          or $state[$p:lk] = 75896                          (: 'element' 'idiv' :)
          or $state[$p:lk] = 75953                          (: 'namespace' 'idiv' :)
          or $state[$p:lk] = 75982                          (: 'processing-instruction' 'idiv' :)
          or $state[$p:lk] = 79958                          (: 'attribute' 'instance' :)
          or $state[$p:lk] = 79992                          (: 'element' 'instance' :)
          or $state[$p:lk] = 80049                          (: 'namespace' 'instance' :)
          or $state[$p:lk] = 80078                          (: 'processing-instruction' 'instance' :)
          or $state[$p:lk] = 80470                          (: 'attribute' 'intersect' :)
          or $state[$p:lk] = 80504                          (: 'element' 'intersect' :)
          or $state[$p:lk] = 80561                          (: 'namespace' 'intersect' :)
          or $state[$p:lk] = 80590                          (: 'processing-instruction' 'intersect' :)
          or $state[$p:lk] = 82006                          (: 'attribute' 'is' :)
          or $state[$p:lk] = 82040                          (: 'element' 'is' :)
          or $state[$p:lk] = 82097                          (: 'namespace' 'is' :)
          or $state[$p:lk] = 82126                          (: 'processing-instruction' 'is' :)
          or $state[$p:lk] = 84566                          (: 'attribute' 'le' :)
          or $state[$p:lk] = 84600                          (: 'element' 'le' :)
          or $state[$p:lk] = 84657                          (: 'namespace' 'le' :)
          or $state[$p:lk] = 84686                          (: 'processing-instruction' 'le' :)
          or $state[$p:lk] = 85590                          (: 'attribute' 'let' :)
          or $state[$p:lk] = 85624                          (: 'element' 'let' :)
          or $state[$p:lk] = 85681                          (: 'namespace' 'let' :)
          or $state[$p:lk] = 85710                          (: 'processing-instruction' 'let' :)
          or $state[$p:lk] = 87126                          (: 'attribute' 'lt' :)
          or $state[$p:lk] = 87160                          (: 'element' 'lt' :)
          or $state[$p:lk] = 87217                          (: 'namespace' 'lt' :)
          or $state[$p:lk] = 87246                          (: 'processing-instruction' 'lt' :)
          or $state[$p:lk] = 88662                          (: 'attribute' 'mod' :)
          or $state[$p:lk] = 88696                          (: 'element' 'mod' :)
          or $state[$p:lk] = 88753                          (: 'namespace' 'mod' :)
          or $state[$p:lk] = 88782                          (: 'processing-instruction' 'mod' :)
          or $state[$p:lk] = 89174                          (: 'attribute' 'modify' :)
          or $state[$p:lk] = 89208                          (: 'element' 'modify' :)
          or $state[$p:lk] = 91734                          (: 'attribute' 'ne' :)
          or $state[$p:lk] = 91768                          (: 'element' 'ne' :)
          or $state[$p:lk] = 91825                          (: 'namespace' 'ne' :)
          or $state[$p:lk] = 91854                          (: 'processing-instruction' 'ne' :)
          or $state[$p:lk] = 96854                          (: 'attribute' 'only' :)
          or $state[$p:lk] = 96888                          (: 'element' 'only' :)
          or $state[$p:lk] = 96945                          (: 'namespace' 'only' :)
          or $state[$p:lk] = 96974                          (: 'processing-instruction' 'only' :)
          or $state[$p:lk] = 97878                          (: 'attribute' 'or' :)
          or $state[$p:lk] = 97912                          (: 'element' 'or' :)
          or $state[$p:lk] = 97969                          (: 'namespace' 'or' :)
          or $state[$p:lk] = 97998                          (: 'processing-instruction' 'or' :)
          or $state[$p:lk] = 98390                          (: 'attribute' 'order' :)
          or $state[$p:lk] = 98424                          (: 'element' 'order' :)
          or $state[$p:lk] = 98481                          (: 'namespace' 'order' :)
          or $state[$p:lk] = 98510                          (: 'processing-instruction' 'order' :)
          or $state[$p:lk] = 107606                         (: 'attribute' 'return' :)
          or $state[$p:lk] = 107640                         (: 'element' 'return' :)
          or $state[$p:lk] = 107697                         (: 'namespace' 'return' :)
          or $state[$p:lk] = 107726                         (: 'processing-instruction' 'return' :)
          or $state[$p:lk] = 109142                         (: 'attribute' 'satisfies' :)
          or $state[$p:lk] = 109176                         (: 'element' 'satisfies' :)
          or $state[$p:lk] = 109233                         (: 'namespace' 'satisfies' :)
          or $state[$p:lk] = 109262                         (: 'processing-instruction' 'satisfies' :)
          or $state[$p:lk] = 115286                         (: 'attribute' 'stable' :)
          or $state[$p:lk] = 115320                         (: 'element' 'stable' :)
          or $state[$p:lk] = 115377                         (: 'namespace' 'stable' :)
          or $state[$p:lk] = 115406                         (: 'processing-instruction' 'stable' :)
          or $state[$p:lk] = 115798                         (: 'attribute' 'start' :)
          or $state[$p:lk] = 115832                         (: 'element' 'start' :)
          or $state[$p:lk] = 115889                         (: 'namespace' 'start' :)
          or $state[$p:lk] = 115918                         (: 'processing-instruction' 'start' :)
          or $state[$p:lk] = 120918                         (: 'attribute' 'to' :)
          or $state[$p:lk] = 120952                         (: 'element' 'to' :)
          or $state[$p:lk] = 121009                         (: 'namespace' 'to' :)
          or $state[$p:lk] = 121038                         (: 'processing-instruction' 'to' :)
          or $state[$p:lk] = 121430                         (: 'attribute' 'transform' :)
          or $state[$p:lk] = 121464                         (: 'element' 'transform' :)
          or $state[$p:lk] = 121942                         (: 'attribute' 'treat' :)
          or $state[$p:lk] = 121976                         (: 'element' 'treat' :)
          or $state[$p:lk] = 122033                         (: 'namespace' 'treat' :)
          or $state[$p:lk] = 122062                         (: 'processing-instruction' 'treat' :)
          or $state[$p:lk] = 124502                         (: 'attribute' 'union' :)
          or $state[$p:lk] = 124536                         (: 'element' 'union' :)
          or $state[$p:lk] = 124593                         (: 'namespace' 'union' :)
          or $state[$p:lk] = 124622                         (: 'processing-instruction' 'union' :)
          or $state[$p:lk] = 125526                         (: 'attribute' 'update' :)
          or $state[$p:lk] = 125560                         (: 'element' 'update' :)
          or $state[$p:lk] = 130646                         (: 'attribute' 'where' :)
          or $state[$p:lk] = 130680                         (: 'element' 'where' :)
          or $state[$p:lk] = 130737                         (: 'namespace' 'where' :)
          or $state[$p:lk] = 130766                         (: 'processing-instruction' 'where' :)
          or $state[$p:lk] = 132182                         (: 'attribute' 'with' :)
          or $state[$p:lk] = 132216) then                   (: 'element' 'with' :)
      let $state := p:memoized($state, 19)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-PostfixExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 19, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1
     or $state[$p:lk] = 1                                   (: IntegerLiteral :)
     or $state[$p:lk] = 2                                   (: DecimalLiteral :)
     or $state[$p:lk] = 3                                   (: DoubleLiteral :)
     or $state[$p:lk] = 4                                   (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 32                                  (: '%' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 43                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 65                                  (: '?' :)
     or $state[$p:lk] = 69                                  (: '[' :)
     or $state[$p:lk] = 73                                  (: '``[' :)
     or $state[$p:lk] = 82                                  (: 'array' :)
     or $state[$p:lk] = 171                                 (: 'map' :)
     or $state[$p:lk] = 2646                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 2680                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 7345                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 7374                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 7766                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 7800                                (: 'element' QName^Token :)
     or $state[$p:lk] = 14853                               (: URIQualifiedName '#' :)
     or $state[$p:lk] = 14863                               (: QName^Token '#' :)
     or $state[$p:lk] = 14926                               (: 'ancestor' '#' :)
     or $state[$p:lk] = 14927                               (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 14928                               (: 'and' '#' :)
     or $state[$p:lk] = 14931                               (: 'as' '#' :)
     or $state[$p:lk] = 14932                               (: 'ascending' '#' :)
     or $state[$p:lk] = 14933                               (: 'at' '#' :)
     or $state[$p:lk] = 14934                               (: 'attribute' '#' :)
     or $state[$p:lk] = 14939                               (: 'case' '#' :)
     or $state[$p:lk] = 14940                               (: 'cast' '#' :)
     or $state[$p:lk] = 14941                               (: 'castable' '#' :)
     or $state[$p:lk] = 14943                               (: 'child' '#' :)
     or $state[$p:lk] = 14944                               (: 'collation' '#' :)
     or $state[$p:lk] = 14945                               (: 'comment' '#' :)
     or $state[$p:lk] = 14950                               (: 'copy' '#' :)
     or $state[$p:lk] = 14952                               (: 'count' '#' :)
     or $state[$p:lk] = 14955                               (: 'declare' '#' :)
     or $state[$p:lk] = 14956                               (: 'default' '#' :)
     or $state[$p:lk] = 14957                               (: 'delete' '#' :)
     or $state[$p:lk] = 14958                               (: 'descendant' '#' :)
     or $state[$p:lk] = 14959                               (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 14960                               (: 'descending' '#' :)
     or $state[$p:lk] = 14965                               (: 'div' '#' :)
     or $state[$p:lk] = 14966                               (: 'document' '#' :)
     or $state[$p:lk] = 14967                               (: 'document-node' '#' :)
     or $state[$p:lk] = 14968                               (: 'element' '#' :)
     or $state[$p:lk] = 14969                               (: 'else' '#' :)
     or $state[$p:lk] = 14970                               (: 'empty' '#' :)
     or $state[$p:lk] = 14971                               (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 14973                               (: 'end' '#' :)
     or $state[$p:lk] = 14975                               (: 'eq' '#' :)
     or $state[$p:lk] = 14976                               (: 'every' '#' :)
     or $state[$p:lk] = 14978                               (: 'except' '#' :)
     or $state[$p:lk] = 14982                               (: 'following' '#' :)
     or $state[$p:lk] = 14983                               (: 'following-sibling' '#' :)
     or $state[$p:lk] = 14984                               (: 'for' '#' :)
     or $state[$p:lk] = 14990                               (: 'function' '#' :)
     or $state[$p:lk] = 14991                               (: 'ge' '#' :)
     or $state[$p:lk] = 14993                               (: 'group' '#' :)
     or $state[$p:lk] = 14995                               (: 'gt' '#' :)
     or $state[$p:lk] = 14996                               (: 'idiv' '#' :)
     or $state[$p:lk] = 14997                               (: 'if' '#' :)
     or $state[$p:lk] = 14998                               (: 'import' '#' :)
     or $state[$p:lk] = 15003                               (: 'insert' '#' :)
     or $state[$p:lk] = 15004                               (: 'instance' '#' :)
     or $state[$p:lk] = 15005                               (: 'intersect' '#' :)
     or $state[$p:lk] = 15007                               (: 'invoke' '#' :)
     or $state[$p:lk] = 15008                               (: 'is' '#' :)
     or $state[$p:lk] = 15009                               (: 'item' '#' :)
     or $state[$p:lk] = 15013                               (: 'le' '#' :)
     or $state[$p:lk] = 15015                               (: 'let' '#' :)
     or $state[$p:lk] = 15018                               (: 'lt' '#' :)
     or $state[$p:lk] = 15021                               (: 'mod' '#' :)
     or $state[$p:lk] = 15022                               (: 'modify' '#' :)
     or $state[$p:lk] = 15023                               (: 'module' '#' :)
     or $state[$p:lk] = 15025                               (: 'namespace' '#' :)
     or $state[$p:lk] = 15026                               (: 'namespace-node' '#' :)
     or $state[$p:lk] = 15027                               (: 'ne' '#' :)
     or $state[$p:lk] = 15032                               (: 'node' '#' :)
     or $state[$p:lk] = 15037                               (: 'only' '#' :)
     or $state[$p:lk] = 15039                               (: 'or' '#' :)
     or $state[$p:lk] = 15040                               (: 'order' '#' :)
     or $state[$p:lk] = 15041                               (: 'ordered' '#' :)
     or $state[$p:lk] = 15045                               (: 'parent' '#' :)
     or $state[$p:lk] = 15050                               (: 'preceding' '#' :)
     or $state[$p:lk] = 15051                               (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 15054                               (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 15056                               (: 'rename' '#' :)
     or $state[$p:lk] = 15057                               (: 'replace' '#' :)
     or $state[$p:lk] = 15058                               (: 'return' '#' :)
     or $state[$p:lk] = 15061                               (: 'satisfies' '#' :)
     or $state[$p:lk] = 15063                               (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 15064                               (: 'schema-element' '#' :)
     or $state[$p:lk] = 15066                               (: 'self' '#' :)
     or $state[$p:lk] = 15072                               (: 'some' '#' :)
     or $state[$p:lk] = 15073                               (: 'stable' '#' :)
     or $state[$p:lk] = 15074                               (: 'start' '#' :)
     or $state[$p:lk] = 15079                               (: 'switch' '#' :)
     or $state[$p:lk] = 15080                               (: 'text' '#' :)
     or $state[$p:lk] = 15084                               (: 'to' '#' :)
     or $state[$p:lk] = 15085                               (: 'transform' '#' :)
     or $state[$p:lk] = 15086                               (: 'treat' '#' :)
     or $state[$p:lk] = 15087                               (: 'try' '#' :)
     or $state[$p:lk] = 15090                               (: 'typeswitch' '#' :)
     or $state[$p:lk] = 15091                               (: 'union' '#' :)
     or $state[$p:lk] = 15092                               (: 'unordered' '#' :)
     or $state[$p:lk] = 15093                               (: 'update' '#' :)
     or $state[$p:lk] = 15097                               (: 'validate' '#' :)
     or $state[$p:lk] = 15103                               (: 'where' '#' :)
     or $state[$p:lk] = 15106                               (: 'with' '#' :)
     or $state[$p:lk] = 15110                               (: 'xquery' '#' :)
     or $state[$p:lk] = 17413                               (: URIQualifiedName '(' :)
     or $state[$p:lk] = 17423                               (: QName^Token '(' :)
     or $state[$p:lk] = 17486                               (: 'ancestor' '(' :)
     or $state[$p:lk] = 17487                               (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 17488                               (: 'and' '(' :)
     or $state[$p:lk] = 17491                               (: 'as' '(' :)
     or $state[$p:lk] = 17492                               (: 'ascending' '(' :)
     or $state[$p:lk] = 17493                               (: 'at' '(' :)
     or $state[$p:lk] = 17499                               (: 'case' '(' :)
     or $state[$p:lk] = 17500                               (: 'cast' '(' :)
     or $state[$p:lk] = 17501                               (: 'castable' '(' :)
     or $state[$p:lk] = 17503                               (: 'child' '(' :)
     or $state[$p:lk] = 17504                               (: 'collation' '(' :)
     or $state[$p:lk] = 17510                               (: 'copy' '(' :)
     or $state[$p:lk] = 17512                               (: 'count' '(' :)
     or $state[$p:lk] = 17515                               (: 'declare' '(' :)
     or $state[$p:lk] = 17516                               (: 'default' '(' :)
     or $state[$p:lk] = 17517                               (: 'delete' '(' :)
     or $state[$p:lk] = 17518                               (: 'descendant' '(' :)
     or $state[$p:lk] = 17519                               (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 17520                               (: 'descending' '(' :)
     or $state[$p:lk] = 17525                               (: 'div' '(' :)
     or $state[$p:lk] = 17526                               (: 'document' '(' :)
     or $state[$p:lk] = 17529                               (: 'else' '(' :)
     or $state[$p:lk] = 17530                               (: 'empty' '(' :)
     or $state[$p:lk] = 17533                               (: 'end' '(' :)
     or $state[$p:lk] = 17535                               (: 'eq' '(' :)
     or $state[$p:lk] = 17536                               (: 'every' '(' :)
     or $state[$p:lk] = 17538                               (: 'except' '(' :)
     or $state[$p:lk] = 17542                               (: 'following' '(' :)
     or $state[$p:lk] = 17543                               (: 'following-sibling' '(' :)
     or $state[$p:lk] = 17544                               (: 'for' '(' :)
     or $state[$p:lk] = 17550                               (: 'function' '(' :)
     or $state[$p:lk] = 17551                               (: 'ge' '(' :)
     or $state[$p:lk] = 17553                               (: 'group' '(' :)
     or $state[$p:lk] = 17555                               (: 'gt' '(' :)
     or $state[$p:lk] = 17556                               (: 'idiv' '(' :)
     or $state[$p:lk] = 17558                               (: 'import' '(' :)
     or $state[$p:lk] = 17563                               (: 'insert' '(' :)
     or $state[$p:lk] = 17564                               (: 'instance' '(' :)
     or $state[$p:lk] = 17565                               (: 'intersect' '(' :)
     or $state[$p:lk] = 17567                               (: 'invoke' '(' :)
     or $state[$p:lk] = 17568                               (: 'is' '(' :)
     or $state[$p:lk] = 17573                               (: 'le' '(' :)
     or $state[$p:lk] = 17575                               (: 'let' '(' :)
     or $state[$p:lk] = 17578                               (: 'lt' '(' :)
     or $state[$p:lk] = 17581                               (: 'mod' '(' :)
     or $state[$p:lk] = 17582                               (: 'modify' '(' :)
     or $state[$p:lk] = 17583                               (: 'module' '(' :)
     or $state[$p:lk] = 17585                               (: 'namespace' '(' :)
     or $state[$p:lk] = 17587                               (: 'ne' '(' :)
     or $state[$p:lk] = 17597                               (: 'only' '(' :)
     or $state[$p:lk] = 17599                               (: 'or' '(' :)
     or $state[$p:lk] = 17600                               (: 'order' '(' :)
     or $state[$p:lk] = 17601                               (: 'ordered' '(' :)
     or $state[$p:lk] = 17605                               (: 'parent' '(' :)
     or $state[$p:lk] = 17610                               (: 'preceding' '(' :)
     or $state[$p:lk] = 17611                               (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 17616                               (: 'rename' '(' :)
     or $state[$p:lk] = 17617                               (: 'replace' '(' :)
     or $state[$p:lk] = 17618                               (: 'return' '(' :)
     or $state[$p:lk] = 17621                               (: 'satisfies' '(' :)
     or $state[$p:lk] = 17626                               (: 'self' '(' :)
     or $state[$p:lk] = 17632                               (: 'some' '(' :)
     or $state[$p:lk] = 17633                               (: 'stable' '(' :)
     or $state[$p:lk] = 17634                               (: 'start' '(' :)
     or $state[$p:lk] = 17644                               (: 'to' '(' :)
     or $state[$p:lk] = 17645                               (: 'transform' '(' :)
     or $state[$p:lk] = 17646                               (: 'treat' '(' :)
     or $state[$p:lk] = 17647                               (: 'try' '(' :)
     or $state[$p:lk] = 17651                               (: 'union' '(' :)
     or $state[$p:lk] = 17652                               (: 'unordered' '(' :)
     or $state[$p:lk] = 17653                               (: 'update' '(' :)
     or $state[$p:lk] = 17657                               (: 'validate' '(' :)
     or $state[$p:lk] = 17663                               (: 'where' '(' :)
     or $state[$p:lk] = 17666                               (: 'with' '(' :)
     or $state[$p:lk] = 17670                               (: 'xquery' '(' :)
     or $state[$p:lk] = 40022                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 40056                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 40534                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 40568                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 43606                               (: 'attribute' 'at' :)
     or $state[$p:lk] = 43640                               (: 'element' 'at' :)
     or $state[$p:lk] = 44118                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 44152                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 48726                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 48760                               (: 'element' 'child' :)
     or $state[$p:lk] = 49750                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 49784                               (: 'element' 'comment' :)
     or $state[$p:lk] = 52310                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 52344                               (: 'element' 'copy' :)
     or $state[$p:lk] = 54870                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 54904                               (: 'element' 'declare' :)
     or $state[$p:lk] = 55894                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 55928                               (: 'element' 'delete' :)
     or $state[$p:lk] = 56406                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 56440                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 56918                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 56952                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 60502                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 60536                               (: 'element' 'document' :)
     or $state[$p:lk] = 61014                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 61048                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 61526                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 61560                               (: 'element' 'element' :)
     or $state[$p:lk] = 63062                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 63096                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 65622                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 65656                               (: 'element' 'every' :)
     or $state[$p:lk] = 68694                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 68728                               (: 'element' 'following' :)
     or $state[$p:lk] = 69206                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 69240                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 72790                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 72824                               (: 'element' 'function' :)
     or $state[$p:lk] = 76374                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 76408                               (: 'element' 'if' :)
     or $state[$p:lk] = 76886                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 76920                               (: 'element' 'import' :)
     or $state[$p:lk] = 79446                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 79480                               (: 'element' 'insert' :)
     or $state[$p:lk] = 81494                               (: 'attribute' 'invoke' :)
     or $state[$p:lk] = 81528                               (: 'element' 'invoke' :)
     or $state[$p:lk] = 82518                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 82552                               (: 'element' 'item' :)
     or $state[$p:lk] = 89686                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 89720                               (: 'element' 'module' :)
     or $state[$p:lk] = 90710                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 90744                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 91222                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 91256                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 94294                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 94328                               (: 'element' 'node' :)
     or $state[$p:lk] = 98902                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 98936                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 100950                              (: 'attribute' 'parent' :)
     or $state[$p:lk] = 100984                              (: 'element' 'parent' :)
     or $state[$p:lk] = 103510                              (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 103544                              (: 'element' 'preceding' :)
     or $state[$p:lk] = 104022                              (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 104056                              (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 105558                              (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 105592                              (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 106582                              (: 'attribute' 'rename' :)
     or $state[$p:lk] = 106616                              (: 'element' 'rename' :)
     or $state[$p:lk] = 107094                              (: 'attribute' 'replace' :)
     or $state[$p:lk] = 107128                              (: 'element' 'replace' :)
     or $state[$p:lk] = 110166                              (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 110200                              (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 110678                              (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 110712                              (: 'element' 'schema-element' :)
     or $state[$p:lk] = 111702                              (: 'attribute' 'self' :)
     or $state[$p:lk] = 111736                              (: 'element' 'self' :)
     or $state[$p:lk] = 114774                              (: 'attribute' 'some' :)
     or $state[$p:lk] = 114808                              (: 'element' 'some' :)
     or $state[$p:lk] = 118358                              (: 'attribute' 'switch' :)
     or $state[$p:lk] = 118392                              (: 'element' 'switch' :)
     or $state[$p:lk] = 118870                              (: 'attribute' 'text' :)
     or $state[$p:lk] = 118904                              (: 'element' 'text' :)
     or $state[$p:lk] = 122454                              (: 'attribute' 'try' :)
     or $state[$p:lk] = 122488                              (: 'element' 'try' :)
     or $state[$p:lk] = 123990                              (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 124024                              (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 125014                              (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 125048                              (: 'element' 'unordered' :)
     or $state[$p:lk] = 127574                              (: 'attribute' 'validate' :)
     or $state[$p:lk] = 127608                              (: 'element' 'validate' :)
     or $state[$p:lk] = 134230                              (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 134264                              (: 'element' 'xquery' :)
     or $state[$p:lk] = 135254                              (: 'attribute' '{' :)
     or $state[$p:lk] = 135265                              (: 'comment' '{' :)
     or $state[$p:lk] = 135286                              (: 'document' '{' :)
     or $state[$p:lk] = 135288                              (: 'element' '{' :)
     or $state[$p:lk] = 135345                              (: 'namespace' '{' :)
     or $state[$p:lk] = 135361                              (: 'ordered' '{' :)
     or $state[$p:lk] = 135374                              (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 135400                              (: 'text' '{' :)
     or $state[$p:lk] = 135412) then                        (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PostfixExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 26) then                         (: '!' :)
        let $state := p:lookahead2W(234, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 45                          (: '/' :)
           and $state[$p:lk] != 46                          (: '//' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 61                          (: '=>' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 245                         (: 'update' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269                         (: '}`' :)
           and $state[$p:lk] != 23066                       (: '!' '/' :)
           and $state[$p:lk] != 23578) then                 (: '!' '//' :)
        let $state := p:memoized($state, 18)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 45) then             (: '/' :)
                let $state := p:consume(45, $input, $state) (: '/' :)
                return $state
              else if ($state[$p:l1] = 46) then             (: '//' :)
                let $state := p:consume(46, $input, $state) (: '//' :)
                return $state
              else
                let $state := p:consume(26, $input, $state) (: '!' :)
                return $state
            let $state := p:lookahead1W(233, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                                '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                                'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                                'cast' | 'castable' | 'child' | 'collation' |
                                                                'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                                'delete' | 'descendant' | 'descendant-or-self' |
                                                                'descending' | 'div' | 'document' | 'document-node' |
                                                                'element' | 'else' | 'empty' | 'empty-sequence' |
                                                                'end' | 'eq' | 'every' | 'except' | 'following' |
                                                                'following-sibling' | 'for' | 'function' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                'parent' | 'preceding' | 'preceding-sibling' |
                                                                'processing-instruction' | 'rename' | 'replace' |
                                                                'return' | 'satisfies' | 'schema-attribute' |
                                                                'schema-element' | 'self' | 'some' | 'stable' |
                                                                'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                'update' | 'validate' | 'where' | 'with' | 'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-StepExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 45                               (: '/' :)
      and $state[$p:lk] != 46) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 45) then                 (: '/' :)
            let $state := p:consume(45, $input, $state)     (: '/' :)
            return $state
          else if ($state[$p:l1] = 46) then                 (: '//' :)
            let $state := p:consume(46, $input, $state)     (: '//' :)
            return $state
          else
            let $state := p:consume(26, $input, $state)     (: '!' :)
            return $state
        let $state := p:lookahead1W(233, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 26) then                         (: '!' :)
        let $state := p:lookahead2W(234, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 45                          (: '/' :)
           and $state[$p:lk] != 46                          (: '//' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 61                          (: '=>' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 245                         (: 'update' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269                         (: '}`' :)
           and $state[$p:lk] != 23066                       (: '!' '/' :)
           and $state[$p:lk] != 23578) then                 (: '!' '//' :)
        let $state := p:memoized($state, 18)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 45) then             (: '/' :)
                let $state := p:consume(45, $input, $state) (: '/' :)
                return $state
              else if ($state[$p:l1] = 46) then             (: '//' :)
                let $state := p:consume(46, $input, $state) (: '//' :)
                return $state
              else
                let $state := p:consume(26, $input, $state) (: '!' :)
                return $state
            let $state := p:lookahead1W(233, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                                '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                                'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                                'cast' | 'castable' | 'child' | 'collation' |
                                                                'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                                'delete' | 'descendant' | 'descendant-or-self' |
                                                                'descending' | 'div' | 'document' | 'document-node' |
                                                                'element' | 'else' | 'empty' | 'empty-sequence' |
                                                                'end' | 'eq' | 'every' | 'except' | 'following' |
                                                                'following-sibling' | 'for' | 'function' | 'ge' |
                                                                'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                'parent' | 'preceding' | 'preceding-sibling' |
                                                                'processing-instruction' | 'rename' | 'replace' |
                                                                'return' | 'satisfies' | 'schema-attribute' |
                                                                'schema-element' | 'self' | 'some' | 'stable' |
                                                                'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                'treat' | 'try' | 'typeswitch' | 'union' | 'unordered' |
                                                                'update' | 'validate' | 'where' | 'with' | 'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-StepExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 18, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 18, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-RelativePathExpr-1($input, $state)
      else if ($state[$p:lk] != -1
           and $state[$p:lk] != 45                          (: '/' :)
           and $state[$p:lk] != 46) then                    (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 45) then                 (: '/' :)
            let $state := p:consume(45, $input, $state)     (: '/' :)
            return $state
          else if ($state[$p:l1] = 46) then                 (: '//' :)
            let $state := p:consume(46, $input, $state)     (: '//' :)
            return $state
          else
            let $state := p:consume(26, $input, $state)     (: '!' :)
            return $state
        let $state := p:lookahead1W(233, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-StepExpr($input, $state)
        return p:try-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StepExpr($input, $state)
  let $state := p:try-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/' :)
      let $state := p:consume(45, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(244, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ':' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' | ']' |
                                                               '``[' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'words' | 'xquery' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25                         (: EOF :)
              or $state[$p:l1] = 26                         (: '!' :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 40                         (: ',' :)
              or $state[$p:l1] = 41                         (: '-' :)
              or $state[$p:l1] = 48                         (: ':' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '=>' :)
              or $state[$p:l1] = 62                         (: '>' :)
              or $state[$p:l1] = 63                         (: '>=' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 70                         (: ']' :)
              or $state[$p:l1] = 75                         (: 'after' :)
              or $state[$p:l1] = 88                         (: 'before' :)
              or $state[$p:l1] = 99                         (: 'contains' :)
              or $state[$p:l1] = 158                        (: 'into' :)
              or $state[$p:l1] = 196                        (: 'paragraphs' :)
              or $state[$p:l1] = 221                        (: 'sentences' :)
              or $state[$p:l1] = 235                        (: 'times' :)
              or $state[$p:l1] = 261                        (: 'words' :)
              or $state[$p:l1] = 266                        (: '|' :)
              or $state[$p:l1] = 267                        (: '||' :)
              or $state[$p:l1] = 268                        (: '}' :)
              or $state[$p:l1] = 269) then                  (: '}`' :)
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 46) then                       (: '//' :)
      let $state := p:consume(46, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(233, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing PathExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/' :)
      let $state := p:consume(45, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(244, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ':' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' | ']' |
                                                               '``[' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'contains' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'paragraphs' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'sentences' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'words' | 'xquery' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25                         (: EOF :)
              or $state[$p:l1] = 26                         (: '!' :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 40                         (: ',' :)
              or $state[$p:l1] = 41                         (: '-' :)
              or $state[$p:l1] = 48                         (: ':' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '=>' :)
              or $state[$p:l1] = 62                         (: '>' :)
              or $state[$p:l1] = 63                         (: '>=' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 70                         (: ']' :)
              or $state[$p:l1] = 75                         (: 'after' :)
              or $state[$p:l1] = 88                         (: 'before' :)
              or $state[$p:l1] = 99                         (: 'contains' :)
              or $state[$p:l1] = 158                        (: 'into' :)
              or $state[$p:l1] = 196                        (: 'paragraphs' :)
              or $state[$p:l1] = 221                        (: 'sentences' :)
              or $state[$p:l1] = 235                        (: 'times' :)
              or $state[$p:l1] = 261                        (: 'words' :)
              or $state[$p:l1] = 266                        (: '|' :)
              or $state[$p:l1] = 267                        (: '||' :)
              or $state[$p:l1] = 268                        (: '}' :)
              or $state[$p:l1] = 269) then                  (: '}`' :)
          $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 46) then                       (: '//' :)
      let $state := p:consume(46, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(233, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-RelativePathExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26) then                           (: '!' :)
      $state
    else
      let $state := p:consume(26, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(234, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26) then                           (: '!' :)
      $state
    else
      let $state := p:consume(26, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(234, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PathExpr($input, $state)
      return p:try-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PathExpr($input, $state)
  let $state := p:try-SimpleMapExpr-1($input, $state)
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'lax' :)
      let $state := p:consume(164, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(229, $input, $state)          (: 'strict' :)
      return $state
  return $state
};

(:~
 : Try parsing ValidationMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'lax' :)
      let $state := p:consume(164, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(229, $input, $state)          (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(249, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 264) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 241) then                  (: 'type' :)
          let $state := p:consume(241, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing ValidateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(249, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 264) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 241) then                  (: 'type' :)
          let $state := p:consume(241, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeName($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 249) then                          (: 'validate' :)
      let $state := p:lookahead2W(212, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'type' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' |
                                                               '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 84217                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 117497                         (: 'validate' 'strict' :)
          or $state[$p:lk] = 123641                         (: 'validate' 'type' :)
          or $state[$p:lk] = 135417) then                   (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SimpleMapExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 249) then                          (: 'validate' :)
      let $state := p:lookahead2W(212, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'lax' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'strict' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'type' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '{' | '|' | '||' | '}' |
                                                               '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 84217                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 117497                         (: 'validate' 'strict' :)
          or $state[$p:lk] = 123641                         (: 'validate' 'type' :)
          or $state[$p:lk] = 135417) then                   (: 'validate' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExtensionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SimpleMapExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 41) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 41) then                 (: '-' :)
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 41) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 41) then                 (: '-' :)
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
          else
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
        return p:try-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ValueExpr($input, $state)
  return $state
};

(:~
 : Try parsing UnaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ArrowExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrowExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                               '>=' | '>>' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 61) then                         (: '=>' :)
        $state
      else
        let $state := p:consume(61, $input, $state)         (: '=>' :)
        let $state := p:lookahead1W(227, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '$' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ArrowFunctionSpecifier($input, $state)
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | '(' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ArgumentList($input, $state)
        return p:parse-ArrowExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArrowExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrowExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                               '>=' | '>>' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 61) then                         (: '=>' :)
        $state
      else
        let $state := p:consume(61, $input, $state)         (: '=>' :)
        let $state := p:lookahead1W(227, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '$' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ArrowFunctionSpecifier($input, $state)
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | '(' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ArgumentList($input, $state)
        return p:try-ArrowExpr-1($input, $state)
};

(:~
 : Parse ArrowExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrowExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnaryExpr($input, $state)
  let $state := p:parse-ArrowExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing ArrowExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrowExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnaryExpr($input, $state)
  let $state := p:try-ArrowExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BasexUpdateExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexUpdateExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] eq 245) then                        (: 'update' :)
        let $state := p:lookahead2W(239, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '{' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 135413) then                     (: 'update' '{' :)
        $state
      else
        let $state := p:consume(245, $input, $state)        (: 'update' :)
        let $state := p:lookahead1W(80, $input, $state)     (: S^WS | ('(' ':') | '{' :)
        let $state := p:consume(264, $input, $state)        (: '{' :)
        let $state := p:lookahead1W(240, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 268) then               (: '}' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Expr($input, $state)
            return $state
          else
            $state
        let $state := p:consume(268, $input, $state)        (: '}' :)
        return p:parse-BasexUpdateExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BasexUpdateExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexUpdateExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] eq 245) then                        (: 'update' :)
        let $state := p:lookahead2W(239, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '{' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 135413) then                     (: 'update' '{' :)
        $state
      else
        let $state := p:consume(245, $input, $state)        (: 'update' :)
        let $state := p:lookahead1W(80, $input, $state)     (: S^WS | ('(' ':') | '{' :)
        let $state := p:consume(264, $input, $state)        (: '{' :)
        let $state := p:lookahead1W(240, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 268) then               (: '}' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-Expr($input, $state)
            return $state
          else
            $state
        let $state := p:consume(268, $input, $state)        (: '}' :)
        return p:try-BasexUpdateExpr-1($input, $state)
};

(:~
 : Parse BasexUpdateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexUpdateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ArrowExpr($input, $state)
  let $state := p:parse-BasexUpdateExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing BasexUpdateExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexUpdateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ArrowExpr($input, $state)
  let $state := p:try-BasexUpdateExpr-1($input, $state)
  return $state
};

(:~
 : Parse BasexUpdate1Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexUpdate1Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-BasexUpdateExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing BasexUpdate1Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexUpdate1Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-BasexUpdateExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TransformWithExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TransformWithExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-BasexUpdate1Expr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 237) then                          (: 'transform' :)
      let $state := p:lookahead2W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 132333) then                   (: 'transform' 'with' :)
      let $state := p:memoized($state, 17)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(237, $input, $state)      (: 'transform' :)
          let $state := p:lookahead1W(78, $input, $state)   (: S^WS | ('(' ':') | 'with' :)
          let $state := p:consume(258, $input, $state)      (: 'with' :)
          let $state := p:lookahead1W(80, $input, $state)   (: S^WS | ('(' ':') | '{' :)
          let $state := p:consume(264, $input, $state)      (: '{' :)
          let $state := p:lookahead1W(240, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 268) then             (: '}' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Expr($input, $state)
              return $state
            else
              $state
          let $state := p:consume(268, $input, $state)      (: '}' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(240, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 268) then                 (: '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          return $state
        else
          $state
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing TransformWithExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TransformWithExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-BasexUpdate1Expr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 237) then                          (: 'transform' :)
      let $state := p:lookahead2W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 132333) then                   (: 'transform' 'with' :)
      let $state := p:memoized($state, 17)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(237, $input, $state)      (: 'transform' :)
          let $state := p:lookahead1W(78, $input, $state)   (: S^WS | ('(' ':') | 'with' :)
          let $state := p:consume(258, $input, $state)      (: 'with' :)
          let $state := p:lookahead1W(80, $input, $state)   (: S^WS | ('(' ':') | '{' :)
          let $state := p:consume(264, $input, $state)      (: '{' :)
          let $state := p:lookahead1W(240, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 268) then             (: '}' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-Expr($input, $state)
              return $state
            else
              $state
          let $state := p:consume(268, $input, $state)      (: '}' :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 17, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(240, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 268) then                 (: '}' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-Expr($input, $state)
          return $state
        else
          $state
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TransformWithExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 92) then                           (: 'cast' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42588) then                    (: 'cast' 'as' :)
      let $state := p:memoized($state, 16)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(92, $input, $state)       (: 'cast' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing CastExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TransformWithExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 92) then                           (: 'cast' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42588) then                    (: 'cast' 'as' :)
      let $state := p:memoized($state, 16)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(92, $input, $state)       (: 'cast' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 16, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 93) then                           (: 'castable' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42589) then                    (: 'castable' 'as' :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(93, $input, $state)       (: 'castable' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing CastableExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CastExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 93) then                           (: 'castable' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42589) then                    (: 'castable' 'as' :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(93, $input, $state)       (: 'castable' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SingleType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 15, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 238) then                          (: 'treat' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42734) then                    (: 'treat' 'as' :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(238, $input, $state)      (: 'treat' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing TreatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CastableExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 238) then                          (: 'treat' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42734) then                    (: 'treat' 'as' :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(238, $input, $state)      (: 'treat' :)
          let $state := p:lookahead1W(33, $input, $state)   (: S^WS | ('(' ':') | 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 14, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 156) then                          (: 'instance' :)
      let $state := p:lookahead2W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 96412) then                    (: 'instance' 'of' :)
      let $state := p:memoized($state, 13)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(156, $input, $state)      (: 'instance' :)
          let $state := p:lookahead1W(59, $input, $state)   (: S^WS | ('(' ':') | 'of' :)
          let $state := p:consume(188, $input, $state)      (: 'of' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TreatExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 156) then                          (: 'instance' :)
      let $state := p:lookahead2W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 96412) then                    (: 'instance' 'of' :)
      let $state := p:memoized($state, 13)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(156, $input, $state)      (: 'instance' :)
          let $state := p:lookahead1W(59, $input, $state)   (: S^WS | ('(' ':') | 'of' :)
          let $state := p:consume(188, $input, $state)      (: 'of' :)
          let $state := p:lookahead1W(229, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SequenceType($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 13, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           157)) then                       (: 'intersect' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 12)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 157) then            (: 'intersect' :)
                let $state := p:consume(157, $input, $state) (: 'intersect' :)
                return $state
              else
                let $state := p:consume(130, $input, $state) (: 'except' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-InstanceofExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 157) then                (: 'intersect' :)
            let $state := p:consume(157, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(130, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(186, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           157)) then                       (: 'intersect' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 12)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 157) then            (: 'intersect' :)
                let $state := p:consume(157, $input, $state) (: 'intersect' :)
                return $state
              else
                let $state := p:consume(130, $input, $state) (: 'except' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-InstanceofExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 12, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 12, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-IntersectExceptExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 157) then                (: 'intersect' :)
            let $state := p:consume(157, $input, $state)    (: 'intersect' :)
            return $state
          else
            let $state := p:consume(130, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-InstanceofExpr($input, $state)
        return p:try-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InstanceofExpr($input, $state)
  let $state := p:try-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (243,                             (: 'union' :)
                           266)) then                       (: '|' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 11)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 243) then            (: 'union' :)
                let $state := p:consume(243, $input, $state) (: 'union' :)
                return $state
              else
                let $state := p:consume(266, $input, $state) (: '|' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-IntersectExceptExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 243) then                (: 'union' :)
            let $state := p:consume(243, $input, $state)    (: 'union' :)
            return $state
          else
            let $state := p:consume(266, $input, $state)    (: '|' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (243,                             (: 'union' :)
                           266)) then                       (: '|' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 11)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 243) then            (: 'union' :)
                let $state := p:consume(243, $input, $state) (: 'union' :)
                return $state
              else
                let $state := p:consume(266, $input, $state) (: '|' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-IntersectExceptExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 11, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 11, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-UnionExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 243) then                (: 'union' :)
            let $state := p:consume(243, $input, $state)    (: 'union' :)
            return $state
          else
            let $state := p:consume(266, $input, $state)    (: '|' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-IntersectExceptExpr($input, $state)
        return p:try-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing UnionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-IntersectExceptExpr($input, $state)
  let $state := p:try-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (38,                              (: '*' :)
                           117,                             (: 'div' :)
                           148,                             (: 'idiv' :)
                           173)) then                       (: 'mod' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 10)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 38) then             (: '*' :)
                let $state := p:consume(38, $input, $state) (: '*' :)
                return $state
              else if ($state[$p:l1] = 117) then            (: 'div' :)
                let $state := p:consume(117, $input, $state) (: 'div' :)
                return $state
              else if ($state[$p:l1] = 148) then            (: 'idiv' :)
                let $state := p:consume(148, $input, $state) (: 'idiv' :)
                return $state
              else
                let $state := p:consume(173, $input, $state) (: 'mod' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-UnionExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '*' :)
            let $state := p:consume(38, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 117) then                (: 'div' :)
            let $state := p:consume(117, $input, $state)    (: 'div' :)
            return $state
          else if ($state[$p:l1] = 148) then                (: 'idiv' :)
            let $state := p:consume(148, $input, $state)    (: 'idiv' :)
            return $state
          else
            let $state := p:consume(173, $input, $state)    (: 'mod' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (38,                              (: '*' :)
                           117,                             (: 'div' :)
                           148,                             (: 'idiv' :)
                           173)) then                       (: 'mod' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 10)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 38) then             (: '*' :)
                let $state := p:consume(38, $input, $state) (: '*' :)
                return $state
              else if ($state[$p:l1] = 117) then            (: 'div' :)
                let $state := p:consume(117, $input, $state) (: 'div' :)
                return $state
              else if ($state[$p:l1] = 148) then            (: 'idiv' :)
                let $state := p:consume(148, $input, $state) (: 'idiv' :)
                return $state
              else
                let $state := p:consume(173, $input, $state) (: 'mod' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-UnionExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 10, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 10, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-MultiplicativeExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 38) then                 (: '*' :)
            let $state := p:consume(38, $input, $state)     (: '*' :)
            return $state
          else if ($state[$p:l1] = 117) then                (: 'div' :)
            let $state := p:consume(117, $input, $state)    (: 'div' :)
            return $state
          else if ($state[$p:l1] = 148) then                (: 'idiv' :)
            let $state := p:consume(148, $input, $state)    (: 'idiv' :)
            return $state
          else
            let $state := p:consume(173, $input, $state)    (: 'mod' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-UnionExpr($input, $state)
        return p:try-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-UnionExpr($input, $state)
  let $state := p:try-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (39,                              (: '+' :)
                           41)) then                        (: '-' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 39) then             (: '+' :)
                let $state := p:consume(39, $input, $state) (: '+' :)
                return $state
              else
                let $state := p:consume(41, $input, $state) (: '-' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-MultiplicativeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '+' :)
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
          else
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = (39,                              (: '+' :)
                           41)) then                        (: '-' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 39) then             (: '+' :)
                let $state := p:consume(39, $input, $state) (: '+' :)
                return $state
              else
                let $state := p:consume(41, $input, $state) (: '-' :)
                return $state
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-MultiplicativeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 9, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 9, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-AdditiveExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '+' :)
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
          else
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-MultiplicativeExpr($input, $state)
        return p:try-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MultiplicativeExpr($input, $state)
  let $state := p:try-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 236) then                          (: 'to' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 27                            (: '!=' :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 53                            (: '<' :)
         and $state[$p:lk] != 57                            (: '<<' :)
         and $state[$p:lk] != 58                            (: '<=' :)
         and $state[$p:lk] != 60                            (: '=' :)
         and $state[$p:lk] != 62                            (: '>' :)
         and $state[$p:lk] != 63                            (: '>=' :)
         and $state[$p:lk] != 64                            (: '>>' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 127                           (: 'eq' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 143                           (: 'ge' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 147                           (: 'gt' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 160                           (: 'is' :)
         and $state[$p:lk] != 165                           (: 'le' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 170                           (: 'lt' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 179                           (: 'ne' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(236, $input, $state)      (: 'to' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing RangeExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 236) then                          (: 'to' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 27                            (: '!=' :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 53                            (: '<' :)
         and $state[$p:lk] != 57                            (: '<<' :)
         and $state[$p:lk] != 58                            (: '<=' :)
         and $state[$p:lk] != 60                            (: '=' :)
         and $state[$p:lk] != 62                            (: '>' :)
         and $state[$p:lk] != 63                            (: '>=' :)
         and $state[$p:lk] != 64                            (: '>>' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 127                           (: 'eq' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 143                           (: 'ge' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 147                           (: 'gt' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 160                           (: 'is' :)
         and $state[$p:lk] != 165                           (: 'le' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 170                           (: 'lt' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 179                           (: 'ne' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 8)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(236, $input, $state)      (: 'to' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-AdditiveExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 8, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 267) then                        (: '||' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(267, $input, $state)    (: '||' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-RangeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(267, $input, $state)        (: '||' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-RangeExpr($input, $state)
        return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 267) then                        (: '||' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(267, $input, $state)    (: '||' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-RangeExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 7, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 7, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-StringConcatExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(267, $input, $state)        (: '||' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-RangeExpr($input, $state)
        return p:try-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-RangeExpr($input, $state)
  let $state := p:try-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Parse FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 99) then                           (: 'contains' :)
      let $state := p:lookahead2W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 118883) then                   (: 'contains' 'text' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(99, $input, $state)       (: 'contains' :)
          let $state := p:lookahead1W(69, $input, $state)   (: S^WS | ('(' ':') | 'text' :)
          let $state := p:consume(232, $input, $state)      (: 'text' :)
          let $state := p:lookahead1W(153, $input, $state)  (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTSelection($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 259) then              (: 'without' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-FTIgnoreOption($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(99, $input, $state)           (: 'contains' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 259) then                  (: 'without' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTContainsExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTContainsExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:l1] eq 99) then                           (: 'contains' :)
      let $state := p:lookahead2W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 118883) then                   (: 'contains' 'text' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:consume(99, $input, $state)       (: 'contains' :)
          let $state := p:lookahead1W(69, $input, $state)   (: S^WS | ('(' ':') | 'text' :)
          let $state := p:consume(232, $input, $state)      (: 'text' :)
          let $state := p:lookahead1W(153, $input, $state)  (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTSelection($input, $state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 259) then              (: 'without' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-FTIgnoreOption($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 6, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:consume(99, $input, $state)           (: 'contains' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      let $state := p:lookahead1W(153, $input, $state)      (: StringLiteral | S^WS | '(' | '(#' | ('(' ':') | 'ftnot' |
                                                               '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTSelection($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 259) then                  (: 'without' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTIgnoreOption($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:l1] = (27,                                (: '!=' :)
                         53,                                (: '<' :)
                         57,                                (: '<<' :)
                         58,                                (: '<=' :)
                         60,                                (: '=' :)
                         62,                                (: '>' :)
                         63,                                (: '>=' :)
                         64,                                (: '>>' :)
                         127,                               (: 'eq' :)
                         143,                               (: 'ge' :)
                         147,                               (: 'gt' :)
                         160,                               (: 'is' :)
                         165,                               (: 'le' :)
                         170,                               (: 'lt' :)
                         179)) then                         (: 'ne' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 236                           (: 'to' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 127                    (: 'eq' :)
                  or $state[$p:l1] = 143                    (: 'ge' :)
                  or $state[$p:l1] = 147                    (: 'gt' :)
                  or $state[$p:l1] = 165                    (: 'le' :)
                  or $state[$p:l1] = 170                    (: 'lt' :)
                  or $state[$p:l1] = 179) then              (: 'ne' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ValueComp($input, $state)
              return $state
            else if ($state[$p:l1] = 57                     (: '<<' :)
                  or $state[$p:l1] = 64                     (: '>>' :)
                  or $state[$p:l1] = 160) then              (: 'is' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-NodeComp($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-GeneralComp($input, $state)
              return $state
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTContainsExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 127                        (: 'eq' :)
              or $state[$p:l1] = 143                        (: 'ge' :)
              or $state[$p:l1] = 147                        (: 'gt' :)
              or $state[$p:l1] = 165                        (: 'le' :)
              or $state[$p:l1] = 170                        (: 'lt' :)
              or $state[$p:l1] = 179) then                  (: 'ne' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 160) then                  (: 'is' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeComp($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTContainsExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTContainsExpr($input, $state)
  let $state :=
    if ($state[$p:l1] = (27,                                (: '!=' :)
                         53,                                (: '<' :)
                         57,                                (: '<<' :)
                         58,                                (: '<=' :)
                         60,                                (: '=' :)
                         62,                                (: '>' :)
                         63,                                (: '>=' :)
                         64,                                (: '>>' :)
                         127,                               (: 'eq' :)
                         143,                               (: 'ge' :)
                         147,                               (: 'gt' :)
                         160,                               (: 'is' :)
                         165,                               (: 'le' :)
                         170,                               (: 'lt' :)
                         179)) then                         (: 'ne' :)
      let $state := p:lookahead2W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] != 25                            (: EOF :)
         and $state[$p:lk] != 37                            (: ')' :)
         and $state[$p:lk] != 38                            (: '*' :)
         and $state[$p:lk] != 39                            (: '+' :)
         and $state[$p:lk] != 40                            (: ',' :)
         and $state[$p:lk] != 41                            (: '-' :)
         and $state[$p:lk] != 48                            (: ':' :)
         and $state[$p:lk] != 52                            (: ';' :)
         and $state[$p:lk] != 70                            (: ']' :)
         and $state[$p:lk] != 75                            (: 'after' :)
         and $state[$p:lk] != 80                            (: 'and' :)
         and $state[$p:lk] != 83                            (: 'as' :)
         and $state[$p:lk] != 84                            (: 'ascending' :)
         and $state[$p:lk] != 88                            (: 'before' :)
         and $state[$p:lk] != 91                            (: 'case' :)
         and $state[$p:lk] != 92                            (: 'cast' :)
         and $state[$p:lk] != 93                            (: 'castable' :)
         and $state[$p:lk] != 96                            (: 'collation' :)
         and $state[$p:lk] != 99                            (: 'contains' :)
         and $state[$p:lk] != 104                           (: 'count' :)
         and $state[$p:lk] != 108                           (: 'default' :)
         and $state[$p:lk] != 112                           (: 'descending' :)
         and $state[$p:lk] != 117                           (: 'div' :)
         and $state[$p:lk] != 121                           (: 'else' :)
         and $state[$p:lk] != 122                           (: 'empty' :)
         and $state[$p:lk] != 125                           (: 'end' :)
         and $state[$p:lk] != 130                           (: 'except' :)
         and $state[$p:lk] != 136                           (: 'for' :)
         and $state[$p:lk] != 145                           (: 'group' :)
         and $state[$p:lk] != 148                           (: 'idiv' :)
         and $state[$p:lk] != 156                           (: 'instance' :)
         and $state[$p:lk] != 157                           (: 'intersect' :)
         and $state[$p:lk] != 158                           (: 'into' :)
         and $state[$p:lk] != 167                           (: 'let' :)
         and $state[$p:lk] != 173                           (: 'mod' :)
         and $state[$p:lk] != 174                           (: 'modify' :)
         and $state[$p:lk] != 189                           (: 'only' :)
         and $state[$p:lk] != 191                           (: 'or' :)
         and $state[$p:lk] != 192                           (: 'order' :)
         and $state[$p:lk] != 196                           (: 'paragraphs' :)
         and $state[$p:lk] != 210                           (: 'return' :)
         and $state[$p:lk] != 213                           (: 'satisfies' :)
         and $state[$p:lk] != 221                           (: 'sentences' :)
         and $state[$p:lk] != 225                           (: 'stable' :)
         and $state[$p:lk] != 226                           (: 'start' :)
         and $state[$p:lk] != 235                           (: 'times' :)
         and $state[$p:lk] != 236                           (: 'to' :)
         and $state[$p:lk] != 237                           (: 'transform' :)
         and $state[$p:lk] != 238                           (: 'treat' :)
         and $state[$p:lk] != 243                           (: 'union' :)
         and $state[$p:lk] != 255                           (: 'where' :)
         and $state[$p:lk] != 258                           (: 'with' :)
         and $state[$p:lk] != 261                           (: 'words' :)
         and $state[$p:lk] != 266                           (: '|' :)
         and $state[$p:lk] != 267                           (: '||' :)
         and $state[$p:lk] != 268                           (: '}' :)
         and $state[$p:lk] != 269) then                     (: '}`' :)
      let $state := p:memoized($state, 5)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 127                    (: 'eq' :)
                  or $state[$p:l1] = 143                    (: 'ge' :)
                  or $state[$p:l1] = 147                    (: 'gt' :)
                  or $state[$p:l1] = 165                    (: 'le' :)
                  or $state[$p:l1] = 170                    (: 'lt' :)
                  or $state[$p:l1] = 179) then              (: 'ne' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ValueComp($input, $state)
              return $state
            else if ($state[$p:l1] = 57                     (: '<<' :)
                  or $state[$p:l1] = 64                     (: '>>' :)
                  or $state[$p:l1] = 160) then              (: 'is' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-NodeComp($input, $state)
              return $state
            else
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-GeneralComp($input, $state)
              return $state
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTContainsExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 5, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 127                        (: 'eq' :)
              or $state[$p:l1] = 143                        (: 'ge' :)
              or $state[$p:l1] = 147                        (: 'gt' :)
              or $state[$p:l1] = 165                        (: 'le' :)
              or $state[$p:l1] = 170                        (: 'lt' :)
              or $state[$p:l1] = 179) then                  (: 'ne' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 160) then                  (: 'is' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-NodeComp($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTContainsExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 80) then                         (: 'and' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 4)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(80, $input, $state)     (: 'and' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-ComparisonExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(80, $input, $state)         (: 'and' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 80) then                         (: 'and' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 191                         (: 'or' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 4)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(80, $input, $state)     (: 'and' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-ComparisonExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 4, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 4, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-AndExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(80, $input, $state)         (: 'and' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ComparisonExpr($input, $state)
        return p:try-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing AndExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ComparisonExpr($input, $state)
  let $state := p:try-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 191) then                        (: 'or' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(191, $input, $state)    (: 'or' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-AndExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(191, $input, $state)        (: 'or' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] eq 191) then                        (: 'or' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] != 25                          (: EOF :)
           and $state[$p:lk] != 27                          (: '!=' :)
           and $state[$p:lk] != 37                          (: ')' :)
           and $state[$p:lk] != 38                          (: '*' :)
           and $state[$p:lk] != 39                          (: '+' :)
           and $state[$p:lk] != 40                          (: ',' :)
           and $state[$p:lk] != 41                          (: '-' :)
           and $state[$p:lk] != 48                          (: ':' :)
           and $state[$p:lk] != 52                          (: ';' :)
           and $state[$p:lk] != 53                          (: '<' :)
           and $state[$p:lk] != 57                          (: '<<' :)
           and $state[$p:lk] != 58                          (: '<=' :)
           and $state[$p:lk] != 60                          (: '=' :)
           and $state[$p:lk] != 62                          (: '>' :)
           and $state[$p:lk] != 63                          (: '>=' :)
           and $state[$p:lk] != 64                          (: '>>' :)
           and $state[$p:lk] != 70                          (: ']' :)
           and $state[$p:lk] != 75                          (: 'after' :)
           and $state[$p:lk] != 80                          (: 'and' :)
           and $state[$p:lk] != 83                          (: 'as' :)
           and $state[$p:lk] != 84                          (: 'ascending' :)
           and $state[$p:lk] != 88                          (: 'before' :)
           and $state[$p:lk] != 91                          (: 'case' :)
           and $state[$p:lk] != 92                          (: 'cast' :)
           and $state[$p:lk] != 93                          (: 'castable' :)
           and $state[$p:lk] != 96                          (: 'collation' :)
           and $state[$p:lk] != 99                          (: 'contains' :)
           and $state[$p:lk] != 104                         (: 'count' :)
           and $state[$p:lk] != 108                         (: 'default' :)
           and $state[$p:lk] != 112                         (: 'descending' :)
           and $state[$p:lk] != 117                         (: 'div' :)
           and $state[$p:lk] != 121                         (: 'else' :)
           and $state[$p:lk] != 122                         (: 'empty' :)
           and $state[$p:lk] != 125                         (: 'end' :)
           and $state[$p:lk] != 127                         (: 'eq' :)
           and $state[$p:lk] != 130                         (: 'except' :)
           and $state[$p:lk] != 136                         (: 'for' :)
           and $state[$p:lk] != 143                         (: 'ge' :)
           and $state[$p:lk] != 145                         (: 'group' :)
           and $state[$p:lk] != 147                         (: 'gt' :)
           and $state[$p:lk] != 148                         (: 'idiv' :)
           and $state[$p:lk] != 156                         (: 'instance' :)
           and $state[$p:lk] != 157                         (: 'intersect' :)
           and $state[$p:lk] != 158                         (: 'into' :)
           and $state[$p:lk] != 160                         (: 'is' :)
           and $state[$p:lk] != 165                         (: 'le' :)
           and $state[$p:lk] != 167                         (: 'let' :)
           and $state[$p:lk] != 170                         (: 'lt' :)
           and $state[$p:lk] != 173                         (: 'mod' :)
           and $state[$p:lk] != 174                         (: 'modify' :)
           and $state[$p:lk] != 179                         (: 'ne' :)
           and $state[$p:lk] != 189                         (: 'only' :)
           and $state[$p:lk] != 192                         (: 'order' :)
           and $state[$p:lk] != 196                         (: 'paragraphs' :)
           and $state[$p:lk] != 210                         (: 'return' :)
           and $state[$p:lk] != 213                         (: 'satisfies' :)
           and $state[$p:lk] != 221                         (: 'sentences' :)
           and $state[$p:lk] != 225                         (: 'stable' :)
           and $state[$p:lk] != 226                         (: 'start' :)
           and $state[$p:lk] != 235                         (: 'times' :)
           and $state[$p:lk] != 236                         (: 'to' :)
           and $state[$p:lk] != 237                         (: 'transform' :)
           and $state[$p:lk] != 238                         (: 'treat' :)
           and $state[$p:lk] != 243                         (: 'union' :)
           and $state[$p:lk] != 255                         (: 'where' :)
           and $state[$p:lk] != 258                         (: 'with' :)
           and $state[$p:lk] != 261                         (: 'words' :)
           and $state[$p:lk] != 266                         (: '|' :)
           and $state[$p:lk] != 267                         (: '||' :)
           and $state[$p:lk] != 268                         (: '}' :)
           and $state[$p:lk] != 269) then                   (: '}`' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:consume(191, $input, $state)    (: 'or' :)
            let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                                Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                                '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                                '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                'castable' | 'child' | 'collation' | 'comment' |
                                                                'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                'descendant' | 'descendant-or-self' | 'descending' |
                                                                'div' | 'document' | 'document-node' | 'element' |
                                                                'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                'every' | 'except' | 'following' | 'following-sibling' |
                                                                'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                                'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                                'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                                'mod' | 'modify' | 'module' | 'namespace' |
                                                                'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                                'order' | 'ordered' | 'parent' | 'preceding' |
                                                                'preceding-sibling' | 'processing-instruction' |
                                                                'rename' | 'replace' | 'return' | 'satisfies' |
                                                                'schema-attribute' | 'schema-element' | 'self' |
                                                                'some' | 'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                                'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                                'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                                'xquery' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-AndExpr($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 3, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 3, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-OrExpr-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:consume(191, $input, $state)        (: 'or' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AndExpr($input, $state)
        return p:try-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing OrExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AndExpr($input, $state)
  let $state := p:try-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse CopyModifySpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifySpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing CopyModifySpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CopyModifySpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CopyModifyExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifyExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | 'modify' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-CopyModifySpec($input, $state)
        return p:parse-CopyModifyExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CopyModifyExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CopyModifyExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | 'modify' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-CopyModifySpec($input, $state)
        return p:try-CopyModifyExpr-1($input, $state)
};

(:~
 : Parse CopyModifyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyModifyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(102, $input, $state)              (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CopyModifySpec($input, $state)
  let $state := p:parse-CopyModifyExpr-1($input, $state)
  let $state := p:consume(174, $input, $state)              (: 'modify' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing CopyModifyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CopyModifyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(102, $input, $state)              (: 'copy' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CopyModifySpec($input, $state)
  let $state := p:try-CopyModifyExpr-1($input, $state)
  let $state := p:consume(174, $input, $state)              (: 'modify' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse KeySpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KeySpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing KeySpecifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-KeySpecifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NCName($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnaryLookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnaryLookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-KeySpecifier($input, $state)
  return $state
};

(:~
 : Try parsing UnaryLookup.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnaryLookup($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-KeySpecifier($input, $state)
  return $state
};

(:~
 : Parse StringConstructorInterpolation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructorInterpolation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(74, $input, $state)               (: '`{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 269) then                     (: '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(269, $input, $state)              (: '}`' :)
  return $state
};

(:~
 : Try parsing StringConstructorInterpolation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructorInterpolation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(74, $input, $state)               (: '`{' :)
  let $state := p:lookahead1W(241, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 269) then                     (: '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(269, $input, $state)              (: '}`' :)
  return $state
};

(:~
 : Parse the 1st loop of production StringConstructorContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructorContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: ']``' | '`{' :)
    return
      if ($state[$p:l1] != 74) then                         (: '`{' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-StringConstructorInterpolation($input, $state)
        let $state := p:lookahead1(1, $input, $state)       (: StringConstructorChars :)
        let $state := p:consume(16, $input, $state)         (: StringConstructorChars :)
        return p:parse-StringConstructorContent-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production StringConstructorContent (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructorContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: ']``' | '`{' :)
    return
      if ($state[$p:l1] != 74) then                         (: '`{' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-StringConstructorInterpolation($input, $state)
        let $state := p:lookahead1(1, $input, $state)       (: StringConstructorChars :)
        let $state := p:consume(16, $input, $state)         (: StringConstructorChars :)
        return p:try-StringConstructorContent-1($input, $state)
};

(:~
 : Parse StringConstructorContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructorContent($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(1, $input, $state)             (: StringConstructorChars :)
  let $state := p:consume(16, $input, $state)               (: StringConstructorChars :)
  let $state := p:parse-StringConstructorContent-1($input, $state)
  return $state
};

(:~
 : Try parsing StringConstructorContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructorContent($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(1, $input, $state)             (: StringConstructorChars :)
  let $state := p:consume(16, $input, $state)               (: StringConstructorChars :)
  let $state := p:try-StringConstructorContent-1($input, $state)
  return $state
};

(:~
 : Parse StringConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-StringConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(73, $input, $state)               (: '``[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-StringConstructorContent($input, $state)
  let $state := p:consume(72, $input, $state)               (: ']``' :)
  return $state
};

(:~
 : Try parsing StringConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-StringConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(73, $input, $state)               (: '``[' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-StringConstructorContent($input, $state)
  let $state := p:consume(72, $input, $state)               (: ']``' :)
  return $state
};

(:~
 : Parse CurlyArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurlyArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CurlyArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CurlyArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SquareArrayConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ']' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-SquareArrayConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SquareArrayConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SquareArrayConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | ']' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ExprSingle($input, $state)
        return p:try-SquareArrayConstructor-1($input, $state)
};

(:~
 : Parse SquareArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SquareArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(238, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | ']' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 70) then                      (: ']' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-SquareArrayConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Try parsing SquareArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SquareArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(238, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | ']' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 70) then                      (: ']' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      let $state := p:try-SquareArrayConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(70, $input, $state)               (: ']' :)
  return $state
};

(:~
 : Parse ArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SquareArrayConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurlyArrayConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ArrayConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: '[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SquareArrayConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CurlyArrayConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse MapValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing MapValueExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse MapKeyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapKeyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing MapKeyExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapKeyExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse MapConstructorEntry.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapConstructorEntry($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MapKeyExpr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ':' :)
  let $state := p:consume(48, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-MapValueExpr($input, $state)
  return $state
};

(:~
 : Try parsing MapConstructorEntry.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapConstructorEntry($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MapKeyExpr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ':' :)
  let $state := p:consume(48, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-MapValueExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MapConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | ',' | '}' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-MapConstructorEntry($input, $state)
        return p:parse-MapConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MapConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | ',' | '}' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-MapConstructorEntry($input, $state)
        return p:try-MapConstructor-1($input, $state)
};

(:~
 : Parse MapConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MapConstructorEntry($input, $state)
      let $state := p:parse-MapConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing MapConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MapConstructorEntry($input, $state)
      let $state := p:try-MapConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing FunctionBody.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing Param.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Param($input, $state)
        return p:try-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return $state
};

(:~
 : Try parsing ParamList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Param($input, $state)
  let $state := p:try-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Annotation($input, $state)
        return p:parse-InlineFunctionExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Annotation($input, $state)
        return p:try-InlineFunctionExpr-1($input, $state)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionBody($input, $state)
  return $state
};

(:~
 : Try parsing InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FunctionBody($input, $state)
  return $state
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  return $state
};

(:~
 : Try parsing NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  return $state
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InlineFunctionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamedFunctionRef($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InlineFunctionExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NamedFunctionRef($input, $state)
      return $state
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Try parsing URIExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  return $state
};

(:~
 : Try parsing PrefixExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  return $state
};

(:~
 : Try parsing Prefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PrefixExpr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URIExpr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(175, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PrefixExpr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URIExpr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse EnclosedContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing EnclosedContentExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnclosedContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedContentExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(225, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 264) then                      (: '{' :)
      let $state := p:consume(264, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      let $state := p:consume(268, $input, $state)          (: '}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedContentExpr($input, $state)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(118, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(118, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(59, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(15, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(4, $input, $state)         (: DirPIContents :)
      let $state := p:consume(23, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:consume(66, $input, $state)               (: '?>' :)
  return $state
};

(:~
 : Try parsing DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(59, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(15, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(4, $input, $state)         (: DirPIContents :)
      let $state := p:consume(23, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:consume(66, $input, $state)               (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(54, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(3, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(22, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:consume(42, $input, $state)               (: '-->' :)
  return $state
};

(:~
 : Try parsing DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(54, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(3, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(22, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:consume(42, $input, $state)               (: '-->' :)
  return $state
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(55, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(5, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(24, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(11, $input, $state)            (: ']]>' :)
  let $state := p:consume(71, $input, $state)               (: ']]>' :)
  return $state
};

(:~
 : Try parsing CDataSection.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(55, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(5, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(24, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(11, $input, $state)            (: ']]>' :)
  let $state := p:consume(71, $input, $state)               (: ']]>' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing DirElemContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 265) then                      (: '{{' :)
      let $state := p:consume(265, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 270) then                      (: '}}' :)
      let $state := p:consume(270, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing CommonContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 265) then                      (: '{{' :)
      let $state := p:consume(265, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 270) then                      (: '}}' :)
      let $state := p:consume(270, $input, $state)          (: '}}' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(158, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(158, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-QuotAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(159, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(159, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-AposAttrValueContent($input, $state)
            return $state
        return p:try-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(16, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(33, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(33, $input, $state)           (: "'" :)
      return $state
  return $state
};

(:~
 : Try parsing DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(16, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      let $state := p:try-DirAttributeValue-1($input, $state)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      return $state
    else
      let $state := p:consume(33, $input, $state)           (: "'" :)
      let $state := p:try-DirAttributeValue-2($input, $state)
      let $state := p:consume(33, $input, $state)           (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 17) then                         (: S :)
        $state
      else
        let $state := p:consume(17, $input, $state)         (: S :)
        let $state := p:lookahead1(223, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 17                      (: S :)
               and $state[$p:l1] != 47                      (: '/>' :)
               and $state[$p:l1] != 62) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-QName($input, $state)
            let $state := p:lookahead1(13, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:consume(60, $input, $state)     (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 17) then                         (: S :)
        $state
      else
        let $state := p:consume(17, $input, $state)         (: S :)
        let $state := p:lookahead1(223, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 17                      (: S :)
               and $state[$p:l1] != 47                      (: '/>' :)
               and $state[$p:l1] != 62) then                (: '>' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-QName($input, $state)
            let $state := p:lookahead1(13, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:consume(60, $input, $state)     (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:try-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Try parsing DirAttributeList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(164, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(164, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-DirElemContent($input, $state)
        return p:try-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(53, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: '/>' :)
      let $state := p:consume(47, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(62, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(56, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      let $state := p:lookahead1(14, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 17) then                   (: S :)
          let $state := p:consume(17, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
  return $state
};

(:~
 : Try parsing DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(53, $input, $state)               (: '<' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-QName($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: '/>' :)
      let $state := p:consume(47, $input, $state)           (: '/>' :)
      return $state
    else
      let $state := p:consume(62, $input, $state)           (: '>' :)
      let $state := p:try-DirElemConstructor-1($input, $state)
      let $state := p:consume(56, $input, $state)           (: '</' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-QName($input, $state)
      let $state := p:lookahead1(14, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 17) then                   (: S :)
          let $state := p:consume(17, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing DirectConstructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirCommentConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing Constructor.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DirectConstructor($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(244, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(244, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing OrderedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(193, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  return $state
};

(:~
 : Try parsing ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(65, $input, $state)               (: '?' :)
  return $state
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 65) then                           (: '?' :)
      let $state := p:lookahead2W(180, $input, $state)      (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | ',' | 'and' | 'as' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19009                          (: '?' ')' :)
          or $state[$p:lk] = 20545) then                    (: '?' ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing Argument.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 65) then                           (: '?' :)
      let $state := p:lookahead2W(180, $input, $state)      (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | ',' | 'and' | 'as' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 19009                          (: '?' ')' :)
          or $state[$p:lk] = 20545) then                    (: '?' ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArgumentPlaceholder($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Argument($input, $state)
        return p:try-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ArgumentList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Argument($input, $state)
      let $state := p:try-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse FunctionEQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FunctionEQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ArgumentList($input, $state)
  return $state
};

(:~
 : Try parsing FunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FunctionEQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ArgumentList($input, $state)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(43, $input, $state)               (: '.' :)
  return $state
};

(:~
 : Try parsing ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(43, $input, $state)               (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing VarRef.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 177) then                          (: 'namespace' :)
      let $state := p:lookahead2W(179, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'as' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 206) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(177, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (86,                           (: 'attribute' :)
                              120)) then                    (: 'element' :)
      let $state := p:lookahead2W(226, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              232)) then                    (: 'text' :)
      let $state := p:lookahead2W(84, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(133, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              95,                           (: 'child' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              136,                          (: 'for' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              179,                          (: 'ne' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              218,                          (: 'self' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17413                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17423                          (: QName^Token '(' :)
          or $state[$p:lk] = 17486                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17487                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17488                          (: 'and' '(' :)
          or $state[$p:lk] = 17491                          (: 'as' '(' :)
          or $state[$p:lk] = 17492                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17493                          (: 'at' '(' :)
          or $state[$p:lk] = 17499                          (: 'case' '(' :)
          or $state[$p:lk] = 17500                          (: 'cast' '(' :)
          or $state[$p:lk] = 17501                          (: 'castable' '(' :)
          or $state[$p:lk] = 17503                          (: 'child' '(' :)
          or $state[$p:lk] = 17504                          (: 'collation' '(' :)
          or $state[$p:lk] = 17510                          (: 'copy' '(' :)
          or $state[$p:lk] = 17512                          (: 'count' '(' :)
          or $state[$p:lk] = 17515                          (: 'declare' '(' :)
          or $state[$p:lk] = 17516                          (: 'default' '(' :)
          or $state[$p:lk] = 17517                          (: 'delete' '(' :)
          or $state[$p:lk] = 17518                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17519                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17520                          (: 'descending' '(' :)
          or $state[$p:lk] = 17525                          (: 'div' '(' :)
          or $state[$p:lk] = 17526                          (: 'document' '(' :)
          or $state[$p:lk] = 17529                          (: 'else' '(' :)
          or $state[$p:lk] = 17530                          (: 'empty' '(' :)
          or $state[$p:lk] = 17533                          (: 'end' '(' :)
          or $state[$p:lk] = 17535                          (: 'eq' '(' :)
          or $state[$p:lk] = 17536                          (: 'every' '(' :)
          or $state[$p:lk] = 17538                          (: 'except' '(' :)
          or $state[$p:lk] = 17542                          (: 'following' '(' :)
          or $state[$p:lk] = 17543                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17544                          (: 'for' '(' :)
          or $state[$p:lk] = 17551                          (: 'ge' '(' :)
          or $state[$p:lk] = 17553                          (: 'group' '(' :)
          or $state[$p:lk] = 17555                          (: 'gt' '(' :)
          or $state[$p:lk] = 17556                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17558                          (: 'import' '(' :)
          or $state[$p:lk] = 17563                          (: 'insert' '(' :)
          or $state[$p:lk] = 17564                          (: 'instance' '(' :)
          or $state[$p:lk] = 17565                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17567                          (: 'invoke' '(' :)
          or $state[$p:lk] = 17568                          (: 'is' '(' :)
          or $state[$p:lk] = 17573                          (: 'le' '(' :)
          or $state[$p:lk] = 17575                          (: 'let' '(' :)
          or $state[$p:lk] = 17578                          (: 'lt' '(' :)
          or $state[$p:lk] = 17581                          (: 'mod' '(' :)
          or $state[$p:lk] = 17582                          (: 'modify' '(' :)
          or $state[$p:lk] = 17583                          (: 'module' '(' :)
          or $state[$p:lk] = 17585                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17587                          (: 'ne' '(' :)
          or $state[$p:lk] = 17597                          (: 'only' '(' :)
          or $state[$p:lk] = 17599                          (: 'or' '(' :)
          or $state[$p:lk] = 17600                          (: 'order' '(' :)
          or $state[$p:lk] = 17601                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17605                          (: 'parent' '(' :)
          or $state[$p:lk] = 17610                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17611                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17616                          (: 'rename' '(' :)
          or $state[$p:lk] = 17617                          (: 'replace' '(' :)
          or $state[$p:lk] = 17618                          (: 'return' '(' :)
          or $state[$p:lk] = 17621                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17626                          (: 'self' '(' :)
          or $state[$p:lk] = 17632                          (: 'some' '(' :)
          or $state[$p:lk] = 17633                          (: 'stable' '(' :)
          or $state[$p:lk] = 17634                          (: 'start' '(' :)
          or $state[$p:lk] = 17644                          (: 'to' '(' :)
          or $state[$p:lk] = 17645                          (: 'transform' '(' :)
          or $state[$p:lk] = 17646                          (: 'treat' '(' :)
          or $state[$p:lk] = 17647                          (: 'try' '(' :)
          or $state[$p:lk] = 17651                          (: 'union' '(' :)
          or $state[$p:lk] = 17652                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17653                          (: 'update' '(' :)
          or $state[$p:lk] = 17657                          (: 'validate' '(' :)
          or $state[$p:lk] = 17663                          (: 'where' '(' :)
          or $state[$p:lk] = 17666                          (: 'with' '(' :)
          or $state[$p:lk] = 17670) then                    (: 'xquery' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 135361) then                   (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135412) then                   (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 119                            (: 'document-node' :)
          or $state[$p:lk] = 123                            (: 'empty-sequence' :)
          or $state[$p:lk] = 142                            (: 'function' :)
          or $state[$p:lk] = 149                            (: 'if' :)
          or $state[$p:lk] = 161                            (: 'item' :)
          or $state[$p:lk] = 178                            (: 'namespace-node' :)
          or $state[$p:lk] = 184                            (: 'node' :)
          or $state[$p:lk] = 215                            (: 'schema-attribute' :)
          or $state[$p:lk] = 216                            (: 'schema-element' :)
          or $state[$p:lk] = 231                            (: 'switch' :)
          or $state[$p:lk] = 242                            (: 'typeswitch' :)
          or $state[$p:lk] = 14853                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14863                          (: QName^Token '#' :)
          or $state[$p:lk] = 14926                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14927                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14928                          (: 'and' '#' :)
          or $state[$p:lk] = 14931                          (: 'as' '#' :)
          or $state[$p:lk] = 14932                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14933                          (: 'at' '#' :)
          or $state[$p:lk] = 14934                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14939                          (: 'case' '#' :)
          or $state[$p:lk] = 14940                          (: 'cast' '#' :)
          or $state[$p:lk] = 14941                          (: 'castable' '#' :)
          or $state[$p:lk] = 14943                          (: 'child' '#' :)
          or $state[$p:lk] = 14944                          (: 'collation' '#' :)
          or $state[$p:lk] = 14945                          (: 'comment' '#' :)
          or $state[$p:lk] = 14950                          (: 'copy' '#' :)
          or $state[$p:lk] = 14952                          (: 'count' '#' :)
          or $state[$p:lk] = 14955                          (: 'declare' '#' :)
          or $state[$p:lk] = 14956                          (: 'default' '#' :)
          or $state[$p:lk] = 14957                          (: 'delete' '#' :)
          or $state[$p:lk] = 14958                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14959                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14960                          (: 'descending' '#' :)
          or $state[$p:lk] = 14965                          (: 'div' '#' :)
          or $state[$p:lk] = 14966                          (: 'document' '#' :)
          or $state[$p:lk] = 14968                          (: 'element' '#' :)
          or $state[$p:lk] = 14969                          (: 'else' '#' :)
          or $state[$p:lk] = 14970                          (: 'empty' '#' :)
          or $state[$p:lk] = 14973                          (: 'end' '#' :)
          or $state[$p:lk] = 14975                          (: 'eq' '#' :)
          or $state[$p:lk] = 14976                          (: 'every' '#' :)
          or $state[$p:lk] = 14978                          (: 'except' '#' :)
          or $state[$p:lk] = 14982                          (: 'following' '#' :)
          or $state[$p:lk] = 14983                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14984                          (: 'for' '#' :)
          or $state[$p:lk] = 14991                          (: 'ge' '#' :)
          or $state[$p:lk] = 14993                          (: 'group' '#' :)
          or $state[$p:lk] = 14995                          (: 'gt' '#' :)
          or $state[$p:lk] = 14996                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14998                          (: 'import' '#' :)
          or $state[$p:lk] = 15003                          (: 'insert' '#' :)
          or $state[$p:lk] = 15004                          (: 'instance' '#' :)
          or $state[$p:lk] = 15005                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15007                          (: 'invoke' '#' :)
          or $state[$p:lk] = 15008                          (: 'is' '#' :)
          or $state[$p:lk] = 15013                          (: 'le' '#' :)
          or $state[$p:lk] = 15015                          (: 'let' '#' :)
          or $state[$p:lk] = 15018                          (: 'lt' '#' :)
          or $state[$p:lk] = 15021                          (: 'mod' '#' :)
          or $state[$p:lk] = 15022                          (: 'modify' '#' :)
          or $state[$p:lk] = 15023                          (: 'module' '#' :)
          or $state[$p:lk] = 15025                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15027                          (: 'ne' '#' :)
          or $state[$p:lk] = 15037                          (: 'only' '#' :)
          or $state[$p:lk] = 15039                          (: 'or' '#' :)
          or $state[$p:lk] = 15040                          (: 'order' '#' :)
          or $state[$p:lk] = 15041                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15045                          (: 'parent' '#' :)
          or $state[$p:lk] = 15050                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15051                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15054                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15056                          (: 'rename' '#' :)
          or $state[$p:lk] = 15057                          (: 'replace' '#' :)
          or $state[$p:lk] = 15058                          (: 'return' '#' :)
          or $state[$p:lk] = 15061                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15066                          (: 'self' '#' :)
          or $state[$p:lk] = 15072                          (: 'some' '#' :)
          or $state[$p:lk] = 15073                          (: 'stable' '#' :)
          or $state[$p:lk] = 15074                          (: 'start' '#' :)
          or $state[$p:lk] = 15080                          (: 'text' '#' :)
          or $state[$p:lk] = 15084                          (: 'to' '#' :)
          or $state[$p:lk] = 15085                          (: 'transform' '#' :)
          or $state[$p:lk] = 15086                          (: 'treat' '#' :)
          or $state[$p:lk] = 15087                          (: 'try' '#' :)
          or $state[$p:lk] = 15091                          (: 'union' '#' :)
          or $state[$p:lk] = 15092                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15093                          (: 'update' '#' :)
          or $state[$p:lk] = 15097                          (: 'validate' '#' :)
          or $state[$p:lk] = 15103                          (: 'where' '#' :)
          or $state[$p:lk] = 15106                          (: 'with' '#' :)
          or $state[$p:lk] = 15110) then                    (: 'xquery' '#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MapConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 69                             (: '[' :)
          or $state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: '``[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-StringConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UnaryLookup($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 177) then                          (: 'namespace' :)
      let $state := p:lookahead2W(179, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'as' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 206) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(177, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (86,                           (: 'attribute' :)
                              120)) then                    (: 'element' :)
      let $state := p:lookahead2W(226, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (97,                           (: 'comment' :)
                              232)) then                    (: 'text' :)
      let $state := p:lookahead2W(84, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (118,                          (: 'document' :)
                              193,                          (: 'ordered' :)
                              244)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(133, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              78,                           (: 'ancestor' :)
                              79,                           (: 'ancestor-or-self' :)
                              80,                           (: 'and' :)
                              83,                           (: 'as' :)
                              84,                           (: 'ascending' :)
                              85,                           (: 'at' :)
                              91,                           (: 'case' :)
                              92,                           (: 'cast' :)
                              93,                           (: 'castable' :)
                              95,                           (: 'child' :)
                              96,                           (: 'collation' :)
                              102,                          (: 'copy' :)
                              104,                          (: 'count' :)
                              107,                          (: 'declare' :)
                              108,                          (: 'default' :)
                              109,                          (: 'delete' :)
                              110,                          (: 'descendant' :)
                              111,                          (: 'descendant-or-self' :)
                              112,                          (: 'descending' :)
                              117,                          (: 'div' :)
                              121,                          (: 'else' :)
                              122,                          (: 'empty' :)
                              125,                          (: 'end' :)
                              127,                          (: 'eq' :)
                              128,                          (: 'every' :)
                              130,                          (: 'except' :)
                              134,                          (: 'following' :)
                              135,                          (: 'following-sibling' :)
                              136,                          (: 'for' :)
                              143,                          (: 'ge' :)
                              145,                          (: 'group' :)
                              147,                          (: 'gt' :)
                              148,                          (: 'idiv' :)
                              150,                          (: 'import' :)
                              155,                          (: 'insert' :)
                              156,                          (: 'instance' :)
                              157,                          (: 'intersect' :)
                              159,                          (: 'invoke' :)
                              160,                          (: 'is' :)
                              165,                          (: 'le' :)
                              167,                          (: 'let' :)
                              170,                          (: 'lt' :)
                              173,                          (: 'mod' :)
                              174,                          (: 'modify' :)
                              175,                          (: 'module' :)
                              179,                          (: 'ne' :)
                              189,                          (: 'only' :)
                              191,                          (: 'or' :)
                              192,                          (: 'order' :)
                              197,                          (: 'parent' :)
                              202,                          (: 'preceding' :)
                              203,                          (: 'preceding-sibling' :)
                              208,                          (: 'rename' :)
                              209,                          (: 'replace' :)
                              210,                          (: 'return' :)
                              213,                          (: 'satisfies' :)
                              218,                          (: 'self' :)
                              224,                          (: 'some' :)
                              225,                          (: 'stable' :)
                              226,                          (: 'start' :)
                              236,                          (: 'to' :)
                              237,                          (: 'transform' :)
                              238,                          (: 'treat' :)
                              239,                          (: 'try' :)
                              243,                          (: 'union' :)
                              245,                          (: 'update' :)
                              249,                          (: 'validate' :)
                              255,                          (: 'where' :)
                              258,                          (: 'with' :)
                              262)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(83, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43) then                       (: '.' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17413                          (: URIQualifiedName '(' :)
          or $state[$p:lk] = 17423                          (: QName^Token '(' :)
          or $state[$p:lk] = 17486                          (: 'ancestor' '(' :)
          or $state[$p:lk] = 17487                          (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 17488                          (: 'and' '(' :)
          or $state[$p:lk] = 17491                          (: 'as' '(' :)
          or $state[$p:lk] = 17492                          (: 'ascending' '(' :)
          or $state[$p:lk] = 17493                          (: 'at' '(' :)
          or $state[$p:lk] = 17499                          (: 'case' '(' :)
          or $state[$p:lk] = 17500                          (: 'cast' '(' :)
          or $state[$p:lk] = 17501                          (: 'castable' '(' :)
          or $state[$p:lk] = 17503                          (: 'child' '(' :)
          or $state[$p:lk] = 17504                          (: 'collation' '(' :)
          or $state[$p:lk] = 17510                          (: 'copy' '(' :)
          or $state[$p:lk] = 17512                          (: 'count' '(' :)
          or $state[$p:lk] = 17515                          (: 'declare' '(' :)
          or $state[$p:lk] = 17516                          (: 'default' '(' :)
          or $state[$p:lk] = 17517                          (: 'delete' '(' :)
          or $state[$p:lk] = 17518                          (: 'descendant' '(' :)
          or $state[$p:lk] = 17519                          (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 17520                          (: 'descending' '(' :)
          or $state[$p:lk] = 17525                          (: 'div' '(' :)
          or $state[$p:lk] = 17526                          (: 'document' '(' :)
          or $state[$p:lk] = 17529                          (: 'else' '(' :)
          or $state[$p:lk] = 17530                          (: 'empty' '(' :)
          or $state[$p:lk] = 17533                          (: 'end' '(' :)
          or $state[$p:lk] = 17535                          (: 'eq' '(' :)
          or $state[$p:lk] = 17536                          (: 'every' '(' :)
          or $state[$p:lk] = 17538                          (: 'except' '(' :)
          or $state[$p:lk] = 17542                          (: 'following' '(' :)
          or $state[$p:lk] = 17543                          (: 'following-sibling' '(' :)
          or $state[$p:lk] = 17544                          (: 'for' '(' :)
          or $state[$p:lk] = 17551                          (: 'ge' '(' :)
          or $state[$p:lk] = 17553                          (: 'group' '(' :)
          or $state[$p:lk] = 17555                          (: 'gt' '(' :)
          or $state[$p:lk] = 17556                          (: 'idiv' '(' :)
          or $state[$p:lk] = 17558                          (: 'import' '(' :)
          or $state[$p:lk] = 17563                          (: 'insert' '(' :)
          or $state[$p:lk] = 17564                          (: 'instance' '(' :)
          or $state[$p:lk] = 17565                          (: 'intersect' '(' :)
          or $state[$p:lk] = 17567                          (: 'invoke' '(' :)
          or $state[$p:lk] = 17568                          (: 'is' '(' :)
          or $state[$p:lk] = 17573                          (: 'le' '(' :)
          or $state[$p:lk] = 17575                          (: 'let' '(' :)
          or $state[$p:lk] = 17578                          (: 'lt' '(' :)
          or $state[$p:lk] = 17581                          (: 'mod' '(' :)
          or $state[$p:lk] = 17582                          (: 'modify' '(' :)
          or $state[$p:lk] = 17583                          (: 'module' '(' :)
          or $state[$p:lk] = 17585                          (: 'namespace' '(' :)
          or $state[$p:lk] = 17587                          (: 'ne' '(' :)
          or $state[$p:lk] = 17597                          (: 'only' '(' :)
          or $state[$p:lk] = 17599                          (: 'or' '(' :)
          or $state[$p:lk] = 17600                          (: 'order' '(' :)
          or $state[$p:lk] = 17601                          (: 'ordered' '(' :)
          or $state[$p:lk] = 17605                          (: 'parent' '(' :)
          or $state[$p:lk] = 17610                          (: 'preceding' '(' :)
          or $state[$p:lk] = 17611                          (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 17616                          (: 'rename' '(' :)
          or $state[$p:lk] = 17617                          (: 'replace' '(' :)
          or $state[$p:lk] = 17618                          (: 'return' '(' :)
          or $state[$p:lk] = 17621                          (: 'satisfies' '(' :)
          or $state[$p:lk] = 17626                          (: 'self' '(' :)
          or $state[$p:lk] = 17632                          (: 'some' '(' :)
          or $state[$p:lk] = 17633                          (: 'stable' '(' :)
          or $state[$p:lk] = 17634                          (: 'start' '(' :)
          or $state[$p:lk] = 17644                          (: 'to' '(' :)
          or $state[$p:lk] = 17645                          (: 'transform' '(' :)
          or $state[$p:lk] = 17646                          (: 'treat' '(' :)
          or $state[$p:lk] = 17647                          (: 'try' '(' :)
          or $state[$p:lk] = 17651                          (: 'union' '(' :)
          or $state[$p:lk] = 17652                          (: 'unordered' '(' :)
          or $state[$p:lk] = 17653                          (: 'update' '(' :)
          or $state[$p:lk] = 17657                          (: 'validate' '(' :)
          or $state[$p:lk] = 17663                          (: 'where' '(' :)
          or $state[$p:lk] = 17666                          (: 'with' '(' :)
          or $state[$p:lk] = 17670) then                    (: 'xquery' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 135361) then                   (: 'ordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135412) then                   (: 'unordered' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 119                            (: 'document-node' :)
          or $state[$p:lk] = 123                            (: 'empty-sequence' :)
          or $state[$p:lk] = 142                            (: 'function' :)
          or $state[$p:lk] = 149                            (: 'if' :)
          or $state[$p:lk] = 161                            (: 'item' :)
          or $state[$p:lk] = 178                            (: 'namespace-node' :)
          or $state[$p:lk] = 184                            (: 'node' :)
          or $state[$p:lk] = 215                            (: 'schema-attribute' :)
          or $state[$p:lk] = 216                            (: 'schema-element' :)
          or $state[$p:lk] = 231                            (: 'switch' :)
          or $state[$p:lk] = 242                            (: 'typeswitch' :)
          or $state[$p:lk] = 14853                          (: URIQualifiedName '#' :)
          or $state[$p:lk] = 14863                          (: QName^Token '#' :)
          or $state[$p:lk] = 14926                          (: 'ancestor' '#' :)
          or $state[$p:lk] = 14927                          (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 14928                          (: 'and' '#' :)
          or $state[$p:lk] = 14931                          (: 'as' '#' :)
          or $state[$p:lk] = 14932                          (: 'ascending' '#' :)
          or $state[$p:lk] = 14933                          (: 'at' '#' :)
          or $state[$p:lk] = 14934                          (: 'attribute' '#' :)
          or $state[$p:lk] = 14939                          (: 'case' '#' :)
          or $state[$p:lk] = 14940                          (: 'cast' '#' :)
          or $state[$p:lk] = 14941                          (: 'castable' '#' :)
          or $state[$p:lk] = 14943                          (: 'child' '#' :)
          or $state[$p:lk] = 14944                          (: 'collation' '#' :)
          or $state[$p:lk] = 14945                          (: 'comment' '#' :)
          or $state[$p:lk] = 14950                          (: 'copy' '#' :)
          or $state[$p:lk] = 14952                          (: 'count' '#' :)
          or $state[$p:lk] = 14955                          (: 'declare' '#' :)
          or $state[$p:lk] = 14956                          (: 'default' '#' :)
          or $state[$p:lk] = 14957                          (: 'delete' '#' :)
          or $state[$p:lk] = 14958                          (: 'descendant' '#' :)
          or $state[$p:lk] = 14959                          (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 14960                          (: 'descending' '#' :)
          or $state[$p:lk] = 14965                          (: 'div' '#' :)
          or $state[$p:lk] = 14966                          (: 'document' '#' :)
          or $state[$p:lk] = 14968                          (: 'element' '#' :)
          or $state[$p:lk] = 14969                          (: 'else' '#' :)
          or $state[$p:lk] = 14970                          (: 'empty' '#' :)
          or $state[$p:lk] = 14973                          (: 'end' '#' :)
          or $state[$p:lk] = 14975                          (: 'eq' '#' :)
          or $state[$p:lk] = 14976                          (: 'every' '#' :)
          or $state[$p:lk] = 14978                          (: 'except' '#' :)
          or $state[$p:lk] = 14982                          (: 'following' '#' :)
          or $state[$p:lk] = 14983                          (: 'following-sibling' '#' :)
          or $state[$p:lk] = 14984                          (: 'for' '#' :)
          or $state[$p:lk] = 14991                          (: 'ge' '#' :)
          or $state[$p:lk] = 14993                          (: 'group' '#' :)
          or $state[$p:lk] = 14995                          (: 'gt' '#' :)
          or $state[$p:lk] = 14996                          (: 'idiv' '#' :)
          or $state[$p:lk] = 14998                          (: 'import' '#' :)
          or $state[$p:lk] = 15003                          (: 'insert' '#' :)
          or $state[$p:lk] = 15004                          (: 'instance' '#' :)
          or $state[$p:lk] = 15005                          (: 'intersect' '#' :)
          or $state[$p:lk] = 15007                          (: 'invoke' '#' :)
          or $state[$p:lk] = 15008                          (: 'is' '#' :)
          or $state[$p:lk] = 15013                          (: 'le' '#' :)
          or $state[$p:lk] = 15015                          (: 'let' '#' :)
          or $state[$p:lk] = 15018                          (: 'lt' '#' :)
          or $state[$p:lk] = 15021                          (: 'mod' '#' :)
          or $state[$p:lk] = 15022                          (: 'modify' '#' :)
          or $state[$p:lk] = 15023                          (: 'module' '#' :)
          or $state[$p:lk] = 15025                          (: 'namespace' '#' :)
          or $state[$p:lk] = 15027                          (: 'ne' '#' :)
          or $state[$p:lk] = 15037                          (: 'only' '#' :)
          or $state[$p:lk] = 15039                          (: 'or' '#' :)
          or $state[$p:lk] = 15040                          (: 'order' '#' :)
          or $state[$p:lk] = 15041                          (: 'ordered' '#' :)
          or $state[$p:lk] = 15045                          (: 'parent' '#' :)
          or $state[$p:lk] = 15050                          (: 'preceding' '#' :)
          or $state[$p:lk] = 15051                          (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 15054                          (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 15056                          (: 'rename' '#' :)
          or $state[$p:lk] = 15057                          (: 'replace' '#' :)
          or $state[$p:lk] = 15058                          (: 'return' '#' :)
          or $state[$p:lk] = 15061                          (: 'satisfies' '#' :)
          or $state[$p:lk] = 15066                          (: 'self' '#' :)
          or $state[$p:lk] = 15072                          (: 'some' '#' :)
          or $state[$p:lk] = 15073                          (: 'stable' '#' :)
          or $state[$p:lk] = 15074                          (: 'start' '#' :)
          or $state[$p:lk] = 15080                          (: 'text' '#' :)
          or $state[$p:lk] = 15084                          (: 'to' '#' :)
          or $state[$p:lk] = 15085                          (: 'transform' '#' :)
          or $state[$p:lk] = 15086                          (: 'treat' '#' :)
          or $state[$p:lk] = 15087                          (: 'try' '#' :)
          or $state[$p:lk] = 15091                          (: 'union' '#' :)
          or $state[$p:lk] = 15092                          (: 'unordered' '#' :)
          or $state[$p:lk] = 15093                          (: 'update' '#' :)
          or $state[$p:lk] = 15097                          (: 'validate' '#' :)
          or $state[$p:lk] = 15103                          (: 'where' '#' :)
          or $state[$p:lk] = 15106                          (: 'with' '#' :)
          or $state[$p:lk] = 15110) then                    (: 'xquery' '#' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MapConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 69                             (: '[' :)
          or $state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: '``[' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-StringConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: '?' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UnaryLookup($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UpdatingFunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UpdatingFunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-UpdatingFunctionCall-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production UpdatingFunctionCall (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UpdatingFunctionCall-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ExprSingle($input, $state)
        return p:try-UpdatingFunctionCall-1($input, $state)
};

(:~
 : Parse UpdatingFunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-UpdatingFunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(159, $input, $state)              (: 'invoke' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'updating' :)
  let $state := p:consume(246, $input, $state)              (: 'updating' :)
  let $state := p:lookahead1W(232, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               '$' | '%' | '(' | ('(' ':') | '.' | '<' | '<!--' | '<?' |
                                                               '?' | '[' | '``[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      let $state := p:parse-UpdatingFunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing UpdatingFunctionCall.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-UpdatingFunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(159, $input, $state)              (: 'invoke' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'updating' :)
  let $state := p:consume(246, $input, $state)              (: 'updating' :)
  let $state := p:lookahead1W(232, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               '$' | '%' | '(' | ('(' ':') | '.' | '<' | '<!--' | '<?' |
                                                               '?' | '[' | '``[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(237, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      let $state := p:try-UpdatingFunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(209, $input, $state)              (: 'replace' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 250) then                      (: 'value' :)
      let $state := p:consume(250, $input, $state)          (: 'value' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'with' :)
  let $state := p:consume(258, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(209, $input, $state)              (: 'replace' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 250) then                      (: 'value' :)
      let $state := p:consume(250, $input, $state)          (: 'value' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(188, $input, $state)          (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'with' :)
  let $state := p:consume(258, $input, $state)              (: 'with' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing NewNameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(208, $input, $state)              (: 'rename' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NewNameExpr($input, $state)
  return $state
};

(:~
 : Try parsing RenameExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(208, $input, $state)              (: 'rename' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NewNameExpr($input, $state)
  return $state
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(109, $input, $state)              (: 'delete' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Try parsing DeleteExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(109, $input, $state)              (: 'delete' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing TargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'after' :)
      let $state := p:consume(75, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'before' :)
      let $state := p:consume(88, $input, $state)           (: 'before' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(114, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 133) then              (: 'first' :)
              let $state := p:consume(133, $input, $state)  (: 'first' :)
              return $state
            else
              let $state := p:consume(163, $input, $state)  (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:consume(158, $input, $state)          (: 'into' :)
      return $state
  return $state
};

(:~
 : Try parsing InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'after' :)
      let $state := p:consume(75, $input, $state)           (: 'after' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'before' :)
      let $state := p:consume(88, $input, $state)           (: 'before' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state := p:consume(83, $input, $state)       (: 'as' :)
          let $state := p:lookahead1W(114, $input, $state)  (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 133) then              (: 'first' :)
              let $state := p:consume(133, $input, $state)  (: 'first' :)
              return $state
            else
              let $state := p:consume(163, $input, $state)  (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:consume(158, $input, $state)          (: 'into' :)
      return $state
  return $state
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SourceExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(155, $input, $state)              (: 'insert' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SourceExpr($input, $state)
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'after' | 'as' | 'before' | 'into' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Try parsing InsertExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(155, $input, $state)              (: 'insert' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else
      let $state := p:consume(185, $input, $state)          (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SourceExpr($input, $state)
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | ('(' ':') | 'after' | 'as' | 'before' | 'into' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: Wildcard :)
      let $state := p:consume(21, $input, $state)           (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing NameTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: Wildcard :)
      let $state := p:consume(21, $input, $state)           (: Wildcard :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(224, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(224, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-NameTest($input, $state)
        return p:try-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Try parsing CatchErrorList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-NameTest($input, $state)
  let $state := p:try-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(94, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-CatchErrorList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing CatchClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(94, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(224, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-CatchErrorList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Try parsing EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(264, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(240, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 268) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(268, $input, $state)              (: '}' :)
  return $state
};

(:~
 : Parse EnclosedTryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EnclosedTryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Try parsing EnclosedTryTargetExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EnclosedTryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(239, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EnclosedTryTargetExpr($input, $state)
  return $state
};

(:~
 : Try parsing TryClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(239, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EnclosedTryTargetExpr($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(188, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 94) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-CatchClause($input, $state)
    let $state := p:lookahead1W(188, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'paragraphs' | 'return' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 94) then                         (: 'catch' :)
        $state
      else
        p:try-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Try parsing TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-TryClause($input, $state)
  let $state := p:try-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse BasexIfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BasexIfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing BasexIfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-BasexIfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:consume(121, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing IfExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(149, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(233, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:consume(121, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 266) then                        (: '|' :)
        $state
      else
        let $state := p:consume(266, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-SequenceType($input, $state)
        return p:try-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Try parsing SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  let $state := p:try-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(91, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(230, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceTypeUnion($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing CaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(91, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(230, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarName($input, $state)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceTypeUnion($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-CaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:try-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(242, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(242, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:try-TypeswitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(91, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(91, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(235, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:try-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-SwitchCaseClause-1($input, $state)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(160, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ']' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(160, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ']' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ExprSingle($input, $state)
        return p:try-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return $state
};

(:~
 : Try parsing Expr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:try-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 91) then                         (: 'case' :)
        $state
      else
        p:try-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(231, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing SwitchExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(231, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:try-SwitchExpr-1($input, $state)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse QuantifiedVarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedVarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing QuantifiedVarDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuantifiedVarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(96, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-QuantifiedVarDecl($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(96, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-QuantifiedVarDecl($input, $state)
        return p:try-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-QuantifiedVarDecl($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(213, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-QuantifiedVarDecl($input, $state)
  let $state := p:try-QuantifiedExpr-1($input, $state)
  let $state := p:consume(213, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing ReturnClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(210, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(104, $input, $state)              (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing CountClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(104, $input, $state)              (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84                             (: 'ascending' :)
          or $state[$p:l1] = 112) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 84) then                   (: 'ascending' :)
          let $state := p:consume(84, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(112, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(169, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(115, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 144) then                  (: 'greatest' :)
          let $state := p:consume(144, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(166, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing OrderModifier.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84                             (: 'ascending' :)
          or $state[$p:l1] = 112) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 84) then                   (: 'ascending' :)
          let $state := p:consume(84, $input, $state)       (: 'ascending' :)
          return $state
        else
          let $state := p:consume(112, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(169, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(115, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 144) then                  (: 'greatest' :)
          let $state := p:consume(144, $input, $state)      (: 'greatest' :)
          return $state
        else
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(166, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(173, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderModifier($input, $state)
  return $state
};

(:~
 : Try parsing OrderSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(173, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-OrderSpec($input, $state)
        return p:try-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Try parsing OrderSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-OrderSpec($input, $state)
  let $state := p:try-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(61, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-OrderSpecList($input, $state)
  return $state
};

(:~
 : Try parsing OrderByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
    else
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(61, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(90, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingVariable.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing GroupingVariable.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 31) then                           (: '$' :)
      let $state := p:lookahead2W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2591                           (: '$' URIQualifiedName :)
          or $state[$p:lk] = 7711                           (: '$' QName^Token :)
          or $state[$p:lk] = 39967                          (: '$' 'ancestor' :)
          or $state[$p:lk] = 40479                          (: '$' 'ancestor-or-self' :)
          or $state[$p:lk] = 40991                          (: '$' 'and' :)
          or $state[$p:lk] = 42527                          (: '$' 'as' :)
          or $state[$p:lk] = 43039                          (: '$' 'ascending' :)
          or $state[$p:lk] = 43551                          (: '$' 'at' :)
          or $state[$p:lk] = 44063                          (: '$' 'attribute' :)
          or $state[$p:lk] = 46623                          (: '$' 'case' :)
          or $state[$p:lk] = 47135                          (: '$' 'cast' :)
          or $state[$p:lk] = 47647                          (: '$' 'castable' :)
          or $state[$p:lk] = 48671                          (: '$' 'child' :)
          or $state[$p:lk] = 49183                          (: '$' 'collation' :)
          or $state[$p:lk] = 49695                          (: '$' 'comment' :)
          or $state[$p:lk] = 52255                          (: '$' 'copy' :)
          or $state[$p:lk] = 53279                          (: '$' 'count' :)
          or $state[$p:lk] = 54815                          (: '$' 'declare' :)
          or $state[$p:lk] = 55327                          (: '$' 'default' :)
          or $state[$p:lk] = 55839                          (: '$' 'delete' :)
          or $state[$p:lk] = 56351                          (: '$' 'descendant' :)
          or $state[$p:lk] = 56863                          (: '$' 'descendant-or-self' :)
          or $state[$p:lk] = 57375                          (: '$' 'descending' :)
          or $state[$p:lk] = 59935                          (: '$' 'div' :)
          or $state[$p:lk] = 60447                          (: '$' 'document' :)
          or $state[$p:lk] = 60959                          (: '$' 'document-node' :)
          or $state[$p:lk] = 61471                          (: '$' 'element' :)
          or $state[$p:lk] = 61983                          (: '$' 'else' :)
          or $state[$p:lk] = 62495                          (: '$' 'empty' :)
          or $state[$p:lk] = 63007                          (: '$' 'empty-sequence' :)
          or $state[$p:lk] = 64031                          (: '$' 'end' :)
          or $state[$p:lk] = 65055                          (: '$' 'eq' :)
          or $state[$p:lk] = 65567                          (: '$' 'every' :)
          or $state[$p:lk] = 66591                          (: '$' 'except' :)
          or $state[$p:lk] = 68639                          (: '$' 'following' :)
          or $state[$p:lk] = 69151                          (: '$' 'following-sibling' :)
          or $state[$p:lk] = 69663                          (: '$' 'for' :)
          or $state[$p:lk] = 72735                          (: '$' 'function' :)
          or $state[$p:lk] = 73247                          (: '$' 'ge' :)
          or $state[$p:lk] = 74271                          (: '$' 'group' :)
          or $state[$p:lk] = 75295                          (: '$' 'gt' :)
          or $state[$p:lk] = 75807                          (: '$' 'idiv' :)
          or $state[$p:lk] = 76319                          (: '$' 'if' :)
          or $state[$p:lk] = 76831                          (: '$' 'import' :)
          or $state[$p:lk] = 79391                          (: '$' 'insert' :)
          or $state[$p:lk] = 79903                          (: '$' 'instance' :)
          or $state[$p:lk] = 80415                          (: '$' 'intersect' :)
          or $state[$p:lk] = 81439                          (: '$' 'invoke' :)
          or $state[$p:lk] = 81951                          (: '$' 'is' :)
          or $state[$p:lk] = 82463                          (: '$' 'item' :)
          or $state[$p:lk] = 84511                          (: '$' 'le' :)
          or $state[$p:lk] = 85535                          (: '$' 'let' :)
          or $state[$p:lk] = 87071                          (: '$' 'lt' :)
          or $state[$p:lk] = 88607                          (: '$' 'mod' :)
          or $state[$p:lk] = 89119                          (: '$' 'modify' :)
          or $state[$p:lk] = 89631                          (: '$' 'module' :)
          or $state[$p:lk] = 90655                          (: '$' 'namespace' :)
          or $state[$p:lk] = 91167                          (: '$' 'namespace-node' :)
          or $state[$p:lk] = 91679                          (: '$' 'ne' :)
          or $state[$p:lk] = 94239                          (: '$' 'node' :)
          or $state[$p:lk] = 96799                          (: '$' 'only' :)
          or $state[$p:lk] = 97823                          (: '$' 'or' :)
          or $state[$p:lk] = 98335                          (: '$' 'order' :)
          or $state[$p:lk] = 98847                          (: '$' 'ordered' :)
          or $state[$p:lk] = 100895                         (: '$' 'parent' :)
          or $state[$p:lk] = 103455                         (: '$' 'preceding' :)
          or $state[$p:lk] = 103967                         (: '$' 'preceding-sibling' :)
          or $state[$p:lk] = 105503                         (: '$' 'processing-instruction' :)
          or $state[$p:lk] = 106527                         (: '$' 'rename' :)
          or $state[$p:lk] = 107039                         (: '$' 'replace' :)
          or $state[$p:lk] = 107551                         (: '$' 'return' :)
          or $state[$p:lk] = 109087                         (: '$' 'satisfies' :)
          or $state[$p:lk] = 110111                         (: '$' 'schema-attribute' :)
          or $state[$p:lk] = 110623                         (: '$' 'schema-element' :)
          or $state[$p:lk] = 111647                         (: '$' 'self' :)
          or $state[$p:lk] = 114719                         (: '$' 'some' :)
          or $state[$p:lk] = 115231                         (: '$' 'stable' :)
          or $state[$p:lk] = 115743                         (: '$' 'start' :)
          or $state[$p:lk] = 118303                         (: '$' 'switch' :)
          or $state[$p:lk] = 118815                         (: '$' 'text' :)
          or $state[$p:lk] = 120863                         (: '$' 'to' :)
          or $state[$p:lk] = 121375                         (: '$' 'transform' :)
          or $state[$p:lk] = 121887                         (: '$' 'treat' :)
          or $state[$p:lk] = 122399                         (: '$' 'try' :)
          or $state[$p:lk] = 123935                         (: '$' 'typeswitch' :)
          or $state[$p:lk] = 124447                         (: '$' 'union' :)
          or $state[$p:lk] = 124959                         (: '$' 'unordered' :)
          or $state[$p:lk] = 125471                         (: '$' 'update' :)
          or $state[$p:lk] = 127519                         (: '$' 'validate' :)
          or $state[$p:lk] = 130591                         (: '$' 'where' :)
          or $state[$p:lk] = 132127                         (: '$' 'with' :)
          or $state[$p:lk] = 134175) then                   (: '$' 'xquery' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-GroupingVariable($input, $state)
          let $state := p:lookahead1W(171, $input, $state)  (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 51                     (: ':=' :)
                  or $state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 83) then           (: 'as' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-TypeDeclaration($input, $state)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(30, $input, $state) (: S^WS | ('(' ':') | ':=' :)
              let $state := p:consume(51, $input, $state)   (: ':=' :)
              let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                  StringLiteral | URIQualifiedName | QName^Token |
                                                                  S^WS | Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                                  '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                                  '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                  'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                  'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                  'castable' | 'child' | 'collation' | 'comment' |
                                                                  'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                  'descendant' | 'descendant-or-self' | 'descending' |
                                                                  'div' | 'document' | 'document-node' | 'element' |
                                                                  'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                  'every' | 'except' | 'following' |
                                                                  'following-sibling' | 'for' | 'function' | 'ge' |
                                                                  'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                  'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                  'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                  'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                  'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                  'parent' | 'preceding' | 'preceding-sibling' |
                                                                  'processing-instruction' | 'rename' | 'replace' |
                                                                  'return' | 'satisfies' | 'schema-attribute' |
                                                                  'schema-element' | 'self' | 'some' | 'stable' |
                                                                  'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                  'treat' | 'try' | 'typeswitch' | 'union' |
                                                                  'unordered' | 'update' | 'validate' | 'where' |
                                                                  'with' | 'xquery' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ExprSingle($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(166, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 96) then               (: 'collation' :)
              let $state := p:consume(96, $input, $state)   (: 'collation' :)
              let $state := p:lookahead1W(19, $input, $state) (: StringLiteral | S^WS | ('(' ':') :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-URILiteral($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupingVariable($input, $state)
      let $state := p:lookahead1W(171, $input, $state)      (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51                         (: ':=' :)
              or $state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-TypeDeclaration($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(30, $input, $state)   (: S^WS | ('(' ':') | ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(166, $input, $state)      (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 96) then                   (: 'collation' :)
          let $state := p:consume(96, $input, $state)       (: 'collation' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-URILiteral($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing GroupingSpec.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 31) then                           (: '$' :)
      let $state := p:lookahead2W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2591                           (: '$' URIQualifiedName :)
          or $state[$p:lk] = 7711                           (: '$' QName^Token :)
          or $state[$p:lk] = 39967                          (: '$' 'ancestor' :)
          or $state[$p:lk] = 40479                          (: '$' 'ancestor-or-self' :)
          or $state[$p:lk] = 40991                          (: '$' 'and' :)
          or $state[$p:lk] = 42527                          (: '$' 'as' :)
          or $state[$p:lk] = 43039                          (: '$' 'ascending' :)
          or $state[$p:lk] = 43551                          (: '$' 'at' :)
          or $state[$p:lk] = 44063                          (: '$' 'attribute' :)
          or $state[$p:lk] = 46623                          (: '$' 'case' :)
          or $state[$p:lk] = 47135                          (: '$' 'cast' :)
          or $state[$p:lk] = 47647                          (: '$' 'castable' :)
          or $state[$p:lk] = 48671                          (: '$' 'child' :)
          or $state[$p:lk] = 49183                          (: '$' 'collation' :)
          or $state[$p:lk] = 49695                          (: '$' 'comment' :)
          or $state[$p:lk] = 52255                          (: '$' 'copy' :)
          or $state[$p:lk] = 53279                          (: '$' 'count' :)
          or $state[$p:lk] = 54815                          (: '$' 'declare' :)
          or $state[$p:lk] = 55327                          (: '$' 'default' :)
          or $state[$p:lk] = 55839                          (: '$' 'delete' :)
          or $state[$p:lk] = 56351                          (: '$' 'descendant' :)
          or $state[$p:lk] = 56863                          (: '$' 'descendant-or-self' :)
          or $state[$p:lk] = 57375                          (: '$' 'descending' :)
          or $state[$p:lk] = 59935                          (: '$' 'div' :)
          or $state[$p:lk] = 60447                          (: '$' 'document' :)
          or $state[$p:lk] = 60959                          (: '$' 'document-node' :)
          or $state[$p:lk] = 61471                          (: '$' 'element' :)
          or $state[$p:lk] = 61983                          (: '$' 'else' :)
          or $state[$p:lk] = 62495                          (: '$' 'empty' :)
          or $state[$p:lk] = 63007                          (: '$' 'empty-sequence' :)
          or $state[$p:lk] = 64031                          (: '$' 'end' :)
          or $state[$p:lk] = 65055                          (: '$' 'eq' :)
          or $state[$p:lk] = 65567                          (: '$' 'every' :)
          or $state[$p:lk] = 66591                          (: '$' 'except' :)
          or $state[$p:lk] = 68639                          (: '$' 'following' :)
          or $state[$p:lk] = 69151                          (: '$' 'following-sibling' :)
          or $state[$p:lk] = 69663                          (: '$' 'for' :)
          or $state[$p:lk] = 72735                          (: '$' 'function' :)
          or $state[$p:lk] = 73247                          (: '$' 'ge' :)
          or $state[$p:lk] = 74271                          (: '$' 'group' :)
          or $state[$p:lk] = 75295                          (: '$' 'gt' :)
          or $state[$p:lk] = 75807                          (: '$' 'idiv' :)
          or $state[$p:lk] = 76319                          (: '$' 'if' :)
          or $state[$p:lk] = 76831                          (: '$' 'import' :)
          or $state[$p:lk] = 79391                          (: '$' 'insert' :)
          or $state[$p:lk] = 79903                          (: '$' 'instance' :)
          or $state[$p:lk] = 80415                          (: '$' 'intersect' :)
          or $state[$p:lk] = 81439                          (: '$' 'invoke' :)
          or $state[$p:lk] = 81951                          (: '$' 'is' :)
          or $state[$p:lk] = 82463                          (: '$' 'item' :)
          or $state[$p:lk] = 84511                          (: '$' 'le' :)
          or $state[$p:lk] = 85535                          (: '$' 'let' :)
          or $state[$p:lk] = 87071                          (: '$' 'lt' :)
          or $state[$p:lk] = 88607                          (: '$' 'mod' :)
          or $state[$p:lk] = 89119                          (: '$' 'modify' :)
          or $state[$p:lk] = 89631                          (: '$' 'module' :)
          or $state[$p:lk] = 90655                          (: '$' 'namespace' :)
          or $state[$p:lk] = 91167                          (: '$' 'namespace-node' :)
          or $state[$p:lk] = 91679                          (: '$' 'ne' :)
          or $state[$p:lk] = 94239                          (: '$' 'node' :)
          or $state[$p:lk] = 96799                          (: '$' 'only' :)
          or $state[$p:lk] = 97823                          (: '$' 'or' :)
          or $state[$p:lk] = 98335                          (: '$' 'order' :)
          or $state[$p:lk] = 98847                          (: '$' 'ordered' :)
          or $state[$p:lk] = 100895                         (: '$' 'parent' :)
          or $state[$p:lk] = 103455                         (: '$' 'preceding' :)
          or $state[$p:lk] = 103967                         (: '$' 'preceding-sibling' :)
          or $state[$p:lk] = 105503                         (: '$' 'processing-instruction' :)
          or $state[$p:lk] = 106527                         (: '$' 'rename' :)
          or $state[$p:lk] = 107039                         (: '$' 'replace' :)
          or $state[$p:lk] = 107551                         (: '$' 'return' :)
          or $state[$p:lk] = 109087                         (: '$' 'satisfies' :)
          or $state[$p:lk] = 110111                         (: '$' 'schema-attribute' :)
          or $state[$p:lk] = 110623                         (: '$' 'schema-element' :)
          or $state[$p:lk] = 111647                         (: '$' 'self' :)
          or $state[$p:lk] = 114719                         (: '$' 'some' :)
          or $state[$p:lk] = 115231                         (: '$' 'stable' :)
          or $state[$p:lk] = 115743                         (: '$' 'start' :)
          or $state[$p:lk] = 118303                         (: '$' 'switch' :)
          or $state[$p:lk] = 118815                         (: '$' 'text' :)
          or $state[$p:lk] = 120863                         (: '$' 'to' :)
          or $state[$p:lk] = 121375                         (: '$' 'transform' :)
          or $state[$p:lk] = 121887                         (: '$' 'treat' :)
          or $state[$p:lk] = 122399                         (: '$' 'try' :)
          or $state[$p:lk] = 123935                         (: '$' 'typeswitch' :)
          or $state[$p:lk] = 124447                         (: '$' 'union' :)
          or $state[$p:lk] = 124959                         (: '$' 'unordered' :)
          or $state[$p:lk] = 125471                         (: '$' 'update' :)
          or $state[$p:lk] = 127519                         (: '$' 'validate' :)
          or $state[$p:lk] = 130591                         (: '$' 'where' :)
          or $state[$p:lk] = 132127                         (: '$' 'with' :)
          or $state[$p:lk] = 134175) then                   (: '$' 'xquery' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-GroupingVariable($input, $state)
          let $state := p:lookahead1W(171, $input, $state)  (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 51                     (: ':=' :)
                  or $state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] = 83) then           (: 'as' :)
                  let $state :=
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-TypeDeclaration($input, $state)
                  return $state
                else
                  $state
              let $state := p:lookahead1W(30, $input, $state) (: S^WS | ('(' ':') | ':=' :)
              let $state := p:consume(51, $input, $state)   (: ':=' :)
              let $state := p:lookahead1W(235, $input, $state) (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                                  StringLiteral | URIQualifiedName | QName^Token |
                                                                  S^WS | Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                                  '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                                  '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                                  'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                                  'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                                  'castable' | 'child' | 'collation' | 'comment' |
                                                                  'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                                  'descendant' | 'descendant-or-self' | 'descending' |
                                                                  'div' | 'document' | 'document-node' | 'element' |
                                                                  'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                                  'every' | 'except' | 'following' |
                                                                  'following-sibling' | 'for' | 'function' | 'ge' |
                                                                  'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                                  'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                                  'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                                  'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                                  'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                                  'parent' | 'preceding' | 'preceding-sibling' |
                                                                  'processing-instruction' | 'rename' | 'replace' |
                                                                  'return' | 'satisfies' | 'schema-attribute' |
                                                                  'schema-element' | 'self' | 'some' | 'stable' |
                                                                  'start' | 'switch' | 'text' | 'to' | 'transform' |
                                                                  'treat' | 'try' | 'typeswitch' | 'union' |
                                                                  'unordered' | 'update' | 'validate' | 'where' |
                                                                  'with' | 'xquery' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-ExprSingle($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(166, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 96) then               (: 'collation' :)
              let $state := p:consume(96, $input, $state)   (: 'collation' :)
              let $state := p:lookahead1W(19, $input, $state) (: StringLiteral | S^WS | ('(' ':') :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-URILiteral($input, $state)
              return $state
            else
              $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -1, -1)
            else
              p:memoize($backtrack, $state, 2, $backtrack[$p:e0], -2, -2)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-GroupingVariable($input, $state)
      let $state := p:lookahead1W(171, $input, $state)      (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51                         (: ':=' :)
              or $state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 83) then               (: 'as' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-TypeDeclaration($input, $state)
              return $state
            else
              $state
          let $state := p:lookahead1W(30, $input, $state)   (: S^WS | ('(' ':') | ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ExprSingle($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(166, $input, $state)      (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 96) then                   (: 'collation' :)
          let $state := p:consume(96, $input, $state)       (: 'collation' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-URILiteral($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-GroupingSpec($input, $state)
        return p:try-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Try parsing GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-GroupingSpec($input, $state)
  let $state := p:try-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(145, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(90, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Try parsing GroupByClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(145, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(90, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(255, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing WhereClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(255, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 136                            (: 'for' :)
          or $state[$p:l1] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing IntermediateClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 136                            (: 'for' :)
          or $state[$p:l1] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CountClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(223, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Try parsing SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(223, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(125, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(125, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing NextItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing PreviousItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing CurrentItem.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 205) then                      (: 'previous' :)
      let $state := p:consume(205, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 180) then                      (: 'next' :)
      let $state := p:consume(180, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing WindowVars.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 205) then                      (: 'previous' :)
      let $state := p:consume(205, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 180) then                      (: 'next' :)
      let $state := p:consume(180, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(226, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(226, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowVars($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(254, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(240, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 125                            (: 'end' :)
          or $state[$p:l1] = 189) then                      (: 'only' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(240, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(257, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'start' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 125                            (: 'end' :)
          or $state[$p:l1] = 189) then                      (: 'only' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 240) then                      (: 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TumblingWindowClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing WindowClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 240) then                      (: 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TumblingWindowClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarName($input, $state)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ':=' | 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScoreVar($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing LetBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-VarName($input, $state)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ':=' | 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 83) then                   (: 'as' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeDeclaration($input, $state)
          return $state
        else
          $state
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTScoreVar($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(87, $input, $state)     (: S^WS | '$' | ('(' ':') | 'score' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-LetBinding($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(87, $input, $state)     (: S^WS | '$' | ('(' ':') | 'score' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-LetBinding($input, $state)
        return p:try-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(167, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return $state
};

(:~
 : Try parsing LetClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(167, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-LetBinding($input, $state)
  let $state := p:try-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse FTScoreVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTScoreVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(217, $input, $state)              (: 'score' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing FTScoreVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTScoreVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(217, $input, $state)              (: 'score' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  return $state
};

(:~
 : Try parsing PositionalVar.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  return $state
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  return $state
};

(:~
 : Try parsing AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(77, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Try parsing TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing VarName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-VarName($input, $state)
  let $state := p:lookahead1W(156, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' |
                                                               'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'allowing' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 217) then                      (: 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTScoreVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Try parsing ForBinding.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-VarName($input, $state)
  let $state := p:lookahead1W(156, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' |
                                                               'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'allowing' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'in' | 'score' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 217) then                      (: 'score' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTScoreVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(151, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-ForBinding($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-ForBinding($input, $state)
        return p:try-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return $state
};

(:~
 : Try parsing ForClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(136, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ForBinding($input, $state)
  let $state := p:try-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008) then                    (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing InitialClause.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(134, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008) then                    (: 'for' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 167) then                      (: 'let' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-LetClause($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(163, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 210) then                         (: 'return' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(163, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 210) then                         (: 'return' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-IntermediateClause($input, $state)
        return p:try-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ReturnClause($input, $state)
  return $state
};

(:~
 : Try parsing FLWORExpr.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-InitialClause($input, $state)
  let $state := p:try-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(210, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'sliding' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'tumbling' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 159) then                     (: 'invoke' :)
      let $state := p:lookahead2W(203, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'updating' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 167) then                     (: 'let' :)
      let $state := p:lookahead2W(207, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 208) then                     (: 'rename' :)
      let $state := p:lookahead2W(202, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 209) then                     (: 'replace' :)
      let $state := p:lookahead2W(209, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'value' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 239) then                     (: 'try' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (109,                          (: 'delete' :)
                              155)) then                    (: 'insert' :)
      let $state := p:lookahead2W(208, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'nodes' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (102,                          (: 'copy' :)
                              128,                          (: 'every' :)
                              224)) then                    (: 'some' :)
      let $state := p:lookahead2W(200, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (149,                          (: 'if' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17557) then                    (: 'if' '(' :)
      let $state := p:memoized($state, 26)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-IfExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -5, -5)
            else
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -6, -6)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008                          (: 'for' '$' :)
          or $state[$p:lk] = 16039                          (: 'let' '$' :)
          or $state[$p:lk] = 111271                         (: 'let' 'score' :)
          or $state[$p:lk] = 114312                         (: 'for' 'sliding' :)
          or $state[$p:lk] = 123016) then                   (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 16000                          (: 'every' '$' :)
          or $state[$p:lk] = 16096) then                    (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17639) then                    (: 'switch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17650) then                    (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BasexIfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135407) then                   (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94363                          (: 'insert' 'node' :)
          or $state[$p:lk] = 94875) then                    (: 'insert' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94317                          (: 'delete' 'node' :)
          or $state[$p:lk] = 94829) then                    (: 'delete' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94416) then                    (: 'rename' 'node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94417                          (: 'replace' 'node' :)
          or $state[$p:lk] = 128209) then                   (: 'replace' 'value' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 126111) then                   (: 'invoke' 'updating' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-UpdatingFunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 15974) then                    (: 'copy' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyModifyExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ExprSingle.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 136) then                          (: 'for' :)
      let $state := p:lookahead2W(210, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'sliding' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'tumbling' | 'union' | 'update' |
                                                               'where' | 'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 159) then                     (: 'invoke' :)
      let $state := p:lookahead2W(203, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'updating' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 167) then                     (: 'let' :)
      let $state := p:lookahead2W(207, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | 'where' |
                                                               'with' | 'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 208) then                     (: 'rename' :)
      let $state := p:lookahead2W(202, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 209) then                     (: 'replace' :)
      let $state := p:lookahead2W(209, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'value' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 239) then                     (: 'try' :)
      let $state := p:lookahead2W(204, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (109,                          (: 'delete' :)
                              155)) then                    (: 'insert' :)
      let $state := p:lookahead2W(208, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'node' | 'nodes' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (102,                          (: 'copy' :)
                              128,                          (: 'every' :)
                              224)) then                    (: 'some' :)
      let $state := p:lookahead2W(200, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'cast' | 'castable' | 'collation' |
                                                               'contains' | 'count' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'end' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'where' | 'with' |
                                                               'words' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (149,                          (: 'if' :)
                              231,                          (: 'switch' :)
                              242)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(195, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'only' | 'or' | 'order' | 'paragraphs' |
                                                               'return' | 'satisfies' | 'sentences' | 'stable' |
                                                               'start' | 'times' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'where' | 'with' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17557) then                    (: 'if' '(' :)
      let $state := p:memoized($state, 26)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-IfExpr($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -5, -5)
            else
              p:memoize($backtrack, $state, 26, $backtrack[$p:e0], -6, -6)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 16008                          (: 'for' '$' :)
          or $state[$p:lk] = 16039                          (: 'let' '$' :)
          or $state[$p:lk] = 111271                         (: 'let' 'score' :)
          or $state[$p:lk] = 114312                         (: 'for' 'sliding' :)
          or $state[$p:lk] = 123016) then                   (: 'for' 'tumbling' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 16000                          (: 'every' '$' :)
          or $state[$p:lk] = 16096) then                    (: 'some' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17639) then                    (: 'switch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 17650) then                    (: 'typeswitch' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-BasexIfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 135407) then                   (: 'try' '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94363                          (: 'insert' 'node' :)
          or $state[$p:lk] = 94875) then                    (: 'insert' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94317                          (: 'delete' 'node' :)
          or $state[$p:lk] = 94829) then                    (: 'delete' 'nodes' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94416) then                    (: 'rename' 'node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 94417                          (: 'replace' 'node' :)
          or $state[$p:lk] = 128209) then                   (: 'replace' 'value' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 126111) then                   (: 'invoke' 'updating' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-UpdatingFunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 15974) then                    (: 'copy' '$' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CopyModifyExpr($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TypedArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing TypedArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AnyArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(82, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 82) then                           (: 'array' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 22)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyArrayTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyArrayTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedArrayTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ArrayTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 82) then                           (: 'array' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 22)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyArrayTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 22, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyArrayTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypedArrayTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse TypedMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing TypedMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AnyMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyMapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyMapTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(171, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse MapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-MapTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 171) then                          (: 'map' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 21)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyMapTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyMapTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedMapTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing MapTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-MapTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 171) then                          (: 'map' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 21)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyMapTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 21, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyMapTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypedMapTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(39, $input, $state)           (: '+' :)
      return $state
  return $state
};

(:~
 : Try parsing OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state := p:consume(39, $input, $state)           (: '+' :)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 123) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17531) then                    (: 'empty-sequence' '(' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(198, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 65) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Try parsing SequenceType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 123) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17531) then                    (: 'empty-sequence' '(' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ItemType($input, $state)
      let $state := p:lookahead1W(198, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'contains' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 65) then                   (: '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(229, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-SequenceType($input, $state)
        return p:try-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(231, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Try parsing TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(231, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SequenceType($input, $state)
      let $state := p:try-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(83, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(229, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-SequenceType($input, $state)
  return $state
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(142, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Try parsing NumericLiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(144, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(144, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Literal($input, $state)
        return p:try-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(32, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(155, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(144, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-Literal($input, $state)
      let $state := p:parse-Annotation-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing Annotation.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(32, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(155, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(144, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-Literal($input, $state)
      let $state := p:try-Annotation-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-Annotation($input, $state)
        return p:try-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 20)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyFunctionTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyFunctionTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FunctionTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 142) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    let $state := p:memoized($state, 20)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-AnyFunctionTest($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -1, -1)
          else
            p:memoize($backtrack, $state, 20, $backtrack[$p:e0], -2, -2)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyFunctionTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AnyKindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(184, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(178, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(178, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing TextTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(232, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing CommentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(97, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing PITest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(206, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'as' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeName($input, $state)
  return $state
};

(:~
 : Try parsing AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(215, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(215, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing AttributeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing AttributeTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(86, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementName($input, $state)
  return $state
};

(:~
 : Try parsing ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(216, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(216, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing TypeName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  return $state
};

(:~
 : Try parsing ElementName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(92, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 65) then               (: '?' :)
              let $state := p:consume(65, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing ElementTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(120, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(228, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(222, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-TypeName($input, $state)
          let $state := p:lookahead1W(92, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 65) then               (: '?' :)
              let $state := p:consume(65, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(119, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'element' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Try parsing DocumentTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(119, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 120) then                  (: 'element' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-ElementTest($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NamespaceNodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing KindTest.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-NamespaceNodeTest($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         142,                               (: 'function' :)
                         161,                               (: 'item' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17569) then                    (: 'item' '(' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MapTest($input, $state)
      return $state
    else if ($state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ArrayTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ParenthesizedItemType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing ItemType.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = (86,                                (: 'attribute' :)
                         97,                                (: 'comment' :)
                         119,                               (: 'document-node' :)
                         120,                               (: 'element' :)
                         142,                               (: 'function' :)
                         161,                               (: 'item' :)
                         178,                               (: 'namespace-node' :)
                         184,                               (: 'node' :)
                         206,                               (: 'processing-instruction' :)
                         215,                               (: 'schema-attribute' :)
                         216,                               (: 'schema-element' :)
                         232)) then                         (: 'text' :)
      let $state := p:lookahead2W(205, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'after' | 'allowing' |
                                                               'and' | 'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'contains' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'paragraphs' | 'return' | 'satisfies' | 'score' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'where' | 'with' |
                                                               'words' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 17494                          (: 'attribute' '(' :)
          or $state[$p:lk] = 17505                          (: 'comment' '(' :)
          or $state[$p:lk] = 17527                          (: 'document-node' '(' :)
          or $state[$p:lk] = 17528                          (: 'element' '(' :)
          or $state[$p:lk] = 17586                          (: 'namespace-node' '(' :)
          or $state[$p:lk] = 17592                          (: 'node' '(' :)
          or $state[$p:lk] = 17614                          (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 17623                          (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 17624                          (: 'schema-element' '(' :)
          or $state[$p:lk] = 17640) then                    (: 'text' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 17569) then                    (: 'item' '(' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 17550) then                    (: 'function' '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 171) then                      (: 'map' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-MapTest($input, $state)
      return $state
    else if ($state[$p:lk] = 82) then                       (: 'array' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ArrayTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-ParenthesizedItemType($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(101, $input, $state)              (: 'context' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(161, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(229, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'as' | 'ascending' | 'at' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'invoke' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(235, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VarValue($input, $state)
      return $state
    else
      let $state := p:consume(132, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(98, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(235, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Try parsing FTExtensionOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTExtensionOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(190, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(222, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTStopWords($input, $state)
  return $state
};

(:~
 : Try parsing FTStopWordsInclExcl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordsInclExcl($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '(' | ('(' ':') | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-FTStopWords($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWords-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-FTStopWords-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWords (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWords-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:try-FTStopWords-1($input, $state)
};

(:~
 : Parse FTStopWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      return $state
    else
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:parse-FTStopWords-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
  return $state
};

(:~
 : Try parsing FTStopWords.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWords($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-URILiteral($input, $state)
      return $state
    else
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:try-FTStopWords-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 24)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 24)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 24, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 24, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-FTStopWordOption-1($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-1($input, $state)
};

(:~
 : Parse the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 25)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, 25, $backtrack[$p:e0], -1, -1)
              else
                p:memoize($backtrack, $state, 25, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTStopWordsInclExcl($input, $state)
        return p:parse-FTStopWordOption-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production FTStopWordOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordOption-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    let $state :=
      if ($state[$p:l1] = (130,                             (: 'except' :)
                           243)) then                       (: 'union' :)
        let $state := p:lookahead2W(235, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:lk] = 17538                        (: 'except' '(' :)
            or $state[$p:lk] = 17651                        (: 'union' '(' :)
            or $state[$p:lk] = 43650                        (: 'except' 'at' :)
            or $state[$p:lk] = 43763) then                  (: 'union' 'at' :)
        let $state := p:memoized($state, 25)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:try-FTStopWordsInclExcl($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($state, $state, 25, $backtrack[$p:e0], -1, -3)
              else
                p:memoize($backtrack, $state, 25, $backtrack[$p:e0], -2, -2)
      else
        $state
    return
      if ($state[$p:lk] = -3) then
        p:try-FTStopWordOption-2($input, $state)
      else if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTStopWordsInclExcl($input, $state)
        return p:try-FTStopWordOption-2($input, $state)
};

(:~
 : Parse FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 228) then                      (: 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          let $state := p:parse-FTStopWordOption-2($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTStopWords($input, $state)
          let $state := p:parse-FTStopWordOption-1($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
  return $state
};

(:~
 : Try parsing FTStopWordOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStopWordOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 228) then                      (: 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          let $state := p:try-FTStopWordOption-2($input, $state)
          return $state
        else
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTStopWords($input, $state)
          let $state := p:try-FTStopWordOption-1($input, $state)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'stop' :)
      let $state := p:consume(228, $input, $state)          (: 'stop' :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'words' :)
      let $state := p:consume(261, $input, $state)          (: 'words' :)
      return $state
  return $state
};

(:~
 : Parse FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(113, $input, $state)              (: 'diacritics' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 154) then                      (: 'insensitive' :)
      let $state := p:consume(154, $input, $state)          (: 'insensitive' :)
      return $state
    else
      let $state := p:consume(219, $input, $state)          (: 'sensitive' :)
      return $state
  return $state
};

(:~
 : Try parsing FTDiacriticsOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTDiacriticsOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(113, $input, $state)              (: 'diacritics' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 154) then                      (: 'insensitive' :)
      let $state := p:consume(154, $input, $state)          (: 'insensitive' :)
      return $state
    else
      let $state := p:consume(219, $input, $state)          (: 'sensitive' :)
      return $state
  return $state
};

(:~
 : Parse FTCaseOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(118, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 154) then                  (: 'insensitive' :)
          let $state := p:consume(154, $input, $state)      (: 'insensitive' :)
          return $state
        else
          let $state := p:consume(219, $input, $state)      (: 'sensitive' :)
          return $state
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'lowercase' :)
      let $state := p:consume(169, $input, $state)          (: 'lowercase' :)
      return $state
    else
      let $state := p:consume(247, $input, $state)          (: 'uppercase' :)
      return $state
  return $state
};

(:~
 : Try parsing FTCaseOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTCaseOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      let $state := p:lookahead1W(118, $input, $state)      (: S^WS | ('(' ':') | 'insensitive' | 'sensitive' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 154) then                  (: 'insensitive' :)
          let $state := p:consume(154, $input, $state)      (: 'insensitive' :)
          return $state
        else
          let $state := p:consume(219, $input, $state)      (: 'sensitive' :)
          return $state
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'lowercase' :)
      let $state := p:consume(169, $input, $state)          (: 'lowercase' :)
      return $state
    else
      let $state := p:consume(247, $input, $state)          (: 'uppercase' :)
      return $state
  return $state
};

(:~
 : Parse FTStemOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 227) then                      (: 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
  return $state
};

(:~
 : Try parsing FTStemOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTStemOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 227) then                      (: 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'stemming' :)
      let $state := p:consume(227, $input, $state)          (: 'stemming' :)
      return $state
  return $state
};

(:~
 : Parse FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
  return $state
};

(:~
 : Try parsing FTLiteralRange.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTLiteralRange($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 129) then                      (: 'exactly' :)
      let $state := p:consume(129, $input, $state)          (: 'exactly' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(119, $input, $state)      (: S^WS | ('(' ':') | 'least' | 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 166) then                  (: 'least' :)
          let $state := p:consume(166, $input, $state)      (: 'least' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
        else
          let $state := p:consume(176, $input, $state)      (: 'most' :)
          let $state := p:lookahead1W(18, $input, $state)   (: IntegerLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(1, $input, $state)        (: IntegerLiteral :)
          return $state
      return $state
    else
      let $state := p:consume(137, $input, $state)          (: 'from' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(18, $input, $state)       (: IntegerLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
  return $state
};

(:~
 : Parse FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(217, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'relationship' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 207) then                      (: 'relationship' :)
      let $state := p:consume(207, $input, $state)          (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(215, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 85) then                           (: 'at' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 129                            (: 'exactly' :)
          or $state[$p:lk] = 137                            (: 'from' :)
          or $state[$p:lk] = 85077                          (: 'at' 'least' :)
          or $state[$p:lk] = 90197) then                    (: 'at' 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:consume(168, $input, $state)          (: 'levels' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Try parsing FTThesaurusID.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTThesaurusID($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(85, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URILiteral($input, $state)
  let $state := p:lookahead1W(217, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'relationship' | 'return' | 'same' |
                                                               'satisfies' | 'sentences' | 'stable' | 'start' |
                                                               'times' | 'to' | 'transform' | 'treat' | 'union' |
                                                               'using' | 'weight' | 'where' | 'window' | 'with' |
                                                               'without' | 'words' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 207) then                      (: 'relationship' :)
      let $state := p:consume(207, $input, $state)          (: 'relationship' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(215, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'exactly' |
                                                               'except' | 'for' | 'from' | 'ftand' | 'ftor' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'ne' | 'not' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'paragraphs' | 'return' | 'same' | 'satisfies' |
                                                               'sentences' | 'stable' | 'start' | 'times' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'using' | 'weight' |
                                                               'where' | 'window' | 'with' | 'without' | 'words' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:l1] eq 85) then                           (: 'at' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | ('(' ':') | 'end' | 'least' | 'most' | 'start' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 129                            (: 'exactly' :)
          or $state[$p:lk] = 137                            (: 'from' :)
          or $state[$p:lk] = 85077                          (: 'at' 'least' :)
          or $state[$p:lk] = 90197) then                    (: 'at' 'most' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTLiteralRange($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | ('(' ':') | 'levels' :)
      let $state := p:consume(168, $input, $state)          (: 'levels' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-FTThesaurusID($input, $state)
        return p:parse-FTThesaurusOption-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTThesaurusOption (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTThesaurusOption-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | ('(' ':') | 'at' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:try-FTThesaurusID($input, $state)
        return p:try-FTThesaurusOption-1($input, $state)
};

(:~
 : Parse FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 234) then                      (: 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 85) then                   (: 'at' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:parse-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          return $state
        else
          let $state := p:consume(34, $input, $state)       (: '(' :)
          let $state := p:lookahead1W(105, $input, $state)  (: S^WS | ('(' ':') | 'at' | 'default' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 85) then               (: 'at' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:parse-FTThesaurusID($input, $state)
              return $state
            else
              let $state := p:consume(108, $input, $state)  (: 'default' :)
              return $state
          let $state := p:parse-FTThesaurusOption-1($input, $state)
          let $state := p:consume(37, $input, $state)       (: ')' :)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      return $state
  return $state
};

(:~
 : Try parsing FTThesaurusOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTThesaurusOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 234) then                      (: 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      let $state := p:lookahead1W(135, $input, $state)      (: S^WS | '(' | ('(' ':') | 'at' | 'default' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 85) then                   (: 'at' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-FTThesaurusID($input, $state)
          return $state
        else if ($state[$p:l1] = 108) then                  (: 'default' :)
          let $state := p:consume(108, $input, $state)      (: 'default' :)
          return $state
        else
          let $state := p:consume(34, $input, $state)       (: '(' :)
          let $state := p:lookahead1W(105, $input, $state)  (: S^WS | ('(' ':') | 'at' | 'default' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 85) then               (: 'at' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-FTThesaurusID($input, $state)
              return $state
            else
              let $state := p:consume(108, $input, $state)  (: 'default' :)
              return $state
          let $state := p:try-FTThesaurusOption-1($input, $state)
          let $state := p:consume(37, $input, $state)       (: ')' :)
          return $state
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | 'thesaurus' :)
      let $state := p:consume(234, $input, $state)          (: 'thesaurus' :)
      return $state
  return $state
};

(:~
 : Parse FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 256) then                      (: 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
  return $state
};

(:~
 : Try parsing FTWildCardOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTWildCardOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 256) then                      (: 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
    else
      let $state := p:consume(181, $input, $state)          (: 'no' :)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | 'wildcards' :)
      let $state := p:consume(256, $input, $state)          (: 'wildcards' :)
      return $state
  return $state
};

(:~
 : Parse FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(162, $input, $state)              (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Try parsing FTLanguageOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTLanguageOption($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(162, $input, $state)              (: 'language' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse FTMatchOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 181) then                          (: 'no' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 162) then                      (: 'language' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 256                            (: 'wildcards' :)
          or $state[$p:lk] = 131253) then                   (: 'no' 'wildcards' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 234                            (: 'thesaurus' :)
          or $state[$p:lk] = 119989) then                   (: 'no' 'thesaurus' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 227                            (: 'stemming' :)
          or $state[$p:lk] = 116405) then                   (: 'no' 'stemming' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 113) then                      (: 'diacritics' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 228                            (: 'stop' :)
          or $state[$p:lk] = 116917) then                   (: 'no' 'stop' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 190) then                      (: 'option' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTExtensionOption($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FTCaseOption($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing FTMatchOption.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMatchOption($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 181) then                          (: 'no' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | ('(' ':') | 'stemming' | 'stop' | 'thesaurus' |
                                                               'wildcards' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 162) then                      (: 'language' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTLanguageOption($input, $state)
      return $state
    else if ($state[$p:lk] = 256                            (: 'wildcards' :)
          or $state[$p:lk] = 131253) then                   (: 'no' 'wildcards' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTWildCardOption($input, $state)
      return $state
    else if ($state[$p:lk] = 234                            (: 'thesaurus' :)
          or $state[$p:lk] = 119989) then                   (: 'no' 'thesaurus' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTThesaurusOption($input, $state)
      return $state
    else if ($state[$p:lk] = 227                            (: 'stemming' :)
          or $state[$p:lk] = 116405) then                   (: 'no' 'stemming' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTStemOption($input, $state)
      return $state
    else if ($state[$p:lk] = 113) then                      (: 'diacritics' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTDiacriticsOption($input, $state)
      return $state
    else if ($state[$p:lk] = 228                            (: 'stop' :)
          or $state[$p:lk] = 116917) then                   (: 'no' 'stop' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTStopWordOption($input, $state)
      return $state
    else if ($state[$p:lk] = 190) then                      (: 'option' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTExtensionOption($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FTCaseOption($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(248, $input, $state)            (: 'using' :)
    let $state := p:lookahead1W(170, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:parse-FTMatchOption($input, $state)
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    return
      if ($state[$p:l1] != 248) then                        (: 'using' :)
        $state
      else
        p:parse-FTMatchOptions-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FTMatchOptions (one or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMatchOptions-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(248, $input, $state)            (: 'using' :)
    let $state := p:lookahead1W(170, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'diacritics' | 'language' |
                                                               'lowercase' | 'no' | 'option' | 'stemming' | 'stop' |
                                                               'thesaurus' | 'uppercase' | 'wildcards' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else
        p:try-FTMatchOption($input, $state)
    let $state := p:lookahead1W(213, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'at' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'contains' | 'count' | 'default' |
                                                               'descending' | 'different' | 'distance' | 'div' |
                                                               'else' | 'empty' | 'end' | 'entire' | 'eq' | 'except' |
                                                               'for' | 'ftand' | 'ftor' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'not' |
                                                               'only' | 'or' | 'order' | 'ordered' | 'paragraphs' |
                                                               'return' | 'same' | 'satisfies' | 'sentences' |
                                                               'stable' | 'start' | 'times' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'using' | 'weight' | 'where' |
                                                               'window' | 'with' | 'without' | 'words' | '|' | '||' |
                                                               '}' | '}`' :)
    return
      if ($state[$p:l1] != 248) then                        (: 'using' :)
        $state
      else
        p:try-FTMatchOptions-1($input, $state)
};

(:~
 : Parse FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FTMatchOptions-1($input, $state)
  return $state
};

(:~
 : Try parsing FTMatchOptions.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FTMatchOptions($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FTMatchOptions-1($input, $state)
  return $state
};

(:~
 : Parse FTOptionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FTOptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'ft-option' :)
  let $state := p:consume(138, $input, $state)              (: 'ft-option' :)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'using' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-FTMatchOptions($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(150, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(175, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(82, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(174, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(174, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-NCName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      let $state := p:lookahead1W(57, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(150, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(214, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(131, $input, $state)          (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 4) then                       (: StringLiteral :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 150) then                          (: 'import' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 109718) then                   (: 'import' 'schema' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-SchemaImport($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ModuleImport($input, $state)
      return $state
  return $state
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(174, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(60, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 106) then                      (: 'decimal-separator' :)
      let $state := p:consume(106, $input, $state)          (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'grouping-separator' :)
      let $state := p:consume(146, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'infinity' :)
      let $state := p:consume(152, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'minus-sign' :)
      let $state := p:consume(172, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'NaN' :)
      let $state := p:consume(68, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'percent' :)
      let $state := p:consume(200, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'per-mille' :)
      let $state := p:consume(199, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 263) then                      (: 'zero-digit' :)
      let $state := p:consume(263, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'digit' :)
      let $state := p:consume(115, $input, $state)          (: 'digit' :)
      return $state
    else if ($state[$p:l1] = 198) then                      (: 'pattern-separator' :)
      let $state := p:consume(198, $input, $state)          (: 'pattern-separator' :)
      return $state
    else
      let $state := p:consume(131, $input, $state)          (: 'exponent-separator' :)
      return $state
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QName^Token :)
      let $state := p:consume(15, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'copy' :)
      let $state := p:consume(102, $input, $state)          (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'declare' :)
      let $state := p:consume(107, $input, $state)          (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'delete' :)
      let $state := p:consume(109, $input, $state)          (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state := p:consume(118, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'every' :)
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'following' :)
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'import' :)
      let $state := p:consume(150, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'insert' :)
      let $state := p:consume(155, $input, $state)          (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'invoke' :)
      let $state := p:consume(159, $input, $state)          (: 'invoke' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'module' :)
      let $state := p:consume(175, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'modify' :)
      let $state := p:consume(174, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state := p:consume(193, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 208) then                      (: 'rename' :)
      let $state := p:consume(208, $input, $state)          (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'replace' :)
      let $state := p:consume(209, $input, $state)          (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'transform' :)
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'try' :)
      let $state := p:consume(239, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 244) then                      (: 'unordered' :)
      let $state := p:consume(244, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      return $state
    else if ($state[$p:l1] = 249) then                      (: 'validate' :)
      let $state := p:consume(249, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      return $state
    else
      let $state := p:consume(262, $input, $state)          (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Try parsing FunctionName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QName^Token :)
      let $state := p:consume(15, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'ancestor' :)
      let $state := p:consume(78, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(79, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'at' :)
      let $state := p:consume(85, $input, $state)           (: 'at' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'child' :)
      let $state := p:consume(95, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'copy' :)
      let $state := p:consume(102, $input, $state)          (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'declare' :)
      let $state := p:consume(107, $input, $state)          (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'delete' :)
      let $state := p:consume(109, $input, $state)          (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'descendant' :)
      let $state := p:consume(110, $input, $state)          (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'descendant-or-self' :)
      let $state := p:consume(111, $input, $state)          (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'document' :)
      let $state := p:consume(118, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'every' :)
      let $state := p:consume(128, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'following' :)
      let $state := p:consume(134, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'following-sibling' :)
      let $state := p:consume(135, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'import' :)
      let $state := p:consume(150, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'insert' :)
      let $state := p:consume(155, $input, $state)          (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'invoke' :)
      let $state := p:consume(159, $input, $state)          (: 'invoke' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'module' :)
      let $state := p:consume(175, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'modify' :)
      let $state := p:consume(174, $input, $state)          (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'namespace' :)
      let $state := p:consume(177, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state := p:consume(193, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'parent' :)
      let $state := p:consume(197, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 202) then                      (: 'preceding' :)
      let $state := p:consume(202, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: 'preceding-sibling' :)
      let $state := p:consume(203, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 208) then                      (: 'rename' :)
      let $state := p:consume(208, $input, $state)          (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'replace' :)
      let $state := p:consume(209, $input, $state)          (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 218) then                      (: 'self' :)
      let $state := p:consume(218, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 224) then                      (: 'some' :)
      let $state := p:consume(224, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 237) then                      (: 'transform' :)
      let $state := p:consume(237, $input, $state)          (: 'transform' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 239) then                      (: 'try' :)
      let $state := p:consume(239, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 244) then                      (: 'unordered' :)
      let $state := p:consume(244, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 245) then                      (: 'update' :)
      let $state := p:consume(245, $input, $state)          (: 'update' :)
      return $state
    else if ($state[$p:l1] = 249) then                      (: 'validate' :)
      let $state := p:consume(249, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 255) then                      (: 'where' :)
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:l1] = 258) then                      (: 'with' :)
      let $state := p:consume(258, $input, $state)          (: 'with' :)
      return $state
    else
      let $state := p:consume(262, $input, $state)          (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(218, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state := p:consume(97, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state := p:consume(119, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'empty-sequence' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'function' :)
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'if' :)
      let $state := p:consume(149, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'item' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state := p:consume(178, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state := p:consume(206, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state := p:consume(215, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state := p:consume(216, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'switch' :)
      let $state := p:consume(231, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'typeswitch' :)
      let $state := p:consume(242, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing QName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(218, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 86) then                       (: 'attribute' :)
      let $state := p:consume(86, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'comment' :)
      let $state := p:consume(97, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'document-node' :)
      let $state := p:consume(119, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'empty-sequence' :)
      let $state := p:consume(123, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'function' :)
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'if' :)
      let $state := p:consume(149, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'item' :)
      let $state := p:consume(161, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'namespace-node' :)
      let $state := p:consume(178, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'node' :)
      let $state := p:consume(184, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 206) then                      (: 'processing-instruction' :)
      let $state := p:consume(206, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 215) then                      (: 'schema-attribute' :)
      let $state := p:consume(215, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 216) then                      (: 'schema-element' :)
      let $state := p:consume(216, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 231) then                      (: 'switch' :)
      let $state := p:consume(231, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 232) then                      (: 'text' :)
      let $state := p:consume(232, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 242) then                      (: 'typeswitch' :)
      let $state := p:consume(242, $input, $state)          (: 'typeswitch' :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(220, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-QName($input, $state)
      return $state
  return $state
};

(:~
 : Try parsing EQName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(220, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' | 'at' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'count' | 'declare' |
                                                               'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:try-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(172, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'exponent-separator' | 'grouping-separator' |
                                                               'infinity' | 'minus-sign' | 'pattern-separator' |
                                                               'per-mille' | 'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(60, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'decimal-format' :)
      let $state := p:consume(105, $input, $state)          (: 'decimal-format' :)
      let $state := p:lookahead1W(222, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'modify' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'transform' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' | 'update' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EQName($input, $state)
      return $state
    else
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(105, $input, $state)          (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return $state
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 153) then                      (: 'inherit' :)
      let $state := p:consume(153, $input, $state)          (: 'inherit' :)
      return $state
    else
      let $state := p:consume(182, $input, $state)          (: 'no-inherit' :)
      return $state
  return $state
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 204) then                      (: 'preserve' :)
      let $state := p:consume(204, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(183, $input, $state)          (: 'no-preserve' :)
      return $state
  return $state
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(103, $input, $state)              (: 'copy-namespaces' :)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-InheritMode($input, $state)
  return $state
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'revalidation' :)
  let $state := p:consume(211, $input, $state)              (: 'revalidation' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 229) then                      (: 'strict' :)
      let $state := p:consume(229, $input, $state)          (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'lax' :)
      let $state := p:consume(164, $input, $state)          (: 'lax' :)
      return $state
    else
      let $state := p:consume(222, $input, $state)          (: 'skip' :)
      return $state
  return $state
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(192, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 144) then                      (: 'greatest' :)
      let $state := p:consume(144, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(166, $input, $state)          (: 'least' :)
      return $state
  return $state
};

(:~
 : Try parsing EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(192, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(122, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 144) then                      (: 'greatest' :)
      let $state := p:consume(144, $input, $state)          (: 'greatest' :)
      return $state
    else
      let $state := p:consume(166, $input, $state)          (: 'least' :)
      return $state
  return $state
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(194, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 193) then                      (: 'ordered' :)
      let $state := p:consume(193, $input, $state)          (: 'ordered' :)
      return $state
    else
      let $state := p:consume(244, $input, $state)          (: 'unordered' :)
      return $state
  return $state
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(98, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 230) then                      (: 'strip' :)
      let $state := p:consume(230, $input, $state)          (: 'strip' :)
      return $state
    else
      let $state := p:consume(204, $input, $state)          (: 'preserve' :)
      return $state
  return $state
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(87, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(96, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Try parsing DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(96, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URILiteral($input, $state)
  return $state
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(89, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 204) then                      (: 'preserve' :)
      let $state := p:consume(204, $input, $state)          (: 'preserve' :)
      return $state
    else
      let $state := p:consume(230, $input, $state)          (: 'strip' :)
      return $state
  return $state
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 107) then                          (: 'declare' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' | 'revalidation' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 55403) then                    (: 'declare' 'default' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:error]) then
              $state
            else
              p:try-DefaultCollationDecl($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -2, -2)
            else
              let $state := p:restore($backtrack, $state)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else
                  p:try-EmptyOrderDecl($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -6, -6)
                else
                  p:memoize($backtrack, $state, 1, $backtrack[$p:e0], -9, -9)
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 45675) then                    (: 'declare' 'boundary-space' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = -2) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 44651) then                    (: 'declare' 'base-uri' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 50283) then                    (: 'declare' 'construction' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 99435) then                    (: 'declare' 'ordering' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 108139) then                   (: 'declare' 'revalidation' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-RevalidationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 52843) then                    (: 'declare' 'copy-namespaces' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-DecimalFormatDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Try parsing DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(107, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(108, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 120) then                      (: 'element' :)
      let $state := p:consume(120, $input, $state)          (: 'element' :)
      return $state
    else
      let $state := p:consume(142, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:try-URILiteral($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(236, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 107) then                        (: 'declare' :)
        let $state := p:lookahead2W(185, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'contains' | 'context' |
                                                               'copy-namespaces' | 'decimal-format' | 'default' |
                                                               'div' | 'eq' | 'except' | 'ft-option' | 'function' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'option' |
                                                               'or' | 'ordering' | 'revalidation' | 'to' | 'transform' |
                                                               'treat' | 'union' | 'update' | 'updating' | 'variable' |
                                                               '|' | '||' :)
        return $state
      else if ($state[$p:l1] eq 150) then                   (: 'import' :)
        let $state := p:lookahead2W(183, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'schema' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'update' | '|' |
                                                               '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 44651                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 45675                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 50283                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 52843                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 53867                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 55403                            (: 'declare' 'default' :)
      and $state[$p:lk] != 70763                            (: 'declare' 'ft-option' :)
      and $state[$p:lk] != 89750                            (: 'import' 'module' :)
      and $state[$p:lk] != 90731                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 99435                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 108139                           (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 109718) then                     (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 107) then                    (: 'declare' :)
            let $state := p:lookahead2W(167, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'ft-option' | 'namespace' | 'ordering' |
                                                                'revalidation' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 55403) then              (: 'declare' 'default' :)
            let $state := p:memoized($state, 0)
            return
              if ($state[$p:lk] != 0) then
                $state
              else
                let $backtrack := $state
                let $state := p:strip-result($state)
                let $state :=
                  if ($state[$p:error]) then
                    $state
                  else
                    p:try-DefaultNamespaceDecl($input, $state)
                return
                  if (not($state[$p:error])) then
                    p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -1, -1)
                  else
                    p:memoize($backtrack, $state, 0, $backtrack[$p:e0], -2, -2)
          else
            $state
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = -1) then
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 90731) then              (: 'declare' 'namespace' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 150) then                (: 'import' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Import($input, $state)
            return $state
          else if ($state[$p:lk] = 70763) then              (: 'declare' 'ft-option' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-FTOptionDecl($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the lexer state.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(236, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 107) then                        (: 'declare' :)
        let $state := p:lookahead2W(184, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'context' | 'div' | 'eq' |
                                                               'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'option' | 'or' | 'to' | 'transform' | 'treat' |
                                                               'union' | 'update' | 'updating' | 'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 16491                            (: 'declare' '%' :)
      and $state[$p:lk] != 51819                            (: 'declare' 'context' :)
      and $state[$p:lk] != 72811                            (: 'declare' 'function' :)
      and $state[$p:lk] != 97387                            (: 'declare' 'option' :)
      and $state[$p:lk] != 126059                           (: 'declare' 'updating' :)
      and $state[$p:lk] != 128619) then                     (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 107) then                    (: 'declare' :)
            let $state := p:lookahead2W(161, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'updating' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 51819) then              (: 'declare' 'context' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 97387) then              (: 'declare' 'option' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-OptionDecl($input, $state)
            return $state
          else
            let $state :=
              if ($state[$p:error]) then
                $state
              else
                p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else
            p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return $state
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Try parsing URILiteral.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  return $state
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: NCName^Token :)
      let $state := p:consume(14, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
  return $state
};

(:~
 : Try parsing NCName.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:try-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: NCName^Token :)
      let $state := p:consume(14, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'and' :)
      let $state := p:consume(80, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'as' :)
      let $state := p:consume(83, $input, $state)           (: 'as' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'ascending' :)
      let $state := p:consume(84, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'case' :)
      let $state := p:consume(91, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'cast' :)
      let $state := p:consume(92, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'castable' :)
      let $state := p:consume(93, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'collation' :)
      let $state := p:consume(96, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'count' :)
      let $state := p:consume(104, $input, $state)          (: 'count' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'default' :)
      let $state := p:consume(108, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'descending' :)
      let $state := p:consume(112, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'div' :)
      let $state := p:consume(117, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'else' :)
      let $state := p:consume(121, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'empty' :)
      let $state := p:consume(122, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'end' :)
      let $state := p:consume(125, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'eq' :)
      let $state := p:consume(127, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'except' :)
      let $state := p:consume(130, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'for' :)
      let $state := p:consume(136, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'ge' :)
      let $state := p:consume(143, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'group' :)
      let $state := p:consume(145, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'gt' :)
      let $state := p:consume(147, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'idiv' :)
      let $state := p:consume(148, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'instance' :)
      let $state := p:consume(156, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'intersect' :)
      let $state := p:consume(157, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'is' :)
      let $state := p:consume(160, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'le' :)
      let $state := p:consume(165, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'let' :)
      let $state := p:consume(167, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'lt' :)
      let $state := p:consume(170, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'mod' :)
      let $state := p:consume(173, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'ne' :)
      let $state := p:consume(179, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'only' :)
      let $state := p:consume(189, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'or' :)
      let $state := p:consume(191, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'order' :)
      let $state := p:consume(192, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 210) then                      (: 'return' :)
      let $state := p:consume(210, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 213) then                      (: 'satisfies' :)
      let $state := p:consume(213, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 225) then                      (: 'stable' :)
      let $state := p:consume(225, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 226) then                      (: 'start' :)
      let $state := p:consume(226, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 236) then                      (: 'to' :)
      let $state := p:consume(236, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 238) then                      (: 'treat' :)
      let $state := p:consume(238, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 243) then                      (: 'union' :)
      let $state := p:consume(243, $input, $state)          (: 'union' :)
      return $state
    else
      let $state := p:consume(255, $input, $state)          (: 'where' :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(175, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(177, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(174, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'as' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-NCName($input, $state)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(60, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Prolog($input, $state)
  return $state
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(52, $input, $state)               (: ';' :)
  return $state
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consume(262, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 124) then                      (: 'encoding' :)
      let $state := p:consume(124, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else
      let $state := p:consume(252, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:lookahead1W(102, $input, $state)      (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 124) then                  (: 'encoding' :)
          let $state := p:consume(124, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] eq 262) then                          (: 'xquery' :)
      let $state := p:lookahead2W(182, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'encoding' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'to' | 'transform' | 'treat' | 'union' | 'update' |
                                                               'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 63750                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 129286) then                   (: 'xquery' 'version' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 175) then                          (: 'module' :)
      let $state := p:lookahead2W(181, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'contains' | 'div' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'namespace' | 'ne' | 'or' | 'to' |
                                                               'transform' | 'treat' | 'union' | 'update' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 90799) then                    (: 'module' 'namespace' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-LibraryModule($input, $state)
      return $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else
          p:parse-MainModule($input, $state)
      return $state
  return $state
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(235, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'as' |
                                                               'ascending' | 'at' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'invoke' | 'is' | 'item' | 'le' | 'let' | 'lt' | 'map' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' |
                                                               'transform' | 'treat' | 'try' | 'typeswitch' | 'union' |
                                                               'unordered' | 'update' | 'validate' | 'where' | 'with' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else
      p:parse-Module($input, $state)
  let $state := p:consume(25, $input, $state)               (: EOF :)
  return $state
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    string-join
    (
      (
        if ($error/@o) then
          ("syntax error, found ", $p:TOKEN[$error/@o + 1])
        else
          "lexical analysis failed",
        "&#10;",
        "while expecting ",
        if ($error/@x) then
          $p:TOKEN[$error/@x + 1]
        else
          let $expected := p:expected-token-set($error/@s)
          return
          (
            "["[exists($expected[2])],
            string-join($expected, ", "),
            "]"[exists($expected[2])]
          ),
        "&#10;",
        if ($error/@o or $error/@e = $begin) then
          ()
        else
          ("after successfully scanning ", string($error/@e - $begin), " characters beginning "),
        "at line ", string($line), ", column ", string($column), ":&#10;",
        "...", substring($input, $begin, 64), "..."
      ),
      ""
    )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : lexer state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] eq $code) then
  (
    subsequence($state, $p:l1, 6),
    0, 0, 0,
    subsequence($state, 10)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] lt 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 18) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, false(), <memo/>))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:matchW($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] ne 0) then
      subsequence($state, $p:l2, 3)
    else
      p:matchW($input, $state[$p:e1], $set)
  return
  (
    $match[1] * 512 + $state[$p:l1],
    subsequence($state, $p:b0, 5),
    $match,
    subsequence($state, 10)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state lexer state, error indicator, and result stack.
 : @return the updated state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] ne 0) then
    $state
  else
    let $match :=
      (
        p:match($input, $state[$p:e0], $set),
        0, 0, 0
      )
    return
    (
      $match[1],
      subsequence($state, $p:b0, 2),
      $match,
      subsequence($state, 10)
    )
};

(:~
 : Strip result from lexer state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore lexer state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the lexer state before backtracking started.
 : @param $state the lexer state after an alternative failed.
 : @return the updated state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo
  {
    let $errors := ($state[$p:memo], $state[$p:error])[.]
    return $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
    $state[$p:memo]/value
  }
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $dpi for input position $e0. Reconstruct state from the parameters.
 :
 : @param $state the lexer state to be restored.
 : @param $update the lexer state containing updates.
 : @param $dpi the decision point id.
 : @param $e0 the input position.
 : @param $v the id of the successful alternative.
 : @param $lk the new lookahead code.
 : @return the reconstructed state.
 :)
declare function p:memoize($state as item()+,
                           $update as item()+,
                           $dpi as xs:integer,
                           $e0 as xs:integer,
                           $v as xs:integer,
                           $lk as xs:integer) as item()+
{
  $lk,
  subsequence($state, $p:b0, $p:memo - $p:b0),
  let $memo := $update[$p:memo]
  let $errors := ($memo, $update[$p:error])[.]
  return
    element memo
    {
      $errors[@e = max($errors/xs:integer(@e))][last()]/@*,
      $memo/value,
      element value {attribute key {$e0 * 32 + $dpi}, $v}
    },
  subsequence($state, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $dpi
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state lexer state, error indicator, and result stack.
 : @param $dpi the decision point id.
 : @return the updated state.
 :)
declare function p:memoized($state as item()+, $dpi as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 32 + $dpi])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := (0, 1, 1, 0, 0, 0, 0, 0, 0, false(), <memo/>)
  let $state := p:parse-XQuery($s, $state)
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
