xquery version "1.0" encoding "UTF-8";

(: This file was generated on Wed Dec 11, 2013 15:44 (UTC) by REx v5.28 which is Copyright (c) 1979-2013 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: xquery-update-30.ebnf -xquery :)

(:~
 : The parser that was generated for the xquery-update-30 grammar.
 :)
module namespace p="xquery-update-30";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 38, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 38,
  38
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 355, 371,
  387, 423, 423, 423, 415, 339, 331, 339, 331, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 440, 440, 440, 440, 440, 440, 440, 324, 339, 339, 339, 339, 339, 339, 339, 339, 401, 423, 423, 424, 422,
  423, 423, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 338, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 38, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48,
  30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  38, 38, 38, 30, 30, 38, 38, 38, 38, 38, 38, 38, 68, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 38, 30, 38, 30, 30, 38
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 86019, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 19755, 17920, 17946, 17924, 17946, 17946, 17946, 17967, 17940, 17946, 17947, 17963, 17983, 18013, 21630, 25085,
  21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650, 21630,
  18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204,
  18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397,
  18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114,
  18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818,
  18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147,
  19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 17992, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19352, 19400, 19386, 21630, 19361, 37946, 21630,
  25085, 21630, 19906, 28312, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 19416, 35788, 18037, 21630, 34650,
  21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630,
  18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374,
  23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235,
  25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802,
  18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163,
  19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 19370, 19432, 21630, 25534, 21629, 21630, 33892, 33894, 19451, 21625, 21630, 36390, 22538, 20237,
  21630, 25085, 21630, 19906, 19473, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 19492, 35788, 18037, 21630,
  34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630,
  21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388,
  18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615,
  30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781,
  18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133,
  19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 19508, 36171, 21630, 24663, 19545, 21630, 36165, 37223, 19564, 19603, 19589, 36169, 19573,
  37946, 21630, 20480, 21630, 19906, 19627, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 19647, 35788, 18037,
  21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564,
  21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19663, 18311, 18333, 18353, 19208, 36303,
  23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590,
  18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813,
  18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098,
  19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 17992, 32352, 21630, 24663, 19702, 21630, 22583, 22144, 19724, 21630, 32344, 26337,
  19746, 37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788,
  18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216,
  30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208,
  36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554,
  18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749,
  18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447,
  19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630, 21630, 24663, 25078, 21630, 21630, 24894, 19771, 19793, 21630,
  22487, 22498, 37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985,
  35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157,
  19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353,
  19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009,
  18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630,
  18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453,
  18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308,
  19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630, 21630, 24663, 21630, 21630, 21630, 20751, 19817, 21630,
  21630, 21630, 22784, 20066, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358,
  37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 19839, 18117, 18137,
  18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333,
  18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531,
  19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840,
  28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437,
  18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865,
  19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 22547, 19881, 21630, 19050, 21987, 21630, 28560, 28562, 19900,
  21983, 21630, 36916, 19922, 19678, 21630, 25085, 21630, 19906, 24127, 21630, 21630, 20915, 37873, 21630, 22721, 18317,
  18358, 19947, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117,
  18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311,
  18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508,
  18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717,
  25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082,
  18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283,
  19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 19963, 19970, 19972, 19988, 19970, 20035, 19996,
  20012, 20027, 20051, 20090, 20104, 37946, 21630, 34843, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721,
  18317, 18358, 37985, 35788, 20134, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173,
  18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212,
  18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485,
  18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701,
  18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066,
  19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800,
  19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 20182, 21630, 24663, 20150, 21630, 30118,
  37223, 20176, 20198, 20206, 26967, 20222, 37946, 21630, 22117, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630,
  22721, 18317, 18358, 37985, 35788, 20261, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153,
  18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357,
  19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016,
  18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765,
  18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032,
  19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267,
  37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 24885, 21630, 24663, 21630, 21630,
  21630, 37223, 20277, 20292, 20299, 20315, 20327, 37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873,
  21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133,
  18153, 20343, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337,
  18357, 20374, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538,
  19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388,
  18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983,
  19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854,
  19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630, 21630, 24663, 21630,
  21630, 21630, 37223, 20390, 20405, 20412, 26235, 20419, 37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915,
  37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 35231, 21630, 18860, 18053, 18069, 18423, 18085, 18113,
  18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725,
  18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515,
  18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372,
  25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999,
  18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358,
  19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 31177, 21630, 24663,
  36714, 21630, 31173, 37223, 20435, 20450, 20457, 21630, 32904, 37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630,
  20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085,
  18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266,
  22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492,
  18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698,
  25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977,
  18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712,
  18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 20473, 21630, 21630,
  24663, 21630, 21630, 21630, 37223, 20496, 20526, 20533, 28762, 20510, 37946, 21630, 25085, 21630, 19906, 21630, 21630,
  21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 37629, 35231, 26118, 21630, 21630, 20656, 24700,
  34965, 27653, 36749, 36749, 36042, 30923, 30923, 30923, 25508, 21630, 21630, 21630, 26958, 24876, 20549, 20652, 24700,
  30480, 36749, 36749, 36749, 29593, 30923, 30923, 30923, 30924, 32924, 20567, 21630, 21630, 21630, 20586, 20656, 24700,
  36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 20629, 20657, 29744, 33854, 36749,
  25556, 32401, 36069, 30923, 28723, 21630, 35098, 21630, 23981, 36749, 24915, 35404, 30923, 30268, 30558, 36952, 20647,
  29748, 24851, 30923, 25597, 21630, 20673, 28108, 26513, 20697, 20750, 28077, 20716, 31975, 33654, 32731, 20745, 20767,
  28743, 28713, 33844, 36234, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630,
  21630, 24663, 21630, 21630, 21630, 31486, 19451, 21630, 21630, 32358, 20794, 37946, 21630, 25085, 21630, 26041, 21630,
  21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 20835, 21630, 23824, 21630, 34650, 21630, 21630, 21630, 20656,
  24700, 34965, 27653, 36749, 36749, 36042, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 26958, 21630, 21630, 20652,
  24700, 30480, 36749, 36749, 36749, 29593, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656,
  24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749,
  36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630,
  30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724,
  33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992,
  20857, 21630, 24663, 21630, 21630, 21630, 37223, 20877, 20892, 20944, 20931, 20952, 37946, 21630, 25085, 21630, 19906,
  20551, 21630, 20968, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053,
  18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210,
  18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241,
  18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682,
  25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834,
  18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195,
  19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  17992, 20987, 21630, 24663, 21630, 21630, 21630, 32165, 19451, 21630, 21630, 18961, 21004, 26264, 21630, 25085, 21630,
  23962, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 21052, 21630, 23824, 21630, 24170, 21074, 21630,
  21630, 20656, 24700, 34965, 27653, 36749, 36749, 36042, 30923, 30923, 30923, 34473, 21630, 21630, 21630, 21782, 21630,
  21630, 20652, 24700, 30480, 36749, 36749, 36749, 29593, 30923, 30923, 30923, 35663, 21091, 21630, 21630, 21630, 21114,
  21630, 20656, 24700, 36748, 36749, 36749, 34221, 21134, 30923, 30923, 30923, 36705, 21630, 21630, 21630, 21630, 20657,
  29744, 36749, 36749, 25413, 21158, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924,
  21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815,
  33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 17992, 37751, 21630, 28034, 20841, 21630, 21631, 37223, 21204, 21631, 21232, 21630, 23112, 21256, 21630, 36826,
  21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 21364, 21312, 21499, 21662, 35788, 21290, 21630, 34650, 21630,
  18860, 18053, 18069, 18423, 18085, 21306, 21328, 21384, 21841, 21409, 21904, 21439, 22110, 30564, 21630, 21630, 18204,
  18229, 33210, 18256, 18282, 18295, 21368, 21455, 21471, 21932, 21496, 21515, 22069, 22102, 36303, 23388, 18374, 23397,
  18390, 23241, 18409, 18469, 21542, 21555, 21584, 21610, 21647, 21678, 21705, 22077, 21720, 18590, 18615, 30235, 25114,
  18652, 21756, 22175, 21393, 21772, 25784, 22266, 21423, 21798, 18717, 25840, 28630, 21828, 21857, 21873, 21343, 21889,
  21968, 18834, 18884, 20907, 22004, 21594, 22256, 22020, 19066, 19082, 18666, 22054, 22093, 22133, 22160, 21568, 22191,
  22227, 22243, 21689, 21477, 21355, 21480, 21919, 22326, 22282, 22313, 21526, 22297, 22342, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 17992, 19708, 21630, 24663, 25875, 21630, 21630, 37223, 22377, 22998, 23006, 21630, 33924, 37946, 21630,
  25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650,
  21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630,
  22438, 22476, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 22523, 22563, 23388, 18374,
  23397, 22599, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 22619, 18590, 18615, 30235,
  25114, 18652, 18682, 25385, 18762, 22648, 22684, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 22700,
  18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163,
  19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 17992, 21630, 21630, 24663, 21630, 21630, 21630, 21630, 26573, 22741, 22748, 19730, 22764, 37946,
  21630, 25085, 21630, 19906, 21630, 21630, 22800, 20915, 37873, 21630, 22721, 18317, 18358, 22820, 35788, 18037, 21630,
  34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630,
  21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388,
  18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615,
  30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781,
  18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133,
  19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 19931, 31682, 21630, 24663, 21630, 21630, 21630, 37223, 22836, 22861, 22868, 21630, 22845,
  18849, 21630, 25085, 21630, 19906, 21630, 21630, 22884, 20915, 37873, 21630, 22721, 18317, 18358, 22905, 35788, 18037,
  21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564,
  21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303,
  23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590,
  18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813,
  18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098,
  19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 22507, 22921, 21630, 24663, 21630, 21630, 21630, 37223, 22941, 22966, 22973, 22921,
  22950, 22989, 21630, 25085, 21630, 19906, 21630, 21630, 23022, 20915, 37873, 21630, 22721, 18317, 18358, 20358, 35788,
  18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216,
  30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208,
  36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554,
  18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749,
  18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447,
  19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 23055, 21630, 21630, 24663, 26361, 21630, 21630, 37223, 19451, 19777, 26367,
  21630, 23046, 37946, 21630, 25085, 21630, 19906, 20631, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 23071,
  35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157,
  19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353,
  19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009,
  18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630,
  18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453,
  18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308,
  19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 21630,
  21630, 19823, 23087, 37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358,
  37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137,
  18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333,
  18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531,
  19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840,
  28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437,
  18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865,
  19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451,
  23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330,
  30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923,
  30923, 30923, 28723, 21630, 21630, 21630, 22925, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192, 30923,
  30923, 30923, 30924, 23151, 21630, 21630, 21630, 21114, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923,
  30923, 30923, 36705, 21630, 21630, 34139, 21630, 20657, 29744, 36749, 36749, 37476, 23174, 30923, 30923, 28723, 21630,
  21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 23486, 30137, 29748, 24851, 30923, 28721, 21630, 30136,
  29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247,
  27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 21630, 21630, 37223,
  19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652,
  33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522,
  30923, 30923, 30923, 28723, 21630, 21630, 21630, 22925, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192,
  30923, 30923, 30923, 30924, 23151, 21630, 21630, 21630, 21114, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605,
  30923, 30923, 30923, 36705, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 37476, 23174, 30923, 30923, 28723,
  21630, 21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630,
  30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708,
  28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 21630, 21630,
  37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630,
  27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749,
  37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 22925, 25516, 21630, 20652, 24700, 30480, 36749, 36749, 36749,
  30192, 30923, 30923, 30923, 30924, 23151, 21630, 21630, 21630, 21114, 21630, 20656, 24700, 36748, 36749, 36749, 36750,
  20605, 30923, 30923, 30923, 36705, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 37476, 23174, 30923, 30923,
  28723, 21630, 21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721,
  21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718,
  28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 21630,
  21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964,
  21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749,
  36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 22925, 21630, 21630, 20652, 24700, 30480, 36749, 36749,
  36749, 30192, 30923, 30923, 30923, 30924, 23151, 21630, 21630, 21630, 23196, 21630, 20656, 24700, 36748, 36749, 36749,
  36750, 20605, 30923, 30923, 30923, 36705, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 37476, 23174, 30923,
  30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923,
  28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648,
  28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630,
  21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 28513, 21630, 21630, 21630, 20655,
  34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 28514, 21630, 21630, 21630, 20656, 24700, 34965, 30489,
  36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 22925, 21630, 21630, 20652, 24700, 30480, 36749,
  36749, 36749, 30192, 30923, 30923, 30923, 30924, 23151, 21630, 21630, 21630, 21114, 21630, 20656, 24700, 36748, 36749,
  36749, 36750, 20605, 30923, 30923, 30923, 36705, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 37476, 23174,
  30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 21630, 30137, 29748, 24851,
  30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713,
  27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663,
  21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630,
  20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965,
  30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652, 24700, 30480,
  36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748,
  36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556,
  32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748,
  24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743,
  28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630,
  24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630,
  21630, 20655, 34964, 21630, 27652, 33330, 30923, 23818, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700,
  34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652, 24700,
  30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656, 24700,
  36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749,
  25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137,
  29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412,
  28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630,
  21630, 24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 35828, 26631, 21630, 25085, 21630, 21630, 21630,
  21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656,
  24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652,
  24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656,
  24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749,
  36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630,
  30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724,
  33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956,
  21630, 21630, 24663, 21630, 21630, 21630, 37223, 23230, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630,
  21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 19631, 21630, 21630,
  20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630,
  20652, 24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630,
  20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744,
  36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630,
  21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412,
  28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  18956, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 23257, 23269, 26631, 21630, 25085, 21630,
  21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630,
  21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630,
  21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630,
  21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657,
  29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924,
  21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815,
  33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 18956, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085,
  21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630,
  21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630,
  21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630,
  21630, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630,
  20657, 29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 20589, 21630, 23981, 36749, 36749, 35404, 30923,
  30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924,
  30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 23285, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630,
  25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630,
  21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630,
  21630, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630,
  21630, 21630, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630,
  21630, 20657, 29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404,
  30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409,
  30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 17992, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 23306, 23345, 23331, 21630, 23315, 37946,
  21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630,
  34650, 26755, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630,
  21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388,
  18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615,
  30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781,
  18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 23361, 18437, 18453, 18447, 19098, 19133,
  19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 17992, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 21630, 21630, 21630, 22784,
  37946, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037,
  21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564,
  21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303,
  23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590,
  18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813,
  18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098,
  19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 23377, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 23413, 25454, 25462, 21630,
  34578, 23443, 21630, 25085, 21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 23467, 35788,
  18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216,
  30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208,
  36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554,
  18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749,
  18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447,
  19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 18956, 23842, 21630, 24663, 17997, 23483, 23843, 23502, 23518, 23533, 23545,
  23561, 23573, 27838, 23589, 25085, 20118, 29724, 23635, 23659, 19336, 34955, 23675, 36850, 23730, 23746, 30061, 26620,
  21630, 23824, 22354, 21630, 19611, 33635, 21630, 20656, 24700, 23762, 23784, 36749, 36749, 23803, 30923, 30923, 32701,
  28723, 19801, 22415, 23840, 19686, 21630, 21630, 23427, 24700, 23859, 35281, 36749, 27299, 23884, 25575, 30923, 32874,
  37298, 23900, 21630, 21630, 21240, 23916, 24302, 23936, 23978, 23997, 30492, 37344, 36750, 24044, 24093, 25661, 31516,
  34548, 24114, 21630, 24150, 21630, 20657, 29744, 36749, 30172, 34082, 23174, 30923, 35949, 32331, 24186, 21630, 21630,
  23981, 36749, 24220, 21180, 30098, 30924, 31293, 21630, 30137, 27947, 36130, 27102, 31403, 21630, 30136, 29748, 33411,
  30923, 20750, 28077, 33409, 30924, 30815, 33412, 28904, 33412, 36777, 28713, 36122, 28718, 24241, 28247, 27172, 28274,
  27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21988, 24280, 24663, 21630, 24298, 21630, 37223, 24318, 24354,
  24362, 24378, 24390, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923,
  26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923,
  30923, 28723, 21630, 21630, 36021, 22925, 33949, 33944, 20652, 24700, 24406, 36749, 36749, 25262, 30192, 30923, 30923,
  30923, 24431, 23151, 21630, 21630, 21630, 21114, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923,
  30923, 36705, 21630, 21630, 34165, 24793, 24453, 24460, 36749, 36749, 37476, 24476, 30923, 30923, 28723, 21630, 21630,
  21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748,
  33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 24504, 27648, 28718, 28708, 28247, 27172,
  28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 24520, 24663, 21630, 21630, 21630, 24544, 24560,
  24575, 24591, 24606, 24618, 26631, 21630, 37605, 21630, 19244, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 24634,
  29980, 26035, 19520, 23824, 24661, 24679, 32244, 23206, 23956, 33241, 24699, 23946, 24716, 24753, 36749, 37522, 24773,
  30923, 30923, 28723, 24789, 24338, 21630, 22925, 21630, 24809, 20652, 24832, 30480, 32301, 26505, 27577, 30192, 29402,
  35970, 29822, 30924, 23151, 21630, 21630, 19435, 21114, 21630, 20656, 24700, 36748, 36749, 36749, 35393, 20605, 30923,
  30923, 31521, 36705, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 34274, 37476, 23174, 30923, 34345, 28723, 21630,
  21630, 20971, 33016, 36749, 24850, 21180, 32226, 30924, 24867, 21630, 19457, 24910, 24931, 37206, 28721, 21630, 30136,
  29748, 28844, 37540, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 35637, 24955, 27648, 28718, 28708, 28247,
  27172, 24264, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 27531, 24663, 21630, 22206, 36283, 24982,
  24998, 25013, 25021, 25037, 25049, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 24816, 36935, 34964, 25065, 31582,
  33330, 35944, 26035, 26216, 25101, 30836, 34449, 21630, 32186, 25167, 25203, 27035, 29638, 25240, 25261, 25278, 37522,
  25303, 33691, 25338, 28723, 21630, 18574, 22804, 22925, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192,
  30923, 30923, 30923, 30924, 25359, 21630, 28362, 24164, 21114, 21630, 20656, 24700, 25404, 36749, 36749, 25287, 25429,
  30923, 30923, 30923, 25445, 21630, 21630, 21630, 26329, 25478, 33248, 36749, 33864, 37476, 25499, 30923, 37069, 28723,
  27354, 25532, 23451, 25906, 30622, 25550, 21180, 25572, 25591, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 24528,
  30136, 29748, 35006, 32659, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 25613, 28743, 25648, 27648, 28718, 28708,
  28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 37916, 24663, 29999, 26996, 24282,
  25683, 25699, 25715, 25727, 25743, 25755, 26631, 18629, 25771, 25800, 25827, 29510, 25856, 18868, 25891, 25943, 25959,
  26004, 26020, 26057, 26035, 21274, 24204, 22391, 27251, 24077, 21630, 21630, 26092, 24700, 26112, 23868, 26134, 36632,
  26150, 36205, 27462, 27876, 26209, 26232, 26251, 26288, 26315, 21630, 26353, 26387, 26439, 35343, 26476, 26492, 26529,
  26589, 26605, 26655, 26671, 26697, 23151, 26749, 21630, 26771, 26791, 26807, 26180, 24834, 26830, 26866, 27308, 29659,
  20605, 26885, 30923, 26930, 26949, 24332, 26983, 29872, 18929, 27029, 27051, 36624, 27081, 27126, 27161, 27188, 27209,
  27244, 20570, 27683, 35464, 37188, 27267, 27288, 27324, 25343, 31250, 21630, 27340, 34173, 27376, 27401, 27443, 34680,
  21630, 22451, 31906, 27478, 32641, 33805, 28077, 29535, 33602, 31841, 27508, 29207, 35854, 27547, 24939, 27563, 27601,
  28708, 28855, 27625, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 24070, 29706,
  21630, 21036, 27669, 27705, 27713, 27729, 27741, 26631, 21630, 27757, 21630, 21630, 21630, 19529, 21630, 34605, 33546,
  19527, 27798, 33568, 33597, 26035, 19042, 23824, 19048, 21630, 21630, 27827, 21630, 33055, 24700, 34965, 27854, 36749,
  36749, 37522, 37409, 30923, 30923, 28723, 21630, 21630, 21630, 22925, 21630, 21630, 20652, 24700, 30480, 36749, 36749,
  33674, 30192, 30923, 30923, 30923, 27899, 23151, 21630, 21630, 21630, 21114, 18911, 20656, 25218, 36748, 36749, 27923,
  36750, 20605, 30923, 28221, 30923, 36705, 21630, 21630, 21630, 33448, 20657, 27943, 36749, 33308, 37476, 23174, 30923,
  25322, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 21180, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923,
  24437, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648,
  28718, 28708, 24966, 27172, 32743, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630,
  21805, 21630, 21812, 27963, 27978, 27986, 28002, 28014, 26631, 21630, 25085, 21630, 21630, 28030, 21630, 21630, 20655,
  34964, 21630, 27652, 33330, 30923, 27416, 21630, 23824, 21630, 21630, 32001, 21630, 21630, 20656, 24700, 34965, 30489,
  36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652, 24700, 30480, 36749,
  36749, 36749, 35150, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748, 36749,
  36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556, 32401,
  30923, 30923, 28723, 21630, 28050, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 23643, 37102, 28070, 29748, 24851,
  30923, 28721, 21630, 28093, 35713, 28137, 34909, 20750, 28166, 28202, 28237, 30815, 33412, 28724, 33412, 28743, 28713,
  27648, 28718, 28708, 28247, 29466, 28263, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663,
  21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 37654, 21630, 21630, 30796, 21630, 28311,
  20655, 33106, 21630, 28328, 33163, 32138, 26035, 21630, 20160, 33884, 33938, 21630, 21630, 21630, 20656, 24700, 34965,
  30489, 36749, 24757, 37522, 30923, 30923, 34926, 28723, 21630, 21630, 21630, 21630, 21630, 22668, 20652, 24700, 23705,
  36749, 36749, 36749, 35766, 30923, 30923, 30923, 30778, 37324, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748,
  36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 18567, 21630, 21630, 20657, 29744, 36749, 36749, 28352,
  32401, 30923, 29677, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748,
  24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 27585, 31197, 30815, 33412, 28724, 33412, 28743,
  28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 29421,
  24663, 21630, 28386, 37125, 28421, 28437, 28452, 28464, 28480, 28492, 26631, 21630, 37378, 28508, 21630, 21630, 28530,
  28552, 34030, 32790, 21630, 28578, 26412, 28605, 26035, 21630, 23824, 21630, 28621, 21630, 21630, 36990, 28646, 30522,
  28666, 26733, 30630, 36749, 28688, 37266, 34423, 20700, 28740, 32539, 28759, 28778, 23101, 28536, 18599, 20652, 25483,
  28807, 36749, 36749, 28832, 27811, 30923, 30923, 29077, 32407, 21630, 21630, 18893, 31562, 21630, 21630, 20656, 24700,
  28871, 36749, 36749, 36750, 28892, 30923, 30923, 30923, 28724, 26639, 28920, 28936, 28952, 20657, 29744, 26869, 36749,
  25556, 32401, 37272, 30923, 31435, 21630, 21630, 25127, 28972, 29024, 34069, 29063, 30260, 29093, 21630, 21630, 29109,
  29134, 36517, 32633, 29164, 21733, 21943, 29748, 33411, 30923, 27523, 28077, 33409, 30924, 30815, 33412, 28724, 29183,
  29223, 28713, 27648, 28718, 28295, 29248, 27172, 28274, 29261, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630,
  21630, 24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 18021, 21630,
  21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656,
  24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652,
  24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656,
  24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749,
  36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630,
  30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724,
  33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956,
  21630, 21630, 24663, 21630, 28405, 21630, 29288, 29304, 29319, 29327, 29343, 29355, 26631, 36275, 25085, 21630, 29384,
  28030, 30289, 21630, 33005, 34964, 29371, 35646, 33330, 29400, 24059, 29418, 23824, 34293, 34094, 30740, 20861, 21630,
  30470, 32021, 34965, 23714, 34873, 35741, 28121, 35864, 29437, 29455, 29482, 29505, 21630, 34783, 21630, 21630, 21630,
  37578, 24700, 30480, 29526, 29002, 36426, 35150, 35900, 36665, 30080, 30924, 21630, 26272, 29551, 18902, 21028, 21630,
  20656, 30528, 36748, 36749, 29568, 29589, 20605, 30923, 23180, 25632, 28724, 29609, 21630, 21630, 21630, 29628, 29744,
  29654, 36749, 25556, 32401, 29675, 30923, 36239, 21630, 36593, 29693, 29740, 29764, 36749, 31074, 30923, 30924, 37772,
  21630, 29782, 29748, 24851, 30923, 28721, 33497, 30136, 29748, 35179, 36445, 20750, 28077, 33409, 30924, 30815, 33412,
  28724, 33412, 28743, 28713, 31621, 36538, 29803, 28247, 35190, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  18956, 21630, 21630, 29838, 21630, 22889, 21630, 37223, 29888, 29904, 29912, 29928, 29940, 26631, 29959, 25085, 21630,
  32918, 21630, 23290, 21630, 33095, 34964, 29956, 29232, 33330, 29975, 26035, 30154, 23824, 21630, 29996, 30015, 21630,
  21630, 20656, 24700, 34965, 28816, 36749, 30033, 37522, 34919, 30923, 30049, 27907, 33113, 21630, 21630, 21630, 21630,
  21630, 20652, 24700, 30480, 28987, 30879, 36749, 30192, 24028, 30077, 30096, 30924, 21630, 30114, 30134, 32078, 34101,
  30153, 20656, 24700, 36748, 30170, 29573, 30188, 30208, 21188, 30923, 30251, 28724, 21630, 21630, 21630, 21630, 20657,
  29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924,
  30284, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 22632,
  31321, 31552, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 18956, 21630, 21630, 30305, 21630, 23768, 30321, 30593, 30346, 30361, 30369, 30385, 30397, 26631, 31125, 25085,
  30413, 30438, 21630, 30455, 20808, 30508, 30544, 30580, 30609, 30646, 30676, 26035, 30714, 26814, 21630, 21630, 30735,
  30756, 21630, 20656, 24700, 29865, 30489, 24730, 24737, 37522, 30923, 30775, 35873, 28723, 30794, 18213, 21630, 21630,
  30812, 21630, 29787, 24700, 30480, 25919, 36749, 36749, 30192, 36572, 30923, 30923, 30924, 21630, 21630, 18393, 21630,
  23920, 30831, 30852, 26096, 30875, 36749, 26850, 37501, 30895, 30923, 30923, 30922, 30940, 30961, 19548, 21630, 30977,
  34500, 30993, 31013, 31038, 25556, 32854, 31090, 37076, 28723, 31106, 31141, 31169, 23981, 34388, 36749, 35404, 31193,
  30924, 33135, 21630, 18240, 35310, 31213, 31237, 31274, 21630, 23214, 31309, 31347, 31363, 30945, 28077, 31390, 31427,
  30815, 31451, 31475, 31502, 28285, 31537, 31578, 28718, 28708, 24645, 31598, 28274, 31610, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 18956, 21630, 21630, 31637, 21630, 21630, 31678, 31698, 31714, 31729, 31737, 31753, 31765, 26299, 31781,
  25085, 34820, 21630, 35031, 31827, 30719, 31797, 31813, 31878, 31930, 31946, 31962, 26035, 21630, 23824, 30439, 21630,
  22030, 32000, 21630, 20656, 32017, 34965, 30489, 35272, 31914, 27065, 30923, 27223, 24021, 32037, 21118, 22603, 21630,
  32056, 28032, 32072, 25139, 25224, 32094, 32119, 25927, 36749, 33784, 25316, 36896, 32137, 36003, 32154, 32501, 32181,
  21630, 21630, 21630, 20656, 24700, 36748, 28177, 36749, 36750, 20605, 29439, 30923, 30923, 28724, 21630, 32202, 25181,
  21630, 20657, 29744, 36749, 36749, 34879, 32220, 30923, 30923, 28723, 18938, 21630, 21630, 28650, 24225, 36749, 27093,
  37417, 30924, 32242, 21630, 30759, 33024, 24851, 32260, 28721, 21630, 30136, 29748, 33411, 30923, 33442, 20681, 25245,
  30924, 32280, 32317, 28724, 32374, 28743, 28713, 27648, 28718, 28708, 30906, 31374, 28274, 33833, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 30017, 22663, 32464, 32390, 23128, 23158, 32423, 32435, 26631,
  21630, 32451, 21630, 33710, 21630, 21630, 21630, 20655, 31662, 21630, 27652, 33330, 30923, 26035, 21018, 23824, 21630,
  32480, 32496, 21630, 21630, 25974, 24700, 35519, 32103, 27272, 35317, 26544, 31331, 35412, 35882, 32517, 21630, 21630,
  27138, 32555, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 32581, 21630,
  21630, 31286, 35492, 19476, 29118, 32605, 36748, 31052, 36749, 36750, 32624, 35209, 32657, 30923, 28724, 36158, 21630,
  21630, 21630, 20657, 29744, 36749, 32294, 29008, 32675, 30923, 32697, 28723, 21630, 21630, 21630, 23981, 36749, 36749,
  35404, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077,
  33409, 32827, 32717, 33412, 29167, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190,
  26631, 21630, 25085, 21630, 21630, 32759, 21630, 32809, 32779, 34964, 32806, 34996, 35072, 32825, 32843, 21630, 23824,
  21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630,
  21630, 21630, 21630, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749, 31862, 30923, 30923, 30923, 30924, 21630,
  21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630,
  21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749,
  36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 30997, 33411, 32870, 20750,
  28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 30330, 27777, 21630, 27770, 37223, 32890, 32940, 32948, 32964,
  32976, 26631, 21630, 32992, 18097, 19251, 27360, 33040, 32204, 22460, 33082, 33129, 33151, 33179, 35931, 26035, 21630,
  23824, 33206, 33226, 25868, 33264, 21630, 20656, 33286, 34965, 33305, 33324, 31022, 37522, 30923, 33346, 36199, 28723,
  21630, 21630, 27689, 21630, 29716, 28672, 20652, 24700, 33364, 33389, 33406, 33390, 29148, 27457, 36658, 30923, 33428,
  21630, 26371, 31153, 33464, 21630, 33491, 33513, 33537, 33562, 28876, 28589, 23787, 33584, 30923, 33618, 26070, 28150,
  21630, 18920, 33634, 33651, 20657, 29744, 33670, 36749, 25556, 32401, 33690, 30923, 30226, 21630, 33707, 21630, 23981,
  36749, 36749, 33726, 30923, 27193, 21630, 33751, 30137, 26454, 32121, 30923, 28721, 19109, 30136, 29748, 33411, 30923,
  20750, 28077, 33409, 30924, 33769, 35817, 33800, 33412, 27609, 31221, 36741, 28718, 28708, 20778, 33821, 24253, 27637,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 23030, 21630, 23027, 23604, 23619, 33910, 33965, 33973,
  33989, 34001, 27427, 21630, 25085, 21630, 21075, 21630, 19117, 18636, 36474, 26914, 34017, 34056, 26460, 36567, 26559,
  34117, 23824, 34134, 21630, 21630, 37954, 34155, 31893, 37180, 34040, 34189, 34312, 34220, 37522, 36694, 27883, 30923,
  28723, 22577, 33753, 34237, 21630, 21630, 21630, 20652, 24700, 26724, 36749, 34269, 36749, 30192, 30923, 21142, 30923,
  30924, 21630, 21740, 21630, 34290, 32565, 29489, 20656, 30859, 34309, 36749, 34204, 31063, 34328, 30923, 24098, 35580,
  26895, 21630, 21630, 21630, 21630, 34361, 29744, 36749, 34377, 25556, 32401, 30923, 34413, 28723, 35684, 21630, 34446,
  23981, 27385, 36417, 27866, 29816, 34465, 21630, 33270, 30137, 29748, 24851, 30923, 28721, 21630, 34489, 34516, 34537,
  32681, 34564, 28077, 33409, 30924, 30815, 34628, 34644, 33412, 32040, 24011, 29272, 31459, 34666, 28247, 27172, 28274,
  27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 37880, 21630, 21630, 20819, 30422, 34696, 34711,
  34723, 34739, 34751, 26631, 22211, 25085, 34782, 34767, 34799, 29552, 18725, 21952, 34836, 18733, 34859, 34895, 37254,
  26035, 34942, 34981, 21630, 21630, 35022, 35047, 35088, 35122, 25151, 25988, 35143, 35362, 35166, 34397, 35206, 34430,
  35891, 20729, 22403, 21630, 35225, 21630, 21630, 35247, 35297, 35333, 26400, 35359, 35378, 36749, 35428, 35996, 27492,
  35444, 30690, 21630, 35463, 34592, 21630, 35480, 25187, 35508, 35127, 35542, 29037, 36749, 35558, 35596, 35622, 35662,
  25667, 31984, 21630, 21630, 35679, 19884, 35700, 34612, 35729, 35757, 25556, 33475, 27110, 28215, 37306, 26775, 21630,
  35782, 35804, 35844, 36749, 35916, 35965, 35447, 36794, 21630, 30137, 26193, 34521, 35986, 24488, 36019, 28054, 36037,
  36058, 33735, 36266, 36092, 29047, 36108, 30815, 33412, 28724, 33412, 28743, 28713, 28703, 36146, 36187, 36221, 27172,
  28274, 36255, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 21630, 36299, 22038, 36319,
  36334, 36342, 36358, 36370, 26631, 21630, 21098, 21630, 36386, 21630, 21630, 21630, 20655, 34964, 21630, 36406, 33330,
  36442, 26165, 21630, 23824, 21630, 21630, 36461, 21630, 21630, 31652, 24700, 34965, 33373, 36749, 36749, 28336, 34338,
  30923, 30923, 35606, 34118, 22778, 20074, 21630, 36490, 21630, 26905, 33066, 30480, 27927, 26841, 36506, 30192, 30923,
  36554, 30660, 30924, 21630, 36588, 21630, 21630, 21630, 21630, 29853, 24700, 36609, 36749, 36749, 36750, 36648, 25626,
  30923, 30923, 26681, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556, 32401, 30923, 30923, 31258, 21630,
  27145, 21630, 32608, 36749, 36749, 35569, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136,
  29748, 33411, 30923, 20750, 28077, 36681, 29198, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 36730, 28708, 28247,
  26423, 36766, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630, 36819, 36793, 32589,
  36810, 36842, 22422, 36866, 36878, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630, 35062,
  33330, 36894, 26035, 21630, 21216, 21630, 21630, 21630, 21630, 36912, 26712, 24700, 34965, 24415, 36749, 36749, 37522,
  20613, 30923, 30923, 28723, 21630, 21630, 21630, 28398, 21630, 21630, 36932, 33521, 30480, 36749, 28186, 36749, 30192,
  30923, 26933, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605,
  30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723,
  21630, 36951, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630,
  30136, 29748, 33411, 30923, 31411, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708,
  28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 21058, 21630, 29612, 21630,
  28791, 36968, 37006, 37014, 37030, 37042, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630, 20655, 34964, 21630,
  27652, 37058, 27228, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489, 36749, 36749,
  37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652, 24700, 30480, 36749, 36749, 36749,
  30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 27782, 21630, 21630, 20656, 24700, 36748, 36749, 36749, 36750,
  20605, 30923, 30923, 30923, 28724, 24683, 21630, 21630, 21630, 20657, 29744, 37454, 36749, 37092, 32401, 36076, 30923,
  37118, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923, 28721,
  21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648, 28718,
  28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 23285, 21630, 21630, 24663, 21630, 21630,
  21630, 37223, 19451, 23128, 22361, 37141, 37153, 26631, 21630, 24134, 21630, 21630, 21630, 21630, 34245, 37169, 34964,
  34253, 35262, 33330, 37204, 26035, 21630, 23824, 20245, 21266, 37222, 21630, 21630, 20656, 24700, 34965, 30489, 36749,
  36749, 37239, 30923, 30923, 33348, 30698, 21630, 21630, 21630, 21630, 21630, 21630, 20652, 24700, 30480, 36749, 36749,
  36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748, 36749, 36749,
  29766, 37288, 30923, 30923, 30923, 37434, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556, 32401, 30923,
  30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748, 24851, 30923,
  28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713, 27648,
  28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663, 21630,
  21630, 21630, 37223, 19451, 23128, 23135, 36528, 33190, 25811, 21630, 25085, 21630, 21630, 37322, 21630, 21630, 20655,
  34964, 21630, 37340, 37360, 32264, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965, 30489,
  36749, 36749, 37394, 30923, 30923, 30923, 37433, 24196, 21630, 21630, 21630, 21630, 35106, 20652, 33289, 30480, 31855,
  36749, 37450, 30192, 26076, 30923, 30217, 30924, 21630, 31118, 21630, 21630, 21630, 21630, 23690, 24700, 36748, 37470,
  36749, 36750, 20605, 21164, 30923, 30923, 28724, 21630, 21630, 21630, 35526, 20657, 37492, 36749, 37517, 33874, 32401,
  30923, 37538, 37371, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 37556, 21630, 37573, 29748, 24851,
  30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743, 28713,
  27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 18956, 21630, 21630, 24663,
  21630, 21630, 21630, 37223, 37594, 23128, 23135, 36528, 33190, 26631, 21630, 25085, 21630, 21630, 21630, 21630, 21630,
  20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 34965,
  30489, 36749, 36749, 37522, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630, 21630, 20652, 24700, 30480,
  36749, 36749, 36749, 30192, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630, 21630, 20656, 24700, 36748,
  36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657, 29744, 36749, 36749, 25556,
  32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924, 21630, 21630, 30137, 29748,
  24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815, 33412, 28724, 33412, 28743,
  28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630, 21630,
  32763, 37621, 37645, 37670, 37691, 37706, 37675, 37715, 34813, 37731, 37946, 21630, 25085, 21630, 19906, 37767, 21630,
  21630, 20915, 37873, 21630, 22721, 19292, 18358, 37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069, 18423,
  18085, 18113, 18133, 18153, 37788, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256, 18282,
  18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409, 18469,
  18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385, 18762,
  18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884, 20907,
  18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232, 18358,
  22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992, 21630,
  21630, 24663, 21630, 21630, 36982, 37223, 37816, 37841, 37848, 21630, 37825, 37946, 21630, 25085, 21630, 19906, 21630,
  21630, 21630, 37864, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053, 18069,
  18423, 18085, 18113, 18133, 18153, 18173, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210, 18256,
  18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241, 18409,
  18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682, 25385,
  18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834, 18884,
  20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195, 19232,
  18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 17992,
  21630, 21630, 24663, 21630, 21630, 21630, 20988, 37896, 27005, 27013, 21630, 37932, 37946, 21630, 25085, 21630, 19906,
  37745, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 37985, 35788, 18037, 21630, 34650, 21630, 18860, 18053,
  18069, 18423, 18085, 18113, 18133, 18153, 37970, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204, 18229, 33210,
  18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397, 18390, 23241,
  18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114, 18652, 18682,
  25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818, 18786, 18834,
  18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147, 19179, 19195,
  19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  17992, 21630, 21630, 24663, 21630, 21630, 21630, 37223, 19451, 21630, 21630, 21630, 18947, 26631, 21630, 25085, 21630,
  21630, 21630, 21630, 21630, 20655, 34964, 21630, 27652, 33330, 30923, 26035, 21630, 23824, 21630, 21630, 21630, 21630,
  21630, 20656, 24700, 34965, 27653, 36749, 36749, 36042, 30923, 30923, 30923, 28723, 21630, 21630, 21630, 21630, 21630,
  21630, 20652, 24700, 30480, 36749, 36749, 36749, 29593, 30923, 30923, 30923, 30924, 21630, 21630, 21630, 21630, 21630,
  21630, 20656, 24700, 36748, 36749, 36749, 36750, 20605, 30923, 30923, 30923, 28724, 21630, 21630, 21630, 21630, 20657,
  29744, 36749, 36749, 25556, 32401, 30923, 30923, 28723, 21630, 21630, 21630, 23981, 36749, 36749, 35404, 30923, 30924,
  21630, 21630, 30137, 29748, 24851, 30923, 28721, 21630, 30136, 29748, 33411, 30923, 20750, 28077, 33409, 30924, 30815,
  33412, 28724, 33412, 28743, 28713, 27648, 28718, 28708, 28247, 27172, 28274, 27637, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 28370, 21630, 28956, 38001, 38008, 37557, 32531, 37910, 21630, 21630,
  21630, 19906, 21630, 21630, 21630, 20915, 37873, 21630, 22721, 18317, 18358, 18188, 35788, 38024, 21630, 34650, 21630,
  18860, 18053, 18069, 18423, 18085, 18113, 18133, 18153, 37788, 18117, 18137, 18157, 19216, 30564, 21630, 21630, 18204,
  18229, 33210, 18256, 18282, 18266, 22725, 18337, 18357, 19212, 18311, 18333, 18353, 19208, 36303, 23388, 18374, 23397,
  18390, 23241, 18409, 18469, 18492, 18515, 18538, 19016, 18485, 18508, 18531, 19009, 18554, 18590, 18615, 30235, 25114,
  18652, 18682, 25385, 18762, 18698, 25372, 25388, 18765, 18701, 18717, 25840, 28630, 18749, 18813, 18781, 18802, 18818,
  18786, 18834, 18884, 20907, 18977, 18999, 18983, 19032, 19066, 19082, 18437, 18453, 18447, 19098, 19133, 19163, 19147,
  19179, 19195, 19232, 18358, 22712, 18358, 19854, 19267, 37800, 19283, 19865, 19308, 19324, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630, 21630,
  21630, 21630, 73940, 73940, 69843, 69843, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940,
  73940, 73940, 73940, 251, 73940, 49152, 73940, 73940, 73940, 73940, 40960, 73940, 73940, 73940, 73940, 73940, 73940,
  73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 0, 0, 69843, 73940, 69843, 73940, 73940, 73940,
  73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 73940, 45056, 73940, 73940, 73940, 73940,
  73940, 73940, 73940, 73940, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 257, 0, 0, 0, 69843,
  73940, 0, 1056768, 215, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 505, 0, 0, 0, 0, 0, 0, 0, 1691648, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  251, 251, 0, 0, 1363968, 0, 0, 0, 0, 1511424, 0, 1548288, 1564672, 0, 0, 1609728, 1626112, 1638400, 0, 1667072,
  1703936, 1835008, 0, 0, 0, 1114112, 1114112, 1355776, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112,
  1114112, 1511424, 1114112, 1835008, 1114112, 1114112, 1114112, 1114112, 0, 1703936, 0, 1626112, 0, 1703936, 0, 0, 0,
  0, 0, 0, 486, 0, 0, 0, 0, 0, 492, 0, 0, 495, 1581056, 0, 0, 1110016, 1110016, 1355776, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1511424, 1110016, 1110016, 1110016, 1511424,
  1110016, 1110016, 1110016, 1110016, 1110016, 1548288, 1110016, 1564672, 1110016, 1572864, 1110016, 1110016, 1609728,
  1110016, 1110016, 1626112, 1638400, 1110016, 1110016, 1626112, 1638400, 1110016, 1110016, 1667072, 1110016, 1110016,
  1703936, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1835008, 1110016,
  1110016, 1110016, 1835008, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 668, 0, 0, 671, 1110016, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 0, 0, 1622016, 0, 0, 0, 0, 1064960, 0, 0, 0, 0, 0, 0, 0, 0,
  1043, 1044, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1540096, 0, 1634304, 0, 0, 0, 0, 1318912, 0, 0, 0, 0, 0, 0, 0, 1769, 0, 0, 0,
  0, 0, 1775, 342, 342, 0, 0, 0, 0, 1646592, 0, 0, 1646592, 1114112, 1351680, 1114112, 1114112, 1114112, 1114112,
  1114112, 1114112, 0, 0, 1646592, 0, 0, 1110016, 1110016, 1110016, 1351680, 1110016, 1114112, 1474560, 1114112,
  1114112, 1507328, 1114112, 1540096, 1114112, 1114112, 1114112, 1114112, 1634304, 1646592, 1114112, 1114112, 1114112,
  1114112, 1114112, 1114112, 0, 0, 1646592, 0, 0, 1110016, 1110627, 1110627, 1352291, 1110627, 1110016, 1110016,
  1351680, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 0, 1110016, 1110016, 1110016, 1110016, 1110016, 1474560, 1110016, 1110016, 1110016, 1110016, 1507328,
  1110016, 1110016, 1110016, 1110016, 1540096, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1634304, 1110016, 1110016, 1110016, 1634304, 1646592, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 1830912, 1888256, 0, 0, 0, 0,
  0, 0, 1617920, 0, 0, 0, 0, 1671168, 0, 0, 1851392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1303, 0, 0, 0, 0, 0,
  1114112, 1114112, 1114112, 1388544, 1392640, 1114112, 1114112, 1114112, 1114112, 1490944, 1114112, 1114112, 1548288,
  1114112, 1564672, 1114112, 1114112, 1609728, 1626112, 1638400, 1114112, 1667072, 1114112, 1703936, 1114112, 1114112,
  1597440, 1114112, 1114112, 1343488, 1110016, 1110016, 1396736, 1110016, 1110016, 1110016, 1478656, 1110016, 1110016,
  1544192, 1597440, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1871872, 1343488,
  1110016, 1110016, 1396736, 1110016, 1114112, 1568768, 1114112, 1114112, 1605632, 1114112, 1695744, 1114112, 1114112,
  1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1900544, 0, 0, 0, 1073152, 0, 0, 0, 0, 1110016, 1110016,
  1110016, 1110016, 1110016, 1388544, 1392640, 1110016, 1110016, 1110016, 1425408, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1425408, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1490944, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1568768, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1568768,
  1110016, 1110016, 1110016, 1110016, 1605632, 1613824, 1617920, 1110016, 1110016, 1110016, 1683456, 1695744, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1900544, 1110016,
  0, 0, 0, 0, 0, 0, 1400832, 0, 0, 0, 0, 0, 0, 1503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1045, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1495040, 0, 0, 0, 1708032, 0, 0, 0, 0, 0, 0, 0, 0, 1097, 0, 1099, 0, 0, 0, 0, 0, 0, 0, 1527808, 0, 1630208, 0, 0, 0,
  0, 1687552, 1875968, 0, 0, 1818624, 0, 0, 0, 0, 0, 455, 456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555, 0, 0, 0, 0, 0, 0,
  1839104, 1859584, 1335296, 1114112, 1114112, 1114112, 1114112, 1433600, 1114112, 1114112, 1495040, 1114112, 1556480,
  1114112, 1114112, 1597440, 1114112, 1114112, 1344099, 1110627, 1110627, 1397347, 1110627, 1110627, 1110627, 1479267,
  1110627, 1110627, 1544803, 1114112, 1708032, 1114112, 1114112, 1114112, 1810432, 1839104, 1859584, 1892352, 1335296,
  1110016, 1110016, 1110016, 1110016, 1110016, 1404928, 1110016, 1810432, 1110016, 1839104, 1110016, 1859584, 1110016,
  1110016, 1892352, 1110016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1654784, 0, 1699840, 0, 1765376, 0, 1777664, 1896448, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 552, 0, 557, 0, 0, 0, 0, 0, 0, 480, 0, 0, 0, 0, 544, 1114112, 1376256, 1114112, 1114112, 1114112,
  1114112, 1519616, 1114112, 1114112, 1650688, 1765376, 1114112, 1806336, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1708032, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1810432,
  1110016, 1110016, 1110016, 1650688, 1654784, 1110016, 1110016, 1720320, 1110016, 1110016, 1757184, 1110016, 1765376,
  1110016, 1110016, 1806336, 1822720, 1110016, 1110016, 1110016, 1904640, 0, 1110016, 1110016, 1110016, 1904640, 0, 0,
  0, 0, 1110016, 1110016, 1110016, 1376256, 1110016, 1110016, 1110016, 1110016, 1110016, 1454080, 1110016, 1110016,
  1110016, 1110016, 1519616, 1110016, 1110016, 1576960, 1593344, 1110016, 1110016, 1650688, 1654784, 1110016, 0, 0, 0,
  1421312, 0, 0, 1449984, 1486848, 0, 0, 0, 0, 0, 0, 1884160, 0, 0, 0, 0, 0, 1056768, 215, 216, 0, 0, 204800, 0, 0, 0,
  0, 0, 0, 0, 1355776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 551, 0, 556, 0, 559, 0, 0, 1589248, 0, 0, 0, 1712128, 0, 1798144, 0,
  1445888, 0, 0, 0, 0, 0, 0, 0, 0, 1298, 0, 0, 0, 0, 0, 0, 0, 0, 1312, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 0, 0, 0, 0, 0, 0,
  0, 0, 1505, 0, 0, 0, 0, 0, 0, 0, 0, 1529, 0, 0, 0, 0, 0, 0, 0, 0, 1644, 0, 0, 0, 0, 0, 0, 0, 0, 53449, 53449, 2,
  86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 285, 285, 285, 285, 1449984, 1114112, 1114112, 1114112, 1114112,
  1110016, 1110016, 1110016, 1110016, 1110016, 1413120, 1445888, 1449984, 1110016, 1110016, 1486848, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1712128, 1110016, 1110016,
  1761280, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1789952, 1802240, 1110016, 1110016,
  1110016, 1826816, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1900544, 1110016, 0, 1712128, 1110016,
  1110016, 1761280, 1110016, 1110016, 1110016, 1110016, 1110016, 1372160, 0, 0, 0, 0, 0, 0, 0, 746, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 251, 216, 1716224, 0, 1544192, 1523712, 1503232, 1552384, 0, 0, 1744896, 0, 1847296, 0, 1339392,
  1748992, 1867776, 1880064, 0, 0, 0, 1585152, 0, 0, 0, 0, 0, 0, 0, 1396736, 1597440, 0, 1114112, 1396736, 1871872, 0,
  1409024, 0, 0, 0, 1658880, 0, 0, 0, 1863680, 0, 0, 0, 0, 0, 0, 0, 1834, 0, 0, 0, 0, 0, 0, 0, 0, 536, 0, 0, 0, 0, 0, 0,
  0, 1728512, 0, 1359872, 0, 1773568, 1601536, 1359872, 1409024, 1114112, 1601536, 1773568, 1110016, 1359872, 1368064,
  1409024, 1110016, 1110016, 1110016, 1110016, 1531904, 1601536, 1658880, 1736704, 1110016, 1773568, 1110016, 1110016,
  1110016, 1863680, 0, 1110016, 1110016, 1110016, 1531904, 1601536, 1658880, 1736704, 1110016, 1773568, 1110016,
  1110016, 1110016, 1863680, 1110016, 1359872, 1368064, 0, 0, 0, 0, 1675264, 0, 0, 0, 0, 1642496, 0, 1908736, 1466368,
  1466368, 1110016, 1458176, 1466368, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1855488,
  1110016, 1458176, 1466368, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1843200, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1110016, 1110016, 1110016, 1110016, 1110016,
  1855488, 0, 0, 0, 0, 0, 1679360, 0, 0, 0, 0, 0, 0, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 507, 0, 0, 0, 0, 0, 1110016,
  1110016, 1110016, 1110016, 1482752, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1380352, 0,
  1437696, 1785856, 1662976, 1110016, 1110016, 1110016, 1785856, 1429504, 0, 0, 0, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110684, 0, 1110016, 1110687, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1781760, 1441792, 0, 1724416, 1110016, 1536000, 1740800, 1110016, 1110016, 1536000, 1740800,
  1110016, 1560576, 1462272, 1110016, 1462272, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1753088,
  1753088, 0, 0, 0, 0, 0, 0, 547, 0, 0, 0, 0, 0, 0, 464, 0, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 106818,
  106818, 106818, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114688, 106818, 106818, 106818, 322, 106818,
  106818, 106818, 106818, 106818, 106818, 106818, 106818, 106818, 106818, 106818, 0, 0, 106818, 0, 0, 0, 106818, 322,
  322, 322, 322, 322, 322, 106818, 322, 1110016, 0, 728, 728, 0, 5, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 215,
  114688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1317, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1774, 342, 342, 342, 0, 0, 32768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1343, 0, 1110016, 0, 0, 0, 0, 5, 0, 0,
  215, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 1130699, 86019, 4, 5, 207, 0, 0, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 745, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 535, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1508,
  0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 118784, 118784, 0, 0, 0, 1130699, 86019, 4, 5, 0, 0, 118784, 0,
  0, 0, 118784, 0, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 118784, 0, 0, 118784, 0, 118784,
  118784, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 807, 0, 0, 0, 0, 0, 0, 0, 0, 0, 513, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  811, 0, 0, 1110016, 0, 0, 0, 0, 5, 0, 0, 0, 729, 733, 0, 1355776, 0, 0, 1384448, 1110016, 1110016, 1110016, 1843200,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1200, 0, 0, 1205, 0, 0, 0, 0, 0, 1056768, 215, 20924,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1073, 0, 0, 0, 1076, 0, 0, 0, 0, 0, 126976, 126976, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 208896, 0, 0, 0, 49152, 126976, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 213427, 213427, 213427,
  213427, 126976, 126976, 126976, 126976, 126976, 0, 0, 126976, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 69843, 69843,
  69843, 69843, 0, 49152, 0, 131072, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258048, 0, 0, 258048, 0, 0, 0,
  131072, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1029, 0, 0, 0, 0, 0, 0, 292, 0, 0, 0, 0, 292, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 266240, 266240, 266240, 266240, 1110016, 1110016, 1110016, 1835008, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 940, 0, 0, 943, 1110016, 0, 0, 0, 0, 0, 0, 0, 1110016, 1110016, 1482752, 1110016, 1110016,
  1110016, 1110016, 1110016, 0, 0, 0, 1347584, 1110016, 1110016, 1110016, 1110016, 1781760, 1347584, 1110016, 0, 216,
  135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1534, 0, 135463, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1056768, 0, 0, 0, 216, 216, 216, 216, 216, 0, 0, 216, 0, 0, 2, 86019, 4, 5, 0, 0, 241664, 0, 0, 0, 0, 241664, 0, 0,
  0, 1110016, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 216, 1355776, 0, 0, 1384448, 213, 213, 0, 0, 213, 213, 139477, 213, 213,
  213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 252, 213, 213, 139477, 213, 213, 213, 213, 213,
  255, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 139477, 213, 45056, 49152, 213, 213, 213, 213,
  40960, 213, 213, 213, 213, 213, 213, 213, 213, 139477, 139477, 213, 213, 139477, 213, 213, 139477, 139477, 213, 213,
  213, 213, 213, 213, 213, 213, 213, 213, 139477, 213, 213, 213, 213, 213, 213, 139477, 213, 139477, 139477, 139477,
  139477, 139477, 139477, 139477, 139477, 139477, 139477, 139477, 139477, 0, 0, 0, 0, 0, 1056768, 442, 443, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1060, 0, 0, 0, 0, 0, 0, 0, 0, 213, 0, 213, 213, 213, 139477, 213, 139477, 139477, 139477, 139477,
  139477, 139519, 139519, 139519, 139519, 139519, 139477, 139477, 139477, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 485, 0,
  0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 1691648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1126876, 1126876, 0, 0, 1363968, 0, 0, 0, 151552,
  0, 0, 0, 0, 151552, 151552, 0, 0, 0, 0, 0, 0, 0, 760, 0, 0, 0, 251, 251, 0, 0, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0,
  0, 0, 0, 0, 151552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151552, 0, 0, 0, 151552, 151552, 151552, 151552, 151552,
  151552, 151552, 151552, 151552, 151552, 151552, 151552, 151552, 151552, 151552, 0, 151552, 0, 0, 0, 151552, 151552,
  151552, 151552, 0, 0, 0, 86019, 4, 5, 122880, 0, 0, 0, 0, 0, 1056768, 20921, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 774, 0,
  0, 0, 0, 0, 0, 0, 1691648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 1363968, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0,
  0, 0, 0, 155648, 155648, 0, 0, 155648, 0, 0, 0, 155648, 155648, 155648, 155648, 155648, 155648, 155648, 155648,
  155648, 155648, 155648, 155648, 155648, 155648, 155648, 0, 0, 0, 0, 0, 98715, 0, 0, 0, 155648, 0, 0, 155648, 98715,
  98715, 98715, 98715, 98715, 155648, 155648, 98715, 0, 0, 2, 86019, 4, 5, 0, 0, 1110016, 1110016, 1110016, 1835008,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 668, 0, 98304, 671, 1110016, 0, 0, 0, 0, 0, 172032,
  282624, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 1110016, 1110016, 1110016, 1843200, 1110016, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 0, 0, 0, 0, 98304, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 159744, 0, 0,
  159744, 0, 0, 0, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744, 159744,
  159744, 159744, 159744, 0, 0, 2, 86019, 4, 5, 0, 0, 49152, 0, 0, 0, 0, 40960, 163840, 0, 163840, 163840, 0, 163840,
  163840, 163840, 163840, 163840, 0, 0, 163840, 0, 0, 0, 163840, 163840, 163840, 163840, 163840, 163840, 163840, 163840,
  163840, 163840, 163840, 163840, 163840, 163840, 163840, 0, 0, 2, 204, 4, 5, 0, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251,
  251, 251, 0, 143360, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 167936, 167936, 167936, 167936, 167936,
  167936, 167936, 167936, 53449, 53449, 2, 0, 4, 5, 0, 439, 167936, 0, 0, 167936, 0, 0, 0, 167936, 167936, 167936,
  167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 167936, 0, 0, 1089, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 225280, 0, 0, 1281, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1650, 0, 0, 0, 1334,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1663, 0, 0, 0, 0, 1204, 0, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412,
  961, 412, 412, 412, 412, 412, 412, 412, 0, 1523, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 237568, 0, 0, 0, 1766,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 0, 0, 1838, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342, 1903, 389, 389, 389, 389, 412, 412, 1876, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 997, 412, 412, 389, 389, 389, 1908, 389, 1909, 1910, 389, 389, 389, 389, 389, 389,
  412, 412, 412, 412, 412, 1006, 412, 0, 0, 0, 1012, 0, 0, 0, 1018, 0, 412, 412, 1954, 412, 412, 412, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 292, 1966, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1976, 412, 412, 412, 412, 412, 0,
  0, 0, 0, 389, 389, 389, 389, 2061, 389, 412, 176562, 176562, 176562, 176562, 176562, 0, 0, 176562, 53449, 53449, 2,
  86019, 4, 5, 0, 0, 0, 0, 0, 546, 0, 0, 0, 0, 554, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 0, 0, 276, 0, 0, 0, 412, 180224, 0,
  0, 53449, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 219, 219, 0, 0, 0, 0, 0, 217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 826, 0, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 184643, 184643, 0, 0, 184643, 0, 0, 0, 184643, 0, 0,
  0, 0, 0, 0, 184643, 0, 0, 0, 0, 0, 1732608, 0, 0, 0, 0, 0, 0, 0, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112,
  1114112, 1114112, 1114112, 1114112, 1114112, 0, 0, 0, 217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 184643, 184643, 184643, 0,
  184643, 184643, 184643, 184643, 184643, 184643, 184643, 184643, 184643, 184643, 184643, 0, 0, 0, 2, 86019, 4, 5, 0, 0,
  0, 0, 188416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1676, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  294, 285, 285, 285, 285, 285, 0, 0, 285, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 744, 0, 0, 0, 748, 0, 0, 0, 0,
  0, 0, 0, 1323, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 254, 254, 45056, 412, 508, 0, 0, 53449, 5, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 249, 250, 0, 251, 0, 797, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 445, 1271, 0, 0, 0, 0, 1014,
  1273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 478, 0, 0, 0, 0, 0, 1076, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1032, 0, 0, 0, 0, 0, 1204, 1425, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 1231, 412, 412, 412, 412, 412, 412,
  412, 1425, 1591, 0, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1447, 1448, 412, 412, 412, 389,
  389, 389, 389, 1589, 0, 1591, 0, 412, 412, 412, 412, 412, 412, 412, 412, 1445, 412, 412, 412, 412, 412, 412, 412,
  49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 219, 0, 0, 0, 0, 0, 0, 759, 0, 0, 0, 0, 251, 251, 0, 0, 0, 0, 0, 218, 219, 0,
  218, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1313, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147456, 1056768, 215, 216, 0, 200704, 0,
  0, 0, 0, 0, 0, 0, 788, 0, 0, 0, 0, 0, 0, 0, 0, 747, 0, 0, 0, 0, 751, 0, 0, 0, 1691648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1126877, 0, 0, 1363968, 1581056, 0, 0, 1110627, 1110627, 1356387, 1110627, 1110627, 1110627, 1110627, 1110627,
  1110627, 1110627, 1110627, 1110627, 1110627, 669, 1110686, 1110686, 1110686, 1110686, 1110686, 1110627, 1512035,
  1110627, 1110627, 1110627, 1110627, 1110627, 1548899, 1110627, 1565283, 1110627, 1573475, 1110627, 1110627, 1610339,
  1110627, 1110627, 1110627, 1905251, 0, 0, 0, 0, 1110686, 1110686, 1110686, 1376926, 1110686, 1110686, 1110686,
  1110686, 0, 1417216, 0, 0, 1769472, 0, 0, 0, 0, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627,
  1110627, 1110627, 1110627, 1110627, 1110627, 1475171, 1110627, 1110627, 1110627, 1110627, 1626723, 1639011, 1110627,
  1110627, 1667683, 1110627, 1110627, 1704547, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1708643,
  1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110686, 1356446, 1110686, 1110686, 1110686,
  1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1512094, 1110686, 1110686, 1110686, 1110686,
  1708702, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1811102, 1110686, 1110686,
  1667742, 1110686, 1110686, 1704606, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686,
  1110686, 1835678, 1110627, 1507939, 1110627, 1110627, 1110627, 1110627, 1540707, 1110627, 1110627, 1110627, 1110627,
  1110627, 1110627, 1110627, 1110627, 1634915, 1647203, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627,
  1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110686, 1110686, 1110686, 1110686, 1110686,
  1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1352350, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686,
  1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1475230, 1110686, 1110686,
  1110686, 1110686, 1507998, 1110686, 1110686, 1110686, 1110686, 1540766, 1110686, 1110686, 1110686, 1110686, 1110686,
  0, 0, 0, 1348195, 1110627, 1110627, 1110627, 1110627, 1782371, 1348254, 1110686, 0, 1110627, 1110627, 1110627,
  1110627, 1110627, 1389155, 1393251, 1110627, 1110627, 1110627, 1426019, 1110627, 1110627, 1110627, 1110627, 1491555,
  1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1569379, 1110627, 1110627, 1110627, 1110627, 1532515,
  1602147, 1659491, 1737315, 1110627, 1774179, 1110627, 1110627, 1110627, 1864291, 1110686, 1360542, 1368734, 1606243,
  1614435, 1618531, 1110627, 1110627, 1110627, 1684067, 1696355, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627,
  1110627, 1110627, 1712739, 1110627, 1110627, 1761891, 1110627, 1110627, 1110627, 1110627, 1110627, 1110686, 1110627,
  1790563, 1802851, 1110627, 1110627, 1110627, 1827427, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1901155,
  1110627, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 1073152, 0, 0, 0, 0, 1110686,
  1110686, 1110686, 1110686, 1110686, 1389214, 1393310, 1110686, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1355776, 0, 0,
  1384448, 1110686, 1110686, 1426078, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1491614, 1110686,
  1110686, 1110686, 1110686, 1110686, 1856158, 0, 0, 0, 0, 0, 1679360, 0, 0, 0, 0, 1110686, 1110686, 1569438, 1110686,
  1110686, 1110686, 1110686, 1606302, 1614494, 1618590, 1110686, 1110686, 1110686, 1684126, 1696414, 1110686, 1110686,
  1110686, 1110686, 1901214, 1110686, 0, 0, 0, 0, 0, 0, 1400832, 0, 0, 0, 0, 0, 0, 1833, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1287, 0, 0, 0, 0, 0, 1114112, 1708032, 1114112, 1114112, 1114112, 1810432, 1839104, 1859584, 1892352, 1335907,
  1110627, 1110627, 1110627, 1110627, 1110627, 1405539, 1110627, 1811043, 1110627, 1839715, 1110627, 1860195, 1110627,
  1110627, 1892963, 1110627, 0, 0, 0, 0, 0, 0, 0, 793, 793, 0, 0, 0, 797, 1076, 0, 0, 1839774, 1110686, 1860254,
  1110686, 1110686, 1893022, 1110686, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 263, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056,
  1114112, 1376256, 1114112, 1114112, 1114112, 1114112, 1519616, 1114112, 1114112, 1650688, 1765376, 1114112, 1806336,
  1110627, 1110627, 1110627, 1835619, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 668, 0, 0, 671,
  1110686, 1376867, 1110627, 1110627, 1110627, 1110627, 1110627, 1454691, 1110627, 1110627, 1110627, 1110627, 1520227,
  1110627, 1110627, 1577571, 1593955, 1110627, 1110627, 1651299, 1655395, 1110627, 1110627, 1720931, 1110627, 1110627,
  1757795, 1110627, 1765987, 1110627, 1110627, 1806947, 1823331, 1110686, 1454750, 1110686, 1110686, 1110686, 1110686,
  1520286, 1110686, 1110686, 1577630, 1594014, 1110686, 1110686, 1651358, 1655454, 1110686, 1110686, 1110686, 1548958,
  1110686, 1565342, 1110686, 1573534, 1110686, 1110686, 1610398, 1110686, 1110686, 1626782, 1639070, 1110686, 0, 0, 0,
  0, 0, 0, 0, 1110627, 1110627, 1483363, 1110627, 1110627, 1110627, 1110627, 1110627, 1843811, 1110627, 1110627,
  1110627, 1110627, 1110627, 1110627, 1110627, 0, 0, 0, 0, 0, 0, 0, 1842, 0, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342,
  342, 342, 581, 342, 586, 342, 1110686, 1720990, 1110686, 1110686, 1757854, 1110686, 1766046, 1110686, 1110686,
  1807006, 1823390, 1110686, 1110686, 1110686, 1905310, 0, 0, 0, 0, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  221, 1449984, 1114112, 1114112, 1114112, 1114112, 1110627, 1110627, 1110627, 1110627, 1110627, 1413731, 1446499,
  1450595, 1110627, 1110627, 1487459, 1712798, 1110686, 1110686, 1761950, 1110686, 1110686, 1110686, 1110686, 1110686,
  1372160, 0, 0, 0, 0, 0, 0, 0, 805, 0, 0, 0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 286, 0, 45056, 1598051, 1110627, 1110627,
  1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1872483, 1344158, 1110686, 1110686, 1397406, 1110686,
  1110686, 1110686, 1634974, 1647262, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686,
  1110686, 1110686, 1790622, 1802910, 1110686, 1110686, 1110686, 1827486, 1110686, 1110686, 1110686, 1110686, 1479326,
  1110686, 1110686, 1544862, 1598110, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686,
  1843870, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251,
  196608, 0, 0, 0, 1872542, 0, 1409024, 0, 0, 0, 1658880, 0, 0, 0, 1863680, 0, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 0,
  126976, 0, 0, 45056, 1728512, 0, 1359872, 0, 1773568, 1601536, 1359872, 1409024, 1114112, 1601536, 1773568, 1110627,
  1360483, 1368675, 1409635, 1110627, 1110627, 1434211, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1495651,
  1516131, 1110627, 1528419, 1110627, 1110627, 1557091, 1409694, 1110686, 1110686, 1110686, 1110686, 1532574, 1602206,
  1659550, 1737374, 1110686, 1774238, 1110686, 1110686, 1110686, 1864350, 0, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 1675264, 0, 0, 0, 0, 1642496, 0, 1908736, 1466368, 1466368, 1110627, 1458787, 1466979,
  1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1110627, 1856099, 1110686, 1458846, 1467038, 1110686,
  1110686, 1110686, 1110686, 1413790, 1446558, 1450654, 1110686, 1110686, 1487518, 1110686, 1110686, 1110686, 1110686,
  1110686, 1110686, 1495710, 1516190, 1110686, 1528478, 1110686, 1110686, 1557150, 1110686, 1110686, 1110686, 0, 0, 0,
  1110627, 1110627, 1499747, 1110627, 1663587, 1110627, 1110627, 1110627, 1786467, 1110686, 1110686, 1499806, 1110686,
  1110686, 1110686, 1782430, 1441792, 0, 1724416, 1110627, 1536611, 1741411, 1110627, 1110686, 1536670, 1741470,
  1110686, 1560576, 1663646, 1110686, 1110686, 1110686, 1786526, 1429504, 0, 0, 0, 1110627, 1110627, 1110627, 1110627,
  1110627, 1110627, 1110686, 1110686, 1483422, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1110686, 1380352,
  0, 1437696, 1785856, 1462883, 1110627, 1462942, 1110686, 1110627, 1110686, 1110627, 1110686, 1110627, 1110686,
  1753699, 1753758, 0, 0, 0, 0, 0, 0, 771, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 409, 49152, 0, 0, 0, 0, 40960,
  0, 0, 0, 0, 208896, 0, 0, 208896, 0, 0, 0, 0, 0, 770, 0, 0, 0, 0, 0, 776, 0, 0, 0, 0, 0, 0, 1026, 0, 0, 0, 0, 1031, 0,
  0, 0, 0, 0, 0, 1041, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 271, 0, 0, 407, 0, 0, 0, 1622016, 0, 0, 0, 0, 1064960, 0,
  0, 0, 57344, 0, 0, 0, 0, 0, 0, 1841, 0, 0, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 580, 342, 342, 342,
  28672, 0, 0, 1540096, 0, 1634304, 0, 0, 0, 0, 1318912, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 131072, 131072, 131072, 131072,
  131072, 131072, 131072, 0, 0, 131072, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 245760, 0, 0, 0, 0, 245760, 0, 0, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1843200, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 215, 215, 215, 215, 215, 0, 0, 215, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 215,
  0, 216, 0, 0, 0, 216, 0, 0, 0, 1388544, 0, 0, 0, 0, 0, 1025, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126976, 126976, 0, 0, 0,
  0, 0, 1851392, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1048, 0, 0, 1110016, 1110016, 1110016, 1110016, 1900544,
  1110016, 215, 0, 216, 0, 0, 0, 1400832, 0, 0, 0, 0, 0, 0, 1933, 0, 0, 0, 0, 0, 0, 342, 389, 389, 1110016, 1810432,
  1110016, 1839104, 1110016, 1859584, 1110016, 1110016, 1892352, 1110016, 668, 0, 0, 0, 668, 0, 0, 0, 0, 269, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1101, 0, 0, 0, 671, 0, 0, 0, 671, 0, 1335296, 1110016, 1110016, 1110016, 1110016, 1110016,
  1404928, 1110016, 1110016, 1433600, 1110016, 1110016, 1110016, 1904640, 668, 0, 671, 0, 1110016, 1110016, 1110016,
  1376256, 1110016, 1110016, 1110016, 1110016, 0, 1417216, 0, 0, 1769472, 0, 0, 0, 0, 1110016, 1110016, 1110016,
  1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1474560, 1110016, 1110016, 1110016,
  213316, 0, 0, 213316, 0, 0, 0, 213316, 213316, 213316, 213316, 213316, 213316, 213316, 213316, 213316, 213316, 213316,
  213316, 213316, 213316, 213316, 0, 213427, 213427, 213427, 213427, 213427, 213316, 213316, 213428, 0, 0, 2, 86019, 4,
  5, 0, 0, 0, 0, 0, 1040, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 229376, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1064, 0, 0, 1110016, 0, 0, 229376, 0, 5, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 49152, 0, 0, 0, 0,
  40960, 0, 0, 0, 0, 0, 0, 0, 0, 241664, 241664, 241664, 0, 0, 2, 86019, 4, 5, 0, 0, 241664, 0, 0, 241664, 0, 0, 0,
  241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664, 241664,
  241664, 0, 0, 110592, 0, 233472, 249856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 0, 0, 1110016, 0, 0, 233472, 0,
  5, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 0, 0, 0, 245760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1076, 0, 0,
  49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 246085, 246085, 246085, 0, 0, 2, 86019, 0, 5, 0, 0, 246085, 0, 0,
  246085, 0, 0, 0, 246085, 246085, 246085, 246085, 246085, 246085, 246085, 246085, 246085, 246085, 246085, 246085,
  246085, 246085, 246085, 0, 262144, 0, 0, 0, 0, 1056768, 215, 216, 192512, 0, 0, 0, 0, 0, 0, 0, 0, 208896, 208896,
  208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 208896, 0, 0, 0, 0, 0,
  253952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 0, 0, 251, 0, 0, 258048, 0, 0, 258048, 0, 0, 0, 0, 0, 2, 86019,
  1138893, 5, 0, 0, 0, 0, 209, 0, 0, 0, 0, 209, 0, 1110016, 0, 237568, 237568, 0, 5, 0, 0, 0, 0, 0, 0, 1355776, 0, 0,
  1384448, 266240, 266240, 266240, 266240, 266240, 0, 0, 266240, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 1071, 0, 0, 0, 0,
  1074, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 342, 342, 0, 342, 342, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 342, 0, 0, 0, 0, 389, 1271, 0, 0, 0, 0, 0, 1273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 402, 0, 1591, 0, 0,
  0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1459, 412, 412, 412, 412, 0, 0, 0, 1076, 0, 0, 0, 0, 0,
  1325, 0, 0, 0, 0, 0, 0, 0, 821, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1844, 0, 0, 0, 0, 342, 342, 49152, 0, 0, 0, 0, 40960, 0, 0,
  0, 0, 306, 0, 0, 0, 0, 0, 0, 0, 1490944, 0, 1695744, 0, 0, 1900544, 1392640, 0, 1568768, 410, 410, 410, 389, 413, 410,
  410, 410, 410, 410, 410, 410, 413, 413, 413, 413, 413, 410, 410, 413, 53449, 53449, 2, 86019, 4, 5, 0, 0, 53450, 2,
  86019, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 0, 0, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0,
  274432, 274432, 0, 0, 0, 2, 86019, 4, 5, 0, 0, 274432, 274432, 274432, 0, 274432, 274432, 274432, 274432, 274432,
  274432, 274432, 274432, 274432, 274432, 274432, 0, 0, 274432, 0, 0, 0, 274432, 0, 0, 0, 0, 0, 0, 274432, 0, 221184, 0,
  0, 1585152, 0, 0, 0, 0, 0, 0, 0, 1396736, 1597440, 0, 1114112, 1396736, 0, 2, 86019, 4, 206, 0, 0, 0, 0, 0, 210, 0, 0,
  0, 0, 0, 0, 0, 1605632, 1613824, 0, 0, 1683456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1794048, 0, 0, 49152, 0, 0, 0, 0, 40960,
  0, 0, 0, 0, 0, 0, 0, 278528, 0, 0, 0, 0, 0, 1107, 0, 0, 342, 342, 342, 342, 342, 342, 342, 1116, 0, 440, 0, 0, 0,
  1056768, 215, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1673, 0, 0, 0, 0, 0, 0, 1110016, 0, 0, 0, 0, 2191798, 0, 0, 0, 0, 0, 0,
  1355776, 0, 0, 1384448, 220, 220, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1761, 0, 280, 220, 0, 0, 0, 0, 0, 0,
  0, 288, 257, 0, 257, 0, 0, 45056, 49152, 257, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 220, 0, 313, 326, 326, 343, 343, 326,
  343, 343, 343, 326, 366, 366, 366, 366, 366, 366, 366, 379, 366, 366, 366, 366, 366, 366, 343, 366, 366, 366, 366,
  390, 390, 390, 390, 390, 414, 390, 390, 390, 390, 390, 390, 390, 414, 414, 414, 414, 414, 390, 390, 414, 53449, 53449,
  2, 86019, 4, 5, 0, 0, 450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 464, 0, 0, 0, 0, 274, 0, 275, 0, 0, 0, 0, 0, 275, 0,
  279, 0, 0, 0, 0, 282, 0, 0, 275, 0, 0, 0, 289, 0, 0, 0, 45056, 0, 0, 0, 514, 0, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1745, 0, 0, 0, 1749, 0, 0, 0, 526, 0, 0, 0, 0, 532, 0, 0, 0, 538, 0, 0, 0, 0, 543, 342, 342, 342, 592, 342, 342, 342,
  547, 0, 0, 547, 0, 0, 0, 449, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1356, 342, 342, 342, 342,
  342, 1136, 0, 0, 0, 0, 0, 876, 389, 389, 389, 389, 389, 389, 389, 885, 891, 389, 389, 389, 389, 0, 504, 543, 0, 389,
  389, 389, 617, 389, 389, 389, 389, 389, 641, 389, 645, 389, 650, 389, 653, 389, 389, 664, 389, 389, 389, 0, 412, 412,
  412, 412, 677, 866, 342, 342, 342, 342, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 267, 268, 270, 0, 828, 876, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1418, 0, 928, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 668, 99246, 876, 671, 412, 0, 0, 0, 201, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 0, 0, 0, 0, 1052, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 220, 342, 342, 1133, 342, 342, 342, 0, 0, 0, 0, 0, 876, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 895, 389, 389, 389, 1192, 389, 389, 389, 389, 389, 389, 389, 389, 1201, 1204,
  99246, 1206, 1204, 1271, 0, 0, 0, 0, 0, 1273, 0, 0, 0, 0, 0, 0, 0, 0, 1278, 0, 1320, 0, 1076, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1329, 0, 0, 1344, 0, 0, 0, 342, 342, 342, 342, 1351, 1352, 342, 342, 342, 342, 342, 342, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 833, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 508, 285, 0, 0, 0, 342, 342, 1359, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 389, 389, 389, 1342, 389, 389, 389, 389, 389, 389, 1375, 389, 1377, 389, 389, 389,
  1380, 389, 389, 389, 389, 389, 389, 389, 2003, 412, 412, 412, 412, 412, 412, 412, 412, 988, 412, 412, 412, 412, 412,
  412, 412, 412, 412, 1218, 412, 412, 412, 412, 412, 412, 0, 0, 0, 1204, 0, 0, 0, 0, 412, 412, 412, 412, 412, 412, 1436,
  412, 0, 0, 0, 201, 5, 0, 0, 0, 731, 735, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 808, 0, 0, 0, 0, 0,
  1438, 412, 412, 412, 1441, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1460, 412, 412, 412, 0, 1486,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1495, 0, 0, 0, 0, 0, 0, 36864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 0, 0, 479,
  0, 0, 1512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1520, 0, 0, 0, 0, 0, 1309, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 508, 793, 0, 0,
  0, 0, 1641, 0, 0, 0, 0, 0, 0, 0, 1645, 0, 0, 0, 0, 0, 0, 0, 1027, 0, 0, 0, 0, 0, 0, 0, 0, 761, 762, 0, 251, 251, 0, 0,
  0, 389, 389, 389, 389, 1702, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1699, 389, 389, 0, 2040,
  0, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 0, 2080, 0, 389, 389, 389, 389, 412, 412, 412,
  412, 0, 0, 0, 389, 389, 389, 2082, 412, 412, 412, 2084, 0, 222, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232,
  256, 0, 0, 0, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1342, 0, 0, 49152, 0, 0, 296, 0, 40960, 0, 296, 0, 0, 0, 0,
  0, 314, 0, 0, 0, 0, 0, 1489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1046, 0, 0, 0, 0, 0, 344, 344, 0, 344, 344, 344, 296,
  314, 314, 314, 314, 314, 314, 314, 314, 314, 314, 344, 314, 314, 314, 314, 391, 391, 391, 391, 391, 415, 391, 391,
  391, 391, 391, 391, 391, 415, 415, 415, 415, 415, 391, 391, 415, 53449, 53449, 2, 86019, 4, 5, 0, 0, 342, 1131, 342,
  342, 342, 342, 0, 0, 0, 0, 0, 876, 389, 389, 389, 389, 389, 389, 389, 389, 389, 893, 389, 389, 389, 412, 412, 412,
  1259, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 0, 1830, 0, 0, 0, 0, 342, 342, 342, 1539,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 389, 389, 389, 1552, 389, 1554, 389, 0, 1591, 0, 0, 0, 0, 412, 412, 412,
  1595, 412, 1597, 412, 412, 412, 412, 412, 412, 1823, 412, 412, 0, 0, 0, 1828, 0, 0, 0, 389, 1997, 389, 1999, 389,
  2001, 389, 412, 412, 412, 412, 2007, 412, 2009, 412, 2011, 0, 0, 224, 225, 226, 227, 228, 229, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1835, 0, 0, 0, 0, 0, 0, 0, 0, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 45056, 49152, 0, 228, 297, 298, 40960,
  298, 297, 305, 305, 0, 305, 305, 315, 327, 327, 345, 345, 360, 345, 345, 345, 363, 367, 367, 367, 377, 377, 378, 378,
  367, 378, 378, 378, 367, 378, 378, 378, 378, 378, 378, 345, 378, 378, 378, 378, 392, 392, 392, 392, 416, 392, 392,
  392, 392, 392, 392, 392, 416, 416, 416, 416, 416, 392, 392, 416, 53449, 53449, 2, 86019, 4, 5, 0, 0, 389, 389, 389,
  654, 389, 389, 389, 389, 389, 389, 0, 412, 412, 412, 412, 412, 0, 0, 0, 0, 389, 389, 2059, 2060, 389, 389, 412, 766,
  745, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1496, 0,
  0, 854, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 0, 0, 876, 389, 878, 880, 389,
  389, 389, 389, 389, 889, 389, 894, 389, 389, 389, 389, 389, 389, 904, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 921, 389, 389, 389, 389, 389, 389, 389, 900, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 925, 389, 389, 946, 948, 412, 412, 412, 412, 412, 957, 412, 962, 412, 412, 412, 412, 412, 968, 0, 0, 0, 1023, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1533, 0, 0, 0, 1090, 0, 0, 0, 0, 1095, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 553, 0, 0, 0,
  0, 0, 1117, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1369, 342, 1700, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 0, 0, 1741, 0, 0, 0, 0, 0, 1744, 0, 0, 0, 0, 0, 0, 0,
  0, 217088, 0, 0, 0, 0, 0, 0, 0, 0, 155648, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 131072, 0, 45056, 342, 342,
  342, 1780, 342, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1708, 389, 389, 389, 389, 389, 389,
  1794, 1795, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 2005, 412, 412, 412, 412, 412, 412, 1996, 389, 389,
  389, 389, 389, 389, 412, 412, 412, 2006, 412, 412, 412, 412, 412, 0, 0, 0, 0, 2057, 389, 389, 389, 389, 389, 2063, 0,
  0, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 45056, 49152, 0, 0, 259, 0, 40960, 0, 259, 0, 0, 307, 0, 0, 316, 328,
  328, 346, 346, 328, 346, 346, 346, 364, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 346, 368, 368, 368, 368,
  393, 393, 393, 393, 393, 417, 393, 393, 393, 393, 393, 393, 393, 417, 417, 417, 417, 417, 393, 393, 417, 53449, 53449,
  2, 86019, 4, 5, 0, 0, 0, 0, 553, 0, 0, 0, 0, 553, 0, 0, 0, 0, 553, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 251, 251, 251, 0, 0, 0, 754, 0, 0, 756, 757, 0, 0, 0, 0, 0, 0, 251, 251, 0, 0, 0, 0, 0, 0, 1335296, 0, 0, 0, 0,
  0, 1810432, 0, 0, 0, 0, 0, 0, 1671, 1672, 0, 0, 0, 1674, 0, 0, 0, 0, 0, 0, 1108, 0, 342, 342, 342, 1111, 342, 342,
  342, 342, 342, 342, 859, 342, 860, 342, 342, 342, 342, 342, 864, 865, 0, 830, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 837, 0,
  0, 0, 0, 0, 1515, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 0, 0, 0, 840, 342, 842, 342, 342, 342, 342, 342,
  342, 342, 342, 853, 342, 342, 342, 342, 342, 1361, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1125, 342, 342,
  342, 342, 342, 0, 0, 876, 389, 879, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1915, 412, 412,
  898, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1188, 389, 389, 389, 913, 389, 389,
  915, 389, 917, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1415, 1416, 389, 389, 389, 0, 947, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 966, 412, 412, 412, 412, 412, 1213, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 1624, 412, 412, 412, 412, 412, 412, 983, 412, 985, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 1727, 412, 412, 412, 1271, 0, 0, 0, 0, 0, 1273, 0, 0, 0, 0, 0, 1276, 0, 0, 0, 0, 0, 0, 1335296, 1110016,
  1110016, 1110016, 1110016, 1110016, 1404928, 1110016, 1110016, 1433600, 1110016, 1110016, 1110016, 1110016, 1110016,
  1110016, 1495040, 1515520, 1110016, 1527808, 1110016, 1110016, 1556480, 1110016, 1110016, 1110016, 0, 389, 389, 389,
  389, 389, 389, 389, 1376, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1419, 1589, 0, 0, 0, 0, 0, 0, 0, 1204, 0,
  0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 1437, 412, 1476, 1477, 412, 412, 412, 1271, 0, 1273, 0, 0, 0, 0, 0, 0, 0,
  0, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528, 278528,
  278528, 0, 0, 0, 0, 342, 1537, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1126, 342, 342, 342, 0,
  1591, 0, 0, 0, 0, 412, 412, 1594, 412, 412, 412, 412, 412, 412, 412, 809, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1082, 0, 0, 0, 0,
  0, 0, 0, 1653, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 215, 389, 389, 389, 389, 389, 1703, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 0, 0, 0, 0, 0, 0, 412, 412, 1720, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 1222, 412, 412, 1729, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 1826, 0, 0,
  0, 0, 0, 389, 389, 1968, 389, 389, 389, 389, 389, 389, 389, 412, 412, 1978, 412, 412, 412, 412, 412, 1442, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 1470, 412, 412, 412, 412, 412, 389, 389, 1998, 389, 389, 389, 389, 412, 412,
  412, 412, 412, 2008, 412, 412, 412, 412, 412, 1456, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1471, 412,
  412, 1473, 412, 0, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 45056, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 233, 0, 0,
  233, 317, 329, 339, 329, 347, 347, 329, 347, 347, 347, 329, 369, 369, 369, 369, 369, 369, 369, 380, 369, 369, 369,
  369, 369, 369, 347, 369, 369, 369, 369, 394, 394, 394, 394, 394, 418, 394, 394, 394, 394, 394, 394, 394, 418, 418,
  418, 418, 418, 394, 394, 418, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 0, 470, 471, 0, 0, 0, 0, 251, 251, 251, 0,
  0, 0, 0, 0, 0, 1335966, 1110686, 1110686, 1110686, 1110686, 1110686, 1405598, 1110686, 1110686, 1434270, 0, 0, 482,
  483, 0, 0, 0, 487, 0, 0, 490, 0, 0, 0, 0, 0, 0, 215, 216, 0, 0, 0, 0, 0, 0, 448, 0, 0, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0,
  0, 509, 0, 0, 0, 0, 0, 0, 1576960, 0, 0, 1814528, 0, 0, 0, 1806336, 0, 0, 0, 0, 527, 0, 0, 0, 533, 534, 0, 537, 0,
  539, 0, 0, 0, 0, 0, 0, 804, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 208896, 208896, 0, 0, 208896, 208896, 0, 0, 0, 559, 0, 342,
  342, 568, 342, 571, 342, 342, 579, 342, 585, 342, 342, 342, 342, 342, 1682, 342, 342, 342, 342, 342, 342, 342, 389,
  389, 389, 389, 389, 389, 389, 1149, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1165, 389, 1169, 389, 389, 389,
  588, 342, 591, 342, 342, 342, 342, 0, 0, 0, 0, 482, 0, 0, 0, 539, 0, 551, 0, 602, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559, 559,
  0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342, 342, 852, 342, 342, 342, 342, 342, 870, 0, 0, 872, 806, 0, 0, 872,
  0, 0, 765, 0, 602, 0, 0, 389, 389, 616, 389, 620, 389, 389, 632, 389, 642, 389, 646, 389, 389, 652, 655, 659, 389,
  389, 389, 389, 389, 0, 412, 412, 412, 676, 412, 0, 0, 0, 53449, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1057276, 0, 0,
  0, 680, 412, 412, 692, 412, 702, 412, 706, 412, 412, 712, 715, 719, 412, 412, 412, 412, 412, 1467, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 1219, 412, 412, 412, 412, 412, 0, 838, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 1368, 342, 342, 342, 342, 867, 342, 869, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 809, 0, 0, 0,
  0, 389, 389, 899, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 910, 389, 389, 389, 389, 931, 389, 389,
  389, 937, 389, 389, 668, 99246, 876, 671, 412, 0, 0, 0, 53449, 5, 0, 0, 0, 0, 0, 0, 0, 0, 738, 0, 0, 0, 0, 342, 342,
  342, 342, 342, 342, 342, 342, 1355, 342, 342, 342, 342, 342, 389, 389, 1784, 389, 389, 389, 389, 389, 389, 1789, 389,
  999, 412, 412, 412, 1005, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 749, 0, 0, 0, 752, 0, 1020, 0, 1022, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 159744, 1035, 1036, 0, 1038, 1039, 0, 0, 1042, 0, 0, 0, 0, 1047, 0, 0, 0, 0, 0,
  214, 215, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1286, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1054, 0, 0, 0, 0, 1059, 0, 1061, 0, 0, 0,
  0, 0, 0, 215, 216, 0, 0, 0, 0, 0, 447, 0, 0, 0, 1068, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1075, 0, 1076, 0, 0, 0, 0, 0, 1527,
  0, 1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 126976, 126976, 126976, 126976, 0, 0, 0, 1092, 1093, 0, 0, 1096, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 258048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1289, 1290, 1291, 1103, 0, 0, 1106, 0, 0, 0, 0,
  1109, 342, 1110, 342, 1112, 342, 342, 342, 342, 342, 342, 1026, 0, 0, 1137, 1102, 876, 389, 389, 389, 389, 389, 389,
  389, 666, 389, 389, 0, 412, 412, 412, 412, 412, 0, 0, 0, 389, 389, 389, 389, 2075, 389, 412, 412, 342, 342, 1118, 342,
  342, 1120, 342, 342, 342, 342, 1124, 342, 342, 342, 1128, 342, 342, 342, 342, 342, 1782, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 0, 412, 412, 674, 412, 412, 389, 389, 1143, 389, 389, 389, 389, 389, 389, 389, 1152, 389, 389,
  389, 389, 1156, 389, 389, 389, 1159, 389, 389, 389, 389, 389, 389, 389, 1166, 1168, 389, 389, 389, 389, 389, 389, 389,
  1162, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1870, 412, 412, 412, 412, 389, 1174, 1175, 389, 1177,
  1178, 389, 389, 389, 389, 389, 389, 1185, 389, 1187, 389, 389, 389, 389, 389, 933, 389, 389, 389, 389, 389, 668,
  99246, 876, 671, 412, 0, 0, 0, 53449, 5, 0, 0, 0, 0, 0, 0, 0, 737, 0, 0, 0, 0, 0, 213296, 0, 0, 0, 0, 0, 0, 0, 0,
  213316, 213316, 389, 389, 389, 389, 1193, 389, 389, 389, 389, 389, 1199, 0, 1204, 99246, 0, 1204, 1209, 1210, 412,
  1211, 412, 412, 1214, 412, 412, 412, 412, 412, 412, 412, 1223, 412, 0, 0, 0, 53449, 5, 0, 0, 0, 730, 734, 0, 0, 0, 0,
  0, 0, 215, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1492, 0, 1494, 0, 0, 1497, 0, 412, 412, 412, 1227, 412, 412, 412, 1230,
  412, 412, 412, 412, 412, 412, 412, 1237, 1239, 412, 412, 412, 412, 1245, 1246, 412, 1248, 1249, 412, 412, 412, 412,
  412, 412, 0, 0, 0, 0, 1480, 0, 0, 0, 0, 0, 1256, 412, 1258, 412, 412, 412, 412, 412, 1264, 412, 412, 412, 412, 412,
  1270, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 850, 342, 342, 342, 342, 342, 342, 1025, 0, 0, 0, 0, 876, 389,
  389, 389, 389, 389, 389, 884, 389, 389, 389, 389, 389, 389, 0, 1280, 0, 0, 0, 1284, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  810, 0, 0, 0, 0, 0, 1305, 0, 1307, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1649, 0, 0, 0, 0, 0, 1076, 0, 0, 0, 0, 1324,
  0, 0, 0, 0, 0, 0, 1331, 0, 1333, 0, 0, 0, 0, 1338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 251, 251, 764, 0, 0, 0, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 1378, 389, 389, 389, 389, 389, 389, 389, 389, 1163, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 1401, 389, 389, 389, 389, 389, 389, 1383, 389, 1385, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 1566, 389, 412, 1439, 412, 412, 412, 412, 412, 1444, 412, 1446, 412, 412, 412, 412, 412, 412,
  0, 1012, 0, 1018, 0, 0, 0, 0, 0, 0, 0, 1034, 342, 342, 342, 342, 342, 342, 342, 342, 0, 0, 0, 0, 0, 0, 536, 0, 0, 412,
  1463, 1464, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1235, 412, 412, 412, 412, 412, 1478, 412,
  412, 1271, 0, 1273, 0, 0, 0, 0, 0, 0, 0, 0, 1064960, 0, 0, 0, 0, 0, 0, 0, 0, 151552, 0, 151552, 151552, 0, 0, 0, 0, 0,
  0, 0, 1501, 0, 0, 0, 1504, 0, 0, 0, 1506, 1507, 0, 0, 0, 0, 0, 232, 258, 234, 256, 0, 0, 0, 0, 0, 0, 0, 0, 880640,
  880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 880640, 0, 0,
  0, 0, 342, 342, 1538, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 861, 342, 342, 863, 342, 342, 342, 342, 342,
  342, 1549, 342, 342, 342, 342, 389, 389, 389, 389, 1553, 389, 389, 389, 389, 389, 389, 935, 389, 389, 389, 389, 668,
  99246, 876, 671, 412, 389, 389, 389, 389, 389, 1572, 389, 1574, 389, 389, 389, 1578, 389, 389, 389, 389, 0, 0, 0, 0,
  1712, 412, 412, 412, 412, 412, 412, 412, 1809, 412, 412, 412, 412, 412, 412, 412, 412, 1607, 412, 412, 412, 412, 1610,
  1611, 412, 1583, 389, 389, 389, 389, 389, 1586, 389, 389, 389, 0, 1589, 0, 0, 0, 0, 0, 0, 1057, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1660, 0, 0, 0, 0, 0, 0, 1591, 0, 0, 0, 0, 412, 412, 412, 412, 1596, 412, 412, 412, 412, 412, 0, 0, 0, 389,
  389, 389, 389, 389, 389, 412, 412, 412, 412, 1602, 412, 1604, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 1736, 412, 412, 0, 412, 412, 1615, 412, 1617, 412, 412, 412, 1621, 412, 412, 412, 412, 1626, 412, 412, 412, 412,
  973, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 718, 412, 412, 412, 412, 412, 412, 412, 1629, 412, 412,
  412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 791, 509, 0, 0, 0, 0, 389, 389, 389, 389, 1692, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 907, 389, 389, 389, 389, 1701, 389, 389, 389, 389, 389, 389, 389, 389, 1706, 389, 389, 389,
  389, 389, 389, 389, 389, 1181, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1402, 1403, 389, 389, 389, 389, 389,
  389, 389, 389, 1589, 0, 1591, 0, 412, 412, 412, 412, 412, 412, 412, 1718, 0, 0, 1752, 1753, 0, 1754, 0, 0, 0, 1756, 0,
  0, 0, 1760, 0, 0, 0, 0, 0, 1643, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 520, 0, 0, 0, 0, 342, 342, 1779, 342, 1781, 389,
  389, 389, 1785, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1697, 389, 389, 389, 389, 389, 1790, 389, 389, 1793,
  389, 389, 389, 389, 389, 389, 1798, 1800, 389, 1802, 1803, 412, 0, 0, 0, 53449, 5, 0, 0, 0, 731, 735, 0, 0, 0, 0, 0,
  0, 215, 216, 0, 0, 0, 445, 0, 0, 0, 0, 412, 412, 1807, 412, 412, 412, 412, 412, 412, 412, 1812, 412, 412, 1815, 412,
  412, 412, 412, 1212, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 978, 412, 412, 412, 412, 389, 389, 1862,
  389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 1872, 412, 412, 412, 412, 1228, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 1238, 389, 389, 1940, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 1950, 412, 0, 0, 1889, 0,
  0, 0, 1892, 0, 0, 0, 0, 0, 0, 0, 0, 230, 231, 0, 0, 0, 0, 0, 0, 412, 412, 412, 1985, 0, 0, 0, 0, 0, 0, 0, 0, 0, 389,
  389, 1995, 412, 2013, 2014, 0, 0, 0, 0, 0, 2020, 389, 389, 2022, 389, 2024, 389, 389, 389, 389, 389, 389, 1179, 1180,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1914, 389, 412, 412, 412, 389, 389, 2029, 412, 412, 2031, 412,
  2033, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0, 1990, 0, 1992, 389, 1994, 389, 2064, 412, 412, 412, 2068, 0, 0, 0, 389,
  389, 389, 389, 389, 389, 412, 412, 389, 412, 389, 412, 389, 412, 389, 412, 0, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 49152, 0, 254, 0, 299, 40960, 299, 0, 299, 299, 0, 299, 299, 299, 0, 0,
  0, 0, 0, 1657, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1062, 0, 0, 0, 0, 0, 348, 348, 254, 348, 348, 348, 254, 299, 299, 299,
  299, 299, 299, 299, 299, 299, 299, 348, 299, 299, 299, 299, 395, 395, 395, 395, 395, 419, 395, 395, 395, 395, 395,
  395, 395, 419, 419, 419, 419, 419, 395, 395, 419, 53449, 53449, 2, 86019, 4, 5, 0, 0, 466, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  251, 251, 251, 0, 0, 0, 0, 0, 245, 0, 0, 0, 0, 0, 245, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1316, 0, 0, 0, 0, 0, 0, 0,
  389, 612, 389, 389, 389, 389, 389, 389, 636, 389, 389, 389, 389, 389, 389, 389, 1196, 389, 389, 389, 0, 1204, 99246,
  0, 1204, 0, 815, 0, 0, 0, 0, 0, 0, 822, 0, 746, 0, 0, 0, 0, 0, 0, 215, 216, 0, 0, 0, 0, 446, 0, 0, 449, 0, 0, 876,
  389, 389, 389, 389, 882, 389, 389, 389, 890, 389, 389, 389, 389, 0, 1423, 0, 1429, 412, 412, 412, 412, 412, 412, 412,
  412, 987, 412, 412, 412, 412, 412, 412, 412, 412, 412, 976, 412, 412, 979, 412, 412, 412, 412, 1257, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 0, 1010, 0, 0, 0, 1016, 0, 0, 389, 389, 389, 1397, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1154, 389, 389, 342, 342, 342, 1548, 342, 342, 342, 342, 342, 389,
  389, 389, 389, 389, 389, 389, 389, 1787, 389, 389, 49152, 0, 0, 0, 300, 40960, 300, 0, 300, 300, 308, 300, 300, 300,
  330, 330, 349, 349, 330, 349, 349, 349, 330, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 349, 370, 370, 370,
  370, 396, 396, 396, 396, 396, 420, 396, 396, 396, 396, 396, 396, 396, 420, 420, 420, 420, 420, 396, 396, 420, 53449,
  53449, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 515, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 0, 0, 0, 0, 1655, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1846, 342, 342, 1763, 0, 0, 0, 0, 0, 1768, 0, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342,
  389, 389, 389, 389, 389, 0, 0, 0, 0, 1839, 0, 0, 0, 1843, 0, 0, 0, 0, 0, 1847, 342, 342, 342, 342, 342, 1852, 389,
  389, 389, 389, 389, 389, 1858, 389, 389, 389, 389, 389, 389, 389, 936, 389, 389, 389, 668, 99246, 876, 671, 412, 389,
  389, 389, 1863, 389, 389, 389, 389, 389, 389, 389, 412, 1871, 412, 412, 412, 412, 412, 1479, 0, 0, 0, 0, 0, 0, 0, 0,
  1483, 0, 0, 0, 0, 1901, 0, 0, 342, 342, 1902, 342, 342, 389, 389, 389, 389, 389, 389, 389, 389, 1390, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 1164, 389, 389, 389, 389, 389, 389, 1905, 389, 389, 389, 389, 389, 389, 1911, 389, 389,
  389, 389, 389, 412, 412, 412, 412, 412, 1618, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1458, 412, 412, 412,
  412, 412, 412, 412, 1917, 412, 412, 412, 412, 412, 412, 1923, 412, 412, 412, 412, 412, 0, 0, 0, 0, 389, 389, 389, 389,
  389, 389, 412, 2077, 2078, 412, 412, 0, 0, 0, 389, 389, 389, 389, 412, 412, 412, 412, 0, 0, 0, 389, 389, 389, 389,
  412, 412, 412, 412, 0, 0, 0, 0, 0, 1989, 0, 0, 0, 389, 389, 389, 2044, 389, 2045, 389, 389, 389, 412, 412, 412, 2050,
  523, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 389, 389, 389, 618, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 939, 668, 99246, 876, 671, 412, 389, 389, 1584, 389, 389, 389, 389, 389, 389, 389, 0, 0, 0, 0, 0,
  0, 0, 1297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 0, 0, 235, 0, 235, 0, 0, 0, 0, 0, 0, 0, 0, 265, 0, 0, 0, 0,
  0, 0, 1072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 264, 0, 0, 0, 0, 0, 235, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 0, 0, 0, 0,
  45056, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 309, 0, 0, 236, 331, 331, 350, 350, 331, 350, 350, 350, 331, 371, 376,
  376, 376, 376, 376, 376, 381, 376, 376, 376, 376, 376, 376, 350, 376, 376, 376, 376, 397, 397, 397, 397, 397, 421,
  397, 397, 397, 397, 397, 397, 397, 421, 421, 421, 421, 421, 397, 397, 421, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0,
  0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 509, 0, 0, 0, 0, 0, 0, 528, 0, 0, 531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1083, 1084, 0, 1086, 0, 545, 0, 0, 0, 0, 0, 0, 548, 0, 0, 0, 0, 0, 0, 0, 0, 216, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 0, 0,
  0, 0, 389, 389, 389, 389, 621, 389, 629, 389, 389, 389, 389, 389, 389, 389, 389, 1400, 389, 389, 389, 389, 389, 1406,
  389, 681, 412, 689, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 726, 0, 782, 0, 0, 0, 0, 0, 0, 789, 0,
  0, 0, 0, 0, 0, 0, 0, 1376256, 0, 1650688, 0, 0, 1519616, 0, 0, 0, 0, 839, 0, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 1686, 389, 389, 342, 342, 342, 868, 342, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1100, 0, 0, 0,
  0, 389, 929, 389, 389, 389, 389, 934, 389, 389, 389, 389, 668, 99246, 876, 671, 412, 0, 0, 2015, 2016, 0, 0, 0, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 412, 412, 1002, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 389, 389, 389, 0, 0, 1037, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 167936, 167936, 0, 0, 0, 0, 1055, 0, 0, 0, 0, 0, 0, 0, 1063, 0, 0, 0, 0, 0, 249, 0, 0, 0, 0, 249, 0,
  249, 0, 0, 45056, 1130, 342, 342, 342, 342, 342, 0, 0, 1097, 0, 0, 876, 389, 389, 389, 389, 389, 389, 389, 886, 389,
  389, 389, 389, 389, 1172, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1184, 389, 389, 389, 389, 389, 389, 389,
  389, 1868, 389, 389, 412, 412, 412, 412, 412, 0, 0, 0, 0, 389, 2058, 389, 389, 389, 2062, 412, 0, 389, 389, 389, 1373,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1393, 1394, 389, 1396, 0, 0, 0, 1204, 0, 0, 0, 0, 412,
  412, 412, 1434, 412, 412, 412, 412, 412, 412, 1957, 0, 1959, 0, 0, 0, 0, 1963, 0, 1965, 1499, 0, 0, 0, 0, 1502, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1509, 0, 0, 0, 1513, 0, 0, 1516, 0, 0, 0, 0, 0, 0, 0, 0, 1521, 1522, 0, 0, 1525, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 102400, 102400, 102400, 1678, 342, 342, 1680, 342, 342, 342, 342, 342, 342, 342, 1685, 342,
  389, 1687, 389, 389, 389, 389, 389, 1147, 389, 389, 389, 389, 389, 389, 389, 389, 1155, 389, 389, 389, 389, 389, 1161,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 0, 0, 1423, 0, 0, 0, 389, 389, 1690, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 1698, 389, 389, 389, 389, 389, 389, 389, 1389, 389, 1391, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  1912, 389, 389, 389, 412, 412, 412, 1709, 389, 389, 389, 0, 0, 0, 0, 412, 1713, 412, 412, 412, 1716, 412, 412, 412,
  412, 1243, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1255, 412, 412, 1730, 412, 412, 412, 412, 1733, 412, 412,
  412, 1735, 412, 412, 412, 1738, 0, 0, 1765, 0, 0, 0, 0, 0, 1770, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 1357, 342, 1778, 342, 342, 342, 389, 389, 389, 389, 389, 389, 389, 389, 1788, 389, 389, 389, 389, 389,
  389, 1195, 389, 1197, 389, 389, 0, 1204, 99246, 0, 1204, 412, 412, 1819, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 0,
  0, 0, 0, 1964, 0, 389, 389, 389, 389, 1970, 389, 1972, 1973, 1974, 389, 412, 412, 412, 412, 1980, 412, 412, 412, 412,
  1919, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0, 1962, 0, 0, 0, 1982, 1983, 1984, 412, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389, 389, 624, 389, 389, 637, 389, 389, 389, 412, 2051, 412, 412, 412, 0, 0, 0, 0,
  389, 389, 389, 389, 389, 389, 412, 412, 2087, 2088, 389, 412, 389, 412, 389, 412, 0, 0, 0, 0, 0, 0, 0, 389, 389, 389,
  389, 389, 389, 389, 2026, 0, 0, 0, 264, 281, 0, 0, 0, 0, 0, 0, 281, 0, 0, 0, 45056, 49152, 0, 0, 0, 301, 40960, 301,
  0, 301, 301, 0, 301, 301, 301, 332, 332, 351, 351, 332, 351, 351, 351, 332, 372, 372, 372, 372, 372, 372, 372, 372,
  372, 372, 351, 372, 372, 372, 386, 398, 398, 398, 398, 398, 422, 398, 398, 398, 398, 398, 398, 398, 422, 422, 422,
  422, 422, 398, 398, 422, 53449, 53449, 2, 86019, 4, 5, 0, 0, 540, 0, 0, 0, 0, 0, 0, 0, 0, 0, 503, 540, 0, 0, 0, 498,
  0, 0, 0, 0, 503, 0, 0, 0, 0, 0, 0, 0, 503, 412, 683, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 1224, 0, 0, 741, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 236, 237, 412, 970, 412, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1451, 412, 412, 412, 984, 412, 412, 412, 412, 412, 412, 994, 412,
  412, 412, 412, 412, 0, 0, 0, 389, 389, 2073, 2074, 389, 389, 412, 412, 412, 412, 412, 1004, 412, 412, 412, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1340, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 389, 389,
  389, 1145, 1146, 389, 389, 389, 1150, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1913, 389, 389, 412, 412, 412,
  1292, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 544, 389, 389, 389, 389, 1398, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 1404, 389, 389, 389, 389, 389, 389, 1409, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 0, 0, 99246, 0, 0, 0, 0, 1487, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 0, 0, 0, 0, 342, 342, 342, 342,
  342, 342, 1541, 342, 342, 342, 342, 342, 342, 0, 757, 0, 0, 873, 756, 0, 0, 0, 0, 389, 389, 389, 389, 1558, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1417, 389, 389, 0, 412, 1601, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 1627, 0, 0, 0, 0, 1669, 0, 0, 0, 0, 0, 0, 0, 1675, 0, 0, 0, 0, 0, 254, 0, 0,
  0, 261, 0, 0, 0, 0, 0, 0, 0, 1081, 0, 0, 0, 0, 0, 0, 0, 0, 504, 0, 0, 0, 0, 0, 511, 0, 342, 342, 1679, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1689, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1420, 0, 0, 0, 0, 1767, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342,
  342, 342, 342, 342, 1115, 342, 0, 0, 0, 2042, 389, 389, 389, 389, 389, 389, 389, 389, 2048, 412, 412, 412, 412, 412,
  1723, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1250, 1251, 412, 412, 412, 412, 238, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 1354, 342, 342, 342, 342, 342, 342, 871, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1518, 0, 0, 0, 0, 0, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 310, 0, 0, 318, 333, 333, 341, 352,
  352, 333, 352, 352, 352, 333, 373, 373, 373, 373, 373, 373, 373, 373, 373, 373, 352, 373, 373, 373, 373, 399, 399,
  399, 399, 399, 423, 399, 399, 399, 399, 399, 399, 399, 423, 423, 423, 423, 423, 399, 399, 423, 53449, 53685, 2, 86019,
  4, 5, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 412, 684, 412, 412, 697, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 714, 412, 412, 412, 412, 0, 0, 783, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 256, 0,
  258, 0, 799, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 269, 0, 389, 389, 389, 389, 914, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 927, 982, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 995, 412, 412, 412, 412, 412, 701,
  412, 705, 412, 710, 412, 713, 412, 412, 724, 412, 412, 412, 1226, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 1253, 412, 412, 412, 1241, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  1728, 0, 0, 0, 1282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151552, 151552, 0, 0, 1293, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 342, 342, 342, 1332, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 753, 389, 1384, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1582, 1408, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 0, 1204, 99246, 0, 1204, 1421, 0, 0, 1204, 0, 1427, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 1247,
  412, 412, 412, 412, 412, 412, 412, 412, 1632, 1633, 0, 0, 0, 0, 0, 0, 0, 0, 1433600, 1556480, 0, 1892352, 0, 0,
  1470464, 0, 412, 412, 412, 1465, 412, 412, 412, 1469, 412, 412, 412, 412, 412, 412, 412, 412, 1724, 412, 412, 412,
  412, 412, 412, 412, 412, 1734, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 0, 1742, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  540, 0, 0, 0, 0, 239, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 239, 240, 0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0,
  0, 245, 246, 0, 0, 0, 0, 0, 251, 0, 49152, 267, 0, 0, 0, 40960, 0, 239, 0, 0, 0, 0, 0, 0, 334, 340, 353, 353, 340,
  353, 353, 353, 334, 340, 340, 340, 340, 340, 340, 340, 340, 382, 340, 353, 383, 382, 340, 340, 400, 400, 400, 400,
  400, 424, 400, 400, 400, 400, 400, 400, 400, 424, 424, 424, 424, 424, 400, 400, 424, 53449, 53449, 2, 86019, 4, 5, 0,
  0, 0, 481, 0, 0, 0, 0, 0, 0, 488, 0, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 290, 0, 0, 0, 45056, 496, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 780, 0, 0, 0, 0, 530, 0, 0, 0, 0, 0, 0, 0, 459, 0, 542, 0, 0, 0, 0, 342, 342, 342, 342, 342, 846,
  342, 342, 342, 342, 342, 342, 0, 0, 0, 0, 0, 876, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 1395, 389, 563, 0, 481, 0, 0, 342, 566, 342, 342, 342, 575, 342, 342, 583, 342, 342, 342, 342, 342, 857, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 1365, 342, 342, 342, 342, 342, 342, 589, 342, 342, 342, 596, 342, 0, 0,
  563, 0, 0, 0, 546, 0, 0, 0, 0, 0, 1743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1507328, 0, 0, 0, 459, 0, 601, 0, 0, 542,
  0, 605, 0, 0, 546, 459, 609, 0, 0, 0, 0, 0, 267, 0, 0, 0, 0, 267, 0, 267, 0, 0, 45056, 0, 0, 0, 0, 389, 613, 389, 389,
  389, 625, 389, 389, 638, 389, 389, 389, 389, 389, 389, 389, 1694, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  906, 389, 389, 389, 389, 389, 648, 389, 389, 389, 389, 663, 389, 389, 389, 389, 0, 412, 412, 673, 412, 412, 412, 412,
  1244, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1254, 412, 412, 685, 412, 412, 698, 412, 412, 412, 708, 412, 412,
  412, 412, 723, 412, 412, 412, 412, 1261, 1262, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 1009, 0, 0, 0, 1015, 0,
  0, 0, 0, 0, 0, 742, 743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 561, 0, 0, 0, 0, 742, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 741, 0, 0, 0, 0, 0, 816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342, 1777, 412, 412, 972, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1269, 412, 0, 0, 1021, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 523, 0, 0, 0, 1078, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 389, 389, 0, 0, 0, 0, 1336, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 777, 0, 779, 0, 0, 0, 0, 1347, 342, 1349, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1364, 342,
  342, 342, 342, 342, 342, 0, 389, 389, 1372, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1170,
  389, 389, 0, 0, 0, 1204, 0, 0, 0, 0, 412, 412, 1433, 412, 412, 412, 412, 412, 0, 2054, 0, 2056, 389, 389, 389, 389,
  389, 389, 412, 1462, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 1475, 412,
  412, 412, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1898, 0, 1485, 0, 0, 1488, 0, 0, 0, 1491, 0, 0, 1493, 0, 0,
  0, 0, 1498, 0, 0, 0, 0, 1526, 0, 0, 0, 0, 1530, 0, 0, 0, 0, 0, 1535, 342, 342, 1547, 342, 342, 342, 342, 342, 342,
  389, 389, 389, 389, 389, 389, 389, 389, 1859, 389, 389, 389, 1556, 389, 389, 389, 389, 1560, 389, 1562, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 918, 389, 389, 389, 389, 389, 389, 389, 389, 1569, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 1580, 389, 389, 389, 389, 389, 389, 1388, 389, 389, 389, 1392, 389, 389, 389, 389, 389, 389, 389, 389,
  1413, 389, 389, 389, 389, 389, 389, 0, 0, 0, 0, 412, 412, 412, 412, 1715, 412, 412, 412, 412, 412, 412, 1603, 412,
  1605, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1612, 0, 0, 0, 1642, 0, 0, 0, 0, 0, 0, 1646, 1647, 0, 0, 0, 0, 0,
  0, 1285, 0, 0, 0, 0, 0, 0, 0, 0, 0, 459, 460, 461, 0, 0, 0, 0, 0, 0, 0, 0, 1656, 0, 0, 0, 1659, 0, 0, 1661, 0, 0, 0,
  0, 0, 0, 1296, 0, 0, 0, 0, 0, 0, 1302, 0, 0, 1665, 0, 0, 1668, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163840, 0, 0, 0,
  0, 0, 0, 412, 412, 412, 1721, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1926, 412, 0, 389,
  1791, 1792, 389, 389, 389, 389, 1796, 389, 389, 389, 389, 389, 389, 389, 412, 2004, 412, 412, 412, 412, 412, 412, 412,
  1805, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1813, 1814, 412, 412, 412, 412, 412, 1732, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 0, 0, 0, 1635, 0, 0, 0, 0, 0, 412, 1818, 412, 412, 412, 412, 412, 412, 412, 0, 0, 1827, 0, 0,
  0, 0, 0, 0, 1310, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1746, 0, 0, 0, 0, 0, 1848, 1849, 342, 342, 342, 389, 389, 389, 389,
  1855, 1856, 1857, 389, 389, 389, 389, 389, 389, 389, 389, 1946, 389, 412, 412, 412, 412, 412, 412, 955, 412, 412, 412,
  412, 965, 412, 412, 412, 412, 389, 389, 389, 389, 1864, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 1873, 1874,
  1875, 412, 412, 412, 412, 412, 412, 412, 412, 1882, 412, 412, 412, 412, 412, 0, 2070, 0, 389, 389, 389, 389, 389, 389,
  412, 412, 389, 1906, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 412, 1821, 412, 412,
  412, 0, 0, 0, 0, 0, 0, 0, 0, 1894, 0, 0, 0, 0, 0, 0, 412, 412, 412, 1918, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 0, 0, 1634, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389, 1942, 389, 389, 389, 389, 389, 412, 412, 412, 412, 412,
  412, 412, 2035, 412, 412, 0, 2038, 0, 0, 1952, 412, 412, 412, 412, 412, 0, 1958, 0, 0, 1961, 0, 0, 0, 0, 0, 0, 284, 0,
  0, 0, 0, 0, 0, 0, 0, 45056, 389, 389, 389, 1969, 389, 389, 389, 389, 389, 389, 412, 412, 412, 1979, 412, 412, 412,
  412, 1466, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1472, 412, 412, 412, 389, 389, 389, 389, 2000,
  389, 2002, 412, 412, 412, 412, 412, 412, 412, 2010, 412, 412, 412, 412, 1956, 412, 0, 0, 0, 1960, 0, 0, 0, 0, 0, 0, 0,
  1311, 0, 0, 0, 0, 0, 0, 0, 1318, 2012, 0, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389, 389, 389, 389, 389, 635, 389, 389,
  389, 412, 2065, 2066, 412, 412, 0, 0, 0, 389, 389, 389, 389, 389, 389, 412, 412, 389, 412, 389, 412, 2091, 2092, 389,
  412, 0, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389, 2023, 389, 2025, 389, 0, 0, 0, 241, 242, 243, 244, 0, 0, 0, 0, 0, 0, 0,
  251, 0, 0, 0, 0, 342, 342, 342, 342, 342, 847, 342, 342, 342, 342, 342, 342, 342, 0, 467, 510, 0, 0, 467, 0, 0, 0, 0,
  241, 243, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 241664, 0, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243,
  45056, 49152, 0, 242, 244, 243, 40960, 243, 244, 243, 243, 0, 243, 243, 319, 335, 335, 354, 354, 361, 354, 354, 354,
  365, 374, 374, 374, 374, 374, 374, 374, 374, 374, 374, 354, 374, 374, 374, 374, 401, 401, 401, 401, 401, 425, 401,
  401, 401, 401, 401, 401, 401, 425, 425, 425, 425, 425, 401, 401, 425, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 451, 452,
  453, 454, 0, 0, 0, 0, 0, 0, 0, 0, 463, 0, 465, 0, 0, 0, 0, 564, 342, 342, 342, 570, 342, 342, 578, 342, 342, 342, 587,
  342, 342, 342, 342, 594, 342, 342, 453, 0, 0, 599, 0, 0, 0, 525, 0, 0, 0, 0, 0, 0, 0, 0, 0, 525, 0, 0, 541, 0, 0, 0,
  0, 0, 1932, 0, 0, 1935, 0, 0, 0, 0, 342, 389, 389, 389, 389, 389, 389, 1148, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 1203, 1204, 99246, 1208, 1204, 0, 0, 0, 0, 603, 0, 561, 0, 525, 525, 0, 0, 0, 465, 493, 0, 0, 0, 0,
  342, 342, 342, 342, 845, 342, 849, 342, 851, 342, 342, 342, 342, 342, 389, 389, 1854, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 920, 389, 389, 389, 389, 389, 561, 0, 0, 561, 389, 389, 389, 619, 622, 389, 630, 389, 389, 389,
  644, 647, 389, 389, 389, 656, 660, 389, 389, 389, 389, 389, 0, 412, 412, 412, 412, 679, 682, 412, 690, 412, 412, 412,
  704, 707, 412, 412, 412, 716, 720, 412, 412, 412, 412, 412, 1920, 412, 1921, 1922, 412, 412, 412, 412, 412, 412, 0, 0,
  0, 0, 0, 0, 0, 1482, 0, 0, 814, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 813, 342, 342, 342, 856, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 862, 342, 342, 342, 412, 412, 1003, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1993, 389, 389, 1067, 0, 1069, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1077, 0, 0, 1091, 0, 0, 1094, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1315, 0, 0, 0, 0, 342, 342, 342, 1134, 342, 342, 0, 1032, 0, 0, 0, 876, 389, 389, 389, 389, 389,
  389, 389, 887, 389, 389, 389, 389, 897, 389, 1142, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 1804, 1240, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 725, 0, 0, 1272, 0,
  731, 0, 0, 0, 1274, 0, 735, 0, 0, 0, 0, 0, 0, 285, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 0, 0, 0, 0, 1294, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 825, 0, 0, 0, 0, 1500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 560, 562, 0, 0, 0, 1592, 0, 1207,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1726, 412, 412, 412, 412, 0, 1740, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 812, 0, 412, 412, 412, 1808, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 722, 412, 412,
  412, 1928, 0, 0, 1931, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 389, 389, 389, 389, 389, 389, 1573, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 1153, 389, 389, 389, 389, 389, 1939, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412,
  412, 1949, 412, 412, 412, 412, 1630, 412, 412, 0, 0, 0, 0, 0, 1637, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 0,
  126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176562, 176562, 176562, 176562, 389, 1967, 389, 389, 389, 1971, 389, 389,
  389, 389, 412, 1977, 412, 412, 412, 1981, 49152, 283, 0, 0, 0, 40960, 0, 0, 0, 0, 311, 0, 0, 0, 0, 0, 0, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 1267, 412, 412, 412, 0, 402, 402, 402, 402, 426, 402, 402, 402, 402, 402,
  402, 402, 426, 426, 426, 426, 426, 402, 402, 426, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 467, 0, 0, 0, 0, 0, 0, 0, 0,
  251, 251, 251, 0, 0, 0, 0, 0, 283, 0, 0, 0, 0, 283, 0, 283, 0, 0, 45056, 0, 0, 0, 0, 785, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 796, 0, 800, 0, 0, 744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1288, 0, 0, 0, 412, 1001, 412, 412, 412, 412, 412, 0,
  0, 1011, 0, 0, 0, 1017, 0, 0, 0, 0, 0, 102400, 102400, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 1028, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1070, 0, 0, 0, 0, 0, 0, 0, 0, 0, 801, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1330, 0, 0, 1012, 0, 0, 0, 0, 0, 1018, 0, 0,
  0, 0, 0, 0, 0, 0, 287, 0, 0, 0, 0, 287, 0, 45056, 1358, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 389, 389, 1688, 1422, 0, 0, 1204, 0, 1428, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 1810, 412,
  412, 412, 412, 412, 412, 412, 412, 1880, 412, 412, 412, 412, 412, 412, 412, 412, 1453, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 1887, 0, 0, 1429, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 1883, 412, 412, 412, 412, 412, 412, 412, 1616, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  996, 412, 412, 412, 0, 1929, 0, 0, 0, 0, 0, 1934, 0, 0, 1936, 0, 0, 342, 389, 389, 389, 389, 389, 389, 1944, 389, 389,
  389, 412, 1948, 412, 412, 412, 412, 0, 0, 0, 2081, 389, 389, 389, 2083, 412, 412, 412, 0, 0, 0, 0, 516, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 864256, 251, 0, 0, 0, 549, 0, 0, 342, 342, 342, 342, 342, 576, 342, 342, 342, 342, 342, 342,
  598, 0, 0, 0, 0, 548, 0, 0, 0, 548, 549, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 549, 0, 0, 0, 0, 0, 0, 0, 412, 686, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1927, 727, 0, 0, 0, 53449, 5, 0, 0, 0, 732, 736, 0,
  0, 0, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 1599, 412, 412, 412, 412, 1877, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 1252, 412, 412, 412, 49152, 0, 0, 246, 245, 40960, 245, 246, 245, 245, 0, 245, 245, 245,
  0, 0, 0, 0, 0, 163840, 163840, 163840, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 501, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1275, 0, 0, 0, 0, 0, 355, 355, 0, 355, 355, 355, 246, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 355, 245, 245,
  245, 245, 403, 403, 403, 403, 403, 427, 403, 403, 403, 403, 403, 403, 403, 427, 427, 427, 427, 427, 403, 403, 427,
  53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0, 468, 469, 0, 0, 0, 0, 0, 0, 251, 251, 251, 0, 0, 0, 0, 0, 342, 342, 342,
  342, 342, 573, 342, 342, 342, 342, 342, 342, 342, 1683, 342, 342, 342, 342, 342, 389, 389, 389, 389, 1786, 389, 389,
  389, 389, 389, 389, 0, 0, 0, 529, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 468, 0, 0, 0, 0, 342, 342, 342, 844, 342, 342, 848,
  342, 342, 342, 342, 342, 342, 342, 1121, 342, 342, 342, 342, 342, 342, 342, 1129, 342, 590, 342, 342, 595, 342, 342,
  0, 560, 0, 0, 0, 600, 0, 0, 0, 0, 0, 342, 342, 342, 342, 342, 574, 342, 342, 342, 342, 342, 342, 597, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1030, 0, 0, 0, 1033, 0, 0, 520, 0, 0, 0, 604, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1747, 0, 0, 0, 0, 562,
  0, 0, 562, 389, 389, 389, 389, 389, 389, 389, 633, 389, 389, 389, 389, 389, 389, 389, 665, 389, 389, 0, 412, 412, 412,
  412, 678, 649, 651, 389, 389, 661, 389, 389, 389, 389, 389, 0, 412, 412, 412, 412, 412, 389, 389, 412, 53449, 53449,
  2, 86019, 4, 5, 0, 0, 0, 0, 767, 768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1351680, 0, 1474560, 781, 0, 0, 0, 0, 0,
  0, 0, 0, 790, 0, 0, 0, 0, 795, 0, 0, 0, 0, 342, 342, 843, 342, 342, 342, 342, 342, 342, 342, 342, 342, 389, 389, 1551,
  389, 389, 389, 389, 0, 0, 0, 0, 818, 819, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1758, 0, 0, 0, 0, 342, 855, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1127, 342, 342, 0, 790, 876, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 1581, 389, 389, 389, 389, 389, 901, 903, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 0, 412, 412, 412, 412, 412, 969, 971, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  998, 412, 342, 1132, 342, 342, 1135, 342, 0, 0, 0, 0, 0, 876, 389, 389, 389, 389, 389, 389, 389, 888, 389, 389, 389,
  389, 389, 1141, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1189, 389, 389, 1158, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1260, 412,
  412, 412, 412, 412, 412, 1266, 412, 1268, 412, 412, 0, 0, 0, 0, 1891, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1532, 0, 0, 0,
  0, 1304, 0, 0, 0, 1308, 0, 0, 0, 0, 0, 1314, 0, 0, 0, 0, 0, 0, 412, 1593, 412, 412, 412, 412, 412, 1598, 412, 412, 0,
  0, 0, 1335, 0, 1337, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1836, 0, 0, 0, 0, 0, 1345, 0, 0, 1348, 342, 1350, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 1122, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1360, 342, 342, 342, 1362, 1363,
  342, 342, 342, 342, 342, 342, 342, 0, 0, 0, 0, 0, 0, 535, 0, 0, 0, 1370, 389, 389, 389, 1374, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 0, 412, 412, 672, 412, 412, 0, 0, 0, 1204, 0, 0, 0, 0, 1431, 412, 412, 412, 1435, 412, 412,
  412, 412, 696, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1925, 412, 412, 0, 412, 412, 412, 1454,
  1455, 412, 1457, 412, 412, 412, 412, 412, 412, 412, 412, 1461, 1510, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 828,
  0, 0, 1524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 389, 1938, 389, 389, 389, 1557, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 1186, 389, 389, 1600, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 981, 0, 0, 1654, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 510, 0, 0, 389, 1710, 389, 389, 0, 0, 0, 0,
  412, 412, 412, 412, 412, 412, 412, 412, 1879, 412, 412, 412, 412, 1884, 412, 412, 412, 0, 1751, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1049, 1050, 0, 0, 1930, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 1937, 389, 389, 389, 389, 389, 1194,
  389, 389, 389, 389, 389, 0, 1204, 99246, 0, 1204, 412, 412, 412, 1955, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1895,
  1896, 0, 0, 1899, 412, 412, 412, 2067, 412, 2069, 0, 2071, 389, 389, 389, 389, 389, 389, 412, 412, 389, 412, 2089,
  2090, 389, 412, 389, 412, 0, 0, 0, 0, 0, 0, 0, 389, 2021, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1563, 389, 389,
  389, 389, 389, 389, 389, 389, 389, 1576, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1588, 0, 0, 0, 0, 0, 0, 0, 772,
  0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 114979, 49152, 0, 0, 0, 302, 40960, 302, 0, 302, 302, 0, 302,
  302, 320, 0, 0, 0, 0, 0, 208896, 208896, 208896, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 786, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 356, 356, 0, 356, 356, 356, 0, 320, 320, 320, 320, 320, 320, 320, 320,
  320, 320, 356, 320, 320, 384, 387, 404, 404, 404, 404, 404, 428, 404, 404, 404, 404, 404, 404, 404, 428, 428, 428,
  428, 428, 404, 404, 428, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0, 555, 0, 0, 0, 0, 555, 0, 0, 536, 0, 555, 0, 0, 0,
  0, 0, 342, 342, 342, 342, 572, 342, 342, 342, 342, 342, 342, 0, 0, 0, 0, 0, 0, 835, 874, 875, 0, 0, 0, 0, 0, 389, 614,
  389, 389, 389, 389, 389, 389, 639, 389, 389, 389, 389, 389, 389, 389, 1704, 389, 389, 389, 389, 1707, 389, 389, 389,
  389, 389, 389, 389, 1587, 389, 389, 0, 1589, 0, 0, 0, 0, 0, 0, 787, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1326, 0, 0, 0, 0, 0,
  739, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1034, 0, 0, 0, 0, 769, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1519, 0,
  0, 0, 0, 0, 831, 0, 0, 0, 0, 0, 0, 835, 0, 0, 0, 0, 0, 0, 0, 1517, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1771, 1772, 1773, 0,
  342, 1776, 342, 835, 0, 876, 389, 389, 389, 389, 389, 883, 389, 389, 892, 389, 389, 896, 389, 389, 389, 389, 389,
  1399, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1407, 911, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 1419, 0, 0, 1053, 0, 0, 0, 0, 1058, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  608, 0, 0, 0, 0, 389, 389, 389, 389, 1160, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1579, 389, 389,
  389, 0, 0, 1306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 778, 0, 0, 0, 389, 1371, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 908, 389, 389, 0, 0, 0, 1204, 0, 0, 0, 0, 412, 1432, 412, 412, 412, 412, 412, 412, 956,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 1622, 412, 412, 412, 412, 412, 412, 1536, 0, 0, 342, 342, 342, 342, 342,
  342, 342, 342, 342, 342, 342, 342, 1545, 389, 389, 389, 1570, 389, 389, 389, 389, 389, 389, 1577, 389, 389, 389, 389,
  389, 389, 389, 389, 1695, 389, 389, 389, 389, 389, 389, 389, 389, 389, 938, 389, 668, 99246, 876, 671, 945, 1613, 412,
  412, 412, 412, 412, 412, 1620, 412, 412, 412, 412, 412, 412, 412, 412, 974, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 977, 412, 412, 412, 980, 412, 412, 0, 0, 1667, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 794, 0, 0, 412, 412, 412,
  1731, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 0, 1008, 0, 0, 0, 1014, 0, 0, 0, 0, 1837, 0, 0, 0, 1840,
  0, 0, 0, 0, 1845, 0, 0, 0, 342, 342, 342, 342, 342, 342, 342, 1542, 342, 342, 342, 1544, 342, 342, 342, 342, 342,
  1851, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1801, 389, 389, 412, 389, 389, 389, 389, 389, 1865,
  389, 389, 389, 389, 389, 412, 412, 412, 412, 412, 412, 1271, 0, 1273, 0, 0, 1481, 0, 0, 0, 0, 412, 1888, 0, 0, 1890,
  0, 0, 0, 0, 0, 0, 0, 0, 1897, 0, 0, 0, 0, 0, 278528, 278528, 278528, 0, 0, 2, 86019, 4, 2191798, 0, 0, 0, 0, 0, 1295,
  0, 0, 0, 1299, 0, 1300, 1301, 0, 0, 0, 0, 0, 342, 565, 342, 342, 342, 342, 342, 342, 342, 342, 342, 389, 1550, 389,
  389, 389, 389, 389, 389, 389, 389, 1941, 389, 1943, 389, 389, 389, 389, 412, 412, 412, 412, 412, 1951, 412, 1953, 412,
  412, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1060864, 0, 0, 0, 0, 0, 0, 0, 389, 2043, 389, 389, 389, 389, 389, 389,
  389, 412, 2049, 412, 412, 412, 412, 1820, 1822, 412, 1824, 1825, 0, 0, 0, 0, 1829, 0, 1831, 49152, 0, 0, 0, 0, 40960,
  0, 0, 0, 0, 0, 0, 0, 0, 336, 336, 357, 357, 336, 357, 357, 357, 336, 375, 375, 336, 336, 336, 336, 336, 375, 336, 336,
  336, 336, 336, 336, 357, 336, 336, 385, 388, 405, 405, 405, 405, 405, 429, 405, 405, 405, 405, 405, 405, 405, 429,
  429, 429, 429, 429, 405, 405, 429, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 497, 0, 0, 0, 0, 0, 480, 0, 506, 0, 0, 0, 0,
  0, 480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1066, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 0, 0, 0,
  0, 864256, 864256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 489, 0, 491, 0, 493, 0, 0, 342, 342, 342, 593, 342, 342, 342, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1126876, 1126876, 1126876, 0, 0, 0, 0, 557, 610, 0, 389, 615, 389, 389, 389, 389, 389, 634, 640,
  643, 389, 389, 389, 389, 389, 902, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 0, 0, 0, 1590, 0, 1202, 389, 389,
  389, 657, 389, 389, 389, 389, 389, 389, 0, 412, 412, 675, 412, 412, 412, 412, 1878, 412, 412, 412, 412, 1881, 412,
  412, 412, 412, 412, 412, 954, 412, 412, 412, 412, 412, 412, 412, 412, 412, 993, 412, 412, 412, 412, 412, 412, 0, 740,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 750, 0, 0, 0, 0, 0, 342, 342, 342, 569, 342, 342, 342, 342, 342, 342, 342, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 755, 0, 0, 758, 0, 0, 0, 0, 0, 251, 251, 0, 765, 0, 0, 0, 0, 389, 389, 389, 389, 389, 626,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 1869, 389, 412, 412, 412, 412, 412, 0, 0, 801, 0, 0, 0, 0, 0, 806, 0, 0,
  0, 0, 0, 0, 0, 447, 517, 518, 519, 0, 0, 0, 0, 0, 0, 0, 0, 817, 0, 0, 820, 0, 0, 740, 0, 0, 0, 0, 827, 0, 0, 0, 0,
  389, 389, 389, 389, 389, 627, 389, 389, 389, 389, 389, 389, 389, 389, 667, 389, 0, 412, 412, 412, 412, 412, 829, 0, 0,
  0, 0, 0, 0, 0, 0, 836, 0, 0, 0, 0, 0, 0, 0, 1658, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1098, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 841,
  342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1366, 1367, 342, 342, 342, 872, 0, 876, 877, 389, 389, 881,
  389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1202, 1204, 99246, 1207, 1204, 389, 912, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 923, 924, 389, 389, 389, 389, 389, 389, 389, 1867, 389, 389, 389, 412, 412, 412, 412, 412, 0,
  0, 0, 389, 2072, 389, 389, 389, 389, 412, 2076, 412, 412, 949, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 1449, 412, 412, 1051, 0, 0, 0, 0, 1056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1060864, 792, 0, 0, 0, 1088, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1102, 0, 0, 0, 0, 389, 389, 389, 389, 389, 628, 389, 389, 389, 389, 389, 389, 389,
  389, 905, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1151, 389, 389, 389, 389, 389, 389, 0, 0, 1105, 0, 0, 0, 0, 0,
  342, 342, 342, 342, 1113, 342, 342, 342, 342, 342, 389, 1783, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  922, 389, 389, 389, 389, 342, 342, 342, 1119, 342, 342, 342, 342, 342, 1123, 342, 342, 342, 342, 342, 342, 0, 1106, 0,
  1022, 1022, 876, 1138, 1139, 389, 1140, 389, 389, 1144, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 909, 389, 389, 1157, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1167, 389, 389, 1171, 389, 389, 389, 389,
  389, 1411, 389, 389, 389, 389, 389, 389, 389, 389, 389, 0, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 975, 412,
  412, 412, 412, 412, 412, 412, 1190, 1191, 389, 389, 389, 389, 389, 389, 389, 389, 389, 0, 1204, 99246, 0, 1204, 412,
  412, 1242, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1737, 412, 0, 1279, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1677, 1319, 0, 0, 0, 0, 1321, 0, 0, 0, 0, 0, 1327, 0, 0, 0, 0, 0, 0, 1322, 0, 0, 0, 0, 0,
  1328, 0, 0, 0, 0, 0, 1346, 0, 342, 342, 342, 342, 342, 342, 1353, 342, 342, 342, 342, 342, 342, 744, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1531, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1379, 389, 389, 1382, 389,
  389, 389, 389, 1410, 389, 389, 1412, 389, 389, 389, 389, 389, 389, 389, 0, 0, 0, 0, 412, 412, 1714, 412, 412, 412,
  412, 412, 412, 1468, 412, 412, 412, 412, 412, 412, 412, 412, 1474, 0, 1423, 0, 1204, 0, 0, 1429, 0, 412, 412, 412,
  412, 412, 412, 412, 412, 1007, 0, 0, 0, 0, 1013, 0, 0, 0, 1019, 412, 412, 412, 1440, 412, 412, 1443, 412, 412, 412,
  412, 412, 412, 412, 1450, 412, 412, 412, 412, 1986, 0, 1987, 0, 0, 0, 0, 0, 0, 389, 389, 389, 389, 389, 623, 389, 389,
  389, 389, 389, 389, 1452, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1008, 0, 1511, 0,
  0, 1514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1648, 0, 0, 1651, 0, 0, 0, 342, 342, 342, 342, 1540, 342, 342, 342, 342,
  1543, 342, 342, 342, 342, 342, 389, 1853, 389, 389, 389, 389, 389, 389, 389, 1860, 389, 1555, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 1564, 389, 389, 389, 389, 389, 389, 389, 916, 389, 389, 389, 389, 389, 389, 926, 389, 1567,
  1568, 389, 389, 389, 389, 389, 389, 1575, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1198, 389, 0, 1204, 99246, 0,
  1204, 0, 1666, 0, 0, 0, 1670, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1581056, 0, 0, 0, 0, 342, 342, 342, 342, 1681, 342,
  342, 342, 342, 342, 342, 342, 342, 389, 389, 389, 389, 389, 389, 389, 1945, 389, 389, 1947, 412, 412, 412, 412, 412,
  389, 389, 412, 53449, 53685, 2, 86019, 4, 5, 0, 0, 389, 389, 389, 1691, 389, 1693, 389, 389, 389, 1696, 389, 389, 389,
  389, 389, 389, 389, 389, 389, 1975, 412, 412, 412, 412, 412, 412, 953, 959, 412, 412, 412, 412, 412, 412, 412, 412,
  989, 412, 412, 412, 412, 412, 412, 412, 412, 990, 412, 412, 412, 412, 412, 412, 412, 412, 991, 992, 412, 412, 412,
  412, 412, 412, 412, 1216, 1217, 412, 412, 412, 1221, 412, 412, 412, 389, 389, 1711, 389, 0, 0, 0, 0, 412, 412, 412,
  412, 412, 412, 1717, 412, 412, 412, 693, 412, 412, 412, 412, 709, 711, 412, 412, 721, 412, 412, 412, 412, 695, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1625, 412, 412, 412, 1719, 412, 412, 412, 1722, 412, 412, 412,
  412, 412, 412, 412, 412, 412, 412, 412, 1233, 412, 412, 412, 412, 412, 1806, 412, 412, 412, 412, 412, 412, 1811, 412,
  412, 412, 412, 412, 412, 412, 1215, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1265, 412, 412, 412, 412, 412, 0, 0,
  1832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1065, 0, 342, 342, 342, 1850, 342, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 668, 0, 0, 671, 412, 389, 1861, 389, 389, 389, 389, 1866, 389, 389, 389, 389, 412, 412, 412, 412,
  412, 412, 1606, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1608, 412, 412, 412, 412, 412, 0, 1900, 0, 0, 0, 0,
  342, 342, 342, 342, 342, 389, 389, 389, 389, 1904, 412, 1916, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1924, 412,
  412, 412, 0, 0, 0, 0, 2017, 0, 2019, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1799, 389, 389, 389, 412,
  389, 2028, 412, 412, 412, 412, 412, 412, 412, 412, 412, 2037, 0, 0, 0, 0, 0, 0, 1490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2039, 0, 2041, 389, 389, 389, 389, 389, 389, 2046, 2047, 389, 412, 412, 412,
  412, 412, 986, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 963, 412, 412, 412, 967, 412, 412, 412, 2052, 2053,
  412, 0, 0, 2055, 0, 389, 389, 389, 389, 389, 389, 412, 2030, 412, 412, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0,
  1638, 0, 0, 389, 2085, 412, 2086, 389, 412, 389, 412, 389, 412, 389, 412, 0, 0, 0, 0, 0, 0, 0, 1893, 0, 0, 0, 0, 0, 0,
  0, 457, 0, 0, 0, 0, 0, 0, 0, 0, 231, 277, 0, 0, 0, 0, 0, 0, 0, 0, 0, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1388544, 0, 0, 49152, 0, 286, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 337, 337, 358, 358, 362, 358, 358, 358, 362, 337,
  337, 337, 337, 337, 337, 337, 337, 337, 337, 358, 337, 337, 337, 337, 406, 406, 406, 406, 406, 430, 406, 406, 406,
  406, 406, 406, 406, 430, 430, 430, 430, 430, 406, 406, 430, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 499, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 215, 215, 215, 499, 0, 0, 0, 389, 389, 389, 389, 389, 389, 631, 389, 389, 389, 389,
  389, 389, 389, 389, 1705, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1182, 389, 389, 389, 389, 389, 389, 412, 412,
  691, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1885, 412, 412, 0, 0, 0, 802, 0, 803, 0, 0, 0,
  0, 0, 0, 803, 0, 0, 0, 0, 0, 342, 567, 342, 342, 342, 342, 342, 342, 584, 342, 342, 0, 0, 0, 0, 1079, 0, 0, 0, 0, 0,
  0, 0, 0, 1085, 0, 1087, 1173, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1183, 389, 389, 389, 389, 389, 389, 389,
  389, 1797, 389, 389, 389, 389, 389, 389, 412, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 2032, 412, 2034,
  412, 412, 412, 0, 0, 0, 0, 412, 1225, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1234, 412, 412, 412, 412, 699,
  412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1220, 412, 412, 412, 412, 0, 0, 0, 0, 1283, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1662, 0, 0, 1664, 0, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1381, 389,
  389, 389, 389, 389, 1559, 389, 1561, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 919, 389, 389, 389, 389, 389,
  0, 0, 1424, 1204, 0, 0, 0, 1430, 412, 412, 412, 412, 412, 412, 412, 412, 1229, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 1232, 412, 412, 412, 412, 412, 412, 389, 389, 1907, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412,
  412, 412, 951, 412, 412, 960, 412, 412, 964, 412, 412, 412, 412, 412, 412, 1271, 0, 1273, 0, 0, 0, 0, 0, 0, 0, 0,
  163840, 0, 163840, 0, 0, 0, 0, 0, 2027, 389, 412, 412, 412, 412, 412, 412, 412, 412, 2036, 412, 0, 0, 0, 0, 0, 2018,
  0, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 0, 412, 412, 2079, 412, 0, 0, 0,
  389, 389, 389, 389, 412, 412, 412, 412, 0, 0, 0, 1988, 0, 0, 0, 1991, 0, 389, 389, 389, 271, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1750, 49152, 0, 287, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1126877, 147456, 1126877, 0, 147456, 0, 0, 342, 342, 287, 342, 342, 342, 287, 0, 0, 0, 0, 0, 0, 0, 0, 606, 607, 0, 0,
  0, 0, 0, 543, 407, 407, 407, 407, 431, 407, 407, 407, 407, 407, 407, 407, 431, 431, 431, 431, 431, 407, 407, 431,
  53449, 53449, 2, 86019, 4, 5, 0, 0, 412, 687, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,
  1236, 412, 0, 0, 0, 832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 216, 216, 216, 216, 0, 1104, 0, 0, 0, 0, 0, 0, 342, 342,
  342, 342, 342, 342, 342, 342, 582, 342, 342, 1652, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1762, 49152, 249, 0,
  0, 303, 40960, 303, 0, 303, 303, 0, 303, 303, 321, 0, 0, 0, 0, 0, 872448, 0, 872448, 0, 0, 0, 0, 0, 0, 0, 0, 834, 0,
  0, 0, 0, 0, 0, 0, 0, 359, 359, 0, 359, 359, 359, 0, 321, 321, 321, 321, 321, 321, 321, 321, 321, 321, 359, 321, 321,
  321, 321, 408, 408, 408, 408, 408, 432, 408, 408, 408, 408, 408, 408, 408, 432, 432, 432, 432, 432, 408, 408, 432,
  53449, 53449, 2, 86019, 4, 5, 0, 0, 389, 389, 389, 658, 389, 389, 389, 389, 389, 389, 0, 412, 412, 412, 412, 412, 412,
  1619, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1623, 412, 412, 412, 412, 412, 389, 389, 389, 389, 1585, 389,
  389, 389, 389, 389, 0, 0, 0, 0, 0, 0, 0, 1755, 0, 0, 1757, 0, 1759, 0, 0, 0, 412, 1628, 412, 412, 412, 412, 412, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 0, 0, 0, 0, 409, 409, 409, 409, 433, 409, 409, 409, 409, 409, 409, 409, 433, 433, 433,
  433, 433, 409, 409, 433, 53449, 53449, 2, 86019, 4, 5, 0, 0, 0, 0, 550, 0, 0, 342, 342, 342, 342, 342, 577, 342, 342,
  342, 342, 342, 342, 858, 342, 342, 342, 342, 342, 342, 342, 342, 342, 1684, 342, 342, 342, 342, 389, 389, 389, 412,
  688, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1816, 1817, 798, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 45056, 389, 389, 930, 389, 389, 389, 389, 389, 389, 389, 389, 668, 99246, 876, 671, 412, 412, 412,
  694, 700, 703, 412, 412, 412, 412, 412, 717, 412, 412, 412, 412, 412, 952, 412, 412, 412, 412, 412, 412, 412, 412,
  412, 412, 412, 1609, 412, 412, 412, 412, 0, 0, 0, 1204, 1426, 0, 0, 0, 412, 412, 412, 412, 412, 412, 412, 412, 1263,
  412, 412, 412, 412, 412, 412, 412, 412, 0, 0, 0, 0, 1636, 0, 0, 1639, 1640, 0, 512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1277, 0, 0, 0, 0, 512, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 1405, 389, 389, 389,
  389, 389, 389, 662, 389, 389, 389, 389, 389, 0, 412, 412, 412, 412, 412, 412, 1631, 0, 0, 0, 0, 0, 0, 0, 0, 0, 475,
  251, 251, 251, 0, 0, 0, 389, 389, 389, 389, 932, 389, 389, 389, 389, 389, 389, 668, 99246, 876, 671, 412, 412, 412,
  950, 412, 412, 412, 958, 412, 412, 412, 412, 412, 412, 412, 412, 1725, 412, 412, 412, 412, 412, 412, 412, 1000, 412,
  412, 412, 412, 412, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1484, 389, 389, 389, 1176, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 389, 389, 389, 389, 1565, 389, 389, 389, 389, 389, 389, 1386, 1387, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 0, 1589, 0, 0, 0, 0, 1546, 342, 342, 342, 342, 342, 342, 342, 342, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  1414, 389, 389, 389, 389, 389, 0, 389, 389, 389, 389, 1571, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  668, 99246, 876, 671, 412, 412, 1614, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 1886, 412,
  1739, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 1764, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342, 342,
  342, 342, 1114, 342, 342, 49152, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 312, 0, 0, 0, 0, 0, 0, 472, 0, 0, 0, 251, 251, 251, 0,
  0, 0, 864256, 0, 864256, 0, 0, 864256, 0, 864256, 0, 0, 0, 0, 0, 0, 0, 0, 773, 0, 775, 0, 0, 0, 0, 0, 0, 864256, 0,
  864256, 0, 0, 0, 864256, 864256, 0, 0, 0, 0, 0, 0, 0, 473, 474, 0, 251, 251, 251, 0, 0, 0, 0, 864256, 864256, 0, 0, 0,
  0, 864256, 0, 0, 864256, 864256, 0, 0, 0, 0, 0, 0, 0, 0, 864256, 0, 864256, 0, 864256, 0, 0, 0, 864256, 0, 0, 0,
  864256, 0, 0, 0, 864549, 864256, 0, 0, 0, 864549, 0, 0, 0, 0, 0, 0, 864256, 0, 0, 0, 0, 0, 864256, 864256, 0, 0, 0,
  864256, 0, 0, 0, 864256, 0, 0, 864256, 864256, 0, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 884736, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 218, 219, 0, 0, 0, 0, 0, 0, 0, 0, 868352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1748, 0, 0, 0, 1110016, 1110016,
  1110016, 1835008, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 0, 0, 0, 0, 1110016, 1110016,
  1499136, 1110016, 1662976, 1110016, 1110016, 1110016, 1785856, 1110016, 1110016, 1499136, 1110016, 49152, 0, 0, 0, 0,
  40960, 0, 0, 0, 0, 0, 0, 0, 0, 872786, 872786, 872786, 0, 0, 2, 86019, 4, 5, 0, 0, 872786, 0, 0, 872786, 0, 0, 0,
  872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786, 872786,
  872786, 0, 0, 876544, 0, 0, 0, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112, 1114112,
  1114112, 1114112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 0, 0, 0, 251, 0, 294, 0, 0, 0, 0, 294, 0, 0, 0, 0, 0, 0, 0,
  880640, 0, 0, 0, 0, 0, 1056768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 233, 234, 0, 0, 0, 0, 0, 0, 880640, 0, 880640,
  880640, 880640, 0, 0, 2, 86019, 4, 5, 0, 0, 0, 0, 0, 1056768, 215, 216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 739, 823, 824, 0,
  0, 0, 0, 1110016, 1110016, 1110016, 1835008, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 1110016, 941, 0, 0,
  944, 1110016, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1355776, 0, 0, 1384448, 102400, 0, 0, 102400, 0, 0, 0, 102400, 102400,
  102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 0, 0, 1691648,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1363968
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  458, 466, 465, 461, 470, 474, 478, 488, 507, 487, 492, 506, 511, 560, 516, 1023, 515, 808, 483, 520, 521, 500, 502,
  1022, 1366, 525, 481, 530, 542, 498, 500, 1236, 1022, 1357, 808, 495, 542, 1233, 500, 566, 1022, 1022, 536, 542, 549,
  500, 577, 1022, 540, 532, 501, 1022, 546, 558, 552, 1230, 564, 570, 574, 883, 582, 589, 586, 593, 597, 601, 605, 611,
  607, 615, 619, 623, 627, 632, 628, 931, 1022, 1022, 644, 638, 1022, 1183, 1022, 1022, 1022, 1022, 1022, 1022, 643,
  1022, 1407, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 648, 1022, 1022, 1022, 1022, 1022, 1022, 1310, 1022, 1022,
  1022, 1022, 1022, 1294, 1022, 1022, 1022, 1022, 1364, 1022, 1022, 1355, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
  1022, 1022, 1022, 653, 657, 662, 668, 672, 676, 680, 639, 1247, 684, 1289, 688, 1413, 732, 1341, 692, 696, 1317, 1074,
  700, 664, 1022, 649, 657, 1616, 705, 712, 716, 1022, 1454, 1022, 634, 1022, 722, 726, 803, 1022, 718, 1022, 766, 701,
  736, 740, 1022, 744, 945, 754, 760, 764, 1440, 946, 1589, 770, 1438, 783, 787, 796, 800, 812, 816, 824, 828, 832, 836,
  840, 1022, 776, 1606, 846, 850, 854, 857, 908, 863, 1219, 867, 871, 875, 876, 790, 880, 976, 887, 891, 897, 1022, 901,
  1022, 779, 905, 914, 918, 526, 922, 1022, 928, 1022, 1002, 1172, 940, 944, 950, 1022, 973, 1022, 956, 1127, 963, 996,
  1022, 970, 924, 980, 984, 1021, 988, 1124, 993, 1006, 1010, 1014, 1018, 1055, 1027, 966, 1031, 1036, 1032, 1040, 1044,
  1048, 1049, 1053, 1059, 1063, 1067, 1071, 1159, 1078, 1082, 1086, 1090, 1094, 1098, 1154, 1102, 1106, 1113, 1117,
  1121, 1131, 1022, 1138, 1489, 1145, 1149, 1459, 1258, 1207, 1153, 820, 1158, 554, 959, 1457, 1163, 1375, 1176, 1022,
  1181, 952, 1187, 1194, 1201, 1206, 578, 1211, 1216, 1223, 1227, 1212, 658, 1240, 1244, 1190, 1251, 1255, 1197, 1262,
  1269, 1273, 1280, 1277, 1286, 1293, 1022, 1022, 1347, 1109, 1298, 1302, 1305, 1309, 1314, 1401, 1265, 1141, 1134,
  1320, 1321, 1166, 1325, 1335, 806, 1538, 1022, 1339, 1022, 1345, 1166, 1352, 1361, 1386, 1022, 910, 1022, 842, 1385,
  1348, 1370, 819, 1374, 859, 1379, 755, 1384, 1390, 1394, 773, 756, 1022, 792, 708, 1398, 1405, 1411, 1451, 1417, 1421,
  1427, 1431, 1435, 1444, 1448, 1463, 1467, 1471, 1476, 1472, 1480, 1484, 1488, 1022, 1493, 1497, 1501, 1505, 1509,
  1022, 1515, 1519, 750, 747, 1523, 1423, 1022, 1527, 1531, 934, 1380, 1022, 1177, 1330, 1202, 1022, 1535, 1542, 1546,
  1552, 1022, 1328, 1022, 729, 1331, 1558, 1562, 1554, 1022, 1169, 1022, 1548, 893, 1566, 936, 1570, 999, 1022, 1575,
  1579, 1022, 1571, 1022, 1583, 1587, 1511, 1613, 1593, 1595, 1599, 1282, 1603, 1610, 1022, 1022, 1022, 1022, 990, 1620,
  2503, 1630, 1633, 1645, 1634, 1641, 1638, 1633, 1633, 1633, 1648, 1652, 1655, 1662, 1666, 1670, 1658, 1674, 1678,
  1682, 1686, 1690, 2516, 1720, 1720, 1720, 1721, 2516, 1716, 2516, 2516, 2516, 1700, 2515, 2516, 3175, 1720, 1720,
  2586, 2587, 1795, 1744, 1744, 1744, 1744, 1786, 1809, 1725, 2516, 2516, 2516, 1706, 3058, 2587, 2587, 1735, 1770,
  2516, 2516, 2516, 1756, 3059, 2587, 2587, 2587, 1782, 1771, 2516, 2516, 2516, 1814, 1721, 2585, 2587, 2587, 1833,
  1744, 3176, 1720, 1720, 1828, 1720, 1826, 2587, 2587, 2587, 2587, 2516, 3175, 1826, 2587, 1818, 1822, 1744, 1837,
  2516, 2516, 1729, 2678, 2587, 2588, 1744, 1744, 1749, 1811, 2587, 2590, 1744, 1744, 1806, 1812, 1837, 2516, 2645,
  1827, 2587, 2589, 1744, 1786, 2516, 2516, 2516, 1953, 3063, 2516, 2587, 3062, 1837, 2587, 3062, 3064, 2584, 2588,
  1744, 2585, 3061, 1787, 2904, 1787, 3060, 1738, 2906, 1843, 1845, 1852, 1868, 1872, 1876, 1877, 1877, 1878, 1889,
  1877, 1899, 1892, 1882, 1877, 1896, 1903, 1907, 1911, 1915, 1919, 1922, 1885, 1926, 1930, 1941, 1766, 2516, 2516,
  2516, 1958, 1777, 1951, 2516, 2516, 1740, 2125, 3190, 2516, 2516, 2516, 2032, 2132, 2516, 2516, 2516, 2080, 2486,
  2516, 2516, 2516, 2084, 2956, 2516, 2729, 1971, 2033, 2516, 2516, 2516, 2148, 2349, 1976, 2516, 2516, 2034, 2756,
  2807, 1984, 1991, 1995, 1999, 2003, 2007, 2011, 2013, 2017, 2019, 2021, 2516, 3151, 2025, 2124, 2363, 2980, 2039,
  2281, 2050, 2516, 2054, 3052, 2516, 3156, 2516, 2361, 2978, 3135, 2073, 2283, 2758, 2516, 2516, 2516, 2219, 2270,
  2767, 2281, 2516, 1772, 3083, 3106, 2098, 2516, 2516, 2088, 2964, 2968, 2516, 2516, 2118, 2970, 3157, 1944, 1848,
  2767, 3001, 2447, 2102, 2516, 1813, 2894, 2516, 1838, 2730, 1972, 2114, 2446, 2131, 2784, 2093, 2516, 2136, 3050,
  2516, 3123, 2187, 2516, 1858, 3301, 2516, 1861, 2521, 3295, 2140, 2516, 2516, 2516, 2371, 3100, 3027, 2079, 2146,
  2786, 2342, 2153, 2516, 2516, 2122, 2126, 2163, 2342, 2168, 2516, 1936, 3071, 2516, 1986, 1728, 2516, 1986, 1728,
  2793, 2174, 2516, 3157, 2520, 2180, 2184, 2787, 2516, 1987, 2516, 2516, 2287, 3077, 2343, 2516, 2516, 2191, 1847,
  2202, 1696, 2516, 2108, 2112, 2516, 1847, 2516, 2516, 2646, 1720, 1695, 2644, 2737, 2176, 2711, 2516, 2713, 2393,
  2516, 2516, 2516, 3036, 2142, 2714, 2713, 2394, 1709, 2310, 2516, 2206, 2714, 2713, 3012, 1710, 2712, 3264, 1711,
  2518, 3394, 1847, 2516, 2516, 2285, 3031, 2516, 3270, 2229, 3042, 2233, 2237, 2241, 2245, 2251, 2247, 2255, 2263,
  2257, 2516, 2516, 2285, 3047, 2276, 2293, 2516, 2528, 2300, 2305, 2820, 2859, 2309, 2074, 2314, 2318, 2033, 3218,
  2710, 2516, 2516, 2510, 2515, 2521, 2516, 2155, 2587, 3062, 1729, 2330, 2516, 2364, 2212, 2340, 2516, 2516, 2401,
  3195, 2347, 2046, 3279, 3283, 2516, 3277, 3281, 3285, 2406, 2516, 2523, 2516, 2267, 2516, 2516, 2287, 3033, 3320,
  2353, 2441, 2359, 2368, 2516, 2209, 2375, 2386, 2390, 2516, 2516, 2478, 2548, 2384, 2388, 2392, 2516, 2301, 1964,
  2516, 1728, 2516, 1934, 2516, 3114, 2414, 2359, 2421, 2529, 2427, 2516, 2516, 2516, 2400, 2140, 2198, 2474, 2516,
  2516, 2492, 2516, 2724, 2399, 2549, 2516, 2325, 2735, 2527, 2451, 2041, 2457, 2516, 2355, 2564, 1965, 1814, 2473,
  2353, 2516, 2436, 2028, 2516, 2322, 2412, 1802, 2294, 2524, 2355, 2035, 2484, 2490, 2516, 2496, 2197, 2500, 2516,
  2516, 2518, 2355, 2972, 2568, 2521, 2462, 2466, 2516, 2380, 3364, 2516, 2398, 2516, 2405, 2536, 2516, 2516, 2535,
  2169, 2516, 2547, 2540, 2354, 2035, 2035, 2945, 2545, 2516, 2946, 2546, 2516, 2516, 2516, 2516, 1764, 1967, 2516,
  1966, 2559, 2566, 2516, 2572, 2576, 2575, 2575, 3263, 1864, 1863, 1979, 2582, 2604, 1980, 3297, 2594, 2633, 2601,
  2612, 2516, 2516, 2516, 2530, 2616, 2453, 2516, 2516, 2553, 2972, 2279, 2621, 2087, 2625, 2630, 2642, 2650, 2654,
  2658, 2662, 2664, 2668, 2672, 2672, 2672, 2516, 2458, 2962, 2754, 2126, 2516, 2747, 2683, 2522, 3319, 2516, 2272,
  2851, 2839, 2516, 2690, 2694, 2480, 2703, 2708, 2719, 3312, 2723, 3389, 2728, 2516, 3389, 2728, 2617, 2516, 2324,
  2734, 3192, 2516, 2516, 3332, 2516, 2516, 2890, 1775, 3303, 2516, 2741, 2745, 2516, 2432, 2751, 2517, 2764, 2776,
  2516, 2507, 2514, 2526, 3376, 2440, 2035, 2516, 3354, 3358, 2981, 2431, 2987, 2993, 2516, 3356, 3360, 2516, 2519,
  2516, 1960, 2679, 2516, 2326, 2736, 3194, 2516, 2401, 2850, 2805, 2516, 2516, 2516, 2531, 2803, 2516, 2516, 2516,
  2676, 3155, 2516, 3019, 2516, 2521, 2886, 2516, 2521, 2894, 2516, 2522, 2516, 2410, 2811, 2516, 2516, 2516, 2770,
  1954, 2815, 2516, 2516, 2560, 2516, 2104, 3378, 2524, 2516, 2554, 2516, 2453, 2819, 2824, 1801, 3152, 2870, 3333,
  2875, 2452, 2516, 2516, 2516, 2772, 2832, 2516, 2516, 2516, 2801, 2857, 2516, 2516, 2516, 2855, 2837, 1778, 2525,
  2516, 2626, 3306, 2127, 1775, 2843, 2034, 2849, 2516, 3085, 2833, 2516, 2645, 1826, 2587, 1829, 1820, 1744, 1745,
  1809, 1693, 2863, 2516, 1775, 2826, 3154, 2516, 2555, 2516, 2704, 2094, 2541, 3379, 2516, 1774, 3153, 3154, 2516,
  2869, 2516, 2781, 2777, 2792, 2218, 2220, 3129, 2516, 2796, 2960, 2976, 3128, 2516, 3380, 3122, 2942, 2516, 2944,
  2879, 2943, 2942, 2516, 2486, 2485, 2516, 2516, 2578, 2516, 2485, 2516, 2485, 2516, 2865, 2045, 3006, 2944, 2516,
  2516, 2516, 2943, 2901, 2597, 2910, 1626, 2914, 2918, 2922, 2924, 2928, 2936, 2936, 2930, 2516, 2516, 2516, 2944,
  2516, 3196, 2940, 2516, 2881, 2078, 2516, 1752, 2728, 2516, 2516, 2415, 2333, 2997, 2516, 2892, 2896, 2516, 2516,
  2516, 3330, 2794, 1838, 3005, 3010, 2056, 2060, 2516, 2516, 2871, 2068, 2058, 2062, 2516, 2516, 2885, 2516, 2416,
  2417, 2335, 2999, 2516, 2942, 2516, 2516, 1799, 2516, 3043, 2194, 2149, 2516, 2943, 2516, 2516, 1777, 1791, 2334,
  3040, 2795, 2636, 1937, 2516, 2516, 2516, 3086, 3056, 2516, 2516, 2516, 3116, 3068, 3035, 2516, 2516, 2516, 3023,
  3197, 3084, 2983, 2952, 3041, 2170, 2828, 2864, 3141, 3090, 2638, 2516, 2950, 1623, 3326, 2788, 2169, 2516, 2516,
  2932, 2516, 3097, 3104, 2516, 2516, 3052, 2516, 2064, 2415, 3110, 1838, 3120, 2516, 1776, 2516, 1947, 1776, 1760,
  2516, 2516, 1759, 3127, 1855, 2760, 3113, 3093, 2516, 1776, 2341, 2167, 2516, 2516, 2159, 2516, 3133, 2516, 2423,
  3134, 3139, 3092, 2897, 2516, 2989, 2289, 2516, 2966, 2970, 2516, 1773, 2516, 3305, 2845, 2516, 2469, 2516, 2468,
  3174, 2954, 2516, 3172, 1712, 3145, 3150, 3340, 3339, 2336, 3079, 1694, 3173, 3172, 3339, 1712, 2955, 3162, 3166,
  3170, 2697, 2699, 3180, 2516, 2516, 2516, 3291, 3184, 3201, 2516, 3203, 1702, 3207, 3211, 3222, 3226, 3230, 3234,
  3238, 3242, 3244, 3248, 3254, 3252, 3258, 2516, 2516, 3073, 2516, 3262, 3268, 2982, 3216, 1730, 3274, 2069, 2442,
  2516, 3310, 2516, 1947, 3331, 3318, 2606, 2430, 3287, 2516, 3347, 2443, 3316, 2516, 2608, 2516, 3016, 2378, 3366,
  3289, 2221, 2516, 3324, 3146, 1932, 2516, 2516, 3085, 3344, 2516, 3116, 2516, 2516, 3115, 2516, 3319, 2607, 2431,
  3387, 3348, 3324, 3146, 3337, 3214, 2295, 3352, 2443, 3348, 2516, 2516, 2516, 3374, 2516, 3370, 2516, 2400, 3268,
  3187, 1731, 2715, 2686, 2516, 2797, 2259, 2296, 2715, 2516, 2516, 3158, 2079, 3384, 2442, 2516, 2516, 3393, 2516,
  3072, 2714, 3026, 2445, 2577, 2516, 2444, 2516, 3043, 2216, 2225, 3151, 1839, 2516, 2516, 3072, 2714, 2516, 3026,
  2516, 2092, 3398, 3716, 3737, 3403, 3399, 3998, 3579, 3405, 3690, 3606, 3426, 3429, 3703, 3572, 3572, 3572, 3572,
  3452, 3702, 3703, 3453, 3449, 3572, 3704, 3611, 3427, 3703, 3454, 3572, 3572, 3572, 3701, 3459, 3449, 3450, 3572,
  3572, 3661, 3461, 3469, 3474, 3462, 3476, 3477, 3466, 3467, 3472, 3472, 3472, 3471, 3470, 3471, 3470, 3475, 3812,
  3479, 3481, 3484, 3482, 3485, 3487, 3488, 3487, 3487, 3490, 3491, 3692, 3845, 3742, 3642, 3403, 3571, 3406, 3527,
  3433, 3403, 3403, 3643, 3495, 3508, 3403, 3680, 3681, 3403, 3962, 3403, 3403, 3718, 3493, 3403, 3402, 3643, 3403,
  3403, 3643, 3887, 3403, 3530, 3403, 3644, 3569, 3569, 3569, 3569, 3403, 3569, 3569, 3569, 3961, 3403, 3403, 3403,
  3582, 3579, 3403, 3811, 3803, 3499, 3525, 3525, 3403, 3676, 3515, 3802, 3525, 3525, 3525, 3525, 3526, 3500, 3403,
  3502, 3403, 3403, 4055, 4058, 3403, 3698, 3681, 3403, 3403, 4065, 3495, 3714, 3403, 3718, 3413, 3403, 3514, 3573,
  3964, 3575, 3403, 3403, 3403, 3414, 3431, 3403, 3403, 3403, 3416, 3862, 3810, 3974, 3803, 3524, 3525, 3525, 3525,
  3804, 3403, 3413, 3403, 3808, 3575, 3810, 3974, 3507, 3523, 3403, 3509, 3442, 3403, 3403, 3403, 3886, 3525, 3525,
  3525, 3527, 3527, 3527, 3527, 3403, 3403, 3403, 3409, 3852, 3810, 3440, 3440, 3440, 3523, 3523, 3523, 3525, 3569,
  3569, 3970, 3810, 3810, 3810, 3974, 3810, 3810, 3440, 3523, 3804, 3403, 3403, 3403, 3432, 3403, 3810, 3525, 3917,
  3917, 3403, 3403, 3402, 3403, 3403, 3403, 3532, 4132, 3403, 3403, 4067, 3403, 3403, 4106, 4117, 3403, 3403, 3403,
  3905, 3910, 3403, 3674, 3408, 3417, 3538, 3417, 3854, 3540, 3544, 3546, 3417, 3417, 3417, 3417, 3419, 3856, 4072,
  3417, 3417, 3418, 3853, 3590, 3585, 3855, 3417, 3417, 3420, 3586, 3551, 3418, 3413, 3518, 3417, 3548, 3418, 3436,
  3542, 3541, 3553, 4073, 3554, 3557, 3558, 3559, 3435, 3556, 3562, 3562, 3561, 3564, 3566, 3588, 3600, 3600, 3599,
  3599, 3567, 3403, 3549, 3592, 3594, 3596, 3594, 3598, 3601, 3403, 3403, 3404, 3438, 3403, 3403, 3404, 3514, 3862,
  3403, 3682, 3402, 3403, 3403, 4111, 3403, 3403, 4114, 4116, 3961, 3421, 3403, 3403, 3404, 3528, 3576, 3403, 3872,
  3403, 3403, 3404, 4005, 3605, 3403, 3403, 3403, 3434, 3711, 4128, 3571, 3801, 3753, 3658, 3697, 3684, 3610, 3697,
  3403, 3403, 4118, 3403, 3912, 3806, 3613, 3403, 3403, 3406, 3691, 3961, 3505, 3693, 3693, 3613, 3962, 4025, 3642,
  4112, 3730, 3616, 3618, 3620, 3621, 3622, 3624, 3625, 3627, 3628, 3629, 3632, 3631, 3632, 3631, 3631, 3631, 3634,
  3635, 3635, 3635, 3635, 3637, 3637, 3638, 3639, 3403, 3690, 3514, 3679, 3984, 3775, 3697, 3693, 3697, 3403, 3403,
  3403, 3439, 3403, 3650, 3663, 3403, 3403, 3406, 3900, 3721, 3403, 3403, 3403, 3447, 3403, 3696, 3959, 3708, 3720,
  3724, 3403, 3403, 3412, 4057, 3714, 3903, 3944, 3738, 3403, 3403, 3414, 3961, 3727, 3403, 3403, 3403, 3456, 4125,
  3403, 3403, 3403, 3457, 3729, 3403, 3403, 3403, 3494, 3608, 3514, 3801, 3753, 3658, 3403, 3403, 3403, 3768, 3403,
  3642, 3403, 3403, 3403, 3505, 3711, 3843, 3764, 3642, 3771, 3642, 3403, 3403, 3496, 3862, 3710, 3646, 3510, 3838,
  3749, 3775, 3642, 3403, 3400, 3403, 3975, 3495, 3511, 3736, 3403, 3514, 3802, 3673, 3787, 3403, 3403, 3403, 3443,
  3961, 3403, 3709, 3403, 3403, 3439, 3646, 3510, 3748, 3841, 3673, 3787, 3403, 3400, 3403, 3961, 3403, 3846, 3403,
  3403, 3403, 3943, 3747, 3750, 3403, 3403, 3568, 3810, 3646, 3510, 3903, 3520, 3403, 3846, 3494, 3903, 3495, 3903,
  3520, 3403, 3403, 3403, 3528, 3676, 3841, 3781, 3697, 3403, 3400, 3647, 3709, 3403, 3983, 3508, 3403, 3645, 3495,
  3747, 3749, 3779, 3840, 3753, 3787, 3403, 3403, 4121, 3403, 3404, 3972, 3798, 3685, 3403, 3647, 3403, 3784, 3840,
  3787, 3400, 3403, 3406, 3529, 3687, 3570, 3895, 3863, 3655, 3676, 3403, 3403, 3574, 3403, 3403, 3403, 3509, 3790,
  3677, 3845, 3958, 3403, 3794, 3655, 3957, 3861, 3791, 3403, 3668, 3818, 3796, 3814, 3817, 3815, 3822, 3824, 3829,
  3828, 3831, 3828, 3828, 3828, 3828, 3828, 3833, 3828, 3833, 3828, 3825, 3826, 3826, 3403, 3403, 3574, 3414, 3826,
  3826, 3826, 3826, 3403, 3835, 4124, 3403, 3407, 3403, 3403, 3463, 3403, 3861, 3655, 3676, 3410, 3410, 3403, 3403,
  3682, 3839, 3403, 3403, 3412, 3646, 3963, 3514, 3667, 3659, 3846, 3958, 3403, 3403, 3403, 3583, 3403, 3860, 3403,
  3403, 3403, 3603, 3403, 3582, 3866, 3697, 3877, 3403, 3403, 3403, 3643, 3403, 3694, 3876, 3697, 3403, 3727, 3403,
  3722, 3403, 3772, 3403, 3403, 3579, 3496, 3986, 3754, 3515, 3890, 3697, 3403, 3410, 3773, 3403, 3655, 3403, 3433,
  3777, 3403, 3403, 3403, 3645, 3495, 3903, 3403, 3666, 3403, 3403, 3579, 3693, 3675, 3403, 3403, 3403, 3659, 3403,
  3403, 3670, 3403, 3403, 3641, 3403, 3403, 3403, 3444, 3403, 3582, 4019, 3403, 3411, 3497, 3687, 3511, 3772, 3697,
  3403, 3414, 3403, 3404, 3528, 3965, 3409, 3852, 3577, 3685, 3969, 3679, 3984, 3750, 3864, 3403, 3403, 3403, 3672,
  3787, 3835, 3693, 3403, 3403, 3403, 3676, 3403, 3861, 3513, 3709, 3957, 3403, 3403, 3675, 3403, 3574, 3659, 3403,
  3403, 3403, 3682, 3403, 3410, 3403, 4019, 3403, 3403, 3645, 3671, 3670, 3894, 3864, 3403, 3415, 3403, 3403, 3403,
  3981, 3409, 3852, 3578, 3968, 3403, 3858, 3403, 3403, 3403, 3660, 3403, 3403, 3403, 3670, 3511, 3403, 3681, 3403,
  3403, 3403, 3709, 3907, 3403, 3403, 3403, 3734, 3972, 3798, 3534, 3679, 3984, 3775, 3403, 3403, 3646, 3515, 3399,
  3578, 3535, 3516, 3985, 3864, 3403, 3835, 3403, 3403, 3648, 3949, 3698, 3403, 3403, 3403, 3741, 3403, 3669, 3681,
  3403, 3403, 3655, 4021, 3409, 3852, 3578, 3800, 3807, 3888, 3520, 3403, 3424, 3430, 4131, 3403, 3835, 3403, 3861,
  3399, 3971, 3709, 3513, 3957, 3403, 3403, 3403, 3403, 3400, 3403, 3403, 3403, 3404, 3403, 3403, 3403, 3405, 3403,
  3403, 3403, 3406, 3445, 3845, 3404, 3797, 3578, 4128, 3520, 4024, 3403, 3403, 3403, 3755, 3799, 3985, 3403, 3403,
  3403, 3751, 3463, 3897, 4118, 3403, 3403, 3439, 4016, 3403, 4128, 3403, 3403, 3403, 3760, 3440, 3434, 3711, 3910,
  3403, 3403, 3669, 3403, 3403, 3659, 3432, 3712, 3654, 3403, 3403, 3432, 3442, 3403, 3909, 3654, 3403, 3403, 3676,
  3810, 3810, 3810, 3810, 3917, 3525, 3525, 3403, 3659, 3432, 3654, 3399, 3403, 3405, 4118, 3432, 3654, 3432, 3910,
  3403, 3403, 3682, 3574, 3403, 3415, 3654, 4118, 3433, 3433, 3845, 3658, 3697, 3403, 3403, 3690, 3914, 3752, 3870,
  3517, 3403, 3403, 3403, 3772, 3410, 3509, 3784, 3403, 3432, 3654, 3403, 3432, 3441, 3403, 3403, 3840, 3406, 3842,
  3508, 3403, 3403, 3403, 3569, 3569, 3792, 3697, 3463, 3902, 3810, 3916, 4061, 3919, 3921, 3931, 3922, 3925, 3927,
  3922, 3922, 3923, 3922, 3922, 3930, 3928, 3930, 3933, 3934, 3934, 3934, 3934, 3403, 3936, 3940, 3897, 3697, 3403,
  3403, 3519, 3753, 4049, 3403, 3432, 3965, 3431, 3403, 3946, 3536, 3402, 3403, 3769, 3665, 3403, 3433, 3643, 3647,
  3494, 3494, 3503, 3403, 3403, 3403, 3805, 3883, 3403, 3883, 3403, 3403, 3403, 3644, 3403, 3403, 3403, 3573, 3403,
  3948, 3952, 3648, 3762, 3403, 3403, 3403, 3835, 3504, 3403, 3403, 3403, 3836, 3571, 3986, 3754, 3871, 3403, 3403,
  3403, 3840, 3580, 4123, 3678, 3743, 3403, 3664, 3403, 3403, 3690, 3509, 3991, 3988, 3738, 3403, 3439, 3745, 3510,
  3757, 3759, 3403, 3403, 3446, 3655, 3990, 3950, 3994, 3403, 3439, 3843, 3403, 3403, 4120, 4122, 3510, 3431, 3997,
  3403, 3403, 3403, 3847, 3439, 4004, 4007, 3403, 3439, 3843, 3903, 3403, 3403, 3403, 3514, 4009, 3403, 3403, 3403,
  3861, 3403, 3403, 3403, 3647, 3403, 4012, 3848, 3836, 3652, 3898, 3403, 3403, 3690, 3690, 3445, 4018, 3656, 3898,
  3683, 3512, 3657, 3642, 3942, 3403, 3403, 3403, 3868, 3403, 3681, 3403, 3439, 3442, 3403, 3403, 3840, 4014, 3441,
  3512, 3761, 3403, 3845, 3697, 3403, 3403, 3698, 3642, 3403, 3681, 3403, 3441, 3573, 3664, 3700, 3403, 3403, 3403,
  3942, 3403, 3404, 3528, 3700, 3656, 3403, 3403, 3694, 3874, 3519, 3754, 3403, 3403, 3403, 3960, 3441, 3761, 3403,
  3403, 3403, 3962, 3862, 3403, 3403, 3431, 3403, 3869, 3403, 3403, 3711, 3746, 3404, 3973, 3678, 3697, 3403, 3573,
  3446, 3403, 3409, 3528, 3965, 3510, 3431, 3403, 3403, 3431, 4023, 3654, 3403, 3676, 3810, 3810, 3917, 3525, 3804,
  3999, 3769, 3403, 4027, 4030, 4034, 4029, 4033, 4036, 3401, 3705, 3706, 4038, 4039, 4038, 4038, 4038, 4038, 4041,
  4043, 4044, 4044, 3403, 3403, 3716, 3403, 4044, 4044, 4044, 4044, 3677, 4046, 3403, 3403, 3717, 3403, 3403, 3403,
  3437, 3799, 3446, 3406, 4031, 3654, 3403, 3399, 3403, 3433, 3403, 3403, 3403, 4048, 3403, 3403, 3725, 3740, 3975,
  3967, 3510, 3757, 3750, 3776, 3403, 3403, 3438, 3403, 3403, 4051, 3403, 3403, 3731, 3402, 3403, 3403, 3403, 3446,
  3406, 3404, 3402, 3403, 3403, 3732, 3646, 3403, 3884, 3402, 4053, 3655, 3403, 4104, 3579, 3403, 3403, 3735, 3403,
  3581, 3403, 3403, 3403, 3995, 3403, 3943, 3403, 3403, 3786, 3697, 3404, 3514, 3766, 3403, 3441, 3937, 3642, 3403,
  4060, 3943, 3403, 3442, 3403, 3403, 3400, 3963, 3514, 3715, 3765, 3782, 3403, 3403, 3403, 4012, 3741, 3533, 3403,
  3403, 3520, 3403, 3403, 3963, 3514, 3715, 3750, 3642, 3403, 3403, 3521, 3992, 3781, 3642, 3403, 3403, 3810, 3810,
  3810, 3525, 3525, 3525, 3403, 3403, 3809, 3714, 3903, 3862, 3403, 3403, 3403, 4015, 3644, 3667, 3781, 3403, 3403,
  3844, 3403, 3677, 3573, 3403, 3403, 3403, 4014, 3441, 3861, 3403, 3403, 3432, 3438, 3403, 3431, 3406, 3497, 3687,
  3809, 3714, 3862, 3659, 3714, 4063, 3403, 3403, 3849, 3769, 3410, 3654, 3655, 3690, 3403, 3403, 3403, 4106, 3510,
  3403, 3441, 3403, 3840, 3403, 3403, 3403, 3975, 3714, 3403, 3403, 3403, 4016, 3403, 3671, 3512, 3403, 3403, 3403,
  4107, 3403, 3568, 3403, 3655, 3957, 3579, 3399, 3403, 3403, 3961, 3403, 3399, 3432, 3403, 3403, 3403, 3441, 3403,
  3403, 3403, 3442, 3403, 3400, 3982, 3681, 3403, 3982, 3681, 3432, 3403, 3643, 3887, 3403, 3643, 3887, 3399, 3403,
  3403, 3568, 3569, 3569, 3686, 3686, 3686, 3686, 3403, 3962, 3837, 3403, 3442, 3415, 3403, 3446, 3403, 3403, 3405,
  3494, 3403, 3403, 3403, 3851, 3677, 3681, 3681, 3698, 3698, 3403, 3887, 3906, 3699, 3709, 4069, 3403, 3680, 3415,
  3403, 3446, 3442, 3414, 3403, 3403, 3879, 3881, 3698, 3698, 3962, 3614, 3689, 4071, 3688, 3819, 3820, 3689, 4075,
  3456, 3808, 3455, 4077, 4079, 4081, 4083, 4082, 4083, 4085, 4089, 4089, 4090, 4089, 4089, 4087, 4088, 4092, 4094,
  4095, 4095, 4095, 4095, 4096, 4097, 4095, 4101, 4098, 4099, 3901, 3403, 3403, 3403, 4118, 3402, 3403, 3494, 3403,
  3403, 3850, 3403, 3416, 3403, 3752, 3403, 3447, 3577, 4108, 3570, 3679, 3892, 3862, 3776, 3788, 3403, 3403, 3582,
  3584, 3403, 3403, 3582, 3940, 4103, 3403, 3403, 3403, 3912, 3403, 3464, 3403, 3403, 3403, 3938, 3403, 3403, 3403,
  3858, 4110, 3422, 3403, 3403, 3954, 3956, 3962, 3463, 3403, 3647, 3403, 3403, 3403, 3792, 3403, 3573, 3403, 3403,
  3958, 3403, 3403, 3962, 3463, 3403, 3403, 3403, 3846, 3403, 4106, 3403, 3403, 3982, 3512, 3403, 3441, 4127, 3570,
  3403, 3456, 3403, 3403, 3403, 3403, 3509, 3403, 3403, 4002, 3966, 4000, 3651, 3653, 3898, 3402, 3403, 3713, 3403,
  3403, 3403, 4010, 3403, 4014, 3441, 4127, 3431, 4015, 4130, 3403, 3403, 4031, 3403, 3403, 3403, 3862, 3403, 3574,
  3415, 3403, 3583, 3413, 3403, 3403, 3977, 3979, 4015, 3644, 3403, 3403, 3644, 4096, 524288, 0, -2147483648,
  -2147483648, 0, 0, 1, 0, 2, -2147483648, 1, 2, 0, 3, 8, 0, 4, 0, 8, 8, 10, 8, 12, 0, 9, 0, 536936448, 131074, 131088,
  16908288, 134283264, 65536, 65536, 0, 16, 0, 24, 8, 24, 32, 0, 32, 32, 64, 0, 34, 128, 512, 0, 63, -2147352576,
  131072, 8768, 131102, 1073872896, 1073872896, 131072, 8192, 0, 130, 10560, 1073872896, 386007040, 386007040, 16384, 0,
  160, 163856, 268599296, -1761476608, 386039808, 386007040, 117571584, 84017152, 84017152, 386007040, 1459748864,
  386007040, 163840, -1761476608, 147488, 81920, 8536096, 147488, -1073594336, 268582944, -2147336160, -2147336160,
  -1065205698, -1065205698, -1048428482, -1065205698, 386023456, -947765186, 14, 0, 2048, 8192, 8, 384, 8405024,
  8404992, 12, 4096, 4194304, -1610612736, 0, 5184, 32, 8388608, 0, 8192, 32768, 262144, 524288, 16384, 65536, 262144,
  1048576, 1, 8, 16777216, 0, 12192, 8388640, 8388640, 8404992, 8404992, 16, 16, 32, 128, 8256, 512, 67108864, 1024,
  12288, 131072, 5242880, 1, 134234112, 40, 136, 8, 41418752, 65544, 131080, 262152, 67108872, 32776, 8, 134234112,
  262280, 393224, 136, 136, 262296, 10, 1032335850, 1032335850, 8, 1032335850, 2106327544, 1032585720, 1032585720,
  1032598008, 2106458616, 1032598008, 1032598010, 0, 32768, 32768, 65536, 131072, 131072, 0, 64, 64, 128, 768, 1024, 0,
  96, 0, 128, 1024, 8, 152, 1073741848, 1032663544, 2106458618, 26, 58, 35130378, 35142666, 35142990, 35142990,
  35143006, 1108884814, 1108884830, 1032598010, 1032598010, 1032663546, 1067191770, 8192, 25165824, 805306368, 0, 32772,
  34603008, 59768832, 4096, 131072, 134227136, 1082130432, 0, 262148, -2147483646, 545260544, 545259520, 547654696,
  1573380, 1573380, 547130912, 68682244, 547130912, 547130912, 1444495876, 545558056, 545558056, 546606632, 547130920,
  547130924, 547130924, 545562216, 547130924, 702328736, 702328736, 702328737, 702328737, 702328748, 702328745,
  301989888, 536870912, 0, 256, 0, 384, 2048, 0, 480, 3104, 32768, 917504, 3145728, 4194304, 0, 524288, 3145728,
  67108864, 268435456, 0, 131072, 16908288, 547618816, 0, 655360, 0, 786432, 16777216, 2, 32, 2048, 65536, 33554432,
  67108864, 134217728, 0, 16384, 32768, 131072, 262144, 262144, 0, 512, 1024, 1024, 2048, 2048, 4096, 1152, 0, 1024,
  4096, 4096, 0, 162, 370671616, 1073741824, 0, 262144, 64, 262144, 131088, 268566528, 1073872896, -2147352576,
  -2097070079, -2147483648, 545521664, 0, 1048576, 32, 512, 8192, 65536, 786432, 1048576, 2097152, 0, 12, 546570240,
  547094528, 0, 890880, 7776, 0, 1310720, 0, 1073741824, 1835008, 545259520, 545259520, 2, 8, 369098752, 0, 1572864,
  4194304, 536870912, -2147483648, 1835008, 0, 2097152, 4194304, -2147483648, 896, 3072, 32768, 1048576, 4194304,
  8388608, 16777216, 524288, 8388608, 33554432, 0, 81920, 1835008, 4194304, 696254464, 0, 3145728, 0, 55296, 1835008,
  8388608, 50331648, -2147483648, 100663296, 0, 4194304, 1572864, 8388608, 134217728, 4194304, 16777216, 134217728,
  536870912, 1073741824, 16777216, 536870912, 33554432, 268435456, 536870912, 2048, 8388608, 65536, 268435456,
  1073741824, -2147483648, 2, 16778240, 0, 8388608, 1024, 524288, 142606336, 2, 56, 768, 8192, 262144, 2097152, 8388608,
  8404992, 0, 4160, 1024, 8192, 8192, 16384, 16384, 16416, 81952, 142606336, 142610432, 142645282, 268435520, 142606336,
  0, 9175040, 266240, 1644494976, 1644511360, 1644494976, 1787140258, -336085057, -336085057, 1787140258, 1787140258,
  1661272192, 1787140258, 1661272194, 1787140258, 1787664546, 2, 1024, 16384, 262144, 1572864, 0, 65536, 8388608, 2048,
  32768, 524288, 1048576, 0, 192, 512, 2, 1, 4, 56, 10, 24, 131080, 131080, 64, 268435456, 38912, 0, 16777216, 33554432,
  134217728, 1073741824, 327680, 570425344, 344064, 0, 33554432, 201326592, 0, 40894464, 366592, 8388608, 366592,
  704643072, 1073741824, 959, 506880, 32505856, 704643072, -1073741824, 0, 54591488, 34, 2048, 262144, 6291456,
  33554432, 536870912, 1048576, 14680064, 4096, 262144, 8388608, 1048576, 67108864, 536870912, 32, 4096, 16384, 1048576,
  8388608, 16, 512, 262144, 134217728, 16, 8192, 4194304, 16, 4194304, 8192, 16777224, 65540, 16384, 8404992,
  -2142072480, -2143121056, -2142596768, -1605971488, -1605971488, -1605971486, -1605971488, -1068330656, -1605971520,
  -1605971488, -1404644896, -1538862624, -1605971488, -1069379232, -1605969440, -1535191055, -1535191055, 2, 128,
  262144, 536870912, 512, 524288, 4, 65536, 50331648, 268435456, 352, 36864, 448, 53248, 393216, -2147483648, 393216,
  -1610612736, 482, 71303168, 205520896, 0, 67108864, 0, 3616, 32768, 0, 4096, 8192, 64, 256, 512, 2048, 12288, 32768,
  16384, 2, 4, 16384, 32, 384, 1009, 54272, 917504, 74448896, 224, 256, 2048, 1048576, 6291456, 16777216, 8388608,
  393216, 4194304, 192, 20480, 32768, 702283776, 224, 0, 68681728, 226, 0, 69206016, 1024, 20480, 1, 240, 192, 16384,
  50397184, 393216, 536870912, 393216, 0, 117440512, 1, 48, 1, 16, 64, 3145728, 1024, 262144, 1073741824, 1048576,
  1073741824, 134218240, 16384, 67108864, 1375813632, 1024, 67108864, 16793601, 16793601, 0, 134217728, 112, 16793601,
  32772, 16793601, 50413569, -2097070079, -2097070079, -2147450876, -2097070079, -2092875775, -2029961215, -1281525365,
  -1281525365, 131072, 1073741824, 112, 0, 201326592, 1, 50397184, 117506048, -2147483648, 3, 2440, 2432, 28672,
  329056256, 1, 16384, 537149568, 16777216, 268435456, 2, 384, 4, 32768, 4, 1310720, 4096, 262152, 262152, 131208, 8192,
  9175040, 270336, 4235264, 3145761, 3147809, 3145761, 40993, 303137, 3146913, 7381024, 7381024, 7381025, 7643169,
  7381025, 7381025, 7643168, 7381537, 7381029, 7643177, 106867, 106867, 369011, 106867, 7709043, 7446899, 369011,
  4301171, 32, 2097152, 67108864, 1, 32, 3072, 12288, 5, 0, 536870912, 1375813632, 19, 96, 256, 40960, 0, 268435456, 3,
  16, 96, 256, 4096, 32768, 2359296, 256, 8192, 6291456, 256, 65536, 134217728, -2147483648
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "QName",
  "NCName",
  "S",
  "S",
  "CommentContents",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "Wildcard",
  "EOF",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'after'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'before'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'delete'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'first'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'insert'",
  "'instance'",
  "'intersect'",
  "'into'",
  "'is'",
  "'item'",
  "'last'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'modify'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'nodes'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'rename'",
  "'replace'",
  "'return'",
  "'revalidation'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'skip'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'updating'",
  "'validate'",
  "'value'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'with'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 4096,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 4096
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 4096 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 4095) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 4096, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 2092 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 4 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(62, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 47) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 18) then                      (: CommentContents :)
            let $state := p:shift(18, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(35, $input, $state)                 (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:shift(47, $input, $state)                 (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 17) then                            (: S^WS :)
      let $state := p:shift(17, $input, $state)             (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Prolog($input, $state)
  let $state := p:parse-QueryBody($input, $state)
  return $state
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:shift(158, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(4, $input, $state)                  (: StringLiteral :)
  return $state
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(120, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(183, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:l1] = 210) then                           (: '{' :)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(115, $input, $state)            (: 'external' :)
      return $state
  return $state
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(202, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 49) then                            (: ':=' :)
      let $state := p:shift(49, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(115, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: ':=' :)
          let $state := p:shift(49, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(190, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse CompatibilityAnnotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompatibilityAnnotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(199, $input, $state)                (: 'updating' :)
  return $state
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 31                               (: '%' :)
      and $state[$p:l1] != 199) then                        (: 'updating' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 199) then                     (: 'updating' :)
            let $state := p:parse-CompatibilityAnnotation($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Annotation($input, $state)
            return $state
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 202) then                           (: 'variable' :)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 136) then                           (: 'is' :)
      let $state := p:shift(136, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<<' :)
      let $state := p:shift(55, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>>' :)
      return $state
  return $state
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 58) then                            (: '=' :)
      let $state := p:shift(58, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:shift(26, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<' :)
      let $state := p:shift(51, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '<=' :)
      let $state := p:shift(56, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: '>' :)
      let $state := p:shift(59, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(60, $input, $state)             (: '>=' :)
      return $state
  return $state
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'eq' :)
      let $state := p:shift(112, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ne' :)
      let $state := p:shift(150, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'lt' :)
      let $state := p:shift(143, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'le' :)
      let $state := p:shift(140, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'gt' :)
      let $state := p:shift(125, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(121, $input, $state)            (: 'ge' :)
      return $state
  return $state
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-TypeName($input, $state)
  return $state
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(156, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'after' | 'and' | 'as' | 'ascending' |
                                                               'before' | 'case' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '?' :)
      let $state := p:shift(62, $input, $state)             (: '?' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(158, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PredicateList-1($input, $state)
  return $state
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '@' :)
      let $state := p:shift(64, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(180, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-NodeTest($input, $state)
  return $state
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 86) then                            (: 'child' :)
      let $state := p:shift(86, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant' :)
      let $state := p:shift(99, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state := p:shift(77, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'self' :)
      let $state := p:shift(180, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descendant-or-self' :)
      let $state := p:shift(100, $input, $state)            (: 'descendant-or-self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'following-sibling' :)
      let $state := p:shift(118, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(117, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 77) then                            (: 'attribute' :)
      let $state := p:lookahead2W(165, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 86                             (: 'child' :)
          or $state[$p:l1] = 99                             (: 'descendant' :)
          or $state[$p:l1] = 100                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 117                            (: 'following' :)
          or $state[$p:l1] = 118                            (: 'following-sibling' :)
          or $state[$p:l1] = 180) then                      (: 'self' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 12365                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12374                               (: 'child' '::' :)
     or $state[$p:lk] = 12387                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12388                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12405                               (: 'following' '::' :)
     or $state[$p:lk] = 12406                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12468) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(180, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(43, $input, $state)                 (: '..' :)
  return $state
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 77                                  (: 'attribute' :)
     or $state[$p:l1] = 88                                  (: 'comment' :)
     or $state[$p:l1] = 105                                 (: 'document-node' :)
     or $state[$p:l1] = 106                                 (: 'element' :)
     or $state[$p:l1] = 149                                 (: 'namespace-node' :)
     or $state[$p:l1] = 154                                 (: 'node' :)
     or $state[$p:l1] = 171                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 178                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 179                                 (: 'schema-element' :)
     or $state[$p:l1] = 189) then                           (: 'text' :)
      let $state := p:lookahead2W(161, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8525                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8536                                (: 'comment' '(' :)
     or $state[$p:lk] = 8553                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8554                                (: 'element' '(' :)
     or $state[$p:lk] = 8597                                (: 'namespace-node' '(' :)
     or $state[$p:lk] = 8602                                (: 'node' '(' :)
     or $state[$p:lk] = 8619                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8626                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8627                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8637) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 163) then                           (: 'parent' :)
      let $state := p:shift(163, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ancestor' :)
      let $state := p:shift(71, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'preceding-sibling' :)
      let $state := p:shift(168, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'preceding' :)
      let $state := p:shift(167, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(72, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(48, $input, $state)             (: '::' :)
      return $state
  return $state
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 43) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(180, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 71                                  (: 'ancestor' :)
     or $state[$p:l1] = 72                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 163                                 (: 'parent' :)
     or $state[$p:l1] = 167                                 (: 'preceding' :)
     or $state[$p:l1] = 168) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 43                                  (: '..' :)
     or $state[$p:lk] = 12359                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12360                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12451                               (: 'parent' '::' :)
     or $state[$p:lk] = 12455                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12456) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(158, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' | 'as' |
                                                               'ascending' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | 'with' | '|' | '||' | '}' :)
  let $state := p:parse-PredicateList($input, $state)
  return $state
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(66, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(67, $input, $state)                 (: ']' :)
  return $state
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EnclosedExpr($input, $state)
  return $state
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(72, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state := p:parse-Annotation($input, $state)
        return p:parse-InlineFunctionExpr-1($input, $state)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-InlineFunctionExpr-1($input, $state)
  let $state := p:shift(120, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(183, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:parse-FunctionBody($input, $state)
  return $state
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shift(28, $input, $state)                 (: '#' :)
  let $state := p:lookahead1W(16, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(1, $input, $state)                  (: IntegerLiteral :)
  return $state
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 120) then                           (: 'function' :)
      let $state := p:lookahead2W(65, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 31                                  (: '%' :)
     or $state[$p:lk] = 8568) then                          (: 'function' '(' :)
      let $state := p:parse-InlineFunctionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NamedFunctionRef($input, $state)
      return $state
  return $state
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(171, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(146, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '{' :)
  let $state :=
    if ($state[$p:l1] = 210) then                           (: '{' :)
      let $state := p:shift(210, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(214, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(195, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 214) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(88, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(189, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-NCName($input, $state)
  return $state
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(148, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(146, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '{' :)
  let $state :=
    if ($state[$p:l1] = 210) then                           (: '{' :)
      let $state := p:shift(210, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-PrefixExpr($input, $state)
      let $state := p:shift(214, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-URIExpr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(77, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 210) then                           (: '{' :)
      let $state := p:shift(210, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(214, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(195, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 214) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(106, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 210) then                           (: '{' :)
      let $state := p:shift(210, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:shift(214, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(195, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 214) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(104, $input, $state)                (: 'document' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 104) then                           (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(57, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:shift(12, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:shift(16, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(21, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:shift(63, $input, $state)                 (: '?>' :)
  return $state
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(52, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(2, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(20, $input, $state)                 (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:shift(41, $input, $state)                 (: '-->' :)
  return $state
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(53, $input, $state)                 (: '<![CDATA[' :)
  let $state := p:lookahead1(4, $input, $state)             (: CDataSectionContents :)
  let $state := p:shift(22, $input, $state)                 (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:shift(68, $input, $state)                 (: ']]>' :)
  return $state
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 51                                  (: '<' :)
     or $state[$p:l1] = 52                                  (: '<!--' :)
     or $state[$p:l1] = 57) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:shift(9, $input, $state)              (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 11) then                            (: AposAttrContentChar :)
      let $state := p:shift(11, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 6) then                             (: PredefinedEntityRef :)
      let $state := p:shift(6, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:shift(13, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 211) then                      (: '{{' :)
      let $state := p:shift(211, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 215) then                      (: '}}' :)
      let $state := p:shift(215, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 10) then                            (: QuotAttrContentChar :)
      let $state := p:shift(10, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(127, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 7) then                       (: EscapeQuot :)
            let $state := p:shift(7, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(128, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 8) then                       (: EscapeApos :)
            let $state := p:shift(8, $input, $state)        (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 27) then                            (: '"' :)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(32, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(32, $input, $state)             (: "'" :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(19, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 16) then                         (: S :)
        $state
      else
        let $state := p:shift(16, $input, $state)           (: S :)
        let $state := p:lookahead1(179, $input, $state)     (: QName^Token | S | '/>' | '>' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 16                      (: S :)
               and $state[$p:l1] != 46                      (: '/>' :)
               and $state[$p:l1] != 59) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 16) then             (: S :)
                let $state := p:shift(16, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:shift(58, $input, $state)       (: '=' :)
            let $state := p:lookahead1(18, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 16) then             (: S :)
                let $state := p:shift(16, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-DirAttributeList-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(133, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 54) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(51, $input, $state)                 (: '<' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/>' :)
      let $state := p:shift(46, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(59, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(54, $input, $state)             (: '</' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 16) then                   (: S :)
          let $state := p:shift(16, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:shift(59, $input, $state)             (: '>' :)
      return $state
  return $state
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 51) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 52) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 51                                  (: '<' :)
     or $state[$p:l1] = 52                                  (: '<!--' :)
     or $state[$p:l1] = 57) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(198, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(161, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(62, $input, $state)                 (: '?' :)
  return $state
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 62) then                            (: '?' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(72, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(193, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(196, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:parse-ArgumentList($input, $state)
  return $state
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(42, $input, $state)                 (: '.' :)
  return $state
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 148) then                           (: 'namespace' :)
      let $state := p:lookahead2W(150, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '{' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(149, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '{' :)
      return $state
    else if ($state[$p:l1] = 77                             (: 'attribute' :)
          or $state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:lookahead2W(182, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = 88                             (: 'comment' :)
          or $state[$p:l1] = 189) then                      (: 'text' :)
      let $state := p:lookahead2W(66, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 104                            (: 'document' :)
          or $state[$p:l1] = 161                            (: 'ordered' :)
          or $state[$p:l1] = 198) then                      (: 'unordered' :)
      let $state := p:lookahead2W(106, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 14                             (: QName^Token :)
          or $state[$p:l1] = 69                             (: 'after' :)
          or $state[$p:l1] = 71                             (: 'ancestor' :)
          or $state[$p:l1] = 72                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 73                             (: 'and' :)
          or $state[$p:l1] = 74                             (: 'as' :)
          or $state[$p:l1] = 75                             (: 'ascending' :)
          or $state[$p:l1] = 79                             (: 'before' :)
          or $state[$p:l1] = 82                             (: 'case' :)
          or $state[$p:l1] = 83                             (: 'cast' :)
          or $state[$p:l1] = 84                             (: 'castable' :)
          or $state[$p:l1] = 86                             (: 'child' :)
          or $state[$p:l1] = 87                             (: 'collation' :)
          or $state[$p:l1] = 91                             (: 'copy' :)
          or $state[$p:l1] = 93                             (: 'count' :)
          or $state[$p:l1] = 96                             (: 'declare' :)
          or $state[$p:l1] = 97                             (: 'default' :)
          or $state[$p:l1] = 98                             (: 'delete' :)
          or $state[$p:l1] = 99                             (: 'descendant' :)
          or $state[$p:l1] = 100                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 101                            (: 'descending' :)
          or $state[$p:l1] = 103                            (: 'div' :)
          or $state[$p:l1] = 107                            (: 'else' :)
          or $state[$p:l1] = 108                            (: 'empty' :)
          or $state[$p:l1] = 111                            (: 'end' :)
          or $state[$p:l1] = 112                            (: 'eq' :)
          or $state[$p:l1] = 113                            (: 'every' :)
          or $state[$p:l1] = 114                            (: 'except' :)
          or $state[$p:l1] = 116                            (: 'first' :)
          or $state[$p:l1] = 117                            (: 'following' :)
          or $state[$p:l1] = 118                            (: 'following-sibling' :)
          or $state[$p:l1] = 119                            (: 'for' :)
          or $state[$p:l1] = 121                            (: 'ge' :)
          or $state[$p:l1] = 123                            (: 'group' :)
          or $state[$p:l1] = 125                            (: 'gt' :)
          or $state[$p:l1] = 126                            (: 'idiv' :)
          or $state[$p:l1] = 128                            (: 'import' :)
          or $state[$p:l1] = 132                            (: 'insert' :)
          or $state[$p:l1] = 133                            (: 'instance' :)
          or $state[$p:l1] = 134                            (: 'intersect' :)
          or $state[$p:l1] = 135                            (: 'into' :)
          or $state[$p:l1] = 136                            (: 'is' :)
          or $state[$p:l1] = 138                            (: 'last' :)
          or $state[$p:l1] = 140                            (: 'le' :)
          or $state[$p:l1] = 142                            (: 'let' :)
          or $state[$p:l1] = 143                            (: 'lt' :)
          or $state[$p:l1] = 145                            (: 'mod' :)
          or $state[$p:l1] = 146                            (: 'modify' :)
          or $state[$p:l1] = 147                            (: 'module' :)
          or $state[$p:l1] = 150                            (: 'ne' :)
          or $state[$p:l1] = 157                            (: 'only' :)
          or $state[$p:l1] = 159                            (: 'or' :)
          or $state[$p:l1] = 160                            (: 'order' :)
          or $state[$p:l1] = 163                            (: 'parent' :)
          or $state[$p:l1] = 167                            (: 'preceding' :)
          or $state[$p:l1] = 168                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 172                            (: 'rename' :)
          or $state[$p:l1] = 173                            (: 'replace' :)
          or $state[$p:l1] = 174                            (: 'return' :)
          or $state[$p:l1] = 176                            (: 'satisfies' :)
          or $state[$p:l1] = 180                            (: 'self' :)
          or $state[$p:l1] = 183                            (: 'some' :)
          or $state[$p:l1] = 184                            (: 'stable' :)
          or $state[$p:l1] = 185                            (: 'start' :)
          or $state[$p:l1] = 191                            (: 'to' :)
          or $state[$p:l1] = 192                            (: 'treat' :)
          or $state[$p:l1] = 193                            (: 'try' :)
          or $state[$p:l1] = 197                            (: 'union' :)
          or $state[$p:l1] = 200                            (: 'validate' :)
          or $state[$p:l1] = 205                            (: 'where' :)
          or $state[$p:l1] = 207                            (: 'with' :)
          or $state[$p:l1] = 208) then                      (: 'xquery' :)
      let $state := p:lookahead2W(65, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 1                                   (: IntegerLiteral :)
     or $state[$p:lk] = 2                                   (: DecimalLiteral :)
     or $state[$p:lk] = 3                                   (: DoubleLiteral :)
     or $state[$p:lk] = 4) then                             (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 42) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8462                           (: QName^Token '(' :)
          or $state[$p:lk] = 8517                           (: 'after' '(' :)
          or $state[$p:lk] = 8519                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8520                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8521                           (: 'and' '(' :)
          or $state[$p:lk] = 8522                           (: 'as' '(' :)
          or $state[$p:lk] = 8523                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8527                           (: 'before' '(' :)
          or $state[$p:lk] = 8530                           (: 'case' '(' :)
          or $state[$p:lk] = 8531                           (: 'cast' '(' :)
          or $state[$p:lk] = 8532                           (: 'castable' '(' :)
          or $state[$p:lk] = 8534                           (: 'child' '(' :)
          or $state[$p:lk] = 8535                           (: 'collation' '(' :)
          or $state[$p:lk] = 8539                           (: 'copy' '(' :)
          or $state[$p:lk] = 8541                           (: 'count' '(' :)
          or $state[$p:lk] = 8544                           (: 'declare' '(' :)
          or $state[$p:lk] = 8545                           (: 'default' '(' :)
          or $state[$p:lk] = 8546                           (: 'delete' '(' :)
          or $state[$p:lk] = 8547                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8548                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8549                           (: 'descending' '(' :)
          or $state[$p:lk] = 8551                           (: 'div' '(' :)
          or $state[$p:lk] = 8552                           (: 'document' '(' :)
          or $state[$p:lk] = 8555                           (: 'else' '(' :)
          or $state[$p:lk] = 8556                           (: 'empty' '(' :)
          or $state[$p:lk] = 8559                           (: 'end' '(' :)
          or $state[$p:lk] = 8560                           (: 'eq' '(' :)
          or $state[$p:lk] = 8561                           (: 'every' '(' :)
          or $state[$p:lk] = 8562                           (: 'except' '(' :)
          or $state[$p:lk] = 8564                           (: 'first' '(' :)
          or $state[$p:lk] = 8565                           (: 'following' '(' :)
          or $state[$p:lk] = 8566                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8567                           (: 'for' '(' :)
          or $state[$p:lk] = 8569                           (: 'ge' '(' :)
          or $state[$p:lk] = 8571                           (: 'group' '(' :)
          or $state[$p:lk] = 8573                           (: 'gt' '(' :)
          or $state[$p:lk] = 8574                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8576                           (: 'import' '(' :)
          or $state[$p:lk] = 8580                           (: 'insert' '(' :)
          or $state[$p:lk] = 8581                           (: 'instance' '(' :)
          or $state[$p:lk] = 8582                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8583                           (: 'into' '(' :)
          or $state[$p:lk] = 8584                           (: 'is' '(' :)
          or $state[$p:lk] = 8586                           (: 'last' '(' :)
          or $state[$p:lk] = 8588                           (: 'le' '(' :)
          or $state[$p:lk] = 8590                           (: 'let' '(' :)
          or $state[$p:lk] = 8591                           (: 'lt' '(' :)
          or $state[$p:lk] = 8593                           (: 'mod' '(' :)
          or $state[$p:lk] = 8594                           (: 'modify' '(' :)
          or $state[$p:lk] = 8595                           (: 'module' '(' :)
          or $state[$p:lk] = 8596                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8598                           (: 'ne' '(' :)
          or $state[$p:lk] = 8605                           (: 'only' '(' :)
          or $state[$p:lk] = 8607                           (: 'or' '(' :)
          or $state[$p:lk] = 8608                           (: 'order' '(' :)
          or $state[$p:lk] = 8609                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8611                           (: 'parent' '(' :)
          or $state[$p:lk] = 8615                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8616                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8620                           (: 'rename' '(' :)
          or $state[$p:lk] = 8621                           (: 'replace' '(' :)
          or $state[$p:lk] = 8622                           (: 'return' '(' :)
          or $state[$p:lk] = 8624                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8628                           (: 'self' '(' :)
          or $state[$p:lk] = 8631                           (: 'some' '(' :)
          or $state[$p:lk] = 8632                           (: 'stable' '(' :)
          or $state[$p:lk] = 8633                           (: 'start' '(' :)
          or $state[$p:lk] = 8639                           (: 'to' '(' :)
          or $state[$p:lk] = 8640                           (: 'treat' '(' :)
          or $state[$p:lk] = 8641                           (: 'try' '(' :)
          or $state[$p:lk] = 8645                           (: 'union' '(' :)
          or $state[$p:lk] = 8646                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8648                           (: 'validate' '(' :)
          or $state[$p:lk] = 8653                           (: 'where' '(' :)
          or $state[$p:lk] = 8655                           (: 'with' '(' :)
          or $state[$p:lk] = 8656) then                     (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 53921) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 53958) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 5                              (: URIQualifiedName :)
          or $state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 105                            (: 'document-node' :)
          or $state[$p:lk] = 109                            (: 'empty-sequence' :)
          or $state[$p:lk] = 120                            (: 'function' :)
          or $state[$p:lk] = 127                            (: 'if' :)
          or $state[$p:lk] = 137                            (: 'item' :)
          or $state[$p:lk] = 149                            (: 'namespace-node' :)
          or $state[$p:lk] = 154                            (: 'node' :)
          or $state[$p:lk] = 178                            (: 'schema-attribute' :)
          or $state[$p:lk] = 179                            (: 'schema-element' :)
          or $state[$p:lk] = 188                            (: 'switch' :)
          or $state[$p:lk] = 196                            (: 'typeswitch' :)
          or $state[$p:lk] = 7182                           (: QName^Token '#' :)
          or $state[$p:lk] = 7237                           (: 'after' '#' :)
          or $state[$p:lk] = 7239                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7240                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7241                           (: 'and' '#' :)
          or $state[$p:lk] = 7242                           (: 'as' '#' :)
          or $state[$p:lk] = 7243                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7245                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7247                           (: 'before' '#' :)
          or $state[$p:lk] = 7250                           (: 'case' '#' :)
          or $state[$p:lk] = 7251                           (: 'cast' '#' :)
          or $state[$p:lk] = 7252                           (: 'castable' '#' :)
          or $state[$p:lk] = 7254                           (: 'child' '#' :)
          or $state[$p:lk] = 7255                           (: 'collation' '#' :)
          or $state[$p:lk] = 7256                           (: 'comment' '#' :)
          or $state[$p:lk] = 7259                           (: 'copy' '#' :)
          or $state[$p:lk] = 7261                           (: 'count' '#' :)
          or $state[$p:lk] = 7264                           (: 'declare' '#' :)
          or $state[$p:lk] = 7265                           (: 'default' '#' :)
          or $state[$p:lk] = 7266                           (: 'delete' '#' :)
          or $state[$p:lk] = 7267                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7268                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7269                           (: 'descending' '#' :)
          or $state[$p:lk] = 7271                           (: 'div' '#' :)
          or $state[$p:lk] = 7272                           (: 'document' '#' :)
          or $state[$p:lk] = 7274                           (: 'element' '#' :)
          or $state[$p:lk] = 7275                           (: 'else' '#' :)
          or $state[$p:lk] = 7276                           (: 'empty' '#' :)
          or $state[$p:lk] = 7279                           (: 'end' '#' :)
          or $state[$p:lk] = 7280                           (: 'eq' '#' :)
          or $state[$p:lk] = 7281                           (: 'every' '#' :)
          or $state[$p:lk] = 7282                           (: 'except' '#' :)
          or $state[$p:lk] = 7284                           (: 'first' '#' :)
          or $state[$p:lk] = 7285                           (: 'following' '#' :)
          or $state[$p:lk] = 7286                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7287                           (: 'for' '#' :)
          or $state[$p:lk] = 7289                           (: 'ge' '#' :)
          or $state[$p:lk] = 7291                           (: 'group' '#' :)
          or $state[$p:lk] = 7293                           (: 'gt' '#' :)
          or $state[$p:lk] = 7294                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7296                           (: 'import' '#' :)
          or $state[$p:lk] = 7300                           (: 'insert' '#' :)
          or $state[$p:lk] = 7301                           (: 'instance' '#' :)
          or $state[$p:lk] = 7302                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7303                           (: 'into' '#' :)
          or $state[$p:lk] = 7304                           (: 'is' '#' :)
          or $state[$p:lk] = 7306                           (: 'last' '#' :)
          or $state[$p:lk] = 7308                           (: 'le' '#' :)
          or $state[$p:lk] = 7310                           (: 'let' '#' :)
          or $state[$p:lk] = 7311                           (: 'lt' '#' :)
          or $state[$p:lk] = 7313                           (: 'mod' '#' :)
          or $state[$p:lk] = 7314                           (: 'modify' '#' :)
          or $state[$p:lk] = 7315                           (: 'module' '#' :)
          or $state[$p:lk] = 7316                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7318                           (: 'ne' '#' :)
          or $state[$p:lk] = 7325                           (: 'only' '#' :)
          or $state[$p:lk] = 7327                           (: 'or' '#' :)
          or $state[$p:lk] = 7328                           (: 'order' '#' :)
          or $state[$p:lk] = 7329                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7331                           (: 'parent' '#' :)
          or $state[$p:lk] = 7335                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7336                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7339                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7340                           (: 'rename' '#' :)
          or $state[$p:lk] = 7341                           (: 'replace' '#' :)
          or $state[$p:lk] = 7342                           (: 'return' '#' :)
          or $state[$p:lk] = 7344                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7348                           (: 'self' '#' :)
          or $state[$p:lk] = 7351                           (: 'some' '#' :)
          or $state[$p:lk] = 7352                           (: 'stable' '#' :)
          or $state[$p:lk] = 7353                           (: 'start' '#' :)
          or $state[$p:lk] = 7357                           (: 'text' '#' :)
          or $state[$p:lk] = 7359                           (: 'to' '#' :)
          or $state[$p:lk] = 7360                           (: 'treat' '#' :)
          or $state[$p:lk] = 7361                           (: 'try' '#' :)
          or $state[$p:lk] = 7365                           (: 'union' '#' :)
          or $state[$p:lk] = 7366                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7368                           (: 'validate' '#' :)
          or $state[$p:lk] = 7373                           (: 'where' '#' :)
          or $state[$p:lk] = 7375                           (: 'with' '#' :)
          or $state[$p:lk] = 7376) then                     (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Constructor($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(161, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 33                               (: '(' :)
      and $state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 66) then                      (: '[' :)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  return $state
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 77) then                            (: 'attribute' :)
      let $state := p:lookahead2W(198, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' | '|' |
                                                               '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 22349) then                     (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(64, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24909) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27725) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(115, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30541) then                (: 'attribute' 'for' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 34125) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(97, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 40269) then                (: 'attribute' 'only' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 47181) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19277                      (: 'attribute' 'ascending' :)
              or $state[$p:lk] = 25933) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(140, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23885                      (: 'attribute' 'count' :)
              or $state[$p:lk] = 36429) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(69, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28493                      (: 'attribute' 'end' :)
              or $state[$p:lk] = 47437) then                (: 'attribute' 'start' :)
          let $state := p:lookahead3W(129, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31565                      (: 'attribute' 'group' :)
              or $state[$p:lk] = 41037) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21325                      (: 'attribute' 'cast' :)
              or $state[$p:lk] = 21581                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 49229) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17741                      (: 'attribute' 'after' :)
              or $state[$p:lk] = 18765                      (: 'attribute' 'and' :)
              or $state[$p:lk] = 19021                      (: 'attribute' 'as' :)
              or $state[$p:lk] = 20301                      (: 'attribute' 'before' :)
              or $state[$p:lk] = 21069                      (: 'attribute' 'case' :)
              or $state[$p:lk] = 26445                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 27469                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 28749                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 29261                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 31053                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 32077                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 32333                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 34381                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 34637                      (: 'attribute' 'into' :)
              or $state[$p:lk] = 34893                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 35917                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 36685                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 37197                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 37453                      (: 'attribute' 'modify' :)
              or $state[$p:lk] = 38477                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 40781                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 44621                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 45133                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 48973                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 50509                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 52557                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 53069) then                (: 'attribute' 'with' :)
          let $state := p:lookahead3W(194, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:lookahead2W(197, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '{' | '|' |
                                                               '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 22378) then                     (: 'element' 'collation' :)
          let $state := p:lookahead3W(64, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24938) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27754) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(115, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30570) then                (: 'element' 'for' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 34154) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(97, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 40298) then                (: 'element' 'only' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 47210) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19306                      (: 'element' 'ascending' :)
              or $state[$p:lk] = 25962) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(140, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23914                      (: 'element' 'count' :)
              or $state[$p:lk] = 36458) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(69, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28522                      (: 'element' 'end' :)
              or $state[$p:lk] = 47466) then                (: 'element' 'start' :)
          let $state := p:lookahead3W(129, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31594                      (: 'element' 'group' :)
              or $state[$p:lk] = 41066) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21354                      (: 'element' 'cast' :)
              or $state[$p:lk] = 21610                      (: 'element' 'castable' :)
              or $state[$p:lk] = 49258) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17770                      (: 'element' 'after' :)
              or $state[$p:lk] = 18794                      (: 'element' 'and' :)
              or $state[$p:lk] = 19050                      (: 'element' 'as' :)
              or $state[$p:lk] = 20330                      (: 'element' 'before' :)
              or $state[$p:lk] = 21098                      (: 'element' 'case' :)
              or $state[$p:lk] = 26474                      (: 'element' 'div' :)
              or $state[$p:lk] = 27498                      (: 'element' 'else' :)
              or $state[$p:lk] = 28778                      (: 'element' 'eq' :)
              or $state[$p:lk] = 29290                      (: 'element' 'except' :)
              or $state[$p:lk] = 31082                      (: 'element' 'ge' :)
              or $state[$p:lk] = 32106                      (: 'element' 'gt' :)
              or $state[$p:lk] = 32362                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 34410                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 34666                      (: 'element' 'into' :)
              or $state[$p:lk] = 34922                      (: 'element' 'is' :)
              or $state[$p:lk] = 35946                      (: 'element' 'le' :)
              or $state[$p:lk] = 36714                      (: 'element' 'lt' :)
              or $state[$p:lk] = 37226                      (: 'element' 'mod' :)
              or $state[$p:lk] = 37482                      (: 'element' 'modify' :)
              or $state[$p:lk] = 38506                      (: 'element' 'ne' :)
              or $state[$p:lk] = 40810                      (: 'element' 'or' :)
              or $state[$p:lk] = 44650                      (: 'element' 'return' :)
              or $state[$p:lk] = 45162                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 49002                      (: 'element' 'to' :)
              or $state[$p:lk] = 50538                      (: 'element' 'union' :)
              or $state[$p:lk] = 52586                      (: 'element' 'where' :)
              or $state[$p:lk] = 53098) then                (: 'element' 'with' :)
          let $state := p:lookahead3W(194, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 148                            (: 'namespace' :)
          or $state[$p:l1] = 171) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(170, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 22420                           (: 'namespace' 'collation' :)
         or $state[$p:lk] = 22443) then                     (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(64, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24980                      (: 'namespace' 'default' :)
              or $state[$p:lk] = 25003) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(107, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27796                      (: 'namespace' 'empty' :)
              or $state[$p:lk] = 27819) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(115, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30612                      (: 'namespace' 'for' :)
              or $state[$p:lk] = 30635) then                (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 34196                      (: 'namespace' 'instance' :)
              or $state[$p:lk] = 34219) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(97, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 40340                      (: 'namespace' 'only' :)
              or $state[$p:lk] = 40363) then                (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 47252                      (: 'namespace' 'stable' :)
              or $state[$p:lk] = 47275) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19348                      (: 'namespace' 'ascending' :)
              or $state[$p:lk] = 26004                      (: 'namespace' 'descending' :)
              or $state[$p:lk] = 19371                      (: 'processing-instruction' 'ascending' :)
              or $state[$p:lk] = 26027) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(140, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23956                      (: 'namespace' 'count' :)
              or $state[$p:lk] = 36500                      (: 'namespace' 'let' :)
              or $state[$p:lk] = 23979                      (: 'processing-instruction' 'count' :)
              or $state[$p:lk] = 36523) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(69, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28564                      (: 'namespace' 'end' :)
              or $state[$p:lk] = 47508                      (: 'namespace' 'start' :)
              or $state[$p:lk] = 28587                      (: 'processing-instruction' 'end' :)
              or $state[$p:lk] = 47531) then                (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(129, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31636                      (: 'namespace' 'group' :)
              or $state[$p:lk] = 41108                      (: 'namespace' 'order' :)
              or $state[$p:lk] = 31659                      (: 'processing-instruction' 'group' :)
              or $state[$p:lk] = 41131) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21396                      (: 'namespace' 'cast' :)
              or $state[$p:lk] = 21652                      (: 'namespace' 'castable' :)
              or $state[$p:lk] = 49300                      (: 'namespace' 'treat' :)
              or $state[$p:lk] = 21419                      (: 'processing-instruction' 'cast' :)
              or $state[$p:lk] = 21675                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 49323) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17812                      (: 'namespace' 'after' :)
              or $state[$p:lk] = 18836                      (: 'namespace' 'and' :)
              or $state[$p:lk] = 19092                      (: 'namespace' 'as' :)
              or $state[$p:lk] = 20372                      (: 'namespace' 'before' :)
              or $state[$p:lk] = 21140                      (: 'namespace' 'case' :)
              or $state[$p:lk] = 26516                      (: 'namespace' 'div' :)
              or $state[$p:lk] = 27540                      (: 'namespace' 'else' :)
              or $state[$p:lk] = 28820                      (: 'namespace' 'eq' :)
              or $state[$p:lk] = 29332                      (: 'namespace' 'except' :)
              or $state[$p:lk] = 31124                      (: 'namespace' 'ge' :)
              or $state[$p:lk] = 32148                      (: 'namespace' 'gt' :)
              or $state[$p:lk] = 32404                      (: 'namespace' 'idiv' :)
              or $state[$p:lk] = 34452                      (: 'namespace' 'intersect' :)
              or $state[$p:lk] = 34708                      (: 'namespace' 'into' :)
              or $state[$p:lk] = 34964                      (: 'namespace' 'is' :)
              or $state[$p:lk] = 35988                      (: 'namespace' 'le' :)
              or $state[$p:lk] = 36756                      (: 'namespace' 'lt' :)
              or $state[$p:lk] = 37268                      (: 'namespace' 'mod' :)
              or $state[$p:lk] = 37524                      (: 'namespace' 'modify' :)
              or $state[$p:lk] = 38548                      (: 'namespace' 'ne' :)
              or $state[$p:lk] = 40852                      (: 'namespace' 'or' :)
              or $state[$p:lk] = 44692                      (: 'namespace' 'return' :)
              or $state[$p:lk] = 45204                      (: 'namespace' 'satisfies' :)
              or $state[$p:lk] = 49044                      (: 'namespace' 'to' :)
              or $state[$p:lk] = 50580                      (: 'namespace' 'union' :)
              or $state[$p:lk] = 52628                      (: 'namespace' 'where' :)
              or $state[$p:lk] = 53140                      (: 'namespace' 'with' :)
              or $state[$p:lk] = 17835                      (: 'processing-instruction' 'after' :)
              or $state[$p:lk] = 18859                      (: 'processing-instruction' 'and' :)
              or $state[$p:lk] = 19115                      (: 'processing-instruction' 'as' :)
              or $state[$p:lk] = 20395                      (: 'processing-instruction' 'before' :)
              or $state[$p:lk] = 21163                      (: 'processing-instruction' 'case' :)
              or $state[$p:lk] = 26539                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 27563                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 28843                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 29355                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 31147                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 32171                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 32427                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 34475                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 34731                      (: 'processing-instruction' 'into' :)
              or $state[$p:lk] = 34987                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 36011                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 36779                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 37291                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 37547                      (: 'processing-instruction' 'modify' :)
              or $state[$p:lk] = 38571                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 40875                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 44715                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 45227                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 49067                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 50603                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 52651                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 53163) then                (: 'processing-instruction' 'with' :)
          let $state := p:lookahead3W(194, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 88                             (: 'comment' :)
          or $state[$p:l1] = 104                            (: 'document' :)
          or $state[$p:l1] = 161                            (: 'ordered' :)
          or $state[$p:l1] = 189                            (: 'text' :)
          or $state[$p:l1] = 198) then                      (: 'unordered' :)
      let $state := p:lookahead2W(169, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '{' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 5                              (: URIQualifiedName :)
          or $state[$p:l1] = 109                            (: 'empty-sequence' :)
          or $state[$p:l1] = 127                            (: 'if' :)
          or $state[$p:l1] = 137                            (: 'item' :)
          or $state[$p:l1] = 188                            (: 'switch' :)
          or $state[$p:l1] = 196) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(160, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 71                             (: 'ancestor' :)
          or $state[$p:l1] = 72                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 86                             (: 'child' :)
          or $state[$p:l1] = 99                             (: 'descendant' :)
          or $state[$p:l1] = 100                            (: 'descendant-or-self' :)
          or $state[$p:l1] = 117                            (: 'following' :)
          or $state[$p:l1] = 118                            (: 'following-sibling' :)
          or $state[$p:l1] = 163                            (: 'parent' :)
          or $state[$p:l1] = 167                            (: 'preceding' :)
          or $state[$p:l1] = 168                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 180) then                      (: 'self' :)
      let $state := p:lookahead2W(167, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 14                             (: QName^Token :)
          or $state[$p:l1] = 69                             (: 'after' :)
          or $state[$p:l1] = 73                             (: 'and' :)
          or $state[$p:l1] = 74                             (: 'as' :)
          or $state[$p:l1] = 75                             (: 'ascending' :)
          or $state[$p:l1] = 79                             (: 'before' :)
          or $state[$p:l1] = 82                             (: 'case' :)
          or $state[$p:l1] = 83                             (: 'cast' :)
          or $state[$p:l1] = 84                             (: 'castable' :)
          or $state[$p:l1] = 87                             (: 'collation' :)
          or $state[$p:l1] = 91                             (: 'copy' :)
          or $state[$p:l1] = 93                             (: 'count' :)
          or $state[$p:l1] = 96                             (: 'declare' :)
          or $state[$p:l1] = 97                             (: 'default' :)
          or $state[$p:l1] = 98                             (: 'delete' :)
          or $state[$p:l1] = 101                            (: 'descending' :)
          or $state[$p:l1] = 103                            (: 'div' :)
          or $state[$p:l1] = 105                            (: 'document-node' :)
          or $state[$p:l1] = 107                            (: 'else' :)
          or $state[$p:l1] = 108                            (: 'empty' :)
          or $state[$p:l1] = 111                            (: 'end' :)
          or $state[$p:l1] = 112                            (: 'eq' :)
          or $state[$p:l1] = 113                            (: 'every' :)
          or $state[$p:l1] = 114                            (: 'except' :)
          or $state[$p:l1] = 116                            (: 'first' :)
          or $state[$p:l1] = 119                            (: 'for' :)
          or $state[$p:l1] = 120                            (: 'function' :)
          or $state[$p:l1] = 121                            (: 'ge' :)
          or $state[$p:l1] = 123                            (: 'group' :)
          or $state[$p:l1] = 125                            (: 'gt' :)
          or $state[$p:l1] = 126                            (: 'idiv' :)
          or $state[$p:l1] = 128                            (: 'import' :)
          or $state[$p:l1] = 132                            (: 'insert' :)
          or $state[$p:l1] = 133                            (: 'instance' :)
          or $state[$p:l1] = 134                            (: 'intersect' :)
          or $state[$p:l1] = 135                            (: 'into' :)
          or $state[$p:l1] = 136                            (: 'is' :)
          or $state[$p:l1] = 138                            (: 'last' :)
          or $state[$p:l1] = 140                            (: 'le' :)
          or $state[$p:l1] = 142                            (: 'let' :)
          or $state[$p:l1] = 143                            (: 'lt' :)
          or $state[$p:l1] = 145                            (: 'mod' :)
          or $state[$p:l1] = 146                            (: 'modify' :)
          or $state[$p:l1] = 147                            (: 'module' :)
          or $state[$p:l1] = 149                            (: 'namespace-node' :)
          or $state[$p:l1] = 150                            (: 'ne' :)
          or $state[$p:l1] = 154                            (: 'node' :)
          or $state[$p:l1] = 157                            (: 'only' :)
          or $state[$p:l1] = 159                            (: 'or' :)
          or $state[$p:l1] = 160                            (: 'order' :)
          or $state[$p:l1] = 172                            (: 'rename' :)
          or $state[$p:l1] = 173                            (: 'replace' :)
          or $state[$p:l1] = 174                            (: 'return' :)
          or $state[$p:l1] = 176                            (: 'satisfies' :)
          or $state[$p:l1] = 178                            (: 'schema-attribute' :)
          or $state[$p:l1] = 179                            (: 'schema-element' :)
          or $state[$p:l1] = 183                            (: 'some' :)
          or $state[$p:l1] = 184                            (: 'stable' :)
          or $state[$p:l1] = 185                            (: 'start' :)
          or $state[$p:l1] = 191                            (: 'to' :)
          or $state[$p:l1] = 192                            (: 'treat' :)
          or $state[$p:l1] = 193                            (: 'try' :)
          or $state[$p:l1] = 197                            (: 'union' :)
          or $state[$p:l1] = 200                            (: 'validate' :)
          or $state[$p:l1] = 205                            (: 'where' :)
          or $state[$p:l1] = 207                            (: 'with' :)
          or $state[$p:l1] = 208) then                      (: 'xquery' :)
      let $state := p:lookahead2W(164, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 1                                   (: IntegerLiteral :)
     or $state[$p:lk] = 2                                   (: DecimalLiteral :)
     or $state[$p:lk] = 3                                   (: DoubleLiteral :)
     or $state[$p:lk] = 4                                   (: StringLiteral :)
     or $state[$p:lk] = 30                                  (: '$' :)
     or $state[$p:lk] = 31                                  (: '%' :)
     or $state[$p:lk] = 33                                  (: '(' :)
     or $state[$p:lk] = 42                                  (: '.' :)
     or $state[$p:lk] = 51                                  (: '<' :)
     or $state[$p:lk] = 52                                  (: '<!--' :)
     or $state[$p:lk] = 57                                  (: '<?' :)
     or $state[$p:lk] = 1357                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 1386                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 3661                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 3690                                (: 'element' QName^Token :)
     or $state[$p:lk] = 3988                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 4011                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 7173                                (: URIQualifiedName '#' :)
     or $state[$p:lk] = 7182                                (: QName^Token '#' :)
     or $state[$p:lk] = 7237                                (: 'after' '#' :)
     or $state[$p:lk] = 7239                                (: 'ancestor' '#' :)
     or $state[$p:lk] = 7240                                (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 7241                                (: 'and' '#' :)
     or $state[$p:lk] = 7242                                (: 'as' '#' :)
     or $state[$p:lk] = 7243                                (: 'ascending' '#' :)
     or $state[$p:lk] = 7245                                (: 'attribute' '#' :)
     or $state[$p:lk] = 7247                                (: 'before' '#' :)
     or $state[$p:lk] = 7250                                (: 'case' '#' :)
     or $state[$p:lk] = 7251                                (: 'cast' '#' :)
     or $state[$p:lk] = 7252                                (: 'castable' '#' :)
     or $state[$p:lk] = 7254                                (: 'child' '#' :)
     or $state[$p:lk] = 7255                                (: 'collation' '#' :)
     or $state[$p:lk] = 7256                                (: 'comment' '#' :)
     or $state[$p:lk] = 7259                                (: 'copy' '#' :)
     or $state[$p:lk] = 7261                                (: 'count' '#' :)
     or $state[$p:lk] = 7264                                (: 'declare' '#' :)
     or $state[$p:lk] = 7265                                (: 'default' '#' :)
     or $state[$p:lk] = 7266                                (: 'delete' '#' :)
     or $state[$p:lk] = 7267                                (: 'descendant' '#' :)
     or $state[$p:lk] = 7268                                (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 7269                                (: 'descending' '#' :)
     or $state[$p:lk] = 7271                                (: 'div' '#' :)
     or $state[$p:lk] = 7272                                (: 'document' '#' :)
     or $state[$p:lk] = 7273                                (: 'document-node' '#' :)
     or $state[$p:lk] = 7274                                (: 'element' '#' :)
     or $state[$p:lk] = 7275                                (: 'else' '#' :)
     or $state[$p:lk] = 7276                                (: 'empty' '#' :)
     or $state[$p:lk] = 7277                                (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 7279                                (: 'end' '#' :)
     or $state[$p:lk] = 7280                                (: 'eq' '#' :)
     or $state[$p:lk] = 7281                                (: 'every' '#' :)
     or $state[$p:lk] = 7282                                (: 'except' '#' :)
     or $state[$p:lk] = 7284                                (: 'first' '#' :)
     or $state[$p:lk] = 7285                                (: 'following' '#' :)
     or $state[$p:lk] = 7286                                (: 'following-sibling' '#' :)
     or $state[$p:lk] = 7287                                (: 'for' '#' :)
     or $state[$p:lk] = 7288                                (: 'function' '#' :)
     or $state[$p:lk] = 7289                                (: 'ge' '#' :)
     or $state[$p:lk] = 7291                                (: 'group' '#' :)
     or $state[$p:lk] = 7293                                (: 'gt' '#' :)
     or $state[$p:lk] = 7294                                (: 'idiv' '#' :)
     or $state[$p:lk] = 7295                                (: 'if' '#' :)
     or $state[$p:lk] = 7296                                (: 'import' '#' :)
     or $state[$p:lk] = 7300                                (: 'insert' '#' :)
     or $state[$p:lk] = 7301                                (: 'instance' '#' :)
     or $state[$p:lk] = 7302                                (: 'intersect' '#' :)
     or $state[$p:lk] = 7303                                (: 'into' '#' :)
     or $state[$p:lk] = 7304                                (: 'is' '#' :)
     or $state[$p:lk] = 7305                                (: 'item' '#' :)
     or $state[$p:lk] = 7306                                (: 'last' '#' :)
     or $state[$p:lk] = 7308                                (: 'le' '#' :)
     or $state[$p:lk] = 7310                                (: 'let' '#' :)
     or $state[$p:lk] = 7311                                (: 'lt' '#' :)
     or $state[$p:lk] = 7313                                (: 'mod' '#' :)
     or $state[$p:lk] = 7314                                (: 'modify' '#' :)
     or $state[$p:lk] = 7315                                (: 'module' '#' :)
     or $state[$p:lk] = 7316                                (: 'namespace' '#' :)
     or $state[$p:lk] = 7317                                (: 'namespace-node' '#' :)
     or $state[$p:lk] = 7318                                (: 'ne' '#' :)
     or $state[$p:lk] = 7322                                (: 'node' '#' :)
     or $state[$p:lk] = 7325                                (: 'only' '#' :)
     or $state[$p:lk] = 7327                                (: 'or' '#' :)
     or $state[$p:lk] = 7328                                (: 'order' '#' :)
     or $state[$p:lk] = 7329                                (: 'ordered' '#' :)
     or $state[$p:lk] = 7331                                (: 'parent' '#' :)
     or $state[$p:lk] = 7335                                (: 'preceding' '#' :)
     or $state[$p:lk] = 7336                                (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 7339                                (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 7340                                (: 'rename' '#' :)
     or $state[$p:lk] = 7341                                (: 'replace' '#' :)
     or $state[$p:lk] = 7342                                (: 'return' '#' :)
     or $state[$p:lk] = 7344                                (: 'satisfies' '#' :)
     or $state[$p:lk] = 7346                                (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 7347                                (: 'schema-element' '#' :)
     or $state[$p:lk] = 7348                                (: 'self' '#' :)
     or $state[$p:lk] = 7351                                (: 'some' '#' :)
     or $state[$p:lk] = 7352                                (: 'stable' '#' :)
     or $state[$p:lk] = 7353                                (: 'start' '#' :)
     or $state[$p:lk] = 7356                                (: 'switch' '#' :)
     or $state[$p:lk] = 7357                                (: 'text' '#' :)
     or $state[$p:lk] = 7359                                (: 'to' '#' :)
     or $state[$p:lk] = 7360                                (: 'treat' '#' :)
     or $state[$p:lk] = 7361                                (: 'try' '#' :)
     or $state[$p:lk] = 7364                                (: 'typeswitch' '#' :)
     or $state[$p:lk] = 7365                                (: 'union' '#' :)
     or $state[$p:lk] = 7366                                (: 'unordered' '#' :)
     or $state[$p:lk] = 7368                                (: 'validate' '#' :)
     or $state[$p:lk] = 7373                                (: 'where' '#' :)
     or $state[$p:lk] = 7375                                (: 'with' '#' :)
     or $state[$p:lk] = 7376                                (: 'xquery' '#' :)
     or $state[$p:lk] = 8462                                (: QName^Token '(' :)
     or $state[$p:lk] = 8517                                (: 'after' '(' :)
     or $state[$p:lk] = 8519                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8520                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8521                                (: 'and' '(' :)
     or $state[$p:lk] = 8522                                (: 'as' '(' :)
     or $state[$p:lk] = 8523                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8527                                (: 'before' '(' :)
     or $state[$p:lk] = 8530                                (: 'case' '(' :)
     or $state[$p:lk] = 8531                                (: 'cast' '(' :)
     or $state[$p:lk] = 8532                                (: 'castable' '(' :)
     or $state[$p:lk] = 8534                                (: 'child' '(' :)
     or $state[$p:lk] = 8535                                (: 'collation' '(' :)
     or $state[$p:lk] = 8539                                (: 'copy' '(' :)
     or $state[$p:lk] = 8541                                (: 'count' '(' :)
     or $state[$p:lk] = 8544                                (: 'declare' '(' :)
     or $state[$p:lk] = 8545                                (: 'default' '(' :)
     or $state[$p:lk] = 8546                                (: 'delete' '(' :)
     or $state[$p:lk] = 8547                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8548                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8549                                (: 'descending' '(' :)
     or $state[$p:lk] = 8551                                (: 'div' '(' :)
     or $state[$p:lk] = 8552                                (: 'document' '(' :)
     or $state[$p:lk] = 8555                                (: 'else' '(' :)
     or $state[$p:lk] = 8556                                (: 'empty' '(' :)
     or $state[$p:lk] = 8559                                (: 'end' '(' :)
     or $state[$p:lk] = 8560                                (: 'eq' '(' :)
     or $state[$p:lk] = 8561                                (: 'every' '(' :)
     or $state[$p:lk] = 8562                                (: 'except' '(' :)
     or $state[$p:lk] = 8564                                (: 'first' '(' :)
     or $state[$p:lk] = 8565                                (: 'following' '(' :)
     or $state[$p:lk] = 8566                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8567                                (: 'for' '(' :)
     or $state[$p:lk] = 8568                                (: 'function' '(' :)
     or $state[$p:lk] = 8569                                (: 'ge' '(' :)
     or $state[$p:lk] = 8571                                (: 'group' '(' :)
     or $state[$p:lk] = 8573                                (: 'gt' '(' :)
     or $state[$p:lk] = 8574                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8576                                (: 'import' '(' :)
     or $state[$p:lk] = 8580                                (: 'insert' '(' :)
     or $state[$p:lk] = 8581                                (: 'instance' '(' :)
     or $state[$p:lk] = 8582                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8583                                (: 'into' '(' :)
     or $state[$p:lk] = 8584                                (: 'is' '(' :)
     or $state[$p:lk] = 8586                                (: 'last' '(' :)
     or $state[$p:lk] = 8588                                (: 'le' '(' :)
     or $state[$p:lk] = 8590                                (: 'let' '(' :)
     or $state[$p:lk] = 8591                                (: 'lt' '(' :)
     or $state[$p:lk] = 8593                                (: 'mod' '(' :)
     or $state[$p:lk] = 8594                                (: 'modify' '(' :)
     or $state[$p:lk] = 8595                                (: 'module' '(' :)
     or $state[$p:lk] = 8596                                (: 'namespace' '(' :)
     or $state[$p:lk] = 8598                                (: 'ne' '(' :)
     or $state[$p:lk] = 8605                                (: 'only' '(' :)
     or $state[$p:lk] = 8607                                (: 'or' '(' :)
     or $state[$p:lk] = 8608                                (: 'order' '(' :)
     or $state[$p:lk] = 8609                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8611                                (: 'parent' '(' :)
     or $state[$p:lk] = 8615                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8616                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8620                                (: 'rename' '(' :)
     or $state[$p:lk] = 8621                                (: 'replace' '(' :)
     or $state[$p:lk] = 8622                                (: 'return' '(' :)
     or $state[$p:lk] = 8624                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8628                                (: 'self' '(' :)
     or $state[$p:lk] = 8631                                (: 'some' '(' :)
     or $state[$p:lk] = 8632                                (: 'stable' '(' :)
     or $state[$p:lk] = 8633                                (: 'start' '(' :)
     or $state[$p:lk] = 8639                                (: 'to' '(' :)
     or $state[$p:lk] = 8640                                (: 'treat' '(' :)
     or $state[$p:lk] = 8641                                (: 'try' '(' :)
     or $state[$p:lk] = 8645                                (: 'union' '(' :)
     or $state[$p:lk] = 8646                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8648                                (: 'validate' '(' :)
     or $state[$p:lk] = 8653                                (: 'where' '(' :)
     or $state[$p:lk] = 8655                                (: 'with' '(' :)
     or $state[$p:lk] = 8656                                (: 'xquery' '(' :)
     or $state[$p:lk] = 18253                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 18282                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 18509                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18538                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 19789                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 19818                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 22093                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 22122                               (: 'element' 'child' :)
     or $state[$p:lk] = 22605                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 22634                               (: 'element' 'comment' :)
     or $state[$p:lk] = 23373                               (: 'attribute' 'copy' :)
     or $state[$p:lk] = 23402                               (: 'element' 'copy' :)
     or $state[$p:lk] = 24653                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 24682                               (: 'element' 'declare' :)
     or $state[$p:lk] = 25165                               (: 'attribute' 'delete' :)
     or $state[$p:lk] = 25194                               (: 'element' 'delete' :)
     or $state[$p:lk] = 25421                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 25450                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 25677                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 25706                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 26701                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 26730                               (: 'element' 'document' :)
     or $state[$p:lk] = 26957                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 26986                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 27213                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 27242                               (: 'element' 'element' :)
     or $state[$p:lk] = 27981                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 28010                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 29005                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 29034                               (: 'element' 'every' :)
     or $state[$p:lk] = 29773                               (: 'attribute' 'first' :)
     or $state[$p:lk] = 29802                               (: 'element' 'first' :)
     or $state[$p:lk] = 30029                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 30058                               (: 'element' 'following' :)
     or $state[$p:lk] = 30285                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 30314                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 30797                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 30826                               (: 'element' 'function' :)
     or $state[$p:lk] = 32589                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 32618                               (: 'element' 'if' :)
     or $state[$p:lk] = 32845                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 32874                               (: 'element' 'import' :)
     or $state[$p:lk] = 33869                               (: 'attribute' 'insert' :)
     or $state[$p:lk] = 33898                               (: 'element' 'insert' :)
     or $state[$p:lk] = 35149                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 35178                               (: 'element' 'item' :)
     or $state[$p:lk] = 35405                               (: 'attribute' 'last' :)
     or $state[$p:lk] = 35434                               (: 'element' 'last' :)
     or $state[$p:lk] = 37709                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 37738                               (: 'element' 'module' :)
     or $state[$p:lk] = 37965                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 37994                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 38221                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 38250                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 39501                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 39530                               (: 'element' 'node' :)
     or $state[$p:lk] = 41293                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 41322                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 41805                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 41834                               (: 'element' 'parent' :)
     or $state[$p:lk] = 42829                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 42858                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 43085                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 43114                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 43853                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 43882                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 44109                               (: 'attribute' 'rename' :)
     or $state[$p:lk] = 44138                               (: 'element' 'rename' :)
     or $state[$p:lk] = 44365                               (: 'attribute' 'replace' :)
     or $state[$p:lk] = 44394                               (: 'element' 'replace' :)
     or $state[$p:lk] = 45645                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 45674                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 45901                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 45930                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 46157                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 46186                               (: 'element' 'self' :)
     or $state[$p:lk] = 46925                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 46954                               (: 'element' 'some' :)
     or $state[$p:lk] = 48205                               (: 'attribute' 'switch' :)
     or $state[$p:lk] = 48234                               (: 'element' 'switch' :)
     or $state[$p:lk] = 48461                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 48490                               (: 'element' 'text' :)
     or $state[$p:lk] = 49485                               (: 'attribute' 'try' :)
     or $state[$p:lk] = 49514                               (: 'element' 'try' :)
     or $state[$p:lk] = 50253                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 50282                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 50765                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 50794                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 51277                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 51306                               (: 'element' 'validate' :)
     or $state[$p:lk] = 53325                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 53354                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 53837                               (: 'attribute' '{' :)
     or $state[$p:lk] = 53848                               (: 'comment' '{' :)
     or $state[$p:lk] = 53864                               (: 'document' '{' :)
     or $state[$p:lk] = 53866                               (: 'element' '{' :)
     or $state[$p:lk] = 53908                               (: 'namespace' '{' :)
     or $state[$p:lk] = 53921                               (: 'ordered' '{' :)
     or $state[$p:lk] = 53931                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 53949                               (: 'text' '{' :)
     or $state[$p:lk] = 53958                               (: 'unordered' '{' :)
     or $state[$p:lk] = 13780301                            (: 'attribute' 'after' '{' :)
     or $state[$p:lk] = 13780330                            (: 'element' 'after' '{' :)
     or $state[$p:lk] = 13780372                            (: 'namespace' 'after' '{' :)
     or $state[$p:lk] = 13780395                            (: 'processing-instruction' 'after' '{' :)
     or $state[$p:lk] = 13781325                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 13781354                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 13781396                            (: 'namespace' 'and' '{' :)
     or $state[$p:lk] = 13781419                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 13781581                            (: 'attribute' 'as' '{' :)
     or $state[$p:lk] = 13781610                            (: 'element' 'as' '{' :)
     or $state[$p:lk] = 13781652                            (: 'namespace' 'as' '{' :)
     or $state[$p:lk] = 13781675                            (: 'processing-instruction' 'as' '{' :)
     or $state[$p:lk] = 13781837                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 13781866                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 13781908                            (: 'namespace' 'ascending' '{' :)
     or $state[$p:lk] = 13781931                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 13782861                            (: 'attribute' 'before' '{' :)
     or $state[$p:lk] = 13782890                            (: 'element' 'before' '{' :)
     or $state[$p:lk] = 13782932                            (: 'namespace' 'before' '{' :)
     or $state[$p:lk] = 13782955                            (: 'processing-instruction' 'before' '{' :)
     or $state[$p:lk] = 13783629                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 13783658                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 13783700                            (: 'namespace' 'case' '{' :)
     or $state[$p:lk] = 13783723                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 13783885                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 13783914                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 13783956                            (: 'namespace' 'cast' '{' :)
     or $state[$p:lk] = 13783979                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 13784141                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 13784170                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 13784212                            (: 'namespace' 'castable' '{' :)
     or $state[$p:lk] = 13784235                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 13784909                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 13784938                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 13784980                            (: 'namespace' 'collation' '{' :)
     or $state[$p:lk] = 13785003                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 13786445                            (: 'attribute' 'count' '{' :)
     or $state[$p:lk] = 13786474                            (: 'element' 'count' '{' :)
     or $state[$p:lk] = 13786516                            (: 'namespace' 'count' '{' :)
     or $state[$p:lk] = 13786539                            (: 'processing-instruction' 'count' '{' :)
     or $state[$p:lk] = 13787469                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 13787498                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 13787540                            (: 'namespace' 'default' '{' :)
     or $state[$p:lk] = 13787563                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 13788493                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 13788522                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 13788564                            (: 'namespace' 'descending' '{' :)
     or $state[$p:lk] = 13788587                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 13789005                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 13789034                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 13789076                            (: 'namespace' 'div' '{' :)
     or $state[$p:lk] = 13789099                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 13790029                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 13790058                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 13790100                            (: 'namespace' 'else' '{' :)
     or $state[$p:lk] = 13790123                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 13790285                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 13790314                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 13790356                            (: 'namespace' 'empty' '{' :)
     or $state[$p:lk] = 13790379                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 13791053                            (: 'attribute' 'end' '{' :)
     or $state[$p:lk] = 13791082                            (: 'element' 'end' '{' :)
     or $state[$p:lk] = 13791124                            (: 'namespace' 'end' '{' :)
     or $state[$p:lk] = 13791147                            (: 'processing-instruction' 'end' '{' :)
     or $state[$p:lk] = 13791309                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 13791338                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 13791380                            (: 'namespace' 'eq' '{' :)
     or $state[$p:lk] = 13791403                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 13791821                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 13791850                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 13791892                            (: 'namespace' 'except' '{' :)
     or $state[$p:lk] = 13791915                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 13793101                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 13793130                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 13793172                            (: 'namespace' 'for' '{' :)
     or $state[$p:lk] = 13793195                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 13793613                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 13793642                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 13793684                            (: 'namespace' 'ge' '{' :)
     or $state[$p:lk] = 13793707                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 13794125                            (: 'attribute' 'group' '{' :)
     or $state[$p:lk] = 13794154                            (: 'element' 'group' '{' :)
     or $state[$p:lk] = 13794196                            (: 'namespace' 'group' '{' :)
     or $state[$p:lk] = 13794219                            (: 'processing-instruction' 'group' '{' :)
     or $state[$p:lk] = 13794637                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 13794666                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 13794708                            (: 'namespace' 'gt' '{' :)
     or $state[$p:lk] = 13794731                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 13794893                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 13794922                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 13794964                            (: 'namespace' 'idiv' '{' :)
     or $state[$p:lk] = 13794987                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 13796685                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 13796714                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 13796756                            (: 'namespace' 'instance' '{' :)
     or $state[$p:lk] = 13796779                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 13796941                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 13796970                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 13797012                            (: 'namespace' 'intersect' '{' :)
     or $state[$p:lk] = 13797035                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 13797197                            (: 'attribute' 'into' '{' :)
     or $state[$p:lk] = 13797226                            (: 'element' 'into' '{' :)
     or $state[$p:lk] = 13797268                            (: 'namespace' 'into' '{' :)
     or $state[$p:lk] = 13797291                            (: 'processing-instruction' 'into' '{' :)
     or $state[$p:lk] = 13797453                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 13797482                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 13797524                            (: 'namespace' 'is' '{' :)
     or $state[$p:lk] = 13797547                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 13798477                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 13798506                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 13798548                            (: 'namespace' 'le' '{' :)
     or $state[$p:lk] = 13798571                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 13798989                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 13799018                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 13799060                            (: 'namespace' 'let' '{' :)
     or $state[$p:lk] = 13799083                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 13799245                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 13799274                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 13799316                            (: 'namespace' 'lt' '{' :)
     or $state[$p:lk] = 13799339                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 13799757                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 13799786                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 13799828                            (: 'namespace' 'mod' '{' :)
     or $state[$p:lk] = 13799851                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 13800013                            (: 'attribute' 'modify' '{' :)
     or $state[$p:lk] = 13800042                            (: 'element' 'modify' '{' :)
     or $state[$p:lk] = 13800084                            (: 'namespace' 'modify' '{' :)
     or $state[$p:lk] = 13800107                            (: 'processing-instruction' 'modify' '{' :)
     or $state[$p:lk] = 13801037                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 13801066                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 13801108                            (: 'namespace' 'ne' '{' :)
     or $state[$p:lk] = 13801131                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 13802829                            (: 'attribute' 'only' '{' :)
     or $state[$p:lk] = 13802858                            (: 'element' 'only' '{' :)
     or $state[$p:lk] = 13802900                            (: 'namespace' 'only' '{' :)
     or $state[$p:lk] = 13802923                            (: 'processing-instruction' 'only' '{' :)
     or $state[$p:lk] = 13803341                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 13803370                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 13803412                            (: 'namespace' 'or' '{' :)
     or $state[$p:lk] = 13803435                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 13803597                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 13803626                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 13803668                            (: 'namespace' 'order' '{' :)
     or $state[$p:lk] = 13803691                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 13807181                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 13807210                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 13807252                            (: 'namespace' 'return' '{' :)
     or $state[$p:lk] = 13807275                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 13807693                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 13807722                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 13807764                            (: 'namespace' 'satisfies' '{' :)
     or $state[$p:lk] = 13807787                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 13809741                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 13809770                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 13809812                            (: 'namespace' 'stable' '{' :)
     or $state[$p:lk] = 13809835                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 13809997                            (: 'attribute' 'start' '{' :)
     or $state[$p:lk] = 13810026                            (: 'element' 'start' '{' :)
     or $state[$p:lk] = 13810068                            (: 'namespace' 'start' '{' :)
     or $state[$p:lk] = 13810091                            (: 'processing-instruction' 'start' '{' :)
     or $state[$p:lk] = 13811533                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 13811562                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 13811604                            (: 'namespace' 'to' '{' :)
     or $state[$p:lk] = 13811627                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 13811789                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 13811818                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 13811860                            (: 'namespace' 'treat' '{' :)
     or $state[$p:lk] = 13811883                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 13813069                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 13813098                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 13813140                            (: 'namespace' 'union' '{' :)
     or $state[$p:lk] = 13813163                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 13815117                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 13815146                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 13815188                            (: 'namespace' 'where' '{' :)
     or $state[$p:lk] = 13815211                            (: 'processing-instruction' 'where' '{' :)
     or $state[$p:lk] = 13815629                            (: 'attribute' 'with' '{' :)
     or $state[$p:lk] = 13815658                            (: 'element' 'with' '{' :)
     or $state[$p:lk] = 13815700                            (: 'namespace' 'with' '{' :)
     or $state[$p:lk] = 13815723) then                      (: 'processing-instruction' 'with' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 44                                 (: '/' :)
    and $state[$p:l1] != 45) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 44) then                        (: '/' :)
          let $state := p:shift(44, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(45, $input, $state)         (: '//' :)
          return $state
      let $state := p:lookahead1W(188, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state := p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return $state
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 44) then                            (: '/' :)
      let $state := p:shift(44, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(199, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' | '>' |
                                                               '>=' | '>>' | '@' | ']' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' | '|' | '||' |
                                                               '}' :)
      let $state :=
        if ($state[$p:l1] = 24                              (: EOF :)
         or $state[$p:l1] = 25                              (: '!' :)
         or $state[$p:l1] = 26                              (: '!=' :)
         or $state[$p:l1] = 36                              (: ')' :)
         or $state[$p:l1] = 37                              (: '*' :)
         or $state[$p:l1] = 38                              (: '+' :)
         or $state[$p:l1] = 39                              (: ',' :)
         or $state[$p:l1] = 40                              (: '-' :)
         or $state[$p:l1] = 50                              (: ';' :)
         or $state[$p:l1] = 55                              (: '<<' :)
         or $state[$p:l1] = 56                              (: '<=' :)
         or $state[$p:l1] = 58                              (: '=' :)
         or $state[$p:l1] = 59                              (: '>' :)
         or $state[$p:l1] = 60                              (: '>=' :)
         or $state[$p:l1] = 61                              (: '>>' :)
         or $state[$p:l1] = 67                              (: ']' :)
         or $state[$p:l1] = 212                             (: '|' :)
         or $state[$p:l1] = 213                             (: '||' :)
         or $state[$p:l1] = 214) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 45) then                       (: '//' :)
      let $state := p:shift(45, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(188, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: '!' :)
      $state
    else
      let $state := p:shift(25, $input, $state)             (: '!' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  return $state
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(34, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(177, $input, $state)           (: URIQualifiedName | QName^Token | S | 'after' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'as' |
                                                               'ascending' | 'attribute' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:shift(16, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:shift(16, $input, $state)             (: S :)
      let $state := p:lookahead1(1, $input, $state)         (: PragmaContents :)
      let $state := p:shift(19, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:shift(29, $input, $state)                 (: '#)' :)
  return $state
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(195, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 214) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 139) then                           (: 'lax' :)
      let $state := p:shift(139, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(186, $input, $state)            (: 'strict' :)
      return $state
  return $state
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(200, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(123, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 210) then                     (: '{' :)
      let $state :=
        if ($state[$p:l1] = 195) then                       (: 'type' :)
          let $state := p:shift(195, $input, $state)        (: 'type' :)
          let $state := p:lookahead1W(178, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 200) then                           (: 'validate' :)
      let $state := p:lookahead2W(174, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'lax' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'strict' | 'to' | 'treat' | 'type' | 'union' | 'where' |
                                                               'with' | '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 35784                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 47816                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 50120                               (: 'validate' 'type' :)
     or $state[$p:lk] = 53960) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-SimpleMapExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
    return
      if ($state[$p:l1] != 38                               (: '+' :)
      and $state[$p:l1] != 40) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 40) then                      (: '-' :)
            let $state := p:shift(40, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(38, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return $state
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'cast' :)
      let $state := p:shift(83, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(155, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'castable' :)
      let $state := p:shift(84, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(154, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 192) then                      (: 'treat' :)
      let $state := p:shift(192, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(183, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'union' | 'where' | 'with' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 133) then                      (: 'instance' :)
      let $state := p:shift(133, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(156, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(183, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(152, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 114                              (: 'except' :)
      and $state[$p:l1] != 134) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 134) then                     (: 'intersect' :)
            let $state := p:shift(134, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(114, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(190, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 197                                (: 'union' :)
    and $state[$p:l1] != 212) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 197) then                       (: 'union' :)
          let $state := p:shift(197, $input, $state)        (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(212, $input, $state)        (: '|' :)
          return $state
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37                                 (: '*' :)
    and $state[$p:l1] != 103                                (: 'div' :)
    and $state[$p:l1] != 126                                (: 'idiv' :)
    and $state[$p:l1] != 145) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 37) then                        (: '*' :)
          let $state := p:shift(37, $input, $state)         (: '*' :)
          return $state
        else if ($state[$p:l1] = 103) then                  (: 'div' :)
          let $state := p:shift(103, $input, $state)        (: 'div' :)
          return $state
        else if ($state[$p:l1] = 126) then                  (: 'idiv' :)
          let $state := p:shift(126, $input, $state)        (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(145, $input, $state)        (: 'mod' :)
          return $state
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '+' :)
    and $state[$p:l1] != 40) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 38) then                        (: '+' :)
          let $state := p:shift(38, $input, $state)         (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(40, $input, $state)         (: '-' :)
          return $state
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return $state
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 191) then                      (: 'to' :)
      let $state := p:shift(191, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 213) then                          (: '||' :)
      $state
    else
      let $state := p:shift(213, $input, $state)            (: '||' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  return $state
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 51                             (: '<' :)
          or $state[$p:l1] = 55                             (: '<<' :)
          or $state[$p:l1] = 56                             (: '<=' :)
          or $state[$p:l1] = 58                             (: '=' :)
          or $state[$p:l1] = 59                             (: '>' :)
          or $state[$p:l1] = 60                             (: '>=' :)
          or $state[$p:l1] = 61                             (: '>>' :)
          or $state[$p:l1] = 112                            (: 'eq' :)
          or $state[$p:l1] = 121                            (: 'ge' :)
          or $state[$p:l1] = 125                            (: 'gt' :)
          or $state[$p:l1] = 136                            (: 'is' :)
          or $state[$p:l1] = 140                            (: 'le' :)
          or $state[$p:l1] = 143                            (: 'lt' :)
          or $state[$p:l1] = 150) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 112                             (: 'eq' :)
         or $state[$p:l1] = 121                             (: 'ge' :)
         or $state[$p:l1] = 125                             (: 'gt' :)
         or $state[$p:l1] = 140                             (: 'le' :)
         or $state[$p:l1] = 143                             (: 'lt' :)
         or $state[$p:l1] = 150) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 55                         (: '<<' :)
              or $state[$p:l1] = 61                         (: '>>' :)
              or $state[$p:l1] = 136) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 73) then                           (: 'and' :)
      $state
    else
      let $state := p:shift(73, $input, $state)             (: 'and' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 159) then                          (: 'or' :)
      $state
    else
      let $state := p:shift(159, $input, $state)            (: 'or' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TransformExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TransformExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:shift(39, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:shift(49, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-TransformExpr-1($input, $state)
};

(:~
 : Parse TransformExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TransformExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(91, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(49, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-TransformExpr-1($input, $state)
  let $state := p:shift(146, $input, $state)                (: 'modify' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(174, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReplaceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReplaceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(173, $input, $state)                (: 'replace' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | 'node' | 'value' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 201) then                      (: 'value' :)
      let $state := p:shift(201, $input, $state)            (: 'value' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(156, $input, $state)            (: 'of' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shift(154, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-TargetExpr($input, $state)
  let $state := p:shift(207, $input, $state)                (: 'with' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NewNameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NewNameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse RenameExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RenameExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(172, $input, $state)                (: 'rename' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'node' :)
  let $state := p:shift(154, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-TargetExpr($input, $state)
  let $state := p:shift(74, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-NewNameExpr($input, $state)
  return $state
};

(:~
 : Parse DeleteExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DeleteExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(98, $input, $state)                 (: 'delete' :)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:l1] = 154) then                           (: 'node' :)
      let $state := p:shift(154, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(155, $input, $state)            (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse TargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExprTargetChoice.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InsertExprTargetChoice($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 69) then                            (: 'after' :)
      let $state := p:shift(69, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'before' :)
      let $state := p:shift(79, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 74) then                   (: 'as' :)
          let $state := p:shift(74, $input, $state)         (: 'as' :)
          let $state := p:lookahead1W(89, $input, $state)   (: S^WS | ('(' ':') | 'first' | 'last' :)
          let $state :=
            if ($state[$p:l1] = 116) then                   (: 'first' :)
              let $state := p:shift(116, $input, $state)    (: 'first' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(138, $input, $state)    (: 'last' :)
              return $state
          return $state
        else
          $state
      let $state := p:lookahead1W(46, $input, $state)       (: S^WS | ('(' ':') | 'into' :)
      let $state := p:shift(135, $input, $state)            (: 'into' :)
      return $state
  return $state
};

(:~
 : Parse SourceExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SourceExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse InsertExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InsertExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(132, $input, $state)                (: 'insert' :)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WS | ('(' ':') | 'node' | 'nodes' :)
  let $state :=
    if ($state[$p:l1] = 154) then                           (: 'node' :)
      let $state := p:shift(154, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(155, $input, $state)            (: 'nodes' :)
      return $state
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-SourceExpr($input, $state)
  let $state := p:parse-InsertExprTargetChoice($input, $state)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-TargetExpr($input, $state)
  return $state
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 23) then                            (: Wildcard :)
      let $state := p:shift(23, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(103, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 212) then                        (: '|' :)
        $state
      else
        let $state := p:shift(212, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(180, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return $state
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(85, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(180, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-CatchErrorList($input, $state)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Expr($input, $state)
  return $state
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(193, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(210, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-TryTargetExpr($input, $state)
  let $state := p:shift(214, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(35, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(141, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'after' | 'as' | 'ascending' | 'before' | 'case' |
                                                               'catch' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'end' | 'for' |
                                                               'group' | 'into' | 'let' | 'modify' | 'only' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               'with' | '}' :)
    return
      if ($state[$p:l1] != 85) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return $state
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(127, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(190, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(107, $input, $state)                (: 'else' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(101, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 212) then                        (: '|' :)
        $state
      else
        let $state := p:shift(212, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(183, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  return $state
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(82, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(185, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(183, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:shift(174, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 82) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(196, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(68, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(174, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:shift(82, $input, $state)               (: 'case' :)
    let $state := p:lookahead1W(190, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 82) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:shift(174, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:shift(39, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:parse-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 82) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(188, $input, $state)                (: 'switch' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(174, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:shift(39, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 74) then                   (: 'as' :)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:shift(129, $input, $state)            (: 'in' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 183) then                           (: 'some' :)
      let $state := p:shift(183, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(113, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(129, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(176, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(174, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(93, $input, $state)                 (: 'count' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75                             (: 'ascending' :)
          or $state[$p:l1] = 101) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 75) then                        (: 'ascending' :)
          let $state := p:shift(75, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(101, $input, $state)        (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 108) then                      (: 'empty' :)
      let $state := p:shift(108, $input, $state)            (: 'empty' :)
      let $state := p:lookahead1W(90, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 122) then                       (: 'greatest' :)
          let $state := p:shift(122, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(141, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:shift(87, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-OrderModifier($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(134, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(190, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return $state
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 160) then                           (: 'order' :)
      let $state := p:shift(160, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(81, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(184, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(160, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(81, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-OrderSpecList($input, $state)
  return $state
};

(:~
 : Parse GroupingVariable.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-GroupingVariable($input, $state)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49                             (: ':=' :)
          or $state[$p:l1] = 74) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 74) then                   (: 'as' :)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:shift(49, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:shift(87, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(134, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return $state
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(123, $input, $state)                (: 'group' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shift(81, $input, $state)                 (: 'by' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:parse-GroupingSpecList($input, $state)
  return $state
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(205, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 119                                 (: 'for' :)
     or $state[$p:l1] = 142) then                           (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(182, $input, $state)                (: 'sliding' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(206, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(129, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:parse-WindowEndCondition($input, $state)
  return $state
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 157) then                      (: 'only' :)
      let $state := p:shift(157, $input, $state)            (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shift(111, $input, $state)                (: 'end' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(204, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 170) then                      (: 'previous' :)
      let $state := p:shift(170, $input, $state)            (: 'previous' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 151) then                      (: 'next' :)
      let $state := p:shift(151, $input, $state)            (: 'next' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(30, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(185, $input, $state)                (: 'start' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(204, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(194, $input, $state)                (: 'tumbling' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(206, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(129, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111                            (: 'end' :)
          or $state[$p:l1] = 157) then                      (: 'only' :)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(119, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:l1] = 194) then                           (: 'tumbling' :)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(49, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:shift(39, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:parse-LetBinding($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(142, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return $state
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(76, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return $state
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(70, $input, $state)                 (: 'allowing' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(108, $input, $state)                (: 'empty' :)
  return $state
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(74, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(183, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(30, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'allowing' :)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(129, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:shift(39, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:parse-ForBinding($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(119, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return $state
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'for' :)
      let $state := p:lookahead2W(108, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 7799) then                          (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 142) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(132, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 174) then                         (: 'return' :)
        $state
      else
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  return $state
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'for' :)
      let $state := p:lookahead2W(173, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'sliding' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'tumbling' |
                                                               'union' | 'where' | 'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'rename' :)
      let $state := p:lookahead2W(168, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'replace' :)
      let $state := p:lookahead2W(172, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'value' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'try' :)
      let $state := p:lookahead2W(169, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '{' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 98                             (: 'delete' :)
          or $state[$p:l1] = 132) then                      (: 'insert' :)
      let $state := p:lookahead2W(171, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'node' | 'nodes' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               'with' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 127                            (: 'if' :)
          or $state[$p:l1] = 188                            (: 'switch' :)
          or $state[$p:l1] = 196) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(164, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'after' |
                                                               'and' | 'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' | '|' |
                                                               '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 91                             (: 'copy' :)
          or $state[$p:l1] = 113                            (: 'every' :)
          or $state[$p:l1] = 142                            (: 'let' :)
          or $state[$p:l1] = 183) then                      (: 'some' :)
      let $state := p:lookahead2W(166, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 7799                                (: 'for' '$' :)
     or $state[$p:lk] = 7822                                (: 'let' '$' :)
     or $state[$p:lk] = 46711                               (: 'for' 'sliding' :)
     or $state[$p:lk] = 49783) then                         (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7793                           (: 'every' '$' :)
          or $state[$p:lk] = 7863) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8636) then                     (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8644) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8575) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 53953) then                    (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39556                          (: 'insert' 'node' :)
          or $state[$p:lk] = 39812) then                    (: 'insert' 'nodes' :)
      let $state := p:parse-InsertExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39522                          (: 'delete' 'node' :)
          or $state[$p:lk] = 39778) then                    (: 'delete' 'nodes' :)
      let $state := p:parse-DeleteExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39596) then                    (: 'rename' 'node' :)
      let $state := p:parse-RenameExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 39597                          (: 'replace' 'node' :)
          or $state[$p:lk] = 51629) then                    (: 'replace' 'value' :)
      let $state := p:parse-ReplaceExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7771) then                     (: 'copy' '$' :)
      let $state := p:parse-TransformExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return $state
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ExprSingle($input, $state)
  return $state
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(183, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 62) then                            (: '?' :)
      let $state := p:shift(62, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(38, $input, $state)             (: '+' :)
      return $state
  return $state
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 109) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(163, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'external' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'in' | 'instance' | 'intersect' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'union' | 'where' | 'with' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8557) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(109, $input, $state)            (: 'empty-sequence' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(159, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'after' | 'allowing' | 'and' | 'as' |
                                                               'ascending' | 'at' | 'before' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'into' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | 'with' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 37                              (: '*' :)
         or $state[$p:l1] = 38                              (: '+' :)
         or $state[$p:l1] = 62) then                        (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(72, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(183, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(120, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(186, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shift(74, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(183, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-SequenceType($input, $state)
  return $state
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(120, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shift(37, $input, $state)                 (: '*' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 1) then                             (: IntegerLiteral :)
      let $state := p:shift(1, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:shift(2, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(3, $input, $state)              (: DoubleLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 4) then                             (: StringLiteral :)
      let $state := p:shift(4, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(72, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(118, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(31, $input, $state)                 (: '%' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'updating' |
                                                               'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: '(' :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(118, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-Literal($input, $state)
      let $state := p:parse-Annotation-1($input, $state)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(70, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 120) then                           (: 'function' :)
      let $state := p:lookahead2W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] = 8568) then                      (: 'function' '(' :)
          let $state := p:lookahead3W(187, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 2433400) then                       (: 'function' '(' '*' :)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(154, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(149, $input, $state)                (: 'namespace-node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(189, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(88, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(171, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(148, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'after' | 'and' | 'as' | 'ascending' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'into' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | 'with' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 4) then                         (: StringLiteral :)
          let $state := p:shift(4, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-AttributeName($input, $state)
  return $state
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(178, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return $state
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(77, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(184, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:shift(39, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(178, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ElementName($input, $state)
  return $state
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(179, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-EQName($input, $state)
  return $state
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return $state
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(106, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(184, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:shift(39, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(178, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(73, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 62) then               (: '?' :)
              let $state := p:shift(62, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(105, $input, $state)                (: 'document-node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 106) then                       (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return $state
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 105) then                           (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return $state
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 77                                  (: 'attribute' :)
     or $state[$p:l1] = 88                                  (: 'comment' :)
     or $state[$p:l1] = 105                                 (: 'document-node' :)
     or $state[$p:l1] = 106                                 (: 'element' :)
     or $state[$p:l1] = 120                                 (: 'function' :)
     or $state[$p:l1] = 137                                 (: 'item' :)
     or $state[$p:l1] = 149                                 (: 'namespace-node' :)
     or $state[$p:l1] = 154                                 (: 'node' :)
     or $state[$p:l1] = 171                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 178                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 179                                 (: 'schema-element' :)
     or $state[$p:l1] = 189) then                           (: 'text' :)
      let $state := p:lookahead2W(163, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'after' | 'allowing' | 'and' |
                                                               'as' | 'ascending' | 'at' | 'before' | 'case' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'external' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'in' | 'instance' | 'intersect' | 'into' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'union' | 'where' | 'with' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8525                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8536                                (: 'comment' '(' :)
     or $state[$p:lk] = 8553                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8554                                (: 'element' '(' :)
     or $state[$p:lk] = 8597                                (: 'namespace-node' '(' :)
     or $state[$p:lk] = 8602                                (: 'node' '(' :)
     or $state[$p:lk] = 8619                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8626                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8627                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8637) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8585) then                     (: 'item' '(' :)
      let $state := p:shift(137, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 8568) then                     (: 'function' '(' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  return $state
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:shift(90, $input, $state)                 (: 'context' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:shift(137, $input, $state)                (: 'item' :)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(183, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 49) then                            (: ':=' :)
      let $state := p:shift(49, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(190, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(115, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 49) then                   (: ':=' :)
          let $state := p:shift(49, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(190, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(128, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:shift(147, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(63, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:shift(148, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(145, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(58, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state := p:shift(76, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 148) then                           (: 'namespace' :)
      let $state := p:shift(148, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(145, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(58, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:shift(106, $input, $state)            (: 'element' :)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:shift(148, $input, $state)            (: 'namespace' :)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(74, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:shift(39, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(128, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:shift(177, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(104, $input, $state)          (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 4) then                       (: StringLiteral :)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'at' :)
      let $state := p:shift(76, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 128) then                           (: 'import' :)
      let $state := p:lookahead2W(92, $input, $state)       (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 45440) then                         (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ModuleImport($input, $state)
      return $state
  return $state
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(148, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(145, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(58, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'decimal-separator' :)
      let $state := p:shift(95, $input, $state)             (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'grouping-separator' :)
      let $state := p:shift(124, $input, $state)            (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'infinity' :)
      let $state := p:shift(130, $input, $state)            (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'minus-sign' :)
      let $state := p:shift(144, $input, $state)            (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'NaN' :)
      let $state := p:shift(65, $input, $state)             (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'percent' :)
      let $state := p:shift(166, $input, $state)            (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'per-mille' :)
      let $state := p:shift(165, $input, $state)            (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 209) then                      (: 'zero-digit' :)
      let $state := p:shift(209, $input, $state)            (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'digit' :)
      let $state := p:shift(102, $input, $state)            (: 'digit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(164, $input, $state)            (: 'pattern-separator' :)
      return $state
  return $state
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 14) then                            (: QName^Token :)
      let $state := p:shift(14, $input, $state)             (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'after' :)
      let $state := p:shift(69, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ancestor' :)
      let $state := p:shift(71, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(72, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'and' :)
      let $state := p:shift(73, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ascending' :)
      let $state := p:shift(75, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'before' :)
      let $state := p:shift(79, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'case' :)
      let $state := p:shift(82, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'cast' :)
      let $state := p:shift(83, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'castable' :)
      let $state := p:shift(84, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'child' :)
      let $state := p:shift(86, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:shift(87, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'copy' :)
      let $state := p:shift(91, $input, $state)             (: 'copy' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:shift(93, $input, $state)             (: 'count' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'declare' :)
      let $state := p:shift(96, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'delete' :)
      let $state := p:shift(98, $input, $state)             (: 'delete' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant' :)
      let $state := p:shift(99, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descendant-or-self' :)
      let $state := p:shift(100, $input, $state)            (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'descending' :)
      let $state := p:shift(101, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'div' :)
      let $state := p:shift(103, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'document' :)
      let $state := p:shift(104, $input, $state)            (: 'document' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'else' :)
      let $state := p:shift(107, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty' :)
      let $state := p:shift(108, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'end' :)
      let $state := p:shift(111, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'eq' :)
      let $state := p:shift(112, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'every' :)
      let $state := p:shift(113, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'except' :)
      let $state := p:shift(114, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'first' :)
      let $state := p:shift(116, $input, $state)            (: 'first' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'following' :)
      let $state := p:shift(117, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'following-sibling' :)
      let $state := p:shift(118, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'for' :)
      let $state := p:shift(119, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'ge' :)
      let $state := p:shift(121, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'group' :)
      let $state := p:shift(123, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'gt' :)
      let $state := p:shift(125, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'idiv' :)
      let $state := p:shift(126, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'import' :)
      let $state := p:shift(128, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'insert' :)
      let $state := p:shift(132, $input, $state)            (: 'insert' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'instance' :)
      let $state := p:shift(133, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'intersect' :)
      let $state := p:shift(134, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'into' :)
      let $state := p:shift(135, $input, $state)            (: 'into' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'is' :)
      let $state := p:shift(136, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'last' :)
      let $state := p:shift(138, $input, $state)            (: 'last' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'le' :)
      let $state := p:shift(140, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'let' :)
      let $state := p:shift(142, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'lt' :)
      let $state := p:shift(143, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'mod' :)
      let $state := p:shift(145, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'modify' :)
      let $state := p:shift(146, $input, $state)            (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'module' :)
      let $state := p:shift(147, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:shift(148, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ne' :)
      let $state := p:shift(150, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'only' :)
      let $state := p:shift(157, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'or' :)
      let $state := p:shift(159, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'order' :)
      let $state := p:shift(160, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'ordered' :)
      let $state := p:shift(161, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'parent' :)
      let $state := p:shift(163, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'preceding' :)
      let $state := p:shift(167, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'preceding-sibling' :)
      let $state := p:shift(168, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'rename' :)
      let $state := p:shift(172, $input, $state)            (: 'rename' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'replace' :)
      let $state := p:shift(173, $input, $state)            (: 'replace' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'return' :)
      let $state := p:shift(174, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'satisfies' :)
      let $state := p:shift(176, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'self' :)
      let $state := p:shift(180, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'some' :)
      let $state := p:shift(183, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'stable' :)
      let $state := p:shift(184, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'start' :)
      let $state := p:shift(185, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'to' :)
      let $state := p:shift(191, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'treat' :)
      let $state := p:shift(192, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'try' :)
      let $state := p:shift(193, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'union' :)
      let $state := p:shift(197, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 198) then                      (: 'unordered' :)
      let $state := p:shift(198, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 200) then                      (: 'validate' :)
      let $state := p:shift(200, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'where' :)
      let $state := p:shift(205, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 207) then                      (: 'with' :)
      let $state := p:shift(207, $input, $state)            (: 'with' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(208, $input, $state)            (: 'xquery' :)
      return $state
  return $state
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(175, $input, $state)           (: QName^Token | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 77) then                            (: 'attribute' :)
      let $state := p:shift(77, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'comment' :)
      let $state := p:shift(88, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'document-node' :)
      let $state := p:shift(105, $input, $state)            (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'element' :)
      let $state := p:shift(106, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'empty-sequence' :)
      let $state := p:shift(109, $input, $state)            (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'function' :)
      let $state := p:shift(120, $input, $state)            (: 'function' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'if' :)
      let $state := p:shift(127, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'item' :)
      let $state := p:shift(137, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace-node' :)
      let $state := p:shift(149, $input, $state)            (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'node' :)
      let $state := p:shift(154, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'processing-instruction' :)
      let $state := p:shift(171, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'schema-attribute' :)
      let $state := p:shift(178, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'schema-element' :)
      let $state := p:shift(179, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'switch' :)
      let $state := p:shift(188, $input, $state)            (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'text' :)
      let $state := p:shift(189, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'typeswitch' :)
      let $state := p:shift(196, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return $state
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1(176, $input, $state)           (: URIQualifiedName | QName^Token | 'after' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'as' | 'ascending' |
                                                               'attribute' | 'before' | 'case' | 'cast' | 'castable' |
                                                               'child' | 'collation' | 'comment' | 'copy' | 'count' |
                                                               'declare' | 'default' | 'delete' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'first' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'insert' | 'instance' | 'intersect' |
                                                               'into' | 'is' | 'item' | 'last' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'modify' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'rename' | 'replace' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 5) then                             (: URIQualifiedName :)
      let $state := p:shift(5, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(138, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 50) then                          (: ';' :)
        $state
      else
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(29, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:shift(58, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(4, $input, $state)            (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'decimal-format' :)
      let $state := p:shift(94, $input, $state)             (: 'decimal-format' :)
      let $state := p:lookahead1W(178, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:shift(94, $input, $state)             (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return $state
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 131) then                           (: 'inherit' :)
      let $state := p:shift(131, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(152, $input, $state)            (: 'no-inherit' :)
      return $state
  return $state
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 169) then                           (: 'preserve' :)
      let $state := p:shift(169, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(153, $input, $state)            (: 'no-preserve' :)
      return $state
  return $state
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:shift(92, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:shift(39, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:parse-InheritMode($input, $state)
  return $state
};

(:~
 : Parse RevalidationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RevalidationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'revalidation' :)
  let $state := p:shift(175, $input, $state)                (: 'revalidation' :)
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'skip' | 'strict' :)
  let $state :=
    if ($state[$p:l1] = 186) then                           (: 'strict' :)
      let $state := p:shift(186, $input, $state)            (: 'strict' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lax' :)
      let $state := p:shift(139, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(181, $input, $state)            (: 'skip' :)
      return $state
  return $state
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:shift(160, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(108, $input, $state)                (: 'empty' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:l1] = 122) then                           (: 'greatest' :)
      let $state := p:shift(122, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(141, $input, $state)            (: 'least' :)
      return $state
  return $state
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:shift(162, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 161) then                           (: 'ordered' :)
      let $state := p:shift(161, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(198, $input, $state)            (: 'unordered' :)
      return $state
  return $state
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:shift(89, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 187) then                           (: 'strip' :)
      let $state := p:shift(187, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(169, $input, $state)            (: 'preserve' :)
      return $state
  return $state
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:shift(78, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:shift(87, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:shift(80, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: 'preserve' :)
      let $state := p:shift(169, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(187, $input, $state)            (: 'strip' :)
      return $state
  return $state
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 96) then                            (: 'declare' :)
      let $state := p:lookahead2W(131, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' | 'revalidation' :)
      let $state :=
        if ($state[$p:lk] = 24928) then                     (: 'declare' 'default' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 20576) then                         (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5726560) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 20064) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 22880) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 41568) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10510688) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 44896) then                    (: 'declare' 'revalidation' :)
      let $state := p:parse-RevalidationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23648) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  return $state
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:l1] = 106) then                           (: 'element' :)
      let $state := p:shift(106, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(120, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(148, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 96) then                          (: 'declare' :)
        let $state := p:lookahead2W(151, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'base-uri' |
                                                               'boundary-space' | 'cast' | 'castable' | 'construction' |
                                                               'context' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'div' | 'eq' | 'except' | 'function' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'namespace' | 'ne' | 'option' | 'or' |
                                                               'ordering' | 'revalidation' | 'to' | 'treat' | 'union' |
                                                               'updating' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] = 128) then                    (: 'import' :)
        let $state := p:lookahead2W(144, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'schema' | 'to' | 'treat' |
                                                               'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 20064                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 20576                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 22880                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 23648                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 24160                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 24928                            (: 'declare' 'default' :)
      and $state[$p:lk] != 37760                            (: 'import' 'module' :)
      and $state[$p:lk] != 37984                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 41568                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 44896                            (: 'declare' 'revalidation' :)
      and $state[$p:lk] != 45440) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 96) then                      (: 'declare' :)
            let $state := p:lookahead2W(135, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' | 'revalidation' :)
            let $state :=
              if ($state[$p:lk] = 24928) then               (: 'declare' 'default' :)
                let $state := p:lookahead3W(126, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:lk] = 6971744                       (: 'declare' 'default' 'element' :)
           or $state[$p:lk] = 7889248) then                 (: 'declare' 'default' 'function' :)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 37984) then              (: 'declare' 'namespace' :)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 128) then                (: 'import' :)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'after' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'as' | 'ascending' | 'attribute' | 'before' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'count' | 'declare' | 'default' |
                                                               'delete' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 96) then                          (: 'declare' :)
        let $state := p:lookahead2W(147, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'context' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                               'option' | 'or' | 'to' | 'treat' | 'union' | 'updating' |
                                                               'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 8032                             (: 'declare' '%' :)
      and $state[$p:lk] != 23136                            (: 'declare' 'context' :)
      and $state[$p:lk] != 30816                            (: 'declare' 'function' :)
      and $state[$p:lk] != 40544                            (: 'declare' 'option' :)
      and $state[$p:lk] != 51040                            (: 'declare' 'updating' :)
      and $state[$p:lk] != 51808) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 96) then                      (: 'declare' :)
            let $state := p:lookahead2W(130, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'updating' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:lk] = 23136) then                   (: 'declare' 'context' :)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 40544) then              (: 'declare' 'option' :)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return $state
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(4, $input, $state)                  (: StringLiteral :)
  return $state
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 15) then                            (: NCName^Token :)
      let $state := p:shift(15, $input, $state)             (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'after' :)
      let $state := p:shift(69, $input, $state)             (: 'after' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'and' :)
      let $state := p:shift(73, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'as' :)
      let $state := p:shift(74, $input, $state)             (: 'as' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'ascending' :)
      let $state := p:shift(75, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'before' :)
      let $state := p:shift(79, $input, $state)             (: 'before' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'case' :)
      let $state := p:shift(82, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'cast' :)
      let $state := p:shift(83, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'castable' :)
      let $state := p:shift(84, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'collation' :)
      let $state := p:shift(87, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:shift(93, $input, $state)             (: 'count' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'descending' :)
      let $state := p:shift(101, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'div' :)
      let $state := p:shift(103, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'else' :)
      let $state := p:shift(107, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty' :)
      let $state := p:shift(108, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'end' :)
      let $state := p:shift(111, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'eq' :)
      let $state := p:shift(112, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'except' :)
      let $state := p:shift(114, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'for' :)
      let $state := p:shift(119, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'ge' :)
      let $state := p:shift(121, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'group' :)
      let $state := p:shift(123, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'gt' :)
      let $state := p:shift(125, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'idiv' :)
      let $state := p:shift(126, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'instance' :)
      let $state := p:shift(133, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'intersect' :)
      let $state := p:shift(134, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'into' :)
      let $state := p:shift(135, $input, $state)            (: 'into' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'is' :)
      let $state := p:shift(136, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'le' :)
      let $state := p:shift(140, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'let' :)
      let $state := p:shift(142, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'lt' :)
      let $state := p:shift(143, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'mod' :)
      let $state := p:shift(145, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'modify' :)
      let $state := p:shift(146, $input, $state)            (: 'modify' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ne' :)
      let $state := p:shift(150, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'only' :)
      let $state := p:shift(157, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'or' :)
      let $state := p:shift(159, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'order' :)
      let $state := p:shift(160, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'return' :)
      let $state := p:shift(174, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'satisfies' :)
      let $state := p:shift(176, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'stable' :)
      let $state := p:shift(184, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'start' :)
      let $state := p:shift(185, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'to' :)
      let $state := p:shift(191, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'treat' :)
      let $state := p:shift(192, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'union' :)
      let $state := p:shift(197, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: 'where' :)
      let $state := p:shift(205, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(207, $input, $state)            (: 'with' :)
      return $state
  return $state
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(147, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(148, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(145, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'after' | 'and' |
                                                               'as' | 'ascending' | 'before' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'modify' | 'ne' | 'only' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'union' | 'where' | 'with' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(58, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state := p:parse-Prolog($input, $state)
  return $state
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(50, $input, $state)                 (: ';' :)
  return $state
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shift(208, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:l1] = 110) then                           (: 'encoding' :)
      let $state := p:shift(110, $input, $state)            (: 'encoding' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(4, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(203, $input, $state)            (: 'version' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(4, $input, $state)              (: StringLiteral :)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 110) then                  (: 'encoding' :)
          let $state := p:shift(110, $input, $state)        (: 'encoding' :)
          let $state := p:lookahead1W(17, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:shift(4, $input, $state)          (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:parse-Separator($input, $state)
  return $state
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 208) then                           (: 'xquery' :)
      let $state := p:lookahead2W(143, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'encoding' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'to' | 'treat' | 'union' |
                                                               'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 28368                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 52176) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 147) then                           (: 'module' :)
      let $state := p:lookahead2W(142, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'or' | 'to' | 'treat' | 'union' |
                                                               '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 38035) then                         (: 'module' 'namespace' :)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MainModule($input, $state)
      return $state
  return $state
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'after' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'as' | 'ascending' | 'attribute' | 'before' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'copy' | 'count' | 'declare' | 'default' | 'delete' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'first' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'insert' |
                                                               'instance' | 'intersect' | 'into' | 'is' | 'item' |
                                                               'last' | 'le' | 'let' | 'lt' | 'mod' | 'modify' |
                                                               'module' | 'namespace' | 'namespace-node' | 'ne' |
                                                               'node' | 'only' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'rename' | 'replace' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'with' | 'xquery' :)
  let $state := p:parse-Module($input, $state)
  let $state := p:shift(24, $input, $state)                 (: EOF :)
  return $state
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        if ($error/@e = $begin) then
          ""
        else
          concat("after successfully scanning ", string($error/@e - $begin), " characters "),
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 17) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
