xquery version "1.0" encoding "UTF-8";

(: This file was generated on Fri Dec 13, 2013 10:57 (UTC) by REx v5.29 which is Copyright (c) 1979-2013 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: EcmaScript.ebnf -ll 1 -backtrack -xquery -tree :)

(:~
 : The parser that was generated for the EcmaScript grammar.
 :)
module namespace p="EcmaScript";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 7;

(:~
 : The index of the parser state for accessing the memoization
 : of backtracking results.
 :)
declare variable $p:memo as xs:integer := 8;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 9;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  65, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 23, 24, 25, 26, 27, 28, 7, 29, 29, 29, 29,
  30, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 31, 8, 8, 32, 33, 34, 35, 8, 7, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 8, 45, 46, 47, 48, 49, 50, 8, 51, 52, 53, 54, 55, 56, 57, 58, 8, 59, 60, 61, 62, 7
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 335, 247, 367, 432, 695, 303, 400, 400, 464, 496, 528, 560, 592, 640, 669, 899, 727, 400, 400, 400, 400, 608,
  400, 398, 400, 400, 400, 400, 400, 759, 791, 823, 275, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 855, 887, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 943, 400,
  400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931, 931,
  931, 931, 931, 931, 931, 931, 931, 931, 975, 1007, 1016, 1008, 1008, 1024, 1032, 1040, 1048, 1056, 1313, 1313, 1081,
  1099, 1107, 1115, 1123, 1323, 1149, 1149, 1149, 1148, 1149, 1472, 1149, 1313, 1313, 1314, 1313, 1313, 1313, 1314,
  1313, 1313, 1313, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313,
  1313, 1313, 1320, 1149, 1518, 1319, 1149, 1440, 1149, 1149, 1149, 1149, 1149, 1151, 1344, 1149, 1149, 1149, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1318, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149,
  1149, 1149, 1149, 1312, 1313, 1313, 1318, 1137, 1379, 1439, 1149, 1434, 1440, 1137, 1313, 1313, 1313, 1313, 1313,
  1313, 1313, 1313, 1415, 1313, 1314, 1190, 1434, 1368, 1255, 1434, 1440, 1313, 1313, 1313, 1313, 1313, 1313, 1413,
  1314, 1312, 1311, 1313, 1313, 1313, 1313, 1313, 1314, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1317, 1516,
  1313, 1313, 1313, 1313, 1242, 1519, 1434, 1434, 1434, 1434, 1434, 1434, 1434, 1434, 1436, 1149, 1149, 1149, 1440,
  1149, 1149, 1149, 1073, 1290, 1313, 1313, 1310, 1313, 1313, 1313, 1313, 1314, 1314, 1459, 1311, 1313, 1317, 1149,
  1322, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1312, 1159, 1313, 1313, 1313,
  1313, 1313, 1313, 1313, 1313, 1312, 1159, 1313, 1313, 1313, 1313, 1168, 1149, 1313, 1313, 1313, 1313, 1313, 1313,
  1181, 1088, 1313, 1313, 1313, 1182, 1315, 1319, 1530, 1313, 1313, 1313, 1313, 1313, 1313, 1208, 1434, 1436, 1256,
  1313, 1226, 1434, 1149, 1149, 1530, 1181, 1414, 1313, 1313, 1311, 1240, 1251, 1217, 1229, 1472, 1266, 1226, 1434,
  1319, 1149, 1277, 1300, 1414, 1313, 1313, 1311, 1449, 1251, 1232, 1229, 1149, 1288, 1473, 1434, 1298, 1149, 1530,
  1289, 1310, 1313, 1313, 1311, 1308, 1208, 1331, 1173, 1149, 1149, 1063, 1434, 1149, 1149, 1530, 1181, 1414, 1313,
  1313, 1311, 1411, 1208, 1257, 1229, 1473, 1266, 1091, 1434, 1149, 1149, 1500, 1340, 1356, 1352, 1243, 1340, 1139,
  1091, 1258, 1255, 1472, 1149, 1472, 1434, 1149, 1149, 1530, 1159, 1311, 1313, 1313, 1311, 1160, 1091, 1332, 1255,
  1474, 1149, 1091, 1434, 1149, 1149, 1500, 1159, 1311, 1313, 1313, 1311, 1160, 1091, 1332, 1255, 1474, 1151, 1091,
  1434, 1149, 1149, 1500, 1159, 1311, 1313, 1313, 1311, 1313, 1091, 1218, 1255, 1472, 1149, 1091, 1434, 1149, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1148, 1149, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1312, 1313, 1313, 1313, 1313, 1314,
  1364, 1439, 1376, 1435, 1434, 1440, 1149, 1149, 1149, 1149, 1269, 1388, 1517, 1312, 1398, 1408, 1364, 1200, 1423,
  1436, 1434, 1440, 1149, 1149, 1149, 1149, 1440, 1434, 1440, 1130, 1428, 1313, 1312, 1313, 1313, 1313, 1319, 1433,
  1434, 1332, 1438, 1331, 1433, 1434, 1436, 1433, 1071, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1312, 1313,
  1313, 1313, 1314, 1470, 1312, 1313, 1313, 1313, 1314, 1149, 1433, 1434, 1214, 1434, 1434, 1196, 1068, 1149, 1313,
  1313, 1313, 1318, 1318, 1149, 1308, 1448, 1318, 1149, 1149, 1149, 1149, 1457, 1320, 1457, 1242, 1514, 1400, 1241,
  1268, 1149, 1149, 1149, 1149, 1151, 1149, 1390, 1150, 1354, 1318, 1149, 1149, 1149, 1149, 1468, 1320, 1470, 1313,
  1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1317,
  1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1319, 1313, 1313, 1315, 1315, 1313, 1313, 1313,
  1313, 1315, 1315, 1313, 1460, 1313, 1313, 1313, 1315, 1313, 1313, 1313, 1313, 1313, 1313, 1159, 1140, 1280, 1316,
  1182, 1317, 1313, 1316, 1280, 1316, 1489, 1494, 1149, 1149, 1149, 1482, 1149, 1149, 1149, 1149, 1149, 1321, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1434, 1437, 1071, 1149, 1149, 1149,
  1508, 1149, 1149, 1149, 1312, 1380, 1216, 1149, 1312, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1316,
  1497, 1312, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1527, 1516, 1313, 1313, 1313, 1313, 1316,
  1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1149, 1313, 1313, 1313, 1313, 1315, 1149, 1313, 1313, 1313, 1313, 1314, 1149,
  1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313,
  1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1315, 1149, 1149, 1149, 1149, 1149,
  1149, 1149, 1149, 1149, 1149, 1149, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313, 1313,
  1313, 1313, 1313, 1313, 1313, 1313, 1313, 1317, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 1149, 65,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 4, 0, 0, 1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21,
  21, 21, 21, 21, 21, 22, 22, 23, 24, 25, 26, 27, 28, 7, 29, 29, 29, 29, 30, 29, 8, 7, 7, 7, 7, 7, 63, 63, 7, 63, 7, 7,
  7, 7, 7, 7, 8, 63, 31, 8, 8, 32, 33, 34, 35, 8, 7, 7, 8, 8, 7, 7, 7, 7, 63, 63, 7, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  8, 45, 46, 47, 48, 49, 50, 8, 51, 52, 53, 54, 55, 56, 57, 58, 8, 59, 60, 61, 62, 7, 7, 7, 7, 7, 63, 7, 63, 8, 8, 8, 8,
  8, 8, 8, 7, 8, 7, 1, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 7, 63, 63, 63, 63, 7, 63, 63, 63,
  7, 7, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 7, 8, 63, 63, 7, 63, 63, 63, 7, 63, 63, 8, 7, 7, 8, 8, 7, 7, 63, 8, 63,
  63, 7, 63, 63, 63, 63, 63, 7, 7, 63, 63, 8, 8, 63, 63, 7, 7, 63, 63, 63, 7, 7, 7, 7, 63, 8, 7, 8, 7, 7, 7, 8, 8, 7, 7,
  7, 8, 8, 7, 7, 63, 7, 63, 63, 63, 63, 7, 7, 7, 63, 63, 7, 7, 7, 7, 8, 8, 7, 8, 7, 7, 8, 7, 7, 63, 7, 7, 8, 8, 8, 7, 8,
  8, 7, 8, 8, 8, 8, 7, 8, 7, 8, 8, 63, 63, 8, 8, 8, 7, 7, 7, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7,
  7, 7, 1, 7, 7, 63, 63, 63, 63, 63, 63, 7, 63, 63, 8, 8, 8, 7, 7, 7, 8, 8, 7, 7, 8, 7, 7, 8, 8, 7, 8, 7, 8, 8, 8, 8, 7,
  7, 8, 63, 8, 8, 63, 63, 63, 63, 63, 8, 8, 63, 8, 8, 8, 8, 8, 8, 63, 63, 63, 63, 63, 63, 8, 7, 8, 7, 7, 8, 7, 7, 8, 8,
  7, 8, 8, 8, 7, 8, 7, 8, 7, 8, 7, 7, 8, 8, 7, 8, 8, 7, 7, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 7, 63, 7, 7, 7, 7, 63, 63,
  63, 63, 63, 63, 63, 63, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 8, 7, 8, 8, 7, 7, 7, 7, 7, 8, 7, 8, 7, 8, 7, 8, 7, 7, 7, 8, 7,
  7, 7, 7, 7, 7, 7, 63, 63, 7, 64, 64, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 7, 63, 63, 7, 7, 63, 63, 7, 8, 8, 8, 1, 7,
  7, 7, 7, 63, 7, 8, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 63, 63, 63, 7, 8, 8, 8
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65279, 65280, 65536, 65278, 65279, 65533, 1114111, 7, 1, 7, 7
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4224, 4224, 4224, 4224, 4240, 4636, 4273, 6203, 4251, 4636, 4636, 4338,
  5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316,
  4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4224, 4224, 4224, 4224, 4240,
  4636, 4273, 4274, 4243, 4636, 4636, 4338, 4274, 4411, 4362, 4361, 4638, 4328, 4325, 4636, 5006, 4636, 4322, 4634,
  4636, 4636, 4376, 4291, 4427, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370,
  4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4224, 4224, 4224, 4224, 4230, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4224, 4224, 4224, 4224, 4240, 4636, 4273, 4274, 4243, 4636,
  4636, 4338, 4274, 4411, 4362, 4361, 4638, 6052, 4325, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4274, 4427,
  4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6138,
  6142, 4435, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636,
  4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440,
  4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4403, 4448, 4449, 4457, 4636, 4273, 4465, 4251, 4636, 4636, 4338, 5049, 4266, 4362,
  4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4476, 4308, 4636, 4316, 4639, 4636, 4270,
  4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4549, 4636, 4273, 6203,
  4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376,
  4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018,
  5250, 4839, 5574, 5602, 5574, 6018, 5487, 5600, 5574, 5574, 6206, 5049, 4494, 5574, 5574, 4508, 4328, 5254, 5574,
  5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574, 4842, 5574, 4510, 4275, 5574, 5574, 4914, 4509,
  6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4530, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049,
  4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639,
  4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4538, 4636,
  4273, 6203, 4251, 4636, 4636, 4546, 4557, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636,
  4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258,
  4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 6871, 4574, 4575, 4583, 4636, 4273, 4591, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328,
  4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4602, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659,
  4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4938, 4939, 5201, 5204, 4615, 4636, 4273, 6203, 4251, 4636, 4636,
  4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636,
  4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6515, 5045, 6513, 4274,
  4623, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322,
  4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415,
  4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4631, 4636, 4273, 6203, 4647, 4636, 4636, 4338, 4380, 4655, 4362, 4361,
  4638, 4328, 4283, 4636, 5006, 4636, 4322, 4667, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336,
  4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 7219, 7223, 4678, 4636, 4273, 6203, 4686,
  4636, 4636, 4338, 5880, 4266, 4362, 4361, 4638, 4328, 4694, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291,
  4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 5518,
  5522, 5151, 4702, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006,
  4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419,
  4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4296, 4300, 4710, 4636, 4273, 6203, 4718, 4636, 4636, 4338, 6005, 4266,
  4362, 4361, 4638, 4328, 4694, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636,
  4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4970, 4726, 4727, 4735, 4636, 4273,
  4743, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636,
  4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388,
  4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4760, 4760, 4765, 4768, 4776, 4636, 4273, 6203, 4784, 4636, 4636, 4338, 6898, 4266, 4362, 4361, 4638, 4328, 4792,
  4636, 5006, 4636, 4322, 4800, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360,
  4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4232, 4811, 4812, 4820, 5574, 6018, 4833, 5600, 5574, 5574, 6206,
  5049, 4852, 5574, 5574, 6290, 4594, 4881, 5574, 5574, 5574, 6973, 4864, 5574, 5574, 5502, 4874, 4518, 5574, 5574,
  4892, 5574, 5631, 5244, 5574, 5574, 5574, 6014, 7082, 5574, 4498, 5574, 6449, 4889, 6870, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6020, 4900, 4901, 4909,
  5574, 6018, 4833, 5600, 5574, 5574, 6206, 5049, 4852, 5574, 5574, 6290, 4594, 4881, 5574, 5574, 5574, 6973, 4864,
  5574, 5574, 5502, 4874, 4518, 5574, 5574, 4892, 5574, 5631, 5244, 5574, 5574, 5574, 6014, 7082, 5574, 4498, 5574,
  6449, 4889, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 6020, 4900, 4901, 4909, 5574, 6018, 4833, 5600, 5574, 5574, 6206, 5049, 4852, 5574, 5574, 6290,
  5097, 4881, 5574, 5574, 5574, 6973, 4864, 5574, 5574, 5502, 4874, 4518, 5574, 5574, 4892, 5574, 5631, 5244, 5574,
  5574, 5574, 6014, 7082, 5574, 4498, 5574, 6449, 4889, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4481, 4274, 4274, 4274, 4923, 4636, 4273, 6203, 4251, 4636,
  4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308,
  4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4931,
  4947, 4953, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636,
  4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440,
  4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4961, 4636, 4273, 6203, 4251, 4636, 4636, 5477, 5282, 4266, 4362,
  4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270,
  4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4969, 5532, 4978, 4636, 4273, 6203,
  4251, 4636, 4636, 4986, 4994, 5002, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4394, 4634, 4636, 4636, 4376,
  4291, 4308, 4636, 4316, 4803, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 5014, 4636, 4273, 6203, 4251, 4636, 4636, 4486, 5167, 4266, 4362, 4361, 4638, 4328, 4283, 4636,
  5006, 4636, 4352, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670,
  4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 5022, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049,
  4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639,
  4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 5602, 5574,
  6018, 5487, 5600, 5574, 5574, 6206, 5049, 4852, 5574, 5574, 6290, 4328, 5030, 5574, 5574, 5574, 6973, 4864, 5574,
  5574, 5502, 5038, 4518, 5574, 5574, 4892, 5574, 5631, 5244, 5574, 5574, 5574, 6014, 7082, 5574, 4498, 5574, 6449,
  4889, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 6018, 5250, 4839, 5574, 5602, 5574, 6018, 6831, 5600, 5574, 5574, 6206, 5049, 4852, 5574, 5574, 6290, 4468,
  5030, 5574, 5574, 5574, 6973, 4864, 5574, 5574, 5502, 5038, 4518, 5574, 5574, 4892, 5574, 5631, 5244, 5574, 5574,
  5574, 6014, 7082, 5574, 4498, 5574, 6449, 4889, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 5602, 5574, 6018, 5057, 5600, 5574, 5574,
  6206, 5049, 4494, 5574, 5574, 4508, 4328, 5254, 5574, 5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574,
  5574, 4842, 5574, 4510, 4275, 5574, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6303, 6306,
  5071, 4636, 4273, 6203, 5079, 4636, 4636, 4338, 6737, 4266, 4362, 4361, 4638, 4328, 5087, 4636, 5006, 4636, 4322,
  4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415,
  4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 5095, 5105, 5111, 5114, 5122, 5185, 5149, 5135, 5142, 5185, 5185, 5264, 6333, 5159, 5313, 5312,
  5187, 4328, 5175, 5185, 5335, 5185, 5238, 5183, 5185, 5185, 5278, 5196, 5212, 5185, 5232, 5188, 5185, 5163, 5262,
  5272, 5224, 5290, 5127, 5298, 5219, 5294, 5306, 5321, 5329, 5343, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 5585, 4274, 5352, 4636, 4273, 6203, 4251,
  4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 7193, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291,
  4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 5360, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006,
  4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419,
  4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 4844, 5368, 5381, 5487, 5389, 5410, 5402, 6206, 5049, 5424,
  5574, 5574, 6290, 4328, 5030, 5574, 5574, 5574, 6973, 5442, 5453, 5574, 5873, 5470, 4518, 7108, 5574, 5495, 5574,
  5513, 5244, 5574, 5574, 6846, 6014, 7082, 5574, 4498, 5574, 6449, 4889, 6870, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 5530, 5540, 5063, 5554, 5560, 5574, 6018,
  5487, 5600, 5574, 5574, 6206, 5049, 4852, 5573, 5574, 6290, 4328, 5030, 6720, 6181, 6218, 6973, 4864, 5574, 5574,
  5502, 5038, 4518, 5574, 5574, 4892, 5574, 5631, 5244, 5574, 5574, 5574, 6014, 7082, 5574, 4498, 5574, 6449, 4889,
  6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  5583, 5593, 5546, 5610, 5616, 5574, 6018, 5487, 5600, 5574, 5574, 6206, 5049, 4852, 5574, 5574, 6290, 4328, 5030,
  5574, 5574, 5574, 6973, 5644, 6353, 5574, 7076, 5038, 5657, 5574, 5574, 4892, 5574, 5631, 5244, 5574, 6717, 5574,
  6014, 7082, 5574, 5955, 5574, 5671, 4889, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 5683, 5693, 5765, 5715, 5721, 5574, 6018, 5487, 5600, 5574, 5574, 6206,
  5049, 4852, 5574, 5574, 6290, 4328, 5030, 5574, 5574, 5574, 6973, 4864, 5574, 5575, 5502, 5038, 4518, 6665, 5574,
  4892, 5574, 5631, 5244, 5574, 5574, 5983, 6014, 7082, 5574, 4498, 5574, 6449, 4889, 6870, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 5748, 5759, 5932, 5935, 5773,
  5802, 6018, 5781, 5789, 6235, 5434, 6206, 5049, 5797, 5574, 5574, 6290, 4468, 5030, 5574, 5815, 5574, 6973, 5825,
  5837, 5373, 5707, 5038, 4518, 5854, 5574, 5866, 5574, 5649, 5244, 5574, 5731, 5574, 6014, 6987, 5574, 4498, 7104,
  5396, 5897, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 5915, 5926, 6624, 5943, 5950, 6163, 6018, 5487, 5600, 6849, 5574, 5751, 5049, 4852, 5906, 5574, 6290,
  6758, 5030, 5900, 5903, 6485, 6973, 4864, 5574, 5574, 5502, 5038, 4518, 5574, 5574, 4892, 5574, 5631, 5244, 5574,
  5574, 5574, 6109, 6693, 5574, 4498, 5574, 6449, 5963, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 5971, 5574, 5602, 5574, 6018, 5487, 5600, 5574,
  5574, 6206, 5049, 4494, 5574, 5574, 4508, 4328, 5254, 5574, 5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518,
  5574, 5574, 4842, 6287, 4510, 4275, 5574, 5982, 5565, 4509, 6258, 5991, 6342, 5574, 6257, 4915, 6870, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839,
  5574, 5602, 6935, 6000, 5487, 7069, 6028, 6037, 6206, 5049, 4494, 5574, 5574, 4508, 4328, 5254, 5574, 5574, 5574,
  6973, 4506, 5574, 5574, 6049, 4291, 4518, 5574, 7126, 4842, 5574, 6679, 4275, 5574, 5574, 4914, 4509, 6258, 6960,
  6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 6081, 6060, 6074, 6092, 6100, 6117, 6127, 5487, 6150, 6191, 5807, 6206, 5049, 4494, 5574,
  5907, 6171, 6199, 5254, 6996, 6217, 6226, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574, 4842, 6243, 4510,
  4275, 4866, 5574, 4914, 6253, 6010, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 5602, 5574, 6018, 5487,
  5600, 5574, 5574, 6206, 5049, 4494, 5574, 5574, 4508, 4328, 5254, 5574, 5574, 5574, 6973, 4506, 5574, 5574, 6869,
  4291, 4518, 5574, 5574, 7085, 5574, 4510, 4275, 6578, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018,
  5250, 4839, 5574, 6502, 6271, 6018, 5487, 5600, 5736, 5740, 6206, 5049, 4494, 6266, 5846, 4508, 4328, 5254, 6280,
  6105, 5992, 6973, 4506, 5574, 6484, 6298, 4291, 6314, 5574, 6409, 4842, 7136, 5829, 4275, 5574, 5574, 6322, 6341,
  6350, 6041, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 5602, 5459, 6018, 5487, 5600, 6588, 5574, 5505, 5049,
  4494, 5574, 5574, 4508, 4328, 5254, 5574, 5574, 5574, 6973, 4506, 6163, 5574, 6869, 4291, 4518, 5574, 5574, 4842,
  5574, 4510, 4275, 5574, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6361, 6372, 6772, 6775, 6386, 6406,
  6018, 5889, 5600, 6610, 6245, 5918, 5049, 6417, 5974, 6425, 4508, 5483, 5254, 6434, 6816, 5574, 6444, 4506, 5574,
  5574, 6869, 4291, 4518, 5574, 5574, 4842, 6819, 4510, 4275, 5574, 5574, 5626, 6913, 4607, 6461, 6342, 5574, 6176,
  4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 6018, 5250, 4839, 5574, 4825, 6469, 6018, 5487, 6477, 6493, 5663, 6206, 5049, 4494, 5574, 5574, 4508, 4328,
  5254, 5574, 5574, 5574, 6973, 4506, 6231, 7154, 6869, 4291, 4518, 5574, 6391, 4842, 5574, 6733, 4275, 5726, 5574,
  4914, 4509, 6258, 5574, 6567, 5574, 6257, 5416, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 5602, 5574, 6018, 5487, 5600, 5574, 5574,
  6206, 5049, 4494, 6395, 6398, 6499, 4328, 5254, 6029, 5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574,
  5574, 4842, 5574, 4510, 4275, 5574, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6510, 6523, 6066, 6537,
  6543, 6945, 6018, 5487, 6560, 6575, 6586, 6206, 5049, 4494, 5575, 5574, 6802, 4328, 5254, 6798, 5675, 6596, 6973,
  4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574, 4842, 6746, 6329, 4275, 5574, 6608, 4914, 4509, 6258, 5574, 6342,
  5574, 6917, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 6639, 6618, 6632, 6650, 6656, 5574, 6018, 5487, 5600, 5574, 5574, 6206, 5049, 6673, 6859, 6699,
  4508, 5885, 5254, 5574, 5574, 6963, 6687, 6710, 5574, 6161, 6869, 4291, 6728, 6745, 5574, 4842, 5574, 4510, 4275,
  5574, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6754, 6766, 7010, 6783, 6789, 5574, 6018, 5487, 5600,
  5574, 5574, 6206, 5049, 6810, 6600, 4856, 6453, 6827, 5636, 5574, 6272, 5858, 6973, 6839, 6426, 5842, 6869, 4291,
  4518, 5462, 6157, 7033, 6857, 6867, 5344, 6794, 5574, 4914, 4509, 6258, 5574, 4522, 6702, 6257, 4915, 6870, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250,
  4839, 5574, 5621, 6879, 6894, 5487, 6906, 6886, 6884, 6206, 5049, 4494, 6992, 5574, 6677, 6084, 5254, 6185, 5574,
  6188, 6973, 6925, 5574, 6933, 6869, 4291, 4518, 7117, 6943, 4842, 6661, 4510, 6953, 5574, 5817, 4914, 4509, 6258,
  5574, 6971, 7151, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 6981, 7004, 6378, 7018, 7024, 5574, 6018, 5487, 5600, 5574, 5574, 6206, 5049, 4494,
  5574, 5574, 4508, 4328, 5254, 5574, 5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574, 4842, 5574,
  4510, 4275, 5574, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 7041, 7062, 6529, 7093, 7099, 6552, 6018,
  5487, 5600, 5574, 7116, 6206, 5049, 4494, 5574, 6162, 4508, 4328, 5254, 6549, 5574, 5574, 6973, 4506, 5574, 5574,
  6869, 4291, 4518, 5574, 5574, 4842, 5574, 4510, 4275, 5574, 7029, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915,
  6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  6018, 5250, 4839, 5574, 5602, 7125, 6018, 5057, 5600, 5574, 6436, 6206, 5049, 4494, 5574, 5574, 4508, 6364, 5254,
  5574, 5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574, 4842, 5574, 4510, 4275, 5574, 5574, 4914,
  4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 6018, 5250, 4839, 5574, 5602, 5445, 6018, 5487, 5700, 7135, 7134, 6206,
  5049, 4494, 5574, 5574, 5827, 4328, 5254, 6160, 5574, 5431, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574,
  4842, 5574, 4510, 4275, 5574, 5574, 4914, 4509, 6258, 5574, 7144, 6119, 6257, 4915, 6870, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 5685, 4274, 4749, 4752, 7162,
  4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634,
  4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370,
  4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 7170, 4636, 4273, 6203, 4251, 4636, 4636, 6642, 5049, 7178, 4362, 4361, 4638,
  4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346,
  4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 7186, 6134, 7048, 7054, 4636, 4273, 6203, 4251, 4636,
  4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376, 4291, 4308,
  4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4562,
  4566, 7201, 4636, 4273, 6203, 4251, 4636, 4636, 4338, 5049, 4266, 4362, 4361, 4638, 4328, 4283, 4636, 5006, 4636,
  4322, 4634, 4636, 4636, 4376, 4291, 4308, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440,
  4415, 4370, 4258, 4388, 4402, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 6209, 5574, 6018, 5487, 5600, 5574, 5574, 6206, 5049, 4494, 5574,
  5574, 4508, 4328, 5254, 5574, 5574, 5574, 6973, 4506, 5574, 5574, 6869, 4291, 4518, 5574, 5574, 4842, 5574, 4510,
  4275, 5574, 5574, 4914, 4509, 6258, 5574, 6342, 5574, 6257, 4915, 6870, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4224, 4224, 4224, 4224, 4240, 4636, 4273, 4274,
  4243, 4636, 4636, 4338, 4274, 4411, 4362, 4361, 4638, 4328, 4325, 4636, 5006, 4636, 4322, 4634, 4636, 4636, 4376,
  4274, 4427, 4636, 4316, 4639, 4636, 4270, 4336, 4346, 4659, 4360, 4670, 4419, 4440, 4415, 4370, 4258, 4388, 4402,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 7209, 7215, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274, 4274,
  4274, 4274, 4274, 4274, 4274, 4274, 5632, 5632, 5632, 5632, 5632, 5632, 5632, 5632, 0, 0, 0, 0, 0, 0, 0, 4669, 5632,
  5632, 67072, 0, 0, 67072, 67072, 67072, 0, 0, 67072, 0, 150, 67072, 67072, 67072, 0, 0, 67072, 98304, 96256, 0, 67072,
  67072, 67072, 96256, 0, 106, 6251, 0, 67072, 67072, 67072, 67072, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 0, 100864, 0, 0, 150,
  151, 150, 0, 58, 0, 0, 59, 0, 0, 0, 0, 14919, 14919, 14919, 14919, 14919, 14919, 14919, 14919, 99840, 102912, 0, 151,
  67072, 67072, 101888, 67072, 98816, 67072, 67072, 67072, 104960, 105984, 67072, 67072, 0, 0, 0, 100864, 0, 0, 0, 0, 0,
  58, 59, 0, 94208, 0, 0, 0, 0, 0, 0, 67072, 0, 0, 67584, 103936, 68096, 67072, 67072, 106496, 67072, 67072, 0, 0,
  24576, 100864, 0, 24830, 97792, 67072, 67072, 0, 67072, 67072, 67072, 67072, 67072, 67072, 96768, 105472, 67072,
  67072, 102400, 103424, 67072, 67072, 0, 105984, 0, 0, 0, 0, 106, 0, 0, 0, 98304, 67072, 0, 99328, 95232, 95744, 67072,
  67072, 7680, 22016, 0, 100864, 19968, 24064, 101376, 0, 0, 0, 0, 0, 0, 0, 58, 0, 106, 0, 0, 67072, 67072, 67072,
  67072, 0, 0, 0, 67072, 67072, 67072, 93696, 67072, 99840, 102912, 0, 0, 67072, 67072, 101888, 67072, 6745, 6745,
  67072, 0, 0, 67072, 67072, 67072, 104448, 107008, 67072, 67072, 67072, 0, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
  67072, 0, 0, 67072, 67072, 67072, 0, 3584, 59, 0, 0, 0, 0, 0, 58, 59, 145, 0, 3584, 0, 0, 59, 0, 0, 0, 0, 17920, 0, 0,
  0, 0, 23733, 67072, 0, 0, 0, 106, 6251, 0, 35, 35, 35, 35, 0, 0, 348, 35, 106, 0, 35, 35, 35, 35, 35, 35, 0, 0, 0, 0,
  3122, 3122, 4323, 151, 35, 35, 35, 35, 0, 347, 0, 35, 8192, 8288, 67072, 0, 0, 67072, 67072, 67072, 9306, 9313, 67072,
  0, 0, 67072, 67072, 67072, 0, 9728, 0, 0, 0, 67072, 0, 0, 67072, 67072, 67072, 9728, 0, 0, 0, 150, 0, 0, 0, 0, 45056,
  45056, 45056, 45056, 45056, 45056, 45056, 45056, 0, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 67072, 0, 0, 67072, 67072,
  67072, 0, 58, 3584, 0, 0, 0, 0, 0, 58, 59, 4752, 0, 58, 0, 0, 3584, 0, 0, 0, 35, 35, 35, 35, 339, 10752, 10752, 67072,
  0, 0, 67072, 67072, 67072, 11264, 11264, 67072, 0, 0, 67072, 67072, 67072, 11776, 11874, 67072, 106, 0, 67072, 67072,
  67072, 67072, 67072, 67072, 67072, 67072, 0, 0, 67072, 0, 106, 67072, 67072, 67072, 0, 0, 67072, 0, 185, 6251, 0,
  67072, 67072, 67072, 67072, 67072, 107520, 94208, 67072, 185, 0, 67072, 67072, 67072, 67072, 67072, 67072, 0, 107008,
  94720, 12870, 12899, 67072, 0, 0, 67072, 67072, 67072, 0, 150, 67072, 67072, 67072, 13312, 0, 67072, 224, 0, 100864,
  0, 0, 150, 151, 150, 14336, 14336, 67072, 0, 0, 67072, 67072, 67072, 14919, 14948, 67072, 0, 0, 67072, 67072, 67072,
  0, 150, 67072, 67072, 67072, 0, 15360, 67072, 0, 60, 60, 60, 60, 60, 60, 60, 60, 60, 16444, 67072, 0, 0, 67072, 67072,
  67072, 0, 58, 59, 0, 4752, 4752, 0, 0, 0, 42496, 42496, 42496, 42496, 42496, 42496, 42496, 42496, 36, 36, 36, 36, 36,
  36, 36, 36, 66, 66, 66, 66, 66, 66, 66, 66, 16962, 16997, 67072, 6251, 0, 67072, 67072, 67072, 0, 6251, 67072, 67072,
  67072, 0, 0, 67072, 0, 0, 100864, 0, 0, 4323, 151, 150, 6144, 0, 67072, 67072, 67072, 67072, 67072, 67072, 25088, 0,
  67072, 0, 4669, 4669, 4669, 4669, 4669, 4669, 4669, 4669, 4669, 4669, 35, 0, 0, 35, 35, 35, 0, 0, 35, 112, 114, 0, 58,
  59, 4752, 0, 4670, 0, 3122, 3122, 35, 35, 35, 35, 35, 0, 0, 35, 110, 35, 0, 106, 6251, 186, 35, 35, 35, 35, 35, 202,
  35, 35, 106, 255, 35, 35, 35, 35, 35, 35, 35, 320, 0, 58, 275, 276, 59, 277, 278, 4832, 5266, 0, 3122, 3122, 150, 151,
  150, 35, 35, 4323, 35, 35, 35, 35, 35, 0, 300, 35, 0, 4670, 4670, 4670, 4670, 4670, 4670, 4670, 4670, 4670, 4670, 35,
  0, 0, 35, 35, 35, 0, 35, 35, 35, 35, 35, 17920, 17920, 67072, 0, 0, 67072, 67072, 67072, 18432, 0, 0, 0, 0, 0, 18432,
  0, 0, 10752, 0, 0, 0, 0, 0, 0, 18432, 18432, 18432, 18432, 18432, 18432, 18432, 18432, 67072, 0, 0, 67072, 67072,
  67072, 19035, 19046, 67072, 0, 0, 67072, 67072, 67072, 20992, 0, 0, 0, 0, 0, 0, 0, 60, 92, 21084, 67072, 0, 0, 67072,
  67072, 67072, 7347, 0, 20480, 21684, 23040, 67072, 0, 8704, 10240, 12288, 13824, 15872, 17558, 20480, 23040, 27648,
  43520, 106, 6251, 0, 67072, 67072, 67072, 67072, 97280, 67072, 100352, 67072, 22621, 22631, 67072, 0, 0, 67072, 67072,
  67072, 25600, 25600, 67072, 0, 0, 67072, 67072, 67072, 0, 5266, 0, 3122, 3122, 150, 151, 150, 0, 58, 275, 276, 59,
  277, 278, 0, 0, 11264, 11264, 0, 0, 0, 0, 150, 0, 0, 0, 0, 58, 59, 0, 146, 0, 0, 3122, 3122, 38, 38, 38, 38, 38,
  26112, 26112, 67072, 0, 0, 67072, 67072, 67072, 0, 151, 67072, 67072, 67072, 0, 0, 67072, 0, 0, 100864, 0, 0, 151,
  151, 150, 37, 51, 0, 0, 0, 0, 0, 0, 0, 4752, 0, 37, 37, 0, 0, 0, 0, 51, 51, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
  67109, 0, 0, 67109, 67109, 67109, 67109, 67109, 0, 107008, 94720, 0, 142, 143, 0, 0, 0, 0, 51, 152, 67109, 67109,
  67109, 0, 0, 67109, 51, 0, 0, 0, 0, 0, 0, 0, 14336, 0, 106, 6251, 0, 67109, 67109, 67109, 67109, 0, 0, 0, 0, 150, 0,
  23736, 0, 0, 0, 100864, 51, 51, 152, 228, 150, 106, 0, 67109, 67109, 67109, 67109, 67109, 67109, 67109, 67109, 0, 0,
  67109, 0, 142, 0, 0, 143, 0, 0, 0, 10752, 10752, 10752, 10752, 10752, 10752, 10752, 10752, 99891, 102963, 279, 151,
  67109, 67109, 101925, 67109, 67109, 67109, 104485, 107045, 67109, 67109, 67109, 67109, 67109, 107557, 94245, 67109,
  98853, 67109, 67109, 67109, 104997, 106021, 67109, 67109, 0, 0, 0, 100901, 0, 0, 220, 58, 223, 59, 0, 35, 35, 0, 0, 0,
  0, 3122, 3122, 150, 151, 150, 94208, 0, 0, 0, 0, 0, 0, 67109, 0, 0, 67621, 103973, 68133, 67109, 67109, 106533, 67109,
  67109, 0, 105984, 0, 0, 0, 0, 150, 19639, 0, 0, 97829, 67109, 67109, 0, 67109, 67109, 67109, 67109, 0, 0, 0, 67109,
  67109, 67109, 93733, 67109, 96805, 105509, 67109, 67109, 102437, 103461, 67109, 67109, 37, 67109, 67109, 67109, 67109,
  67109, 67109, 67109, 98304, 96256, 0, 67109, 67109, 67109, 96293, 98341, 67109, 0, 99365, 95269, 95781, 67109, 67109,
  67109, 67109, 97317, 67109, 100389, 67109, 101413, 0, 0, 0, 0, 0, 0, 0, 316, 26624, 26624, 67072, 0, 0, 67072, 67072,
  67072, 27136, 27240, 67072, 0, 0, 67072, 67072, 67072, 35, 118, 35, 35, 35, 35, 35, 120, 35, 35, 35, 268, 35, 35,
  3122, 0, 136, 0, 138, 0, 140, 3122, 150, 153, 35, 35, 0, 0, 35, 0, 0, 355, 35, 357, 35, 35, 172, 35, 175, 35, 35, 153,
  35, 120, 35, 110, 35, 153, 35, 35, 0, 35, 35, 35, 360, 35, 0, 106, 6251, 186, 35, 35, 190, 35, 35, 245, 35, 35, 35,
  35, 35, 176, 35, 35, 106, 255, 256, 35, 35, 35, 35, 35, 35, 131, 35, 260, 35, 35, 35, 35, 264, 35, 35, 122, 35, 35,
  35, 35, 35, 35, 288, 35, 274, 58, 275, 276, 59, 277, 278, 0, 0, 19456, 0, 0, 67072, 0, 0, 215, 0, 0, 58, 59, 0, 0, 0,
  0, 3122, 35, 296, 35, 298, 35, 0, 300, 35, 35, 269, 0, 0, 0, 0, 0, 122, 0, 0, 35, 307, 35, 35, 310, 0, 0, 0, 14336,
  14336, 0, 0, 0, 0, 0, 0, 14336, 38, 3122, 0, 0, 0, 0, 0, 0, 0, 20992, 0, 38, 38, 0, 0, 0, 0, 3122, 3122, 39, 39, 39,
  39, 39, 75, 75, 75, 75, 75, 75, 75, 75, 35, 0, 0, 35, 35, 35, 0, 35, 203, 35, 35, 192, 35, 35, 35, 35, 35, 35, 35, 35,
  114, 39, 3122, 0, 0, 0, 0, 0, 0, 0, 26624, 0, 39, 39, 0, 0, 54, 56, 3122, 150, 35, 35, 35, 0, 0, 35, 35, 35, 76, 76,
  76, 85, 85, 85, 85, 85, 35, 0, 0, 35, 35, 35, 0, 108, 35, 35, 35, 0, 329, 35, 35, 35, 35, 310, 0, 0, 0, 3297, 3298,
  150, 151, 150, 106, 255, 35, 35, 210, 35, 35, 35, 35, 310, 311, 0, 0, 3122, 3122, 4323, 151, 35, 280, 35, 35, 161, 35,
  163, 165, 35, 166, 354, 0, 0, 355, 35, 35, 35, 35, 35, 241, 35, 35, 40, 3122, 0, 0, 0, 0, 0, 0, 0, 42496, 0, 40, 40,
  0, 0, 0, 57, 3122, 150, 35, 35, 131, 0, 0, 35, 35, 269, 0, 0, 0, 0, 273, 77, 77, 77, 77, 86, 86, 86, 86, 35, 0, 0, 35,
  35, 35, 35, 318, 35, 35, 35, 35, 325, 35, 35, 35, 111, 35, 35, 35, 35, 111, 35, 177, 35, 41, 3122, 0, 0, 0, 0, 0, 0,
  167, 0, 0, 0, 41, 41, 0, 0, 0, 0, 3122, 3122, 40, 72, 72, 72, 72, 87, 87, 35, 0, 0, 35, 35, 113, 141, 58, 59, 0, 145,
  145, 0, 3220, 3221, 150, 35, 155, 35, 0, 0, 159, 0, 106, 6251, 186, 187, 35, 35, 35, 124, 126, 35, 35, 35, 174, 35,
  35, 35, 178, 35, 238, 35, 35, 35, 35, 35, 35, 35, 326, 106, 255, 35, 114, 35, 35, 35, 35, 0, 0, 0, 313, 35, 261, 35,
  35, 263, 35, 35, 35, 189, 35, 35, 35, 35, 201, 35, 35, 35, 35, 283, 284, 285, 35, 35, 35, 35, 35, 248, 189, 35, 295,
  35, 297, 35, 35, 0, 300, 35, 35, 269, 0, 0, 0, 272, 0, 0, 13312, 0, 150, 0, 0, 0, 216, 0, 58, 59, 0, 0, 0, 147, 3122,
  35, 359, 4323, 35, 35, 35, 35, 35, 35, 193, 35, 35, 35, 35, 35, 35, 35, 204, 42, 3122, 0, 0, 0, 0, 0, 0, 182, 0, 0, 0,
  42, 42, 0, 0, 55, 0, 3122, 3122, 41, 41, 41, 41, 41, 87, 87, 87, 78, 78, 78, 78, 78, 78, 88, 78, 78, 35, 0, 0, 35, 35,
  35, 207, 0, 0, 348, 35, 35, 35, 4323, 35, 35, 35, 35, 361, 0, 3136, 3136, 35, 35, 35, 35, 35, 35, 198, 35, 321, 35,
  35, 35, 35, 35, 35, 35, 205, 340, 35, 35, 35, 35, 35, 35, 35, 235, 133, 3122, 0, 0, 137, 0, 0, 0, 15360, 150, 0, 0, 0,
  336, 35, 35, 35, 35, 35, 3122, 0, 0, 0, 0, 0, 0, 0, 4670, 157, 35, 35, 35, 35, 35, 35, 35, 236, 35, 170, 35, 173, 35,
  35, 35, 35, 35, 343, 344, 35, 35, 114, 0, 0, 0, 0, 0, 0, 218, 221, 0, 0, 43, 43, 0, 0, 0, 0, 3122, 3122, 45, 45, 45,
  45, 45, 63, 3122, 3122, 43, 43, 43, 43, 43, 3122, 0, 0, 0, 0, 0, 0, 219, 222, 0, 79, 79, 79, 79, 79, 79, 79, 79, 94,
  94, 35, 0, 0, 35, 35, 35, 235, 35, 35, 35, 35, 114, 3122, 0, 0, 35, 119, 35, 35, 35, 35, 35, 35, 35, 353, 134, 3122,
  0, 0, 0, 0, 139, 0, 0, 44544, 0, 0, 0, 0, 0, 6656, 6656, 6656, 6656, 6656, 6656, 6656, 6656, 3122, 150, 119, 35, 35,
  0, 0, 35, 35, 291, 35, 35, 35, 35, 35, 114, 35, 35, 35, 35, 35, 205, 35, 35, 208, 209, 35, 0, 0, 0, 356, 35, 35, 35,
  240, 35, 35, 35, 35, 35, 234, 35, 35, 35, 35, 35, 119, 35, 35, 213, 0, 0, 0, 0, 58, 59, 0, 0, 0, 0, 0, 35, 0, 0, 35,
  35, 35, 237, 35, 35, 35, 35, 35, 35, 35, 240, 243, 233, 35, 35, 247, 35, 35, 35, 262, 35, 35, 35, 35, 164, 35, 35,
  168, 35, 301, 35, 35, 35, 35, 35, 35, 116, 35, 35, 331, 35, 35, 35, 0, 0, 0, 35, 35, 35, 35, 35, 194, 35, 35, 35, 35,
  115, 35, 35, 35, 35, 35, 35, 35, 242, 229, 35, 35, 232, 35, 35, 235, 35, 35, 302, 35, 35, 35, 35, 35, 35, 211, 0, 188,
  35, 0, 0, 270, 0, 0, 0, 26112, 26112, 26112, 26112, 26112, 26112, 26112, 26112, 3122, 3122, 4323, 151, 35, 35, 35,
  281, 35, 327, 35, 0, 35, 35, 257, 35, 35, 308, 35, 0, 0, 0, 0, 152, 0, 0, 0, 330, 35, 35, 35, 35, 0, 0, 0, 35, 333,
  334, 0, 35, 35, 35, 35, 35, 35, 265, 35, 44, 3122, 0, 0, 0, 0, 0, 0, 220, 223, 0, 0, 44, 44, 0, 0, 0, 0, 3122, 3122,
  48, 74, 74, 74, 74, 68, 68, 35, 0, 0, 35, 35, 35, 292, 35, 35, 35, 35, 196, 35, 35, 35, 35, 203, 35, 116, 35, 123, 35,
  35, 35, 35, 35, 35, 293, 35, 0, 106, 6251, 0, 35, 35, 35, 191, 199, 35, 35, 35, 35, 35, 35, 35, 266, 35, 230, 35, 35,
  35, 35, 35, 35, 117, 35, 35, 252, 0, 0, 0, 35, 0, 0, 355, 35, 35, 35, 35, 35, 210, 0, 0, 35, 341, 35, 35, 35, 35, 35,
  345, 35, 120, 35, 35, 35, 35, 35, 132, 3122, 150, 120, 35, 35, 0, 0, 114, 35, 35, 35, 35, 35, 35, 35, 250, 35, 161,
  35, 163, 165, 166, 35, 35, 207, 35, 35, 35, 0, 0, 35, 111, 35, 45, 3122, 0, 0, 0, 0, 0, 0, 11264, 0, 0, 0, 0, 0, 45,
  45, 0, 0, 0, 0, 3122, 3122, 49, 49, 49, 49, 49, 80, 80, 80, 80, 80, 80, 80, 80, 35, 0, 0, 109, 35, 35, 231, 35, 35,
  35, 35, 35, 128, 35, 35, 3122, 150, 35, 35, 158, 0, 0, 35, 35, 308, 35, 0, 0, 0, 349, 158, 35, 162, 35, 35, 35, 35,
  35, 35, 319, 35, 35, 171, 35, 35, 35, 35, 35, 35, 122, 35, 35, 244, 35, 246, 35, 35, 35, 35, 197, 35, 35, 35, 35, 322,
  35, 35, 35, 35, 35, 35, 123, 35, 0, 46, 46, 0, 0, 0, 0, 3122, 3122, 67, 67, 67, 67, 67, 0, 3137, 3137, 46, 46, 46, 46,
  46, 3122, 0, 0, 0, 0, 0, 0, 67072, 44032, 0, 81, 81, 81, 81, 81, 81, 81, 81, 35, 0, 0, 35, 35, 35, 303, 35, 35, 35,
  35, 286, 35, 35, 35, 0, 106, 6251, 0, 35, 188, 35, 35, 35, 35, 0, 0, 312, 0, 251, 35, 0, 0, 0, 253, 0, 0, 335, 35, 35,
  338, 35, 35, 200, 35, 35, 35, 35, 35, 35, 352, 35, 106, 0, 35, 35, 35, 205, 257, 35, 35, 323, 35, 35, 35, 35, 35, 35,
  192, 35, 3122, 3122, 4323, 151, 234, 35, 35, 35, 309, 0, 0, 0, 0, 151, 0, 0, 0, 282, 35, 35, 35, 35, 35, 257, 35, 35,
  47, 3122, 0, 0, 0, 0, 0, 0, 217, 58, 59, 0, 0, 47, 47, 0, 0, 0, 0, 3122, 3122, 68, 68, 68, 68, 68, 68, 68, 68, 82, 82,
  82, 82, 82, 82, 82, 82, 35, 0, 0, 35, 35, 35, 317, 35, 35, 35, 35, 206, 35, 35, 35, 35, 35, 0, 212, 0, 106, 6251, 0,
  35, 189, 35, 35, 239, 35, 35, 35, 35, 35, 35, 304, 35, 0, 214, 0, 0, 0, 58, 59, 0, 145, 145, 0, 3122, 106, 0, 35, 35,
  35, 35, 258, 35, 35, 328, 35, 35, 35, 35, 35, 35, 167, 35, 114, 35, 35, 35, 188, 35, 35, 35, 35, 35, 306, 35, 35, 35,
  0, 0, 0, 0, 0, 0, 0, 59, 35, 121, 35, 125, 35, 127, 35, 35, 35, 35, 35, 35, 154, 35, 35, 35, 3122, 135, 0, 0, 0, 0, 0,
  6251, 0, 0, 0, 3122, 150, 154, 156, 35, 0, 0, 35, 35, 332, 114, 35, 0, 0, 0, 35, 35, 358, 35, 106, 0, 35, 35, 35, 35,
  35, 259, 35, 267, 35, 35, 35, 35, 35, 35, 129, 35, 35, 290, 35, 35, 35, 35, 35, 35, 130, 35, 0, 314, 0, 0, 0, 0, 315,
  35, 35, 342, 35, 35, 35, 35, 35, 35, 249, 35, 188, 35, 35, 35, 0, 0, 0, 35, 0, 0, 48, 3122, 0, 0, 0, 52, 0, 0, 335,
  35, 337, 35, 35, 35, 195, 35, 35, 35, 35, 233, 35, 35, 35, 0, 48, 48, 0, 0, 0, 0, 3122, 3122, 69, 73, 73, 73, 73, 83,
  83, 83, 83, 83, 83, 83, 83, 35, 0, 0, 35, 35, 35, 324, 35, 35, 35, 35, 299, 0, 0, 35, 49, 3122, 0, 0, 0, 0, 53, 0, 0,
  44544, 44544, 44544, 44544, 44544, 44544, 67072, 0, 0, 67072, 67072, 67072, 0, 49, 49, 0, 0, 0, 0, 3122, 150, 35, 35,
  157, 0, 0, 35, 35, 269, 0, 0, 271, 0, 0, 335, 35, 35, 35, 35, 35, 0, 0, 114, 84, 84, 84, 84, 84, 84, 84, 84, 35, 0, 0,
  35, 35, 35, 351, 35, 35, 35, 35, 35, 287, 35, 35, 169, 35, 35, 35, 35, 35, 35, 35, 289, 117, 35, 35, 35, 35, 35, 35,
  35, 294, 35, 160, 35, 35, 35, 35, 35, 35, 35, 305, 35, 114, 35, 35, 346, 0, 0, 35, 35, 350, 35, 35, 35, 35, 35, 124,
  35, 35, 42496, 42496, 67072, 0, 0, 67072, 67072, 67072, 43103, 43113, 67072, 0, 0, 67072, 67072, 67072, 44032, 106,
  6251, 0, 67072, 67072, 67072, 67072, 44544, 0, 0, 0, 44544, 0, 44544, 0, 0, 100864, 0, 0, 150, 150, 150, 45056, 45056,
  67072, 0, 0, 67072, 67072, 67072, 0, 1024, 0, 0, 0, 1024, 1024, 1024, 0, 0, 0, 0, 0, 0, 12870, 12870, 12870, 12870,
  12870, 12870, 12870, 12870
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  136, 140, 144, 148, 152, 199, 158, 266, 164, 168, 214, 180, 184, 197, 199, 199, 200, 264, 206, 212, 199, 225, 231,
  198, 199, 199, 202, 287, 210, 170, 199, 154, 199, 201, 218, 222, 199, 199, 176, 174, 199, 172, 199, 243, 228, 247,
  381, 254, 258, 262, 340, 376, 380, 340, 300, 160, 270, 250, 279, 340, 340, 340, 378, 340, 292, 239, 387, 284, 291,
  340, 340, 376, 380, 340, 237, 339, 307, 340, 356, 296, 298, 304, 316, 340, 322, 333, 318, 326, 330, 336, 413, 345,
  348, 351, 354, 340, 414, 340, 275, 360, 367, 363, 279, 374, 340, 340, 340, 385, 273, 189, 193, 391, 341, 340, 340,
  340, 414, 340, 187, 191, 370, 394, 340, 280, 340, 400, 404, 395, 340, 310, 408, 412, 312, 396, 234, 418, 420, 422,
  427, 427, 581, 424, 426, 428, 431, 429, 433, 435, 438, 437, 438, 439, 441, 515, 524, 524, 517, 524, 529, 530, 520,
  520, 481, 483, 445, 449, 451, 514, 528, 524, 527, 524, 524, 524, 520, 523, 524, 524, 529, 520, 456, 520, 494, 490,
  460, 465, 446, 520, 495, 520, 531, 493, 507, 542, 544, 520, 521, 508, 516, 524, 524, 524, 524, 530, 520, 520, 579,
  497, 499, 500, 498, 500, 528, 525, 527, 524, 524, 527, 520, 577, 577, 523, 526, 528, 524, 524, 528, 524, 524, 523,
  524, 524, 546, 494, 520, 497, 531, 520, 504, 520, 510, 513, 520, 517, 547, 524, 524, 517, 520, 494, 520, 520, 531,
  487, 553, 520, 457, 458, 469, 470, 472, 474, 476, 478, 520, 520, 492, 578, 443, 497, 519, 479, 485, 520, 520, 574,
  496, 576, 507, 489, 520, 520, 520, 490, 535, 519, 537, 492, 577, 577, 578, 539, 520, 520, 520, 504, 463, 552, 520,
  520, 505, 540, 511, 520, 452, 520, 520, 592, 558, 519, 491, 520, 531, 542, 520, 501, 558, 519, 520, 520, 518, 552,
  550, 552, 504, 540, 504, 555, 453, 557, 519, 551, 520, 452, 520, 520, 462, 520, 555, 453, 520, 520, 520, 520, 447,
  560, 541, 520, 541, 562, 564, 566, 568, 570, 570, 572, 520, 520, 520, 549, 520, 583, 520, 533, 520, 520, 454, 585,
  587, 589, 520, 522, 502, 594, 520, 591, 520, 520, 520, 550, 461, 520, 520, 520, 467, 545, 491, 520, 520, 520, 592,
  585, 580, 594, 596, 520, 520, 530, 520, 532, 531, 506, 520, 543, 520, 547, 502, 596, 520, 547, 502, 491, 497, 520,
  520, 520, 545, 491, 498, 530, 3076, 3104, 1051648, 2100224, 2100228, 136317952, 134220800, 3072, 3072, 3936, 1052636,
  134220800, 3936, 856694748, 858791900, 856694748, 990912476, 856694748, 856694748, 856694750, 990912478, 997654494,
  -34, 768, 256, 32, 2176, 0, 48, 20, 12, 20, 33554432, 67108864, 0, 56, 24576, 262144, 268697600, 268697608, 786432,
  8388608, 134217728, -2147483648, 8388608, 100663296, 1610612736, -2130706432, 142606336, 269221888, 910426120,
  910426120, 918814728, 1053032456, 2126774280, -20709368, 2126774536, 2128527037, 2130706431, 0, 160, 0, 41943040,
  1006632960, 1073741824, 1536, 45056, 224, 126976, 2097152, 0, 65536, 0, 64, 0, 4, 256, 0, 32, 32, 128, 128, 512, 2048,
  0, 268435456, 0, 1024, 0, 2048, 4194304, 33554432, 872415232, 335544320, 536870912, 4, 2048, 4, 0, -2147483648, 0, 0,
  1, 128, 4, 4, 12, 4, 20, 4, 32, 0, 2, 0, 3, 469762048, 1073741824, 1024, 32768, 114688, 0, 4194304, 0, 8192, 32768, 0,
  16384, 0, 128, 0, 16777216, -2147483648, 134217728, 0, 264, 0, 33554432, 0, 134217728, 1073741824, 65536, 262144, 16,
  260, 4194564, 263234, 8692802, 8692802, 8912587, 8912587, 13106891, 13106891, 15728379, 16776955, 16, 4, 2, 64, 64,
  256, 512, 3072, 1051652, 9216, 32768, 8, 128, 512, 15360, 49152, 196608, 3145728, 0, 8388608, 4096, 16384, 65536,
  131072
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "EOF",
  "Identifier",
  "'null'",
  "BooleanLiteral",
  "IdentifierName",
  "StringLiteral",
  "RegularExpressionLiteral",
  "DecimalLiteral",
  "HexIntegerLiteral",
  "WhiteSpace",
  "Comment",
  "'!'",
  "'!='",
  "'!=='",
  "'%'",
  "'%='",
  "'&amp;'",
  "'&amp;&amp;'",
  "'&amp;='",
  "'('",
  "')'",
  "'*'",
  "'*='",
  "'+'",
  "'++'",
  "'+='",
  "','",
  "'-'",
  "'--'",
  "'-='",
  "'.'",
  "'/'",
  "'/='",
  "':'",
  "';'",
  "'<'",
  "'<<'",
  "'<<='",
  "'<='",
  "'='",
  "'=='",
  "'==='",
  "'>'",
  "'>='",
  "'>>'",
  "'>>='",
  "'>>>'",
  "'>>>='",
  "'?'",
  "'['",
  "']'",
  "'^'",
  "'^='",
  "'break'",
  "'case'",
  "'catch'",
  "'continue'",
  "'debugger'",
  "'default'",
  "'delete'",
  "'do'",
  "'else'",
  "'finally'",
  "'for'",
  "'function'",
  "'get'",
  "'if'",
  "'in'",
  "'instanceof'",
  "'new'",
  "'return'",
  "'set'",
  "'switch'",
  "'this'",
  "'throw'",
  "'try'",
  "'typeof'",
  "'var'",
  "'void'",
  "'while'",
  "'with'",
  "'{'",
  "'|'",
  "'|='",
  "'||'",
  "'}'",
  "'~'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 512,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 512
    return
      if ($result != 0) then
      (
        $result mod 128 - 1,
        $begin,
        $end - $result idiv 128
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 4)
    let $current := $current + 1
    let $i0 := 512 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 8
    let $next-state := $p:TRANSITION[$i0 mod 8 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 511) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 512, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 2
    let $i0 := $t * 361 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[4 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[8 + $m]
};

(:~
 : Parse DebuggerStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DebuggerStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(58, $input, $state)                 (: 'debugger' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DebuggerStatement", $count, $begin, $end)
};

(:~
 : Try parsing DebuggerStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DebuggerStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(58, $input, $state)                (: 'debugger' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse Finally.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Finally($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(63, $input, $state)                 (: 'finally' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Finally", $count, $begin, $end)
};

(:~
 : Try parsing Finally.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Finally($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(63, $input, $state)                (: 'finally' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-Block($input, $state)
  return $state
};

(:~
 : Parse Catch.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Catch($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(56, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $state := p:lookahead1W(3, $input, $state)            (: WhiteSpace | Comment | ')' :)
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Block($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Catch", $count, $begin, $end)
};

(:~
 : Try parsing Catch.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Catch($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(56, $input, $state)                (: 'catch' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  let $state := p:lookahead1W(3, $input, $state)            (: WhiteSpace | Comment | ')' :)
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-Block($input, $state)
  return $state
};

(:~
 : Parse TryStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(76, $input, $state)                 (: 'try' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Block($input, $state)
  let $state := p:lookahead1W(13, $input, $state)           (: WhiteSpace | Comment | 'catch' | 'finally' :)
  let $state :=
    if ($state[$p:l1] = 56) then                            (: 'catch' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Catch($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'finally' |
                                                               'for' | 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 63) then                   (: 'finally' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Finally($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Finally($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TryStatement", $count, $begin, $end)
};

(:~
 : Try parsing TryStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-TryStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(76, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-Block($input, $state)
  let $state := p:lookahead1W(13, $input, $state)           (: WhiteSpace | Comment | 'catch' | 'finally' :)
  let $state :=
    if ($state[$p:l1] = 56) then                            (: 'catch' :)
      let $state := p:try-Catch($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'finally' |
                                                               'for' | 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 63) then                   (: 'finally' :)
          let $state := p:try-Finally($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Finally($input, $state)
      return $state
  return $state
};

(:~
 : Parse ThrowStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ThrowStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(75, $input, $state)                 (: 'throw' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ThrowStatement", $count, $begin, $end)
};

(:~
 : Try parsing ThrowStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ThrowStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(75, $input, $state)                (: 'throw' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production DefaultClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(27, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'delete' | 'do' | 'for' | 'function' | 'if' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '}' | '~' :)
    return
      if ($state[$p:l1] = 55                                (: 'case' :)
       or $state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Statement($input, $state)
        return p:parse-DefaultClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production DefaultClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DefaultClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(27, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'delete' | 'do' | 'for' | 'function' | 'if' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '}' | '~' :)
    return
      if ($state[$p:l1] = 55                                (: 'case' :)
       or $state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:try-Statement($input, $state)
        return p:try-DefaultClause-1($input, $state)
};

(:~
 : Parse DefaultClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(59, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(4, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:shift(34, $input, $state)                 (: ':' :)
  let $state := p:parse-DefaultClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultClause", $count, $begin, $end)
};

(:~
 : Try parsing DefaultClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-DefaultClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(59, $input, $state)                (: 'default' :)
  let $state := p:lookahead1W(4, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:shiftT(34, $input, $state)                (: ':' :)
  let $state := p:try-DefaultClause-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CaseClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'for' | 'function' | 'if' |
                                                               'new' | 'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '}' | '~' :)
    return
      if ($state[$p:l1] = 55                                (: 'case' :)
       or $state[$p:l1] = 59                                (: 'default' :)
       or $state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Statement($input, $state)
        return p:parse-CaseClause-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CaseClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'for' | 'function' | 'if' |
                                                               'new' | 'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '}' | '~' :)
    return
      if ($state[$p:l1] = 55                                (: 'case' :)
       or $state[$p:l1] = 59                                (: 'default' :)
       or $state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:try-Statement($input, $state)
        return p:try-CaseClause-1($input, $state)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(55, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:shift(34, $input, $state)                 (: ':' :)
  let $state := p:parse-CaseClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Try parsing CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(55, $input, $state)                (: 'case' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:shiftT(34, $input, $state)                (: ':' :)
  let $state := p:try-CaseClause-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseBlock-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(14, $input, $state)         (: WhiteSpace | Comment | 'case' | 'default' | '}' :)
    return
      if ($state[$p:l1] != 55) then                         (: 'case' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-CaseClause($input, $state)
        return p:parse-CaseBlock-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseBlock-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(14, $input, $state)         (: WhiteSpace | Comment | 'case' | 'default' | '}' :)
    return
      if ($state[$p:l1] != 55) then                         (: 'case' :)
        $state
      else
        let $state := p:try-CaseClause($input, $state)
        return p:try-CaseBlock-1($input, $state)
};

(:~
 : Parse the 2nd loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseBlock-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 55) then                           (: 'case' :)
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CaseClause($input, $state)
      return p:parse-CaseBlock-2($input, $state)
};

(:~
 : Try parsing the 2nd loop of production CaseBlock (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseBlock-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 55) then                           (: 'case' :)
      $state
    else
      let $state := p:try-CaseClause($input, $state)
      return p:try-CaseBlock-2($input, $state)
};

(:~
 : Parse CaseBlock.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseBlock($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(82, $input, $state)                 (: '{' :)
  let $state := p:parse-CaseBlock-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: 'default' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-DefaultClause($input, $state)
      let $state := p:parse-CaseBlock-2($input, $state)
      return $state
    else
      $state
  let $state := p:shift(86, $input, $state)                 (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseBlock", $count, $begin, $end)
};

(:~
 : Try parsing CaseBlock.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CaseBlock($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(82, $input, $state)                (: '{' :)
  let $state := p:try-CaseBlock-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: 'default' :)
      let $state := p:try-DefaultClause($input, $state)
      let $state := p:try-CaseBlock-2($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(86, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse SwitchStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(73, $input, $state)                 (: 'switch' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-CaseBlock($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchStatement", $count, $begin, $end)
};

(:~
 : Try parsing SwitchStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SwitchStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(73, $input, $state)                (: 'switch' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:try-CaseBlock($input, $state)
  return $state
};

(:~
 : Parse LabelledStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LabelledStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $state := p:lookahead1W(4, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:shift(34, $input, $state)                 (: ':' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LabelledStatement", $count, $begin, $end)
};

(:~
 : Try parsing LabelledStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LabelledStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  let $state := p:lookahead1W(4, $input, $state)            (: WhiteSpace | Comment | ':' :)
  let $state := p:shiftT(34, $input, $state)                (: ':' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state := p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse WithStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WithStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(81, $input, $state)                 (: 'with' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Statement($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WithStatement", $count, $begin, $end)
};

(:~
 : Try parsing WithStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-WithStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(81, $input, $state)                (: 'with' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state := p:try-Statement($input, $state)
  return $state
};

(:~
 : Parse ReturnStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(71, $input, $state)                 (: 'return' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 1                             (: EOF :)
         and $state[$p:l1] != 35                            (: ';' :)
         and $state[$p:l1] != 54                            (: 'break' :)
         and $state[$p:l1] != 55                            (: 'case' :)
         and $state[$p:l1] != 57                            (: 'continue' :)
         and $state[$p:l1] != 58                            (: 'debugger' :)
         and $state[$p:l1] != 59                            (: 'default' :)
         and $state[$p:l1] != 61                            (: 'do' :)
         and $state[$p:l1] != 62                            (: 'else' :)
         and $state[$p:l1] != 64                            (: 'for' :)
         and $state[$p:l1] != 67                            (: 'if' :)
         and $state[$p:l1] != 71                            (: 'return' :)
         and $state[$p:l1] != 73                            (: 'switch' :)
         and $state[$p:l1] != 75                            (: 'throw' :)
         and $state[$p:l1] != 76                            (: 'try' :)
         and $state[$p:l1] != 78                            (: 'var' :)
         and $state[$p:l1] != 80                            (: 'while' :)
         and $state[$p:l1] != 81                            (: 'with' :)
         and $state[$p:l1] != 86) then                      (: '}' :)
      let $state := p:memoized($state, 16)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-Expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 16)
            else
              p:memoize($backtrack, $state, -2, 16)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnStatement", $count, $begin, $end)
};

(:~
 : Try parsing ReturnStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ReturnStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(71, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 1                             (: EOF :)
         and $state[$p:l1] != 35                            (: ';' :)
         and $state[$p:l1] != 54                            (: 'break' :)
         and $state[$p:l1] != 55                            (: 'case' :)
         and $state[$p:l1] != 57                            (: 'continue' :)
         and $state[$p:l1] != 58                            (: 'debugger' :)
         and $state[$p:l1] != 59                            (: 'default' :)
         and $state[$p:l1] != 61                            (: 'do' :)
         and $state[$p:l1] != 62                            (: 'else' :)
         and $state[$p:l1] != 64                            (: 'for' :)
         and $state[$p:l1] != 67                            (: 'if' :)
         and $state[$p:l1] != 71                            (: 'return' :)
         and $state[$p:l1] != 73                            (: 'switch' :)
         and $state[$p:l1] != 75                            (: 'throw' :)
         and $state[$p:l1] != 76                            (: 'try' :)
         and $state[$p:l1] != 78                            (: 'var' :)
         and $state[$p:l1] != 80                            (: 'while' :)
         and $state[$p:l1] != 81                            (: 'with' :)
         and $state[$p:l1] != 86) then                      (: '}' :)
      let $state := p:memoized($state, 16)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-Expression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 16)
            else
              p:memoize($backtrack, $state, -2, 16)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:try-Expression($input, $state)
      return $state
    else
      $state
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse BreakStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BreakStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(54, $input, $state)                 (: 'break' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(2, $input, $state)         (: Identifier :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 15)
            else
              p:memoize($backtrack, $state, -2, 15)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:shift(2, $input, $state)              (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BreakStatement", $count, $begin, $end)
};

(:~
 : Try parsing BreakStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BreakStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(54, $input, $state)                (: 'break' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:memoized($state, 15)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(2, $input, $state)         (: Identifier :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 15)
            else
              p:memoize($backtrack, $state, -2, 15)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:shiftT(2, $input, $state)             (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse ContinueStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContinueStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(57, $input, $state)                 (: 'continue' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(2, $input, $state)         (: Identifier :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 14)
            else
              p:memoize($backtrack, $state, -2, 14)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:shift(2, $input, $state)              (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContinueStatement", $count, $begin, $end)
};

(:~
 : Try parsing ContinueStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ContinueStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(57, $input, $state)                (: 'continue' :)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:memoized($state, 14)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(2, $input, $state)         (: Identifier :)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 14)
            else
              p:memoize($backtrack, $state, -2, 14)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:shiftT(2, $input, $state)             (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse InitialiserNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialiserNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(40, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AssignmentExpressionNoIn($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialiserNoIn", $count, $begin, $end)
};

(:~
 : Try parsing InitialiserNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-InitialiserNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(40, $input, $state)                (: '=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-AssignmentExpressionNoIn($input, $state)
  return $state
};

(:~
 : Parse VariableDeclarationNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $state := p:lookahead1W(16, $input, $state)           (: WhiteSpace | Comment | ',' | ';' | '=' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '=' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-InitialiserNoIn($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarationNoIn", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarationNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  let $state := p:lookahead1W(16, $input, $state)           (: WhiteSpace | Comment | ',' | ';' | '=' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '=' :)
      let $state := p:try-InitialiserNoIn($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production VariableDeclarationListNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationListNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shift(27, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclarationNoIn($input, $state)
      return p:parse-VariableDeclarationListNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production VariableDeclarationListNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationListNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(27, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclarationNoIn($input, $state)
      return p:try-VariableDeclarationListNoIn-1($input, $state)
};

(:~
 : Parse VariableDeclarationListNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationListNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-VariableDeclarationNoIn($input, $state)
  let $state := p:parse-VariableDeclarationListNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarationListNoIn", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarationListNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationListNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-VariableDeclarationNoIn($input, $state)
  let $state := p:try-VariableDeclarationListNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production RelationalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '<' :)
    and $state[$p:l1] != 39                                 (: '<=' :)
    and $state[$p:l1] != 43                                 (: '>' :)
    and $state[$p:l1] != 44                                 (: '>=' :)
    and $state[$p:l1] != 69) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 36) then                        (: '<' :)
          let $state := p:shift(36, $input, $state)         (: '<' :)
          return $state
        else if ($state[$p:l1] = 43) then                   (: '>' :)
          let $state := p:shift(43, $input, $state)         (: '>' :)
          return $state
        else if ($state[$p:l1] = 39) then                   (: '<=' :)
          let $state := p:shift(39, $input, $state)         (: '<=' :)
          return $state
        else if ($state[$p:l1] = 44) then                   (: '>=' :)
          let $state := p:shift(44, $input, $state)         (: '>=' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(69, $input, $state)         (: 'instanceof' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ShiftExpression($input, $state)
      return p:parse-RelationalExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelationalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '<' :)
    and $state[$p:l1] != 39                                 (: '<=' :)
    and $state[$p:l1] != 43                                 (: '>' :)
    and $state[$p:l1] != 44                                 (: '>=' :)
    and $state[$p:l1] != 69) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 36) then                        (: '<' :)
          let $state := p:shiftT(36, $input, $state)        (: '<' :)
          return $state
        else if ($state[$p:l1] = 43) then                   (: '>' :)
          let $state := p:shiftT(43, $input, $state)        (: '>' :)
          return $state
        else if ($state[$p:l1] = 39) then                   (: '<=' :)
          let $state := p:shiftT(39, $input, $state)        (: '<=' :)
          return $state
        else if ($state[$p:l1] = 44) then                   (: '>=' :)
          let $state := p:shiftT(44, $input, $state)        (: '>=' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(69, $input, $state)        (: 'instanceof' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-ShiftExpression($input, $state)
      return p:try-RelationalExpressionNoIn-1($input, $state)
};

(:~
 : Parse RelationalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ShiftExpression($input, $state)
  let $state := p:parse-RelationalExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelationalExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing RelationalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ShiftExpression($input, $state)
  let $state := p:try-RelationalExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production EqualityExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 13                                 (: '!=' :)
    and $state[$p:l1] != 14                                 (: '!==' :)
    and $state[$p:l1] != 41                                 (: '==' :)
    and $state[$p:l1] != 42) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 41) then                        (: '==' :)
          let $state := p:shift(41, $input, $state)         (: '==' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '!=' :)
          let $state := p:shift(13, $input, $state)         (: '!=' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '===' :)
          let $state := p:shift(42, $input, $state)         (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(14, $input, $state)         (: '!==' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelationalExpressionNoIn($input, $state)
      return p:parse-EqualityExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production EqualityExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 13                                 (: '!=' :)
    and $state[$p:l1] != 14                                 (: '!==' :)
    and $state[$p:l1] != 41                                 (: '==' :)
    and $state[$p:l1] != 42) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 41) then                        (: '==' :)
          let $state := p:shiftT(41, $input, $state)        (: '==' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '!=' :)
          let $state := p:shiftT(13, $input, $state)        (: '!=' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '===' :)
          let $state := p:shiftT(42, $input, $state)        (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(14, $input, $state)        (: '!==' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-RelationalExpressionNoIn($input, $state)
      return p:try-EqualityExpressionNoIn-1($input, $state)
};

(:~
 : Parse EqualityExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RelationalExpressionNoIn($input, $state)
  let $state := p:parse-EqualityExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EqualityExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing EqualityExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-RelationalExpressionNoIn($input, $state)
  let $state := p:try-EqualityExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 17) then                           (: '&' :)
      $state
    else
      let $state := p:shift(17, $input, $state)             (: '&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EqualityExpressionNoIn($input, $state)
      return p:parse-BitwiseANDExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 17) then                           (: '&' :)
      $state
    else
      let $state := p:shiftT(17, $input, $state)            (: '&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-EqualityExpressionNoIn($input, $state)
      return p:try-BitwiseANDExpressionNoIn-1($input, $state)
};

(:~
 : Parse BitwiseANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EqualityExpressionNoIn($input, $state)
  let $state := p:parse-BitwiseANDExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseANDExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EqualityExpressionNoIn($input, $state)
  let $state := p:try-BitwiseANDExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseXORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 52) then                           (: '^' :)
      $state
    else
      let $state := p:shift(52, $input, $state)             (: '^' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseANDExpressionNoIn($input, $state)
      return p:parse-BitwiseXORExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseXORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 52) then                           (: '^' :)
      $state
    else
      let $state := p:shiftT(52, $input, $state)            (: '^' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-BitwiseANDExpressionNoIn($input, $state)
      return p:try-BitwiseXORExpressionNoIn-1($input, $state)
};

(:~
 : Parse BitwiseXORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseANDExpressionNoIn($input, $state)
  let $state := p:parse-BitwiseXORExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseXORExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseXORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseANDExpressionNoIn($input, $state)
  let $state := p:try-BitwiseXORExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 83) then                           (: '|' :)
      $state
    else
      let $state := p:shift(83, $input, $state)             (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseXORExpressionNoIn($input, $state)
      return p:parse-BitwiseORExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 83) then                           (: '|' :)
      $state
    else
      let $state := p:shiftT(83, $input, $state)            (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-BitwiseXORExpressionNoIn($input, $state)
      return p:try-BitwiseORExpressionNoIn-1($input, $state)
};

(:~
 : Parse BitwiseORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseXORExpressionNoIn($input, $state)
  let $state := p:parse-BitwiseORExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseORExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseXORExpressionNoIn($input, $state)
  let $state := p:try-BitwiseORExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&&' :)
      $state
    else
      let $state := p:shift(18, $input, $state)             (: '&&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseORExpressionNoIn($input, $state)
      return p:parse-LogicalANDExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalANDExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&&' :)
      $state
    else
      let $state := p:shiftT(18, $input, $state)            (: '&&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-BitwiseORExpressionNoIn($input, $state)
      return p:try-LogicalANDExpressionNoIn-1($input, $state)
};

(:~
 : Parse LogicalANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseORExpressionNoIn($input, $state)
  let $state := p:parse-LogicalANDExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalANDExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing LogicalANDExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseORExpressionNoIn($input, $state)
  let $state := p:try-LogicalANDExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 85) then                           (: '||' :)
      $state
    else
      let $state := p:shift(85, $input, $state)             (: '||' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LogicalANDExpressionNoIn($input, $state)
      return p:parse-LogicalORExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalORExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 85) then                           (: '||' :)
      $state
    else
      let $state := p:shiftT(85, $input, $state)            (: '||' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-LogicalANDExpressionNoIn($input, $state)
      return p:try-LogicalORExpressionNoIn-1($input, $state)
};

(:~
 : Parse LogicalORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalANDExpressionNoIn($input, $state)
  let $state := p:parse-LogicalORExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalORExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing LogicalORExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalANDExpressionNoIn($input, $state)
  let $state := p:try-LogicalORExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ConditionalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConditionalExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 49) then                     (: '?' :)
        let $state := p:memoized($state, 13)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:shiftT(49, $input, $state)      (: '?' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpression($input, $state)
            let $state := p:shiftT(34, $input, $state)      (: ':' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpressionNoIn($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 13)
              else
                p:memoize($backtrack, $state, -2, 13)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:shift(49, $input, $state)           (: '?' :)
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-AssignmentExpression($input, $state)
        let $state := p:shift(34, $input, $state)           (: ':' :)
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-AssignmentExpressionNoIn($input, $state)
        return p:parse-ConditionalExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ConditionalExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ConditionalExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 49) then                     (: '?' :)
        let $state := p:memoized($state, 13)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:shiftT(49, $input, $state)      (: '?' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpression($input, $state)
            let $state := p:shiftT(34, $input, $state)      (: ':' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-AssignmentExpressionNoIn($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 13)
              else
                p:memoize($backtrack, $state, -2, 13)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:shiftT(49, $input, $state)          (: '?' :)
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:try-AssignmentExpression($input, $state)
        let $state := p:shiftT(34, $input, $state)          (: ':' :)
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:try-AssignmentExpressionNoIn($input, $state)
        return p:try-ConditionalExpressionNoIn-1($input, $state)
};

(:~
 : Parse ConditionalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConditionalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalORExpressionNoIn($input, $state)
  let $state := p:parse-ConditionalExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ConditionalExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalORExpressionNoIn($input, $state)
  let $state := p:try-ConditionalExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse AssignmentExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AssignmentExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 12                            (: '!' :)
         and $state[$p:l1] != 24                            (: '+' :)
         and $state[$p:l1] != 25                            (: '++' :)
         and $state[$p:l1] != 28                            (: '-' :)
         and $state[$p:l1] != 29                            (: '--' :)
         and $state[$p:l1] != 60                            (: 'delete' :)
         and $state[$p:l1] != 77                            (: 'typeof' :)
         and $state[$p:l1] != 79                            (: 'void' :)
         and $state[$p:l1] != 87) then                      (: '~' :)
      let $state := p:memoized($state, 12)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(20, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpressionNoIn($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 12)
            else
              p:memoize($backtrack, $state, -2, 12)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:parse-LeftHandSideExpression($input, $state)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpressionNoIn($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ConditionalExpressionNoIn($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AssignmentExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 12                            (: '!' :)
         and $state[$p:l1] != 24                            (: '+' :)
         and $state[$p:l1] != 25                            (: '++' :)
         and $state[$p:l1] != 28                            (: '-' :)
         and $state[$p:l1] != 29                            (: '--' :)
         and $state[$p:l1] != 60                            (: 'delete' :)
         and $state[$p:l1] != 77                            (: 'typeof' :)
         and $state[$p:l1] != 79                            (: 'void' :)
         and $state[$p:l1] != 87) then                      (: '~' :)
      let $state := p:memoized($state, 12)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(20, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpressionNoIn($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 12)
            else
              p:memoize($backtrack, $state, -2, 12)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:try-LeftHandSideExpression($input, $state)
      let $state := p:try-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpressionNoIn($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ConditionalExpressionNoIn($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shift(27, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpressionNoIn($input, $state)
      return p:parse-ExpressionNoIn-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ExpressionNoIn (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExpressionNoIn-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(27, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpressionNoIn($input, $state)
      return p:try-ExpressionNoIn-1($input, $state)
};

(:~
 : Parse ExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AssignmentExpressionNoIn($input, $state)
  let $state := p:parse-ExpressionNoIn-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExpressionNoIn", $count, $begin, $end)
};

(:~
 : Try parsing ExpressionNoIn.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExpressionNoIn($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AssignmentExpressionNoIn($input, $state)
  let $state := p:try-ExpressionNoIn-1($input, $state)
  return $state
};

(:~
 : Parse IterationStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IterationStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: 'for' :)
      let $state := p:memoized($state, 11)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(64, $input, $state)        (: 'for' :)
          let $state := p:lookahead1W(2, $input, $state)    (: WhiteSpace | Comment | '(' :)
          let $state := p:shiftT(20, $input, $state)        (: '(' :)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 35) then              (: ';' :)
              let $state := p:try-ExpressionNoIn($input, $state)
              return $state
            else
              $state
          let $state := p:shiftT(35, $input, $state)        (: ';' :)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 35) then              (: ';' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:shiftT(35, $input, $state)        (: ';' :)
          let $state := p:lookahead1W(21, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 21) then              (: ')' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:shiftT(21, $input, $state)        (: ')' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -3, 11)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:shiftT(64, $input, $state)    (: 'for' :)
              let $state := p:lookahead1W(2, $input, $state) (: WhiteSpace | Comment | '(' :)
              let $state := p:shiftT(20, $input, $state)    (: '(' :)
              let $state := p:lookahead1W(5, $input, $state) (: WhiteSpace | Comment | 'var' :)
              let $state := p:shiftT(78, $input, $state)    (: 'var' :)
              let $state := p:lookahead1W(0, $input, $state) (: Identifier | WhiteSpace | Comment :)
              let $state := p:try-VariableDeclarationListNoIn($input, $state)
              let $state := p:shiftT(35, $input, $state)    (: ';' :)
              let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                 Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                                 '[' | 'delete' | 'function' | 'new' | 'this' |
                                                                 'typeof' | 'void' | '{' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 35) then          (: ';' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:shiftT(35, $input, $state)    (: ';' :)
              let $state := p:lookahead1W(21, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                 Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                                 '[' | 'delete' | 'function' | 'new' | 'this' |
                                                                 'typeof' | 'void' | '{' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 21) then          (: ')' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:shiftT(21, $input, $state)    (: ')' :)
              let $state := p:lookahead1W(24, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                 Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                                 '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                                 'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                                 'switch' | 'this' | 'throw' | 'try' | 'typeof' |
                                                                 'var' | 'void' | 'while' | 'with' | '{' | '~' :)
              let $state := p:try-Statement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -4, 11)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state := p:shiftT(64, $input, $state) (: 'for' :)
                  let $state := p:lookahead1W(2, $input, $state) (: WhiteSpace | Comment | '(' :)
                  let $state := p:shiftT(20, $input, $state) (: '(' :)
                  let $state := p:lookahead1W(19, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                     Comment | '(' | '[' | 'function' | 'new' | 'this' |
                                                                     '{' :)
                  let $state := p:try-LeftHandSideExpression($input, $state)
                  let $state := p:shiftT(68, $input, $state) (: 'in' :)
                  let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                     Comment | '!' | '(' | '+' | '++' | '-' | '--' |
                                                                     '[' | 'delete' | 'function' | 'new' | 'this' |
                                                                     'typeof' | 'void' | '{' | '~' :)
                  let $state := p:try-Expression($input, $state)
                  let $state := p:shiftT(21, $input, $state) (: ')' :)
                  let $state := p:lookahead1W(24, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                     Comment | '!' | '(' | '+' | '++' | '-' | '--' |
                                                                     ';' | '[' | 'break' | 'continue' | 'debugger' |
                                                                     'delete' | 'do' | 'for' | 'function' | 'if' |
                                                                     'new' | 'return' | 'switch' | 'this' | 'throw' |
                                                                     'try' | 'typeof' | 'var' | 'void' | 'while' |
                                                                     'with' | '{' | '~' :)
                  let $state := p:try-Statement($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, -5, 11)
                    else
                      p:memoize($backtrack, $state, -6, 11)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:l1] = 61) then                            (: 'do' :)
      let $state := p:shift(61, $input, $state)             (: 'do' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WhiteSpace | Comment | 'while' :)
      let $state := p:shift(80, $input, $state)             (: 'while' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(29, $input, $state)       (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Semicolon($input, $state)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state := p:shift(64, $input, $state)             (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 35) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ExpressionNoIn($input, $state)
          return $state
        else
          $state
      let $state := p:shift(35, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 35) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shift(35, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 21) then                  (: ')' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -4) then
      let $state := p:shift(64, $input, $state)             (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(5, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:shift(78, $input, $state)             (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclarationListNoIn($input, $state)
      let $state := p:shift(35, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 35) then                  (: ';' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shift(35, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 21) then                  (: ')' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state := p:shift(64, $input, $state)             (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '(' | '[' | 'function' | 'new' | 'this' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LeftHandSideExpression($input, $state)
      let $state := p:shift(68, $input, $state)             (: 'in' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state := p:shift(64, $input, $state)             (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(5, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:shift(78, $input, $state)             (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclarationNoIn($input, $state)
      let $state := p:shift(68, $input, $state)             (: 'in' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(80, $input, $state)             (: 'while' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IterationStatement", $count, $begin, $end)
};

(:~
 : Try parsing IterationStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IterationStatement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: 'for' :)
      let $state := p:memoized($state, 11)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(64, $input, $state)        (: 'for' :)
          let $state := p:lookahead1W(2, $input, $state)    (: WhiteSpace | Comment | '(' :)
          let $state := p:shiftT(20, $input, $state)        (: '(' :)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 35) then              (: ';' :)
              let $state := p:try-ExpressionNoIn($input, $state)
              return $state
            else
              $state
          let $state := p:shiftT(35, $input, $state)        (: ';' :)
          let $state := p:lookahead1W(22, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 35) then              (: ';' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:shiftT(35, $input, $state)        (: ';' :)
          let $state := p:lookahead1W(21, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] != 21) then              (: ')' :)
              let $state := p:try-Expression($input, $state)
              return $state
            else
              $state
          let $state := p:shiftT(21, $input, $state)        (: ')' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -3, 11)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:shiftT(64, $input, $state)    (: 'for' :)
              let $state := p:lookahead1W(2, $input, $state) (: WhiteSpace | Comment | '(' :)
              let $state := p:shiftT(20, $input, $state)    (: '(' :)
              let $state := p:lookahead1W(5, $input, $state) (: WhiteSpace | Comment | 'var' :)
              let $state := p:shiftT(78, $input, $state)    (: 'var' :)
              let $state := p:lookahead1W(0, $input, $state) (: Identifier | WhiteSpace | Comment :)
              let $state := p:try-VariableDeclarationListNoIn($input, $state)
              let $state := p:shiftT(35, $input, $state)    (: ';' :)
              let $state := p:lookahead1W(22, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                 Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                                 '[' | 'delete' | 'function' | 'new' | 'this' |
                                                                 'typeof' | 'void' | '{' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 35) then          (: ';' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:shiftT(35, $input, $state)    (: ';' :)
              let $state := p:lookahead1W(21, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                 Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                                 '[' | 'delete' | 'function' | 'new' | 'this' |
                                                                 'typeof' | 'void' | '{' | '~' :)
              let $state :=
                if ($state[$p:error]) then
                  $state
                else if ($state[$p:l1] != 21) then          (: ')' :)
                  let $state := p:try-Expression($input, $state)
                  return $state
                else
                  $state
              let $state := p:shiftT(21, $input, $state)    (: ')' :)
              let $state := p:lookahead1W(24, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                 StringLiteral | RegularExpressionLiteral |
                                                                 DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                 Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                                 '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                                 'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                                 'switch' | 'this' | 'throw' | 'try' | 'typeof' |
                                                                 'var' | 'void' | 'while' | 'with' | '{' | '~' :)
              let $state := p:try-Statement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -4, 11)
                else
                  let $state := p:restore($backtrack, $state)
                  let $state := p:shiftT(64, $input, $state) (: 'for' :)
                  let $state := p:lookahead1W(2, $input, $state) (: WhiteSpace | Comment | '(' :)
                  let $state := p:shiftT(20, $input, $state) (: '(' :)
                  let $state := p:lookahead1W(19, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                     Comment | '(' | '[' | 'function' | 'new' | 'this' |
                                                                     '{' :)
                  let $state := p:try-LeftHandSideExpression($input, $state)
                  let $state := p:shiftT(68, $input, $state) (: 'in' :)
                  let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                     Comment | '!' | '(' | '+' | '++' | '-' | '--' |
                                                                     '[' | 'delete' | 'function' | 'new' | 'this' |
                                                                     'typeof' | 'void' | '{' | '~' :)
                  let $state := p:try-Expression($input, $state)
                  let $state := p:shiftT(21, $input, $state) (: ')' :)
                  let $state := p:lookahead1W(24, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                     StringLiteral | RegularExpressionLiteral |
                                                                     DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                     Comment | '!' | '(' | '+' | '++' | '-' | '--' |
                                                                     ';' | '[' | 'break' | 'continue' | 'debugger' |
                                                                     'delete' | 'do' | 'for' | 'function' | 'if' |
                                                                     'new' | 'return' | 'switch' | 'this' | 'throw' |
                                                                     'try' | 'typeof' | 'var' | 'void' | 'while' |
                                                                     'with' | '{' | '~' :)
                  let $state := p:try-Statement($input, $state)
                  return
                    if (not($state[$p:error])) then
                      p:memoize($backtrack, $state, -5, 11)
                    else
                      p:memoize($backtrack, $state, -6, 11)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:l1] = 61) then                            (: 'do' :)
      let $state := p:shiftT(61, $input, $state)            (: 'do' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      let $state := p:lookahead1W(6, $input, $state)        (: WhiteSpace | Comment | 'while' :)
      let $state := p:shiftT(80, $input, $state)            (: 'while' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(29, $input, $state)       (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:try-Semicolon($input, $state)
      return $state
    else if ($state[$p:lk] = -3) then
      let $state := p:shiftT(64, $input, $state)            (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 35) then                  (: ';' :)
          let $state := p:try-ExpressionNoIn($input, $state)
          return $state
        else
          $state
      let $state := p:shiftT(35, $input, $state)            (: ';' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 35) then                  (: ';' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shiftT(35, $input, $state)            (: ';' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 21) then                  (: ')' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -4) then
      let $state := p:shiftT(64, $input, $state)            (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(5, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:shiftT(78, $input, $state)            (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclarationListNoIn($input, $state)
      let $state := p:shiftT(35, $input, $state)            (: ';' :)
      let $state := p:lookahead1W(22, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 35) then                  (: ';' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shiftT(35, $input, $state)            (: ';' :)
      let $state := p:lookahead1W(21, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 21) then                  (: ')' :)
          let $state := p:try-Expression($input, $state)
          return $state
        else
          $state
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -5) then
      let $state := p:shiftT(64, $input, $state)            (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(19, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '(' | '[' | 'function' | 'new' | 'this' | '{' :)
      let $state := p:try-LeftHandSideExpression($input, $state)
      let $state := p:shiftT(68, $input, $state)            (: 'in' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:lk] = -6) then
      let $state := p:shiftT(64, $input, $state)            (: 'for' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(5, $input, $state)        (: WhiteSpace | Comment | 'var' :)
      let $state := p:shiftT(78, $input, $state)            (: 'var' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclarationNoIn($input, $state)
      let $state := p:shiftT(68, $input, $state)            (: 'in' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(80, $input, $state)            (: 'while' :)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
  return $state
};

(:~
 : Parse IfStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(67, $input, $state)                 (: 'if' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expression($input, $state)
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Statement($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: 'else' :)
      let $state := p:memoized($state, 10)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(62, $input, $state)        (: 'else' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 10)
            else
              p:memoize($backtrack, $state, -2, 10)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:shift(62, $input, $state)             (: 'else' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Statement($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IfStatement", $count, $begin, $end)
};

(:~
 : Try parsing IfStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-IfStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(67, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-Expression($input, $state)
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(24, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
  let $state := p:try-Statement($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: 'else' :)
      let $state := p:memoized($state, 10)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:shiftT(62, $input, $state)        (: 'else' :)
          let $state := p:lookahead1W(24, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
          let $state := p:try-Statement($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 10)
            else
              p:memoize($backtrack, $state, -2, 10)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state := p:shiftT(62, $input, $state)            (: 'else' :)
      let $state := p:lookahead1W(24, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
      let $state := p:try-Statement($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse ExpressionStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExpressionStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expression($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExpressionStatement", $count, $begin, $end)
};

(:~
 : Try parsing ExpressionStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ExpressionStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-Expression($input, $state)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse EmptyStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(35, $input, $state)                 (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyStatement", $count, $begin, $end)
};

(:~
 : Try parsing EmptyStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EmptyStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(35, $input, $state)                (: ';' :)
  return $state
};

(:~
 : Parse Semicolon.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Semicolon($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 35) then                            (: ';' :)
      let $state := p:shift(35, $input, $state)             (: ';' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Semicolon", $count, $begin, $end)
};

(:~
 : Try parsing Semicolon.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Semicolon($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 35) then                            (: ';' :)
      let $state := p:shiftT(35, $input, $state)            (: ';' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      $state
  return $state
};

(:~
 : Parse PostfixExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LeftHandSideExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '++' :)
          or $state[$p:l1] = 29) then                       (: '--' :)
      let $state := p:memoized($state, 4)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:l1] = 25) then                    (: '++' :)
              let $state := p:shiftT(25, $input, $state)    (: '++' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shiftT(29, $input, $state)    (: '--' :)
              return $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 4)
            else
              p:memoize($backtrack, $state, -2, 4)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:l1] = 25) then                        (: '++' :)
          let $state := p:shift(25, $input, $state)         (: '++' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(29, $input, $state)         (: '--' :)
          return $state
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpression", $count, $begin, $end)
};

(:~
 : Try parsing PostfixExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PostfixExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LeftHandSideExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '++' :)
          or $state[$p:l1] = 29) then                       (: '--' :)
      let $state := p:memoized($state, 4)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state :=
            if ($state[$p:l1] = 25) then                    (: '++' :)
              let $state := p:shiftT(25, $input, $state)    (: '++' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shiftT(29, $input, $state)    (: '--' :)
              return $state
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 4)
            else
              p:memoize($backtrack, $state, -2, 4)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = -1) then
      let $state :=
        if ($state[$p:l1] = 25) then                        (: '++' :)
          let $state := p:shiftT(25, $input, $state)        (: '++' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(29, $input, $state)        (: '--' :)
          return $state
      return $state
    else
      $state
  return $state
};

(:~
 : Parse UnaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 60) then                            (: 'delete' :)
      let $state := p:shift(60, $input, $state)             (: 'delete' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'void' :)
      let $state := p:shift(79, $input, $state)             (: 'void' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'typeof' :)
      let $state := p:shift(77, $input, $state)             (: 'typeof' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '++' :)
      let $state := p:shift(25, $input, $state)             (: '++' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: '--' :)
      let $state := p:shift(29, $input, $state)             (: '--' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 24) then                       (: '+' :)
      let $state := p:shift(24, $input, $state)             (: '+' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 28) then                       (: '-' :)
      let $state := p:shift(28, $input, $state)             (: '-' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 87) then                       (: '~' :)
      let $state := p:shift(87, $input, $state)             (: '~' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 12) then                       (: '!' :)
      let $state := p:shift(12, $input, $state)             (: '!' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PostfixExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing UnaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-UnaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 60) then                            (: 'delete' :)
      let $state := p:shiftT(60, $input, $state)            (: 'delete' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'void' :)
      let $state := p:shiftT(79, $input, $state)            (: 'void' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'typeof' :)
      let $state := p:shiftT(77, $input, $state)            (: 'typeof' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '++' :)
      let $state := p:shiftT(25, $input, $state)            (: '++' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: '--' :)
      let $state := p:shiftT(29, $input, $state)            (: '--' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 24) then                       (: '+' :)
      let $state := p:shiftT(24, $input, $state)            (: '+' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 28) then                       (: '-' :)
      let $state := p:shiftT(28, $input, $state)            (: '-' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 87) then                       (: '~' :)
      let $state := p:shiftT(87, $input, $state)            (: '~' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 12) then                       (: '!' :)
      let $state := p:shiftT(12, $input, $state)            (: '!' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-UnaryExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PostfixExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production MultiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(32, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '!=' | '!==' | '%' | '&' | '&&' | '(' |
                                                               ')' | '*' | '+' | '++' | ',' | '-' | '--' | '/' | ':' |
                                                               ';' | '<' | '<<' | '<=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>>' | '?' | '[' | ']' | '^' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'else' | 'for' | 'function' | 'if' | 'in' |
                                                               'instanceof' | 'new' | 'return' | 'switch' | 'this' |
                                                               'throw' | 'try' | 'typeof' | 'var' | 'void' | 'while' |
                                                               'with' | '{' | '|' | '||' | '}' | '~' :)
    return
      if ($state[$p:l1] != 15                               (: '%' :)
      and $state[$p:l1] != 22                               (: '*' :)
      and $state[$p:l1] != 32) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 22) then                      (: '*' :)
            let $state := p:shift(22, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 32) then                 (: '/' :)
            let $state := p:shift(32, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(15, $input, $state)       (: '%' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-UnaryExpression($input, $state)
        return p:parse-MultiplicativeExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MultiplicativeExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(32, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '!=' | '!==' | '%' | '&' | '&&' | '(' |
                                                               ')' | '*' | '+' | '++' | ',' | '-' | '--' | '/' | ':' |
                                                               ';' | '<' | '<<' | '<=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>>' | '?' | '[' | ']' | '^' | 'break' | 'case' |
                                                               'continue' | 'debugger' | 'default' | 'delete' | 'do' |
                                                               'else' | 'for' | 'function' | 'if' | 'in' |
                                                               'instanceof' | 'new' | 'return' | 'switch' | 'this' |
                                                               'throw' | 'try' | 'typeof' | 'var' | 'void' | 'while' |
                                                               'with' | '{' | '|' | '||' | '}' | '~' :)
    return
      if ($state[$p:l1] != 15                               (: '%' :)
      and $state[$p:l1] != 22                               (: '*' :)
      and $state[$p:l1] != 32) then                         (: '/' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 22) then                      (: '*' :)
            let $state := p:shiftT(22, $input, $state)      (: '*' :)
            return $state
          else if ($state[$p:l1] = 32) then                 (: '/' :)
            let $state := p:shiftT(32, $input, $state)      (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(15, $input, $state)      (: '%' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:try-UnaryExpression($input, $state)
        return p:try-MultiplicativeExpression-1($input, $state)
};

(:~
 : Parse MultiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpression($input, $state)
  let $state := p:parse-MultiplicativeExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpression", $count, $begin, $end)
};

(:~
 : Try parsing MultiplicativeExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MultiplicativeExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-UnaryExpression($input, $state)
  let $state := p:try-MultiplicativeExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production AdditiveExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 24                           (: '+' :)
            or $state[$p:l1] = 28) then                     (: '-' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:l1] = 24) then                  (: '+' :)
                let $state := p:shiftT(24, $input, $state)  (: '+' :)
                return $state
              else if ($state[$p:error]) then
                $state
              else
                let $state := p:shiftT(28, $input, $state)  (: '-' :)
                return $state
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-MultiplicativeExpression($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 3)
              else
                p:memoize($backtrack, $state, -2, 3)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:l1] = 24) then                      (: '+' :)
            let $state := p:shift(24, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(28, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-MultiplicativeExpression($input, $state)
        return p:parse-AdditiveExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production AdditiveExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 24                           (: '+' :)
            or $state[$p:l1] = 28) then                     (: '-' :)
        let $state := p:memoized($state, 3)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:l1] = 24) then                  (: '+' :)
                let $state := p:shiftT(24, $input, $state)  (: '+' :)
                return $state
              else if ($state[$p:error]) then
                $state
              else
                let $state := p:shiftT(28, $input, $state)  (: '-' :)
                return $state
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-MultiplicativeExpression($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 3)
              else
                p:memoize($backtrack, $state, -2, 3)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state :=
          if ($state[$p:l1] = 24) then                      (: '+' :)
            let $state := p:shiftT(24, $input, $state)      (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(28, $input, $state)      (: '-' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
        let $state := p:try-MultiplicativeExpression($input, $state)
        return p:try-AdditiveExpression-1($input, $state)
};

(:~
 : Parse AdditiveExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpression($input, $state)
  let $state := p:parse-AdditiveExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpression", $count, $begin, $end)
};

(:~
 : Try parsing AdditiveExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AdditiveExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-MultiplicativeExpression($input, $state)
  let $state := p:try-AdditiveExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production ShiftExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ShiftExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37                                 (: '<<' :)
    and $state[$p:l1] != 45                                 (: '>>' :)
    and $state[$p:l1] != 47) then                           (: '>>>' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 37) then                        (: '<<' :)
          let $state := p:shift(37, $input, $state)         (: '<<' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: '>>' :)
          let $state := p:shift(45, $input, $state)         (: '>>' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(47, $input, $state)         (: '>>>' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpression($input, $state)
      return p:parse-ShiftExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ShiftExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ShiftExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37                                 (: '<<' :)
    and $state[$p:l1] != 45                                 (: '>>' :)
    and $state[$p:l1] != 47) then                           (: '>>>' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 37) then                        (: '<<' :)
          let $state := p:shiftT(37, $input, $state)        (: '<<' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: '>>' :)
          let $state := p:shiftT(45, $input, $state)        (: '>>' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(47, $input, $state)        (: '>>>' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AdditiveExpression($input, $state)
      return p:try-ShiftExpression-1($input, $state)
};

(:~
 : Parse ShiftExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ShiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpression($input, $state)
  let $state := p:parse-ShiftExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ShiftExpression", $count, $begin, $end)
};

(:~
 : Try parsing ShiftExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ShiftExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AdditiveExpression($input, $state)
  let $state := p:try-ShiftExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production RelationalExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '<' :)
    and $state[$p:l1] != 39                                 (: '<=' :)
    and $state[$p:l1] != 43                                 (: '>' :)
    and $state[$p:l1] != 44                                 (: '>=' :)
    and $state[$p:l1] != 68                                 (: 'in' :)
    and $state[$p:l1] != 69) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 36) then                        (: '<' :)
          let $state := p:shift(36, $input, $state)         (: '<' :)
          return $state
        else if ($state[$p:l1] = 43) then                   (: '>' :)
          let $state := p:shift(43, $input, $state)         (: '>' :)
          return $state
        else if ($state[$p:l1] = 39) then                   (: '<=' :)
          let $state := p:shift(39, $input, $state)         (: '<=' :)
          return $state
        else if ($state[$p:l1] = 44) then                   (: '>=' :)
          let $state := p:shift(44, $input, $state)         (: '>=' :)
          return $state
        else if ($state[$p:l1] = 69) then                   (: 'instanceof' :)
          let $state := p:shift(69, $input, $state)         (: 'instanceof' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(68, $input, $state)         (: 'in' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ShiftExpression($input, $state)
      return p:parse-RelationalExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production RelationalExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 36                                 (: '<' :)
    and $state[$p:l1] != 39                                 (: '<=' :)
    and $state[$p:l1] != 43                                 (: '>' :)
    and $state[$p:l1] != 44                                 (: '>=' :)
    and $state[$p:l1] != 68                                 (: 'in' :)
    and $state[$p:l1] != 69) then                           (: 'instanceof' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 36) then                        (: '<' :)
          let $state := p:shiftT(36, $input, $state)        (: '<' :)
          return $state
        else if ($state[$p:l1] = 43) then                   (: '>' :)
          let $state := p:shiftT(43, $input, $state)        (: '>' :)
          return $state
        else if ($state[$p:l1] = 39) then                   (: '<=' :)
          let $state := p:shiftT(39, $input, $state)        (: '<=' :)
          return $state
        else if ($state[$p:l1] = 44) then                   (: '>=' :)
          let $state := p:shiftT(44, $input, $state)        (: '>=' :)
          return $state
        else if ($state[$p:l1] = 69) then                   (: 'instanceof' :)
          let $state := p:shiftT(69, $input, $state)        (: 'instanceof' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(68, $input, $state)        (: 'in' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-ShiftExpression($input, $state)
      return p:try-RelationalExpression-1($input, $state)
};

(:~
 : Parse RelationalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ShiftExpression($input, $state)
  let $state := p:parse-RelationalExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelationalExpression", $count, $begin, $end)
};

(:~
 : Try parsing RelationalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-RelationalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-ShiftExpression($input, $state)
  let $state := p:try-RelationalExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production EqualityExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 13                                 (: '!=' :)
    and $state[$p:l1] != 14                                 (: '!==' :)
    and $state[$p:l1] != 41                                 (: '==' :)
    and $state[$p:l1] != 42) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 41) then                        (: '==' :)
          let $state := p:shift(41, $input, $state)         (: '==' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '!=' :)
          let $state := p:shift(13, $input, $state)         (: '!=' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '===' :)
          let $state := p:shift(42, $input, $state)         (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(14, $input, $state)         (: '!==' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelationalExpression($input, $state)
      return p:parse-EqualityExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production EqualityExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 13                                 (: '!=' :)
    and $state[$p:l1] != 14                                 (: '!==' :)
    and $state[$p:l1] != 41                                 (: '==' :)
    and $state[$p:l1] != 42) then                           (: '===' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 41) then                        (: '==' :)
          let $state := p:shiftT(41, $input, $state)        (: '==' :)
          return $state
        else if ($state[$p:l1] = 13) then                   (: '!=' :)
          let $state := p:shiftT(13, $input, $state)        (: '!=' :)
          return $state
        else if ($state[$p:l1] = 42) then                   (: '===' :)
          let $state := p:shiftT(42, $input, $state)        (: '===' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shiftT(14, $input, $state)        (: '!==' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-RelationalExpression($input, $state)
      return p:try-EqualityExpression-1($input, $state)
};

(:~
 : Parse EqualityExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EqualityExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RelationalExpression($input, $state)
  let $state := p:parse-EqualityExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EqualityExpression", $count, $begin, $end)
};

(:~
 : Try parsing EqualityExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-EqualityExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-RelationalExpression($input, $state)
  let $state := p:try-EqualityExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 17) then                           (: '&' :)
      $state
    else
      let $state := p:shift(17, $input, $state)             (: '&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EqualityExpression($input, $state)
      return p:parse-BitwiseANDExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 17) then                           (: '&' :)
      $state
    else
      let $state := p:shiftT(17, $input, $state)            (: '&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-EqualityExpression($input, $state)
      return p:try-BitwiseANDExpression-1($input, $state)
};

(:~
 : Parse BitwiseANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EqualityExpression($input, $state)
  let $state := p:parse-BitwiseANDExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseANDExpression", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-EqualityExpression($input, $state)
  let $state := p:try-BitwiseANDExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseXORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 52) then                           (: '^' :)
      $state
    else
      let $state := p:shift(52, $input, $state)             (: '^' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseANDExpression($input, $state)
      return p:parse-BitwiseXORExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseXORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 52) then                           (: '^' :)
      $state
    else
      let $state := p:shiftT(52, $input, $state)            (: '^' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-BitwiseANDExpression($input, $state)
      return p:try-BitwiseXORExpression-1($input, $state)
};

(:~
 : Parse BitwiseXORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseXORExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseANDExpression($input, $state)
  let $state := p:parse-BitwiseXORExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseXORExpression", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseXORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseXORExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseANDExpression($input, $state)
  let $state := p:try-BitwiseXORExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production BitwiseORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 83) then                           (: '|' :)
      $state
    else
      let $state := p:shift(83, $input, $state)             (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseXORExpression($input, $state)
      return p:parse-BitwiseORExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production BitwiseORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 83) then                           (: '|' :)
      $state
    else
      let $state := p:shiftT(83, $input, $state)            (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-BitwiseXORExpression($input, $state)
      return p:try-BitwiseORExpression-1($input, $state)
};

(:~
 : Parse BitwiseORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BitwiseORExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseXORExpression($input, $state)
  let $state := p:parse-BitwiseORExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BitwiseORExpression", $count, $begin, $end)
};

(:~
 : Try parsing BitwiseORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-BitwiseORExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseXORExpression($input, $state)
  let $state := p:try-BitwiseORExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&&' :)
      $state
    else
      let $state := p:shift(18, $input, $state)             (: '&&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-BitwiseORExpression($input, $state)
      return p:parse-LogicalANDExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalANDExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 18) then                           (: '&&' :)
      $state
    else
      let $state := p:shiftT(18, $input, $state)            (: '&&' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-BitwiseORExpression($input, $state)
      return p:try-LogicalANDExpression-1($input, $state)
};

(:~
 : Parse LogicalANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-BitwiseORExpression($input, $state)
  let $state := p:parse-LogicalANDExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalANDExpression", $count, $begin, $end)
};

(:~
 : Try parsing LogicalANDExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalANDExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-BitwiseORExpression($input, $state)
  let $state := p:try-LogicalANDExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production LogicalORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 85) then                           (: '||' :)
      $state
    else
      let $state := p:shift(85, $input, $state)             (: '||' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LogicalANDExpression($input, $state)
      return p:parse-LogicalORExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production LogicalORExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 85) then                           (: '||' :)
      $state
    else
      let $state := p:shiftT(85, $input, $state)            (: '||' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-LogicalANDExpression($input, $state)
      return p:try-LogicalORExpression-1($input, $state)
};

(:~
 : Parse LogicalORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LogicalORExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalANDExpression($input, $state)
  let $state := p:parse-LogicalORExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LogicalORExpression", $count, $begin, $end)
};

(:~
 : Try parsing LogicalORExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LogicalORExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalANDExpression($input, $state)
  let $state := p:try-LogicalORExpression-1($input, $state)
  return $state
};

(:~
 : Parse ConditionalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-LogicalORExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: '?' :)
      let $state := p:shift(49, $input, $state)             (: '?' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      let $state := p:shift(34, $input, $state)             (: ':' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConditionalExpression", $count, $begin, $end)
};

(:~
 : Try parsing ConditionalExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ConditionalExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-LogicalORExpression($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: '?' :)
      let $state := p:shiftT(49, $input, $state)            (: '?' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      let $state := p:shiftT(34, $input, $state)            (: ':' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse AssignmentOperator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AssignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 40) then                            (: '=' :)
      let $state := p:shift(40, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*=' :)
      let $state := p:shift(23, $input, $state)             (: '*=' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: '/=' :)
      let $state := p:shift(33, $input, $state)             (: '/=' :)
      return $state
    else if ($state[$p:l1] = 16) then                       (: '%=' :)
      let $state := p:shift(16, $input, $state)             (: '%=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '+=' :)
      let $state := p:shift(26, $input, $state)             (: '+=' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '-=' :)
      let $state := p:shift(30, $input, $state)             (: '-=' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '<<=' :)
      let $state := p:shift(38, $input, $state)             (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: '>>=' :)
      let $state := p:shift(46, $input, $state)             (: '>>=' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: '>>>=' :)
      let $state := p:shift(48, $input, $state)             (: '>>>=' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '&=' :)
      let $state := p:shift(19, $input, $state)             (: '&=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '^=' :)
      let $state := p:shift(53, $input, $state)             (: '^=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(84, $input, $state)             (: '|=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentOperator", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentOperator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AssignmentOperator($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 40) then                            (: '=' :)
      let $state := p:shiftT(40, $input, $state)            (: '=' :)
      return $state
    else if ($state[$p:l1] = 23) then                       (: '*=' :)
      let $state := p:shiftT(23, $input, $state)            (: '*=' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: '/=' :)
      let $state := p:shiftT(33, $input, $state)            (: '/=' :)
      return $state
    else if ($state[$p:l1] = 16) then                       (: '%=' :)
      let $state := p:shiftT(16, $input, $state)            (: '%=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '+=' :)
      let $state := p:shiftT(26, $input, $state)            (: '+=' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '-=' :)
      let $state := p:shiftT(30, $input, $state)            (: '-=' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '<<=' :)
      let $state := p:shiftT(38, $input, $state)            (: '<<=' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: '>>=' :)
      let $state := p:shiftT(46, $input, $state)            (: '>>=' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: '>>>=' :)
      let $state := p:shiftT(48, $input, $state)            (: '>>>=' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '&=' :)
      let $state := p:shiftT(19, $input, $state)            (: '&=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '^=' :)
      let $state := p:shiftT(53, $input, $state)            (: '^=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(84, $input, $state)            (: '|=' :)
      return $state
  return $state
};

(:~
 : Parse NewExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NewExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'new' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-MemberExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 6)
            else
              p:memoize($backtrack, $state, -2, 6)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -2) then
      let $state := p:shift(70, $input, $state)             (: 'new' :)
      let $state := p:lookahead1W(19, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '(' | '[' | 'function' | 'new' | 'this' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NewExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MemberExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NewExpression", $count, $begin, $end)
};

(:~
 : Try parsing NewExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NewExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'new' :)
      let $state := p:memoized($state, 6)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-MemberExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 6)
            else
              p:memoize($backtrack, $state, -2, 6)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -2) then
      let $state := p:shiftT(70, $input, $state)            (: 'new' :)
      let $state := p:lookahead1W(19, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '(' | '[' | 'function' | 'new' | 'this' | '{' :)
      let $state := p:try-NewExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-MemberExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Arguments (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Arguments-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shift(27, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return p:parse-Arguments-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Arguments (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Arguments-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(27, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return p:try-Arguments-1($input, $state)
};

(:~
 : Parse Arguments.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Arguments($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(21, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 21) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      let $state := p:parse-Arguments-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Arguments", $count, $begin, $end)
};

(:~
 : Try parsing Arguments.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Arguments($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(21, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | ')' | '+' | '++' | '-' | '--' |
                                                               '[' | 'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 21) then                      (: ')' :)
      let $state := p:try-AssignmentExpression($input, $state)
      let $state := p:try-Arguments-1($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  return $state
};

(:~
 : Parse FunctionExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(65, $input, $state)                 (: 'function' :)
  let $state := p:lookahead1W(9, $input, $state)            (: Identifier | WhiteSpace | Comment | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:shift(2, $input, $state)              (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(10, $input, $state)           (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:shift(82, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(26, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $state := p:shift(86, $input, $state)                 (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionExpression", $count, $begin, $end)
};

(:~
 : Try parsing FunctionExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(65, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(9, $input, $state)            (: Identifier | WhiteSpace | Comment | '(' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:shiftT(2, $input, $state)             (: Identifier :)
      return $state
    else
      $state
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(10, $input, $state)           (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:try-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:shiftT(82, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(26, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-FunctionBody($input, $state)
  let $state := p:shiftT(86, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production Expression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shift(27, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return p:parse-Expression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Expression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(27, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return p:try-Expression-1($input, $state)
};

(:~
 : Parse Expression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AssignmentExpression($input, $state)
  let $state := p:parse-Expression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expression", $count, $begin, $end)
};

(:~
 : Try parsing Expression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Expression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-AssignmentExpression($input, $state)
  let $state := p:try-Expression-1($input, $state)
  return $state
};

(:~
 : Parse PropertySetParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PropertySetParameterList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PropertySetParameterList", $count, $begin, $end)
};

(:~
 : Try parsing PropertySetParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PropertySetParameterList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  return $state
};

(:~
 : Parse PropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 5) then                             (: IdentifierName :)
      let $state := p:shift(5, $input, $state)              (: IdentifierName :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PropertyName", $count, $begin, $end)
};

(:~
 : Try parsing PropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PropertyName($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 5) then                             (: IdentifierName :)
      let $state := p:shiftT(5, $input, $state)             (: IdentifierName :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: StringLiteral :)
      let $state := p:shiftT(6, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse PropertyAssignment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PropertyAssignment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 66) then                            (: 'get' :)
      let $state := p:shift(66, $input, $state)             (: 'get' :)
      let $state := p:lookahead1W(15, $input, $state)       (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertyName($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(3, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(7, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:shift(82, $input, $state)             (: '{' :)
      let $state := p:lookahead1W(26, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      let $state := p:shift(86, $input, $state)             (: '}' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'set' :)
      let $state := p:shift(72, $input, $state)             (: 'set' :)
      let $state := p:lookahead1W(15, $input, $state)       (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertyName($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertySetParameterList($input, $state)
      let $state := p:lookahead1W(3, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      let $state := p:lookahead1W(7, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:shift(82, $input, $state)             (: '{' :)
      let $state := p:lookahead1W(26, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      let $state := p:shift(86, $input, $state)             (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PropertyName($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: WhiteSpace | Comment | ':' :)
      let $state := p:shift(34, $input, $state)             (: ':' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PropertyAssignment", $count, $begin, $end)
};

(:~
 : Try parsing PropertyAssignment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PropertyAssignment($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 66) then                            (: 'get' :)
      let $state := p:shiftT(66, $input, $state)            (: 'get' :)
      let $state := p:lookahead1W(15, $input, $state)       (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment :)
      let $state := p:try-PropertyName($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(3, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(7, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:shiftT(82, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(26, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:try-FunctionBody($input, $state)
      let $state := p:shiftT(86, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'set' :)
      let $state := p:shiftT(72, $input, $state)            (: 'set' :)
      let $state := p:lookahead1W(15, $input, $state)       (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment :)
      let $state := p:try-PropertyName($input, $state)
      let $state := p:lookahead1W(2, $input, $state)        (: WhiteSpace | Comment | '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-PropertySetParameterList($input, $state)
      let $state := p:lookahead1W(3, $input, $state)        (: WhiteSpace | Comment | ')' :)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      let $state := p:lookahead1W(7, $input, $state)        (: WhiteSpace | Comment | '{' :)
      let $state := p:shiftT(82, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(26, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
      let $state := p:try-FunctionBody($input, $state)
      let $state := p:shiftT(86, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PropertyName($input, $state)
      let $state := p:lookahead1W(4, $input, $state)        (: WhiteSpace | Comment | ':' :)
      let $state := p:shiftT(34, $input, $state)            (: ':' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production ObjectLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ObjectLiteral-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: WhiteSpace | Comment | ',' | '}' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 27) then                     (: ',' :)
        let $state := p:memoized($state, 8)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:shiftT(27, $input, $state)      (: ',' :)
            let $state := p:lookahead1W(17, $input, $state) (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment | 'get' | 'set' :)
            let $state := p:try-PropertyAssignment($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 8)
              else
                p:memoize($backtrack, $state, -2, 8)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:shift(27, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment | 'get' | 'set' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-PropertyAssignment($input, $state)
        return p:parse-ObjectLiteral-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ObjectLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ObjectLiteral-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(12, $input, $state)         (: WhiteSpace | Comment | ',' | '}' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 27) then                     (: ',' :)
        let $state := p:memoized($state, 8)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state := p:shiftT(27, $input, $state)      (: ',' :)
            let $state := p:lookahead1W(17, $input, $state) (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment | 'get' | 'set' :)
            let $state := p:try-PropertyAssignment($input, $state)
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 8)
              else
                p:memoize($backtrack, $state, -2, 8)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1) then
        $state
      else
        let $state := p:shiftT(27, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment | 'get' | 'set' :)
        let $state := p:try-PropertyAssignment($input, $state)
        return p:try-ObjectLiteral-1($input, $state)
};

(:~
 : Parse ObjectLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ObjectLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(82, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment | 'get' |
                                                               'set' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 86) then                      (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PropertyAssignment($input, $state)
      let $state := p:parse-ObjectLiteral-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 27) then                   (: ',' :)
          let $state := p:shift(27, $input, $state)         (: ',' :)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: WhiteSpace | Comment | '}' :)
  let $state := p:shift(86, $input, $state)                 (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ObjectLiteral", $count, $begin, $end)
};

(:~
 : Try parsing ObjectLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ObjectLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(82, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IdentifierName | StringLiteral | DecimalLiteral |
                                                               HexIntegerLiteral | WhiteSpace | Comment | 'get' |
                                                               'set' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 86) then                      (: '}' :)
      let $state := p:try-PropertyAssignment($input, $state)
      let $state := p:try-ObjectLiteral-1($input, $state)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 27) then                   (: ',' :)
          let $state := p:shiftT(27, $input, $state)        (: ',' :)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(8, $input, $state)            (: WhiteSpace | Comment | '}' :)
  let $state := p:shiftT(86, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse the 1st loop of production ArrayLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayLiteral-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shift(27, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | ',' | '-' | '--' |
                                                               '[' | ']' | 'delete' | 'function' | 'new' | 'this' |
                                                               'typeof' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 27                        (: ',' :)
             and $state[$p:l1] != 51) then                  (: ']' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-AssignmentExpression($input, $state)
          return $state
        else
          $state
      return p:parse-ArrayLiteral-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production ArrayLiteral (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArrayLiteral-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(27, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | ',' | '-' | '--' |
                                                               '[' | ']' | 'delete' | 'function' | 'new' | 'this' |
                                                               'typeof' | 'void' | '{' | '~' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 27                        (: ',' :)
             and $state[$p:l1] != 51) then                  (: ']' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return $state
        else
          $state
      return p:try-ArrayLiteral-1($input, $state)
};

(:~
 : Parse ArrayLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(50, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(23, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | ',' | '-' | '--' |
                                                               '[' | ']' | 'delete' | 'function' | 'new' | 'this' |
                                                               'typeof' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 27                            (: ',' :)
         and $state[$p:l1] != 51) then                      (: ']' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
    else
      $state
  let $state := p:parse-ArrayLiteral-1($input, $state)
  let $state := p:shift(51, $input, $state)                 (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayLiteral", $count, $begin, $end)
};

(:~
 : Try parsing ArrayLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-ArrayLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(50, $input, $state)                (: '[' :)
  let $state := p:lookahead1W(23, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | ',' | '-' | '--' |
                                                               '[' | ']' | 'delete' | 'function' | 'new' | 'this' |
                                                               'typeof' | 'void' | '{' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 27                            (: ',' :)
         and $state[$p:l1] != 51) then                      (: ']' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
    else
      $state
  let $state := p:try-ArrayLiteral-1($input, $state)
  let $state := p:shiftT(51, $input, $state)                (: ']' :)
  return $state
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 8) then                             (: DecimalLiteral :)
      let $state := p:shift(8, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(9, $input, $state)              (: HexIntegerLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Try parsing NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 8) then                             (: DecimalLiteral :)
      let $state := p:shiftT(8, $input, $state)             (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shiftT(9, $input, $state)             (: HexIntegerLiteral :)
      return $state
  return $state
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 3) then                             (: NullLiteral :)
      let $state := p:shift(3, $input, $state)              (: NullLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: BooleanLiteral :)
      let $state := p:shift(4, $input, $state)              (: BooleanLiteral :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: RegularExpressionLiteral :)
      let $state := p:shift(7, $input, $state)              (: RegularExpressionLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Try parsing Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Literal($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 3) then                             (: NullLiteral :)
      let $state := p:shiftT(3, $input, $state)             (: NullLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: BooleanLiteral :)
      let $state := p:shiftT(4, $input, $state)             (: BooleanLiteral :)
      return $state
    else if ($state[$p:l1] = 6) then                        (: StringLiteral :)
      let $state := p:shiftT(6, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: RegularExpressionLiteral :)
      let $state := p:shiftT(7, $input, $state)             (: RegularExpressionLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NumericLiteral($input, $state)
      return $state
  return $state
};

(:~
 : Parse PrimaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 74) then                            (: 'this' :)
      let $state := p:shift(74, $input, $state)             (: 'this' :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:shift(2, $input, $state)              (: Identifier :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '[' :)
      let $state := p:parse-ArrayLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: '{' :)
      let $state := p:parse-ObjectLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 20) then                       (: '(' :)
      let $state := p:shift(20, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expression($input, $state)
      let $state := p:shift(21, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Literal($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpression", $count, $begin, $end)
};

(:~
 : Try parsing PrimaryExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-PrimaryExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 74) then                            (: 'this' :)
      let $state := p:shiftT(74, $input, $state)            (: 'this' :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:shiftT(2, $input, $state)             (: Identifier :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '[' :)
      let $state := p:try-ArrayLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: '{' :)
      let $state := p:try-ObjectLiteral($input, $state)
      return $state
    else if ($state[$p:l1] = 20) then                       (: '(' :)
      let $state := p:shiftT(20, $input, $state)            (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-Expression($input, $state)
      let $state := p:shiftT(21, $input, $state)            (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Literal($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production MemberExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MemberExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '!=' | '!==' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'in' | 'instanceof' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '|' | '|=' | '||' | '}' | '~' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 50) then                     (: '[' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:l1] = 50) then                  (: '[' :)
                let $state := p:shiftT(50, $input, $state)  (: '[' :)
                let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                   StringLiteral | RegularExpressionLiteral |
                                                                   DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                   Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                                   'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                                   'void' | '{' | '~' :)
                let $state := p:try-Expression($input, $state)
                let $state := p:shiftT(51, $input, $state)  (: ']' :)
                return $state
              else if ($state[$p:error]) then
                $state
              else
                let $state := p:shiftT(31, $input, $state)  (: '.' :)
                let $state := p:lookahead1W(1, $input, $state) (: IdentifierName | WhiteSpace | Comment :)
                let $state := p:shiftT(5, $input, $state)   (: IdentifierName :)
                return $state
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 7)
              else
                p:memoize($backtrack, $state, -2, 7)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 31) then                         (: '.' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 50) then                      (: '[' :)
            let $state := p:shift(50, $input, $state)       (: '[' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Expression($input, $state)
            let $state := p:shift(51, $input, $state)       (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(31, $input, $state)       (: '.' :)
            let $state := p:lookahead1W(1, $input, $state)  (: IdentifierName | WhiteSpace | Comment :)
            let $state := p:shift(5, $input, $state)        (: IdentifierName :)
            return $state
        return p:parse-MemberExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production MemberExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MemberExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '!=' | '!==' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'in' | 'instanceof' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '|' | '|=' | '||' | '}' | '~' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 50) then                     (: '[' :)
        let $state := p:memoized($state, 7)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:l1] = 50) then                  (: '[' :)
                let $state := p:shiftT(50, $input, $state)  (: '[' :)
                let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                   StringLiteral | RegularExpressionLiteral |
                                                                   DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                   Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                                   'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                                   'void' | '{' | '~' :)
                let $state := p:try-Expression($input, $state)
                let $state := p:shiftT(51, $input, $state)  (: ']' :)
                return $state
              else if ($state[$p:error]) then
                $state
              else
                let $state := p:shiftT(31, $input, $state)  (: '.' :)
                let $state := p:lookahead1W(1, $input, $state) (: IdentifierName | WhiteSpace | Comment :)
                let $state := p:shiftT(5, $input, $state)   (: IdentifierName :)
                return $state
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 7)
              else
                p:memoize($backtrack, $state, -2, 7)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 31) then                         (: '.' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 50) then                      (: '[' :)
            let $state := p:shiftT(50, $input, $state)      (: '[' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-Expression($input, $state)
            let $state := p:shiftT(51, $input, $state)      (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(31, $input, $state)      (: '.' :)
            let $state := p:lookahead1W(1, $input, $state)  (: IdentifierName | WhiteSpace | Comment :)
            let $state := p:shiftT(5, $input, $state)       (: IdentifierName :)
            return $state
        return p:try-MemberExpression-1($input, $state)
};

(:~
 : Parse MemberExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MemberExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = 65) then                            (: 'function' :)
      let $state := p:parse-FunctionExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'new' :)
      let $state := p:shift(70, $input, $state)             (: 'new' :)
      let $state := p:lookahead1W(19, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '(' | '[' | 'function' | 'new' | 'this' | '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MemberExpression($input, $state)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Arguments($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PrimaryExpression($input, $state)
      return $state
  let $state := p:parse-MemberExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MemberExpression", $count, $begin, $end)
};

(:~
 : Try parsing MemberExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-MemberExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:l1] = 65) then                            (: 'function' :)
      let $state := p:try-FunctionExpression($input, $state)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'new' :)
      let $state := p:shiftT(70, $input, $state)            (: 'new' :)
      let $state := p:lookahead1W(19, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '(' | '[' | 'function' | 'new' | 'this' | '{' :)
      let $state := p:try-MemberExpression($input, $state)
      let $state := p:try-Arguments($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-PrimaryExpression($input, $state)
      return $state
  let $state := p:try-MemberExpression-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production CallExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CallExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '!=' | '!==' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'in' | 'instanceof' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '|' | '|=' | '||' | '}' | '~' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 20                           (: '(' :)
            or $state[$p:l1] = 50) then                     (: '[' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:l1] = 20) then                  (: '(' :)
                let $state := p:try-Arguments($input, $state)
                return $state
              else if ($state[$p:l1] = 50) then             (: '[' :)
                let $state := p:shiftT(50, $input, $state)  (: '[' :)
                let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                   StringLiteral | RegularExpressionLiteral |
                                                                   DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                   Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                                   'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                                   'void' | '{' | '~' :)
                let $state := p:try-Expression($input, $state)
                let $state := p:shiftT(51, $input, $state)  (: ']' :)
                return $state
              else if ($state[$p:error]) then
                $state
              else
                let $state := p:shiftT(31, $input, $state)  (: '.' :)
                let $state := p:lookahead1W(1, $input, $state) (: IdentifierName | WhiteSpace | Comment :)
                let $state := p:shiftT(5, $input, $state)   (: IdentifierName :)
                return $state
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 9)
              else
                p:memoize($backtrack, $state, -2, 9)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 31) then                         (: '.' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 20) then                      (: '(' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Arguments($input, $state)
            return $state
          else if ($state[$p:l1] = 50) then                 (: '[' :)
            let $state := p:shift(50, $input, $state)       (: '[' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Expression($input, $state)
            let $state := p:shift(51, $input, $state)       (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(31, $input, $state)       (: '.' :)
            let $state := p:lookahead1W(1, $input, $state)  (: IdentifierName | WhiteSpace | Comment :)
            let $state := p:shift(5, $input, $state)        (: IdentifierName :)
            return $state
        return p:parse-CallExpression-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production CallExpression (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CallExpression-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '!=' | '!==' | '%' | '%=' | '&' | '&&' |
                                                               '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' |
                                                               '-' | '--' | '-=' | '.' | '/' | '/=' | ':' | ';' | '<' |
                                                               '<<' | '<<=' | '<=' | '=' | '==' | '===' | '>' | '>=' |
                                                               '>>' | '>>=' | '>>>' | '>>>=' | '?' | '[' | ']' | '^' |
                                                               '^=' | 'break' | 'case' | 'continue' | 'debugger' |
                                                               'default' | 'delete' | 'do' | 'else' | 'for' |
                                                               'function' | 'if' | 'in' | 'instanceof' | 'new' |
                                                               'return' | 'switch' | 'this' | 'throw' | 'try' |
                                                               'typeof' | 'var' | 'void' | 'while' | 'with' | '{' |
                                                               '|' | '|=' | '||' | '}' | '~' :)
    let $state :=
      if ($state[$p:error]) then
        $state
      else if ($state[$p:l1] = 20                           (: '(' :)
            or $state[$p:l1] = 50) then                     (: '[' :)
        let $state := p:memoized($state, 9)
        return
          if ($state[$p:lk] != 0) then
            $state
          else
            let $backtrack := $state
            let $state := p:strip-result($state)
            let $state :=
              if ($state[$p:l1] = 20) then                  (: '(' :)
                let $state := p:try-Arguments($input, $state)
                return $state
              else if ($state[$p:l1] = 50) then             (: '[' :)
                let $state := p:shiftT(50, $input, $state)  (: '[' :)
                let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                                   StringLiteral | RegularExpressionLiteral |
                                                                   DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                                   Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                                   'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                                   'void' | '{' | '~' :)
                let $state := p:try-Expression($input, $state)
                let $state := p:shiftT(51, $input, $state)  (: ']' :)
                return $state
              else if ($state[$p:error]) then
                $state
              else
                let $state := p:shiftT(31, $input, $state)  (: '.' :)
                let $state := p:lookahead1W(1, $input, $state) (: IdentifierName | WhiteSpace | Comment :)
                let $state := p:shiftT(5, $input, $state)   (: IdentifierName :)
                return $state
            return
              if (not($state[$p:error])) then
                p:memoize($backtrack, $state, -1, 9)
              else
                p:memoize($backtrack, $state, -2, 9)
      else
        ($state[$p:l1], subsequence($state, 2))
    return
      if ($state[$p:lk] != -1
      and $state[$p:lk] != 31) then                         (: '.' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 20) then                      (: '(' :)
            let $state := p:try-Arguments($input, $state)
            return $state
          else if ($state[$p:l1] = 50) then                 (: '[' :)
            let $state := p:shiftT(50, $input, $state)      (: '[' :)
            let $state := p:lookahead1W(20, $input, $state) (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
            let $state := p:try-Expression($input, $state)
            let $state := p:shiftT(51, $input, $state)      (: ']' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shiftT(31, $input, $state)      (: '.' :)
            let $state := p:lookahead1W(1, $input, $state)  (: IdentifierName | WhiteSpace | Comment :)
            let $state := p:shiftT(5, $input, $state)       (: IdentifierName :)
            return $state
        return p:try-CallExpression-1($input, $state)
};

(:~
 : Parse CallExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CallExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MemberExpression($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Arguments($input, $state)
  let $state := p:parse-CallExpression-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CallExpression", $count, $begin, $end)
};

(:~
 : Try parsing CallExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-CallExpression($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-MemberExpression($input, $state)
  let $state := p:try-Arguments($input, $state)
  let $state := p:try-CallExpression-1($input, $state)
  return $state
};

(:~
 : Parse LeftHandSideExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LeftHandSideExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    let $state := p:memoized($state, 5)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state := p:try-CallExpression($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, -1, 5)
          else
            p:memoize($backtrack, $state, -2, 5)
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:parse-CallExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NewExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "LeftHandSideExpression", $count, $begin, $end)
};

(:~
 : Try parsing LeftHandSideExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-LeftHandSideExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    let $state := p:memoized($state, 5)
    return
      if ($state[$p:lk] != 0) then
        $state
      else
        let $backtrack := $state
        let $state := p:strip-result($state)
        let $state := p:try-CallExpression($input, $state)
        return
          if (not($state[$p:error])) then
            p:memoize($backtrack, $state, -1, 5)
          else
            p:memoize($backtrack, $state, -2, 5)
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:try-CallExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-NewExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse AssignmentExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AssignmentExpression($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 12                            (: '!' :)
         and $state[$p:l1] != 24                            (: '+' :)
         and $state[$p:l1] != 25                            (: '++' :)
         and $state[$p:l1] != 28                            (: '-' :)
         and $state[$p:l1] != 29                            (: '--' :)
         and $state[$p:l1] != 60                            (: 'delete' :)
         and $state[$p:l1] != 77                            (: 'typeof' :)
         and $state[$p:l1] != 79                            (: 'void' :)
         and $state[$p:l1] != 87) then                      (: '~' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(20, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 2)
            else
              p:memoize($backtrack, $state, -2, 2)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:parse-LeftHandSideExpression($input, $state)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AssignmentExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ConditionalExpression($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AssignmentExpression", $count, $begin, $end)
};

(:~
 : Try parsing AssignmentExpression.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-AssignmentExpression($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 12                            (: '!' :)
         and $state[$p:l1] != 24                            (: '+' :)
         and $state[$p:l1] != 25                            (: '++' :)
         and $state[$p:l1] != 28                            (: '-' :)
         and $state[$p:l1] != 29                            (: '--' :)
         and $state[$p:l1] != 60                            (: 'delete' :)
         and $state[$p:l1] != 77                            (: 'typeof' :)
         and $state[$p:l1] != 79                            (: 'void' :)
         and $state[$p:l1] != 87) then                      (: '~' :)
      let $state := p:memoized($state, 2)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-LeftHandSideExpression($input, $state)
          let $state := p:try-AssignmentOperator($input, $state)
          let $state := p:lookahead1W(20, $input, $state)   (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
          let $state := p:try-AssignmentExpression($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 2)
            else
              p:memoize($backtrack, $state, -2, 2)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:try-LeftHandSideExpression($input, $state)
      let $state := p:try-AssignmentOperator($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
      let $state := p:try-AssignmentExpression($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ConditionalExpression($input, $state)
      return $state
  return $state
};

(:~
 : Parse Initialiser.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Initialiser($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(40, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AssignmentExpression($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Initialiser", $count, $begin, $end)
};

(:~
 : Try parsing Initialiser.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Initialiser($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(40, $input, $state)                (: '=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | '[' |
                                                               'delete' | 'function' | 'new' | 'this' | 'typeof' |
                                                               'void' | '{' | '~' :)
  let $state := p:try-AssignmentExpression($input, $state)
  return $state
};

(:~
 : Parse VariableDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $state := p:lookahead1W(31, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | ',' | '-' | '--' |
                                                               ';' | '=' | '[' | 'break' | 'case' | 'continue' |
                                                               'debugger' | 'default' | 'delete' | 'do' | 'else' |
                                                               'for' | 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '=' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Initialiser($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  let $state := p:lookahead1W(31, $input, $state)           (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | ',' | '-' | '--' |
                                                               ';' | '=' | '[' | 'break' | 'case' | 'continue' |
                                                               'debugger' | 'default' | 'delete' | 'do' | 'else' |
                                                               'for' | 'function' | 'if' | 'new' | 'return' | 'switch' |
                                                               'this' | 'throw' | 'try' | 'typeof' | 'var' | 'void' |
                                                               'while' | 'with' | '{' | '}' | '~' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 40) then                       (: '=' :)
      let $state := p:try-Initialiser($input, $state)
      return $state
    else
      $state
  return $state
};

(:~
 : Parse the 1st loop of production VariableDeclarationList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shift(27, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VariableDeclaration($input, $state)
      return p:parse-VariableDeclarationList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production VariableDeclarationList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 27) then                           (: ',' :)
      $state
    else
      let $state := p:shiftT(27, $input, $state)            (: ',' :)
      let $state := p:lookahead1W(0, $input, $state)        (: Identifier | WhiteSpace | Comment :)
      let $state := p:try-VariableDeclaration($input, $state)
      return p:try-VariableDeclarationList-1($input, $state)
};

(:~
 : Parse VariableDeclarationList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableDeclarationList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-VariableDeclaration($input, $state)
  let $state := p:parse-VariableDeclarationList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableDeclarationList", $count, $begin, $end)
};

(:~
 : Try parsing VariableDeclarationList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableDeclarationList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-VariableDeclaration($input, $state)
  let $state := p:try-VariableDeclarationList-1($input, $state)
  return $state
};

(:~
 : Parse VariableStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VariableStatement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(78, $input, $state)                 (: 'var' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VariableDeclarationList($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Semicolon($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VariableStatement", $count, $begin, $end)
};

(:~
 : Try parsing VariableStatement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-VariableStatement($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(78, $input, $state)                (: 'var' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:try-VariableDeclarationList($input, $state)
  let $state := p:try-Semicolon($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production Block (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Block-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(26, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Statement($input, $state)
        return p:parse-Block-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production Block (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Block-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(26, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:try-Statement($input, $state)
        return p:try-Block-1($input, $state)
};

(:~
 : Parse Block.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Block($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(82, $input, $state)                 (: '{' :)
  let $state := p:parse-Block-1($input, $state)
  let $state := p:shift(86, $input, $state)                 (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Block", $count, $begin, $end)
};

(:~
 : Try parsing Block.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Block($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(82, $input, $state)                (: '{' :)
  let $state := p:try-Block-1($input, $state)
  let $state := p:shiftT(86, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse Statement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Statement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2                              (: Identifier :)
          or $state[$p:l1] = 82) then                       (: '{' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-Block($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 1)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:try-ExpressionStatement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -4, 1)
                else
                  p:memoize($backtrack, $state, -11, 1)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:parse-Block($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'var' :)
      let $state := p:parse-VariableStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 35) then                       (: ';' :)
      let $state := p:parse-EmptyStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'if' :)
      let $state := p:parse-IfStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 61                             (: 'do' :)
          or $state[$p:l1] = 64                             (: 'for' :)
          or $state[$p:l1] = 80) then                       (: 'while' :)
      let $state := p:parse-IterationStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'continue' :)
      let $state := p:parse-ContinueStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'break' :)
      let $state := p:parse-BreakStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'return' :)
      let $state := p:parse-ReturnStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-WithStatement($input, $state)
      return $state
    else if ($state[$p:lk] = -11) then
      let $state := p:parse-LabelledStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'switch' :)
      let $state := p:parse-SwitchStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'throw' :)
      let $state := p:parse-ThrowStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'try' :)
      let $state := p:parse-TryStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 58) then                       (: 'debugger' :)
      let $state := p:parse-DebuggerStatement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExpressionStatement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Statement", $count, $begin, $end)
};

(:~
 : Try parsing Statement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Statement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2                              (: Identifier :)
          or $state[$p:l1] = 82) then                       (: '{' :)
      let $state := p:memoized($state, 1)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-Block($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 1)
            else
              let $state := p:restore($backtrack, $state)
              let $state := p:try-ExpressionStatement($input, $state)
              return
                if (not($state[$p:error])) then
                  p:memoize($backtrack, $state, -4, 1)
                else
                  p:memoize($backtrack, $state, -11, 1)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:try-Block($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'var' :)
      let $state := p:try-VariableStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 35) then                       (: ';' :)
      let $state := p:try-EmptyStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'if' :)
      let $state := p:try-IfStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 61                             (: 'do' :)
          or $state[$p:l1] = 64                             (: 'for' :)
          or $state[$p:l1] = 80) then                       (: 'while' :)
      let $state := p:try-IterationStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'continue' :)
      let $state := p:try-ContinueStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'break' :)
      let $state := p:try-BreakStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'return' :)
      let $state := p:try-ReturnStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:try-WithStatement($input, $state)
      return $state
    else if ($state[$p:lk] = -11) then
      let $state := p:try-LabelledStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'switch' :)
      let $state := p:try-SwitchStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'throw' :)
      let $state := p:try-ThrowStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'try' :)
      let $state := p:try-TryStatement($input, $state)
      return $state
    else if ($state[$p:l1] = 58) then                       (: 'debugger' :)
      let $state := p:try-DebuggerStatement($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-ExpressionStatement($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production FunctionBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(26, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SourceElement($input, $state)
        return p:parse-FunctionBody-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FunctionBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(26, $input, $state)         (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
    return
      if ($state[$p:l1] = 86) then                          (: '}' :)
        $state
      else
        let $state := p:try-SourceElement($input, $state)
        return p:try-FunctionBody-1($input, $state)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionBody-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Try parsing FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $state := p:try-FunctionBody-1($input, $state)
  return $state
};

(:~
 : Parse the 1st loop of production FormalParameterList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FormalParameterList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(11, $input, $state)         (: WhiteSpace | Comment | ')' | ',' :)
    return
      if ($state[$p:l1] != 27) then                         (: ',' :)
        $state
      else
        let $state := p:shift(27, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WhiteSpace | Comment :)
        let $state := p:shift(2, $input, $state)            (: Identifier :)
        return p:parse-FormalParameterList-1($input, $state)
};

(:~
 : Try parsing the 1st loop of production FormalParameterList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FormalParameterList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(11, $input, $state)         (: WhiteSpace | Comment | ')' | ',' :)
    return
      if ($state[$p:l1] != 27) then                         (: ',' :)
        $state
      else
        let $state := p:shiftT(27, $input, $state)          (: ',' :)
        let $state := p:lookahead1W(0, $input, $state)      (: Identifier | WhiteSpace | Comment :)
        let $state := p:shiftT(2, $input, $state)           (: Identifier :)
        return p:try-FormalParameterList-1($input, $state)
};

(:~
 : Parse FormalParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FormalParameterList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $state := p:parse-FormalParameterList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FormalParameterList", $count, $begin, $end)
};

(:~
 : Try parsing FormalParameterList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FormalParameterList($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  let $state := p:try-FormalParameterList-1($input, $state)
  return $state
};

(:~
 : Parse FunctionDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(65, $input, $state)                 (: 'function' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:shift(2, $input, $state)                  (: Identifier :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shift(20, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(10, $input, $state)           (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(21, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:shift(82, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(26, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $state := p:shift(86, $input, $state)                 (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDeclaration", $count, $begin, $end)
};

(:~
 : Try parsing FunctionDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-FunctionDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(65, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(0, $input, $state)            (: Identifier | WhiteSpace | Comment :)
  let $state := p:shiftT(2, $input, $state)                 (: Identifier :)
  let $state := p:lookahead1W(2, $input, $state)            (: WhiteSpace | Comment | '(' :)
  let $state := p:shiftT(20, $input, $state)                (: '(' :)
  let $state := p:lookahead1W(10, $input, $state)           (: Identifier | WhiteSpace | Comment | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 2) then                        (: Identifier :)
      let $state := p:try-FormalParameterList($input, $state)
      return $state
    else
      $state
  let $state := p:shiftT(21, $input, $state)                (: ')' :)
  let $state := p:lookahead1W(7, $input, $state)            (: WhiteSpace | Comment | '{' :)
  let $state := p:shiftT(82, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(26, $input, $state)           (: Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '}' | '~' :)
  let $state := p:try-FunctionBody($input, $state)
  let $state := p:shiftT(86, $input, $state)                (: '}' :)
  return $state
};

(:~
 : Parse SourceElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SourceElement($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'function' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-FunctionDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:parse-FunctionDeclaration($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Statement($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SourceElement", $count, $begin, $end)
};

(:~
 : Try parsing SourceElement.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-SourceElement($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: 'function' :)
      let $state := p:memoized($state, 0)
      return
        if ($state[$p:lk] != 0) then
          $state
        else
          let $backtrack := $state
          let $state := p:strip-result($state)
          let $state := p:try-FunctionDeclaration($input, $state)
          return
            if (not($state[$p:error])) then
              p:memoize($backtrack, $state, -1, 0)
            else
              p:memoize($backtrack, $state, -2, 0)
    else
      ($state[$p:l1], subsequence($state, 2))
  let $state :=
    if ($state[$p:lk] = -1) then
      let $state := p:try-FunctionDeclaration($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Statement($input, $state)
      return $state
  return $state
};

(:~
 : Parse the 1st loop of production Program (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Program-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(25, $input, $state)         (: EOF | Identifier | NullLiteral | BooleanLiteral |
                                                               StringLiteral | RegularExpressionLiteral |
                                                               DecimalLiteral | HexIntegerLiteral | WhiteSpace |
                                                               Comment | '!' | '(' | '+' | '++' | '-' | '--' | ';' |
                                                               '[' | 'break' | 'continue' | 'debugger' | 'delete' |
                                                               'do' | 'for' | 'function' | 'if' | 'new' | 'return' |
                                                               'switch' | 'this' | 'throw' | 'try' | 'typeof' | 'var' |
                                                               'void' | 'while' | 'with' | '{' | '~' :)
    return
      if ($state[$p:l1] = 1) then                           (: EOF :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SourceElement($input, $state)
        return p:parse-Program-1($input, $state)
};

(:~
 : Parse Program.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Program($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Program-1($input, $state)
  let $state := p:shift(1, $input, $state)                  (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Program", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        if ($error/@e = $begin) then
          ""
        else
          concat("after successfully scanning ", string($error/@e - $begin), " characters "),
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e1 - $p:l1 + 1),
    0,
    $state[$p:e1],
    subsequence($state, $p:e1),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:shift, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shiftT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e1 - $p:l1 + 1),
    0,
    $state[$p:e1],
    subsequence($state, $p:e1)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      if ($state[$p:e1] < $state[$p:memo]/@e) then
        $state[$p:memo]/@*
      else
      (
        attribute b {$state[$p:b1]},
        attribute e {$state[$p:e1]},
        if ($state[$p:l1] < 0) then
          attribute s {- $state[$p:l1]}
        else
          (attribute o {$state[$p:l1]}, attribute x {$code})
      )
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $begin,
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 10                                      (: WhiteSpace :)
     or $match[1] = 11) then                                (: Comment :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      subsequence($state, $p:e1 + 1)
    )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      subsequence($state, $p:e1 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Strip result from parser state, in order to avoid carrying it while
 : backtracking.
 :
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:strip-result($state as item()+) as item()+
{
  subsequence($state, 1, $p:memo)
};

(:~
 : Restore parser state after unsuccessfully trying an alternative,
 : merging any memoization that was collected on the way.
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after an alternative failed.
 : @return the updated parser state.
 :)
declare function p:restore($backtrack as item()+,
                           $state as item()+) as item()+
{
  subsequence($backtrack, 1, $p:memo - 1),
  element memo{$state[$p:error]/@*, $state[$p:memo]/value}
};

(:~
 : Memoize the backtracking result that was computed at decision point
 : $i for input position $state[$p:e0].
 :
 : @param $backtrack the parser state before backtracking started.
 : @param $state the parser state after successfully trying an alternative.
 : @param $v the id of the successful alternative.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoize($backtrack as item()+,
                           $state as item()+,
                           $v as xs:integer,
                           $i as xs:integer) as item()+
{
  $v,
  subsequence($backtrack, $p:lk + 1, $p:memo - $p:lk - 1),
  element memo
  {
    $state[$p:memo]/value,
    element value {attribute key {$backtrack[$p:e0] * 32 + $i}, $v}
  },
  subsequence($backtrack, $p:memo + 1)
};

(:~
 : Retrieve memoized backtracking result for decision point $i
 : and input position $state[$p:e0] into $state[$p:lk].
 :
 : @param $state the parser state.
 : @param $i the decision point id.
 : @return the updated parser state.
 :)
declare function p:memoized($state as item()+, $i as xs:integer) as item()+
{
  let $value := data($state[$p:memo]/value[@key = $state[$p:e0] * 32 + $i])
  return
  (
    if ($value) then $value else 0,
    subsequence($state, $p:lk + 1)
  )
};

(:~
 : Parse start symbol Program from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Program($s as xs:string) as item()*
{
  let $state := p:parse-Program($s, (0, 1, 1, 0, 1, 0, false(), <memo/>))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
