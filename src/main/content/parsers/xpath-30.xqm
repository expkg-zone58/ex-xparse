xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun Sep 27, 2015 13:19 (UTC+01) by REx v5.35 which is Copyright (c) 1979-2015 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: xpath-30.ebnf -xquery -tree -name parser :)

(:~
 : The parser that was generated for the parser grammar.
 :)
module namespace p="parser";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  55, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6,
  7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23,
  24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 25, 23, 23, 23, 23, 23, 23, 23, 23, 23, 26, 6, 27, 6, 23, 6, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 331, 370,
  386, 422, 422, 422, 414, 354, 346, 354, 346, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 439, 439, 439, 439, 439, 439, 439, 315, 354, 354, 354, 354, 354, 354, 354, 354, 400, 422, 422, 423, 421,
  422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 353, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 55, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16,
  16, 16, 16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 6, 23, 23, 25, 23, 23, 23, 23, 23, 23, 23, 23, 23, 26, 6, 27, 6, 23, 23, 23, 23, 23, 23, 23, 6, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 28, 29, 30, 31, 32, 33, 34, 35, 36, 23, 23, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 6, 6, 6, 6, 6,
  6, 6, 54, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
  54, 54
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 6, 23, 6, 23, 23, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 3587, 3584, 3584, 3603, 6229, 5750, 4084, 3891, 3619, 3635, 3662, 3681,
  12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775,
  3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129,
  4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 10594, 10607, 4180, 6229,
  5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748,
  3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069,
  4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 4682, 4196, 6888, 4216, 6229, 5750, 4084, 3891, 4232, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716,
  3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895,
  3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4248, 6229, 4262, 4282, 6229, 5750, 4084, 3891, 3619, 3635,
  3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888,
  3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053,
  4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4298, 6229, 4329,
  4313, 6229, 5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076,
  3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986,
  4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 4682, 6229, 6229, 4282, 6229, 5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684,
  3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917,
  3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 4345, 5610, 4365, 6229, 5750, 4084, 3891,
  4381, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791,
  3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804,
  4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4397,
  4412, 4428, 4443, 6229, 5750, 4084, 3891, 4459, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833,
  3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969,
  3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 4475, 4506, 4518, 4490, 6229, 5750, 4084, 3891, 4534, 3635, 3662, 3681, 12121,
  3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907,
  3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4550, 11786, 11798, 4596, 6229, 5750,
  4084, 3891, 3619, 3635, 3662, 3681, 4031, 3665, 3684, 3700, 3716, 3841, 3857, 4113, 3849, 12076, 3732, 3748, 3764,
  3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081,
  4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 4682, 4618, 4612, 4634, 6229, 5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 4650, 3716, 3841,
  3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862,
  3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 4666, 4678, 4698, 6229, 5750, 4084, 3891, 3619, 3635, 3662,
  3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878,
  3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100,
  4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 4720, 4714, 4736,
  6229, 11373, 8179, 9517, 4752, 6229, 4773, 6735, 11884, 5818, 5818, 10386, 4962, 6735, 6735, 9028, 5818, 8938, 5792,
  6735, 6715, 5818, 5819, 11372, 4791, 7420, 8217, 6441, 7887, 6754, 6439, 11709, 8067, 4809, 4830, 6648, 7750, 7089,
  4852, 4878, 11710, 6048, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 4682, 6229, 9714, 4900, 6229, 11373, 8179, 11420, 4752, 6229, 4773, 6735, 11884, 5818, 5818, 11290,
  4962, 6735, 6735, 9028, 5818, 8938, 5792, 6735, 6715, 5818, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439,
  11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 4998, 4916, 4282, 6229, 11963, 4084, 3891, 3619,
  3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820,
  3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046,
  4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4932, 6229,
  5721, 4978, 6229, 11373, 8179, 10348, 4752, 6229, 4773, 6735, 11884, 5818, 5818, 10696, 4962, 6735, 6735, 9028, 5818,
  4836, 5792, 6735, 6715, 5818, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391,
  5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 10187, 6230, 4994, 5014, 6229, 8967, 5574, 5128, 5030, 3635, 5046, 5075, 5457, 5338,
  5116, 5144, 5160, 5499, 5568, 5059, 5176, 5379, 5205, 5526, 5221, 5251, 5267, 5296, 5425, 5325, 5189, 5354, 5368,
  5395, 5411, 5432, 5100, 5448, 5090, 5235, 5309, 5473, 5488, 8980, 8975, 5280, 5555, 5515, 5542, 5590, 5604, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 4564, 4576, 5626, 5642, 5750, 4084,
  3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747,
  3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078,
  3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  4682, 4946, 4958, 5662, 5678, 5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857,
  3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970,
  3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 6260, 6272, 5699, 5715, 5750, 4084, 3891, 3619, 3635, 3662, 3681,
  12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775,
  3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129,
  4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5737, 4200, 4282, 6229,
  5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748,
  3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069,
  4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 4682, 6229, 10000, 5772, 6229, 5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716,
  3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895,
  3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788, 5808, 8046, 6229, 11373, 8179, 8065, 4752, 6229,
  5835, 6735, 7298, 5818, 5818, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6735, 6715, 5818, 5819, 11372, 6735,
  5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458,
  10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788, 5808,
  8046, 6229, 11373, 8179, 8198, 4752, 6229, 5835, 6735, 7298, 5818, 5818, 9692, 6276, 6735, 6735, 10152, 5818, 8066,
  5792, 6735, 6715, 5818, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815,
  11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 4682, 5788, 5853, 5868, 6229, 11373, 8179, 8065, 4752, 6229, 5835, 6735, 7298, 5818, 5818,
  6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6735, 6715, 5818, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818,
  6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 4580, 5884, 4282, 6229, 5750, 4084, 3891,
  3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791,
  3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804,
  4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682,
  9322, 9334, 5904, 6229, 5750, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833,
  3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969,
  3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 9465, 5920, 5932, 5948, 10611, 5964, 11632, 8380, 4752, 6229, 5835, 6735, 7298,
  5818, 5818, 6341, 8553, 6735, 6735, 6012, 5818, 10565, 11660, 6480, 6715, 6034, 5819, 6064, 9920, 5815, 8677, 6441,
  6084, 7695, 9825, 6824, 11023, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788, 5808, 8046, 6229, 11373,
  8179, 8065, 4752, 6229, 5835, 6735, 7298, 5818, 5818, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6735, 6715,
  5818, 5819, 12024, 6735, 7052, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408,
  6108, 6149, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 4682, 6182, 6195, 6211, 6227, 11373, 7844, 11457, 6246, 6229, 6292, 6735, 7396, 11486, 5818, 6341, 6276, 10059,
  7627, 9802, 9595, 6338, 5792, 6735, 7185, 5818, 6166, 11372, 6735, 5815, 8065, 6357, 6378, 11146, 10745, 6402, 6429,
  6735, 6457, 6475, 5815, 11705, 4883, 6408, 6496, 7725, 4884, 10458, 10462, 9210, 6882, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 6542, 6554, 6570, 11602, 6586, 6610, 6637, 6664, 6690, 6712,
  8918, 7586, 5818, 10099, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6734, 6715, 6752, 5819, 11372, 7518, 5815,
  6770, 6814, 8085, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705, 10409, 7325, 6840, 7725, 4884, 10458, 10462,
  6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 6904, 6916, 6932,
  8157, 3646, 6948, 6964, 7014, 4349, 7038, 7510, 7074, 8666, 7132, 9308, 7162, 10905, 7201, 7238, 7261, 7277, 5792,
  7293, 7314, 7347, 7369, 6998, 6735, 10329, 8065, 7391, 7412, 10841, 9901, 7436, 7464, 7490, 7534, 7581, 7602, 6123,
  7618, 7643, 7684, 6854, 7720, 9659, 7741, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 4682, 5788, 7766, 7781, 6229, 11373, 7797, 7824, 4752, 6229, 5835, 6735, 7298, 5818, 5818, 6341,
  6276, 6735, 11101, 10152, 5818, 11915, 5792, 6735, 6715, 5818, 5819, 7860, 8396, 5815, 7546, 6441, 11707, 5818, 6439,
  11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 7942, 7903, 7928, 6882, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 7969, 7981, 7997, 6229, 11373, 8179, 8065, 4752,
  6229, 5835, 6735, 7298, 5818, 5818, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6735, 6715, 5818, 5819, 11372,
  6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 11214, 8367, 8688, 6386, 11705, 4883, 6408, 11710, 7725, 4884,
  10458, 6621, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788,
  5808, 8626, 6229, 11825, 8586, 8065, 8013, 6229, 5835, 6735, 6307, 5818, 5818, 8038, 6276, 6735, 6735, 10152, 5818,
  8066, 5792, 6735, 6715, 5818, 5819, 11372, 4793, 5815, 6526, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391,
  8062, 8083, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 10813, 8101, 8113, 8129, 10806, 8281, 9498, 8065, 4752, 8145, 8173, 11880, 8485, 8195,
  8214, 8233, 11052, 6735, 6798, 10152, 5818, 8258, 5888, 6735, 8999, 5818, 5819, 11372, 9492, 6092, 8065, 8297, 8655,
  8339, 8412, 10666, 9815, 6735, 5817, 8391, 5815, 11705, 6413, 8435, 11710, 7725, 7331, 8475, 10462, 7146, 6882, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 8501, 8513, 8529, 8545, 8242, 8179,
  8569, 4752, 6229, 8602, 6735, 12036, 9978, 5818, 8618, 6276, 8642, 6735, 10088, 8704, 8066, 5792, 6735, 6715, 5818,
  5819, 11372, 6735, 5815, 8065, 8725, 8754, 5818, 6439, 11709, 9958, 5837, 5817, 8749, 5815, 11705, 4883, 6408, 11710,
  7668, 8770, 8795, 10110, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  4682, 8828, 8840, 8856, 6229, 5996, 8179, 8872, 4752, 6229, 8911, 11323, 7953, 8934, 6517, 8954, 6276, 7177, 8996,
  9631, 11153, 8066, 9015, 9916, 10931, 9050, 7448, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735,
  5817, 8391, 5815, 9071, 11005, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 9099, 9111, 9127, 9143, 9169, 9196, 9240, 4752, 6229, 5835, 9277,
  7298, 10715, 5818, 7375, 6276, 6735, 6735, 10152, 5818, 8066, 10139, 6735, 9294, 5818, 9354, 9370, 9415, 7912, 9444,
  9481, 11707, 9514, 7474, 9533, 9555, 9789, 9581, 7835, 6159, 8447, 9618, 6133, 8323, 9647, 4884, 9083, 9675, 6868,
  9708, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4164, 9730, 9742, 9758, 5683,
  9774, 9841, 9857, 4752, 6229, 5835, 6735, 9886, 5818, 11172, 6341, 9870, 6735, 6735, 7216, 5818, 7058, 5792, 8733,
  6715, 7245, 5819, 11372, 6735, 5815, 8065, 9936, 8419, 9952, 6439, 11709, 8067, 6735, 5817, 8580, 9974, 6322, 10849,
  7657, 11710, 7725, 4884, 10458, 10462, 6868, 9994, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 4682, 5788, 10016, 10031, 6229, 11373, 8179, 8065, 4752, 6229, 10047, 6735, 8812, 11281, 5818, 5987, 6276,
  6735, 6735, 10152, 5818, 8066, 10075, 7869, 6715, 7704, 5819, 11372, 7878, 5815, 10126, 6441, 11707, 5818, 6439,
  11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788, 5808, 8046, 9253, 11996, 8179, 10174, 4752,
  6229, 5835, 6735, 7298, 5818, 5818, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6735, 6715, 5818, 5819, 11372,
  6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 11317, 10203, 8391, 5815, 11705, 4883, 6408, 11710, 7725,
  4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682,
  10226, 10238, 10254, 4266, 10270, 5976, 7808, 4752, 6229, 10294, 6736, 7298, 9055, 9034, 6341, 6276, 10310, 6735,
  10377, 10345, 8066, 10364, 4814, 11401, 6459, 10402, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 11926, 10278, 8067,
  6735, 5817, 8391, 5815, 11132, 10425, 10672, 10530, 7725, 4884, 8459, 10447, 6868, 6882, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 10478, 10490, 10506, 7022, 10522, 10546, 10581, 10627, 5646,
  10655, 6792, 7298, 10688, 10712, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 11081, 4775, 9180, 5818, 10731, 10768,
  4862, 5815, 10793, 6068, 10321, 10829, 6439, 11709, 8709, 6362, 7116, 8391, 5815, 7104, 10865, 9539, 11014, 10871,
  10887, 10921, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4757,
  10947, 10959, 10975, 8270, 11510, 10991, 11039, 4752, 11068, 11097, 7501, 11117, 11169, 11188, 6341, 10639, 11204,
  11230, 11246, 11272, 11498, 9261, 6594, 10752, 7353, 10158, 11306, 8312, 9385, 11339, 11389, 6718, 11417, 9565, 8779,
  10210, 11934, 9224, 7557, 11436, 11705, 4883, 6408, 11710, 11473, 9399, 11740, 10462, 8353, 6882, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 11526, 11538, 11554, 6229, 8022, 8179, 11570, 4752,
  6229, 5835, 6735, 7298, 5818, 5818, 6341, 11618, 8805, 11683, 9428, 5818, 11648, 5792, 6735, 6715, 5818, 5819, 11372,
  6735, 5815, 8065, 11676, 11757, 5818, 6439, 11709, 8067, 6735, 5817, 6781, 9684, 11705, 4883, 6408, 11710, 10431,
  11699, 10458, 11256, 11726, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682,
  5788, 5808, 8046, 6229, 6674, 8179, 11773, 11814, 6229, 11841, 6735, 7298, 11451, 5818, 6341, 11866, 9278, 6735,
  10152, 10557, 8066, 5792, 6735, 6715, 5818, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735,
  5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788, 5808, 8046, 6229, 11373, 10777, 9602, 4752, 6229, 5835, 6735,
  7298, 5818, 5818, 6341, 6276, 6735, 6735, 10152, 5818, 8066, 5792, 6735, 6715, 5818, 5819, 11372, 11752, 11900, 7222,
  6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462,
  6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 5788, 5808, 8046,
  9457, 9153, 8179, 11950, 4752, 6229, 5835, 6735, 11850, 5818, 5818, 11987, 6276, 6735, 6735, 10152, 5818, 8066, 5792,
  6735, 6715, 5818, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705,
  4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 4682, 5788, 5808, 8046, 6229, 11373, 7565, 6018, 4752, 6229, 5835, 6735, 7298, 5818, 5818, 6341,
  6276, 6735, 6735, 10152, 5818, 8066, 5792, 10897, 6715, 6508, 5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439,
  11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710, 7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 9338, 12012, 6229, 4282, 6229, 8885, 11971, 3891, 3619,
  3635, 5756, 3681, 4142, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820,
  3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046,
  4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 11353,
  11365, 12052, 6229, 12068, 4084, 3891, 3619, 3635, 3662, 3681, 12121, 3665, 3684, 3700, 3716, 3841, 3857, 3833, 3849,
  12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970, 3969, 3953,
  3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 4682, 6979, 6991, 12092, 6229, 5750, 4084, 3891, 3619, 3635, 12108, 3681, 4000, 3665,
  3684, 3700, 3716, 3841, 3857, 3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923,
  3917, 3939, 8895, 3862, 3970, 3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 4682, 6229, 6229, 6696, 6229, 11373, 8179,
  8065, 4752, 6229, 4773, 6735, 11884, 5818, 5818, 6341, 4962, 6735, 6735, 9028, 5818, 8066, 5792, 6735, 6715, 5818,
  5819, 11372, 6735, 5815, 8065, 6441, 11707, 5818, 6439, 11709, 8067, 6735, 5817, 8391, 5815, 11705, 4883, 6408, 11710,
  7725, 4884, 10458, 10462, 6868, 6882, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 11583, 11595, 12137, 6229, 5750, 4084, 3891, 12153, 3635, 5756, 3681, 4142, 3665, 3684, 3700, 3716, 3841, 3857,
  3833, 3849, 12076, 3732, 3748, 3764, 3747, 3791, 3820, 3888, 3878, 3775, 3907, 3923, 3917, 3939, 8895, 3862, 3970,
  3969, 3953, 3986, 4016, 4069, 4081, 4078, 3804, 4046, 4053, 4100, 4129, 4158, 6229, 6229, 6229, 6229, 6229, 6229,
  6229, 6229, 6229, 6229, 6229, 6229, 6229, 9266, 9266, 9266, 9266, 9266, 9266, 9266, 9266, 9266, 9266, 9266, 9266,
  9266, 9266, 9266, 9266, 10299, 9266, 9266, 9266, 9266, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63,
  138240, 201728, 215040, 0, 10299, 10299, 0, 0, 0, 0, 0, 0, 0, 190464, 0, 197632, 198656, 0, 0, 204800, 206848, 208896,
  0, 212992, 216064, 0, 0, 230400, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 168, 89, 89, 178, 0, 162, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 190464, 139264, 139264, 139264, 139264, 197632,
  198656, 139264, 197632, 198656, 139264, 200704, 139264, 204800, 139264, 206848, 208896, 139264, 139264, 212992,
  139264, 216064, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 230400, 139264, 139264,
  139264, 134144, 0, 0, 0, 0, 176128, 185344, 0, 0, 0, 0, 209920, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 139264, 176128, 0,
  188416, 0, 199680, 0, 0, 0, 0, 0, 0, 0, 179200, 137216, 139264, 139264, 179200, 139264, 139264, 139264, 139264,
  139264, 188416, 139264, 139264, 139264, 139264, 139264, 199680, 139264, 139264, 205824, 139264, 214016, 139264,
  139264, 139264, 139264, 139264, 139264, 225280, 226304, 139264, 228352, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 231424, 139264, 233472, 0, 0, 192512, 139264, 214016, 139264, 139264, 139264,
  139264, 139264, 139264, 225280, 226304, 139264, 228352, 139264, 139264, 139264, 0, 139264, 139264, 186368, 139264,
  139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 186368, 0, 0, 0, 0, 0, 233472, 0, 231424, 0, 139264,
  139264, 139264, 181248, 139264, 139264, 139264, 139264, 0, 0, 139264, 176128, 139264, 139264, 139264, 139264, 139264,
  185344, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 195584, 139264, 139264, 139264, 139264, 139264,
  207872, 209920, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 0, 0,
  202752, 180224, 231424, 139264, 233472, 139264, 139264, 139264, 181248, 139264, 139264, 139264, 139264, 139264,
  191488, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0,
  133120, 177152, 0, 221184, 0, 0, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 192512, 139264,
  139264, 139264, 139264, 139264, 217088, 139264, 139264, 221184, 139264, 139264, 227328, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 187392, 0, 0, 0, 0, 0, 139264, 139264, 139264, 182272, 139264, 139264, 187392, 139264,
  139264, 0, 203776, 222208, 139264, 178176, 139264, 139264, 139264, 193536, 203776, 210944, 218112, 139264, 222208,
  139264, 174080, 139264, 180224, 139264, 139264, 139264, 139264, 196608, 202752, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 139264, 139264, 178176, 139264, 139264, 139264, 193536, 203776, 210944,
  218112, 139264, 222208, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 230400, 139264, 139264,
  139264, 0, 0, 310, 139264, 139264, 0, 139264, 183296, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
  232448, 139264, 183296, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 230400, 139264, 139264,
  139264, 0, 11264, 207, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 224256, 139264, 139264, 189440, 139264,
  211968, 139264, 139264, 139264, 224256, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 232448, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 175104, 139264, 139264, 139264, 139264, 223232, 175104, 139264, 139264, 139264,
  139264, 0, 11264, 139264, 176128, 139264, 139264, 139264, 139264, 139264, 185344, 139264, 139264, 139264, 223232,
  139264, 194560, 219136, 139264, 139264, 194560, 219136, 139264, 184320, 139264, 184320, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 230400, 139264, 139264, 139264, 0, 0, 0, 139264, 139264, 139264, 139264,
  139264, 220160, 220160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 57, 0, 0, 10299, 0, 0, 13379, 0, 0, 133120, 0, 0, 0, 0, 0, 0,
  10299, 10299, 10299, 62, 63, 138240, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38912, 38912, 62, 0, 0,
  133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 5254, 63, 138240, 201728, 215040, 0, 10299, 10299, 62, 0, 0, 0, 0, 0,
  0, 190464, 0, 197632, 198656, 0, 15360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 15360, 0, 15360, 15360, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 152, 0, 0, 0, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240, 0, 0,
  16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 0, 16384, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63,
  138240, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 16384, 16384, 16384, 16384, 16384, 16384, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 266, 0, 0, 63, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 5255, 138240, 201728,
  215040, 0, 10299, 10299, 0, 63, 0, 0, 0, 0, 0, 190464, 0, 197632, 198656, 51, 51, 51, 17459, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 10300, 17459, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 17459, 51, 51, 17459, 51, 17459, 17459, 17459,
  17459, 51, 51, 17459, 17459, 51, 17459, 17459, 17459, 17459, 17459, 17459, 17459, 0, 0, 133120, 0, 0, 0, 0, 0, 0,
  10372, 10372, 10372, 62, 63, 138240, 201728, 215040, 0, 10372, 10372, 0, 0, 0, 0, 0, 0, 0, 190464, 0, 197632, 198656,
  0, 0, 0, 0, 19456, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 0, 19456, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 28672, 62,
  63, 138240, 19456, 19456, 0, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456, 19456,
  19456, 0, 0, 0, 19456, 19456, 19456, 0, 0, 0, 19456, 0, 19456, 201728, 215040, 0, 10299, 0, 0, 0, 0, 0, 0, 0, 0,
  190464, 0, 197632, 198656, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 10299, 0, 0, 0, 0, 0, 0, 31812, 31812, 31812,
  31812, 31812, 31812, 31812, 31812, 31812, 31812, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40960, 40960, 40960, 11371, 0,
  0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240, 21504, 21504, 21504, 21504, 0, 0, 0, 0, 0, 0, 0, 0,
  21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299,
  10299, 10299, 62, 63, 138240, 139264, 139264, 139264, 139264, 139264, 230400, 139264, 139264, 139264, 134144, 349, 0,
  0, 0, 176128, 185344, 22528, 0, 0, 0, 22528, 0, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 0, 0, 22528, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62,
  63, 138240, 23552, 23552, 23552, 23552, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 23552, 23552, 23552, 23552, 23552, 23552,
  23552, 23552, 23552, 23552, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 10299, 10299, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 10299, 0, 0, 0, 162, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
  457, 89, 509, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 522, 630, 89, 89, 89, 633, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 456, 89, 89, 89, 644, 108, 108, 108, 647, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 350, 350, 0, 0, 108, 108, 108, 108, 699, 108, 108, 108, 0, 703, 89, 89, 89, 89, 89, 89, 89, 514,
  89, 89, 89, 518, 89, 89, 89, 89, 89, 89, 89, 713, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 89, 89, 89, 89, 89,
  89, 89, 89, 24702, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 26711, 26711, 26711, 26711, 0, 0,
  0, 0, 0, 0, 0, 26711, 26711, 26711, 26711, 26711, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 0, 0, 0, 0, 0, 0,
  34816, 34816, 34816, 34816, 34816, 34816, 34816, 34816, 34816, 34816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 269, 0, 89,
  89, 127, 0, 0, 52, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 0, 53, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 26711, 26711, 26711, 0, 0, 18432, 133120, 29696, 0, 0, 0, 0, 0, 10373, 18432, 10373, 62, 63, 138240, 201728,
  215040, 0, 0, 10373, 0, 0, 0, 0, 0, 0, 0, 190464, 0, 197632, 198656, 0, 162, 139425, 139425, 139425, 139425, 139425,
  139425, 139425, 139425, 139425, 139425, 190625, 139425, 139425, 139425, 139425, 0, 0, 139470, 176334, 139470, 139470,
  139470, 139470, 139470, 185550, 139470, 139470, 139425, 197793, 198817, 139425, 200865, 139425, 204961, 139425,
  207009, 209057, 139425, 139425, 213153, 139425, 216225, 139425, 174286, 139470, 180430, 139470, 139470, 139470,
  139470, 196814, 202958, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 0, 0,
  0, 202752, 180224, 139470, 200910, 139470, 205006, 139470, 207054, 209102, 139470, 139470, 213198, 139470, 216270,
  139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 0, 133120,
  177152, 139470, 139470, 139470, 139470, 139470, 230606, 139470, 139470, 139470, 134144, 0, 0, 0, 0, 176128, 185344, 0,
  0, 0, 0, 209920, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 139425, 176289, 139470, 139470, 139470, 139470, 139470, 195790,
  139470, 139470, 139470, 139470, 139470, 208078, 210126, 139470, 139470, 139470, 139470, 139470, 139470, 139470,
  139470, 139470, 139470, 231630, 139470, 233678, 0, 0, 192512, 0, 188416, 0, 199680, 0, 0, 0, 0, 0, 0, 0, 179200,
  137216, 139425, 139425, 179361, 214177, 139425, 139425, 139425, 139425, 139425, 139425, 225441, 226465, 139425,
  228513, 139425, 139425, 139425, 139470, 139470, 0, 203776, 222208, 139425, 178337, 139425, 139425, 139425, 193697,
  203937, 211105, 218273, 139425, 222369, 179406, 139470, 139470, 139470, 139470, 139470, 188622, 139470, 139470,
  139470, 139470, 139470, 199886, 139470, 139470, 206030, 139470, 214222, 139470, 139470, 139470, 139470, 139470,
  139470, 225486, 226510, 139470, 228558, 139470, 139470, 139470, 0, 139425, 139425, 186529, 139425, 139425, 139425,
  139425, 139425, 139425, 139425, 139470, 139470, 186574, 0, 0, 0, 0, 0, 233472, 0, 231424, 0, 139425, 139425, 139425,
  181409, 139425, 139425, 139425, 139470, 178382, 139470, 139470, 139470, 193742, 203982, 211150, 218318, 139470,
  222414, 139470, 139470, 231585, 139425, 233633, 139470, 139470, 139470, 181454, 139470, 139470, 139470, 139470,
  139470, 191694, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 190670, 139470, 139470,
  139470, 139470, 197838, 198862, 0, 221184, 0, 0, 0, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425,
  192673, 139425, 139425, 139425, 217249, 139425, 139425, 221345, 139425, 139425, 227489, 139425, 139470, 139470,
  139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 0, 135168, 229376, 0, 139470, 139470,
  139470, 192718, 139470, 139470, 139470, 139470, 139470, 217294, 139470, 139470, 221390, 139470, 139470, 227534,
  139470, 187392, 0, 0, 0, 0, 0, 139425, 139425, 139425, 182433, 139425, 139425, 187553, 139425, 139425, 191649, 139425,
  139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139470, 139470,
  139470, 182478, 139470, 139470, 187598, 174241, 139425, 180385, 139425, 139425, 139425, 139425, 196769, 202913,
  139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 230561, 139425, 139425, 139425, 0, 0, 207, 139470,
  139470, 0, 139425, 183457, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 232609, 139470, 183502,
  139470, 139470, 139470, 139470, 139470, 139470, 139470, 232654, 0, 139425, 139425, 139425, 139425, 139425, 139425,
  139425, 185505, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 195745, 139425, 139425, 224417, 139470,
  139470, 189646, 139470, 212174, 139470, 139470, 139470, 224462, 139425, 139425, 139425, 139425, 139425, 139425,
  188577, 139425, 139425, 139425, 139425, 139425, 199841, 139425, 139425, 205985, 139425, 139470, 139470, 139470,
  139470, 139470, 139470, 175265, 139425, 139425, 139425, 139425, 223393, 175310, 139470, 139470, 139470, 139470,
  139470, 139470, 139470, 224256, 139425, 139425, 189601, 139425, 212129, 139425, 139425, 139425, 208033, 210081,
  139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 139425, 205, 139470, 139470, 139470,
  139470, 139470, 139470, 223438, 139425, 194721, 219297, 139425, 139470, 194766, 219342, 139470, 184481, 139425,
  184526, 139470, 139425, 139470, 139425, 139470, 220321, 220366, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 63, 63, 63, 63, 63,
  31812, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240, 0, 0, 0, 32768, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 265, 0, 267, 268, 34816, 0, 0, 133120, 0, 30720, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240, 0, 0,
  14336, 33792, 36864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 0, 0, 0, 0, 35909, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299,
  10299, 10299, 62, 63, 138240, 0, 0, 0, 0, 37888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 127, 127, 127, 127, 127, 0,
  38912, 0, 0, 0, 0, 0, 0, 0, 38912, 0, 38912, 38912, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 190464, 139264, 139264, 139264, 39936, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299,
  10299, 10299, 62, 63, 138240, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 365, 89, 89, 89, 0, 0, 0, 0, 89, 108,
  89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 269, 162, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 642, 0, 0, 0, 0, 90, 109, 90, 90, 90, 90, 109, 109, 109, 109, 109,
  109, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 40960, 40960, 40960, 40960, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 365, 89, 443, 89, 41984, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240, 0, 0, 55,
  64, 55, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 91, 110, 91, 91, 91, 91, 110, 110, 110, 110, 110, 110, 110, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 0, 0, 159, 0, 160, 89, 89, 89, 165, 89, 89, 89, 89,
  191, 193, 89, 89, 202, 89, 0, 108, 108, 108, 108, 108, 108, 108, 347, 108, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89,
  172, 89, 89, 89, 396, 89, 89, 11573, 365, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 248, 108, 0, 0, 0,
  470, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 481, 108, 108, 0, 89, 746, 89, 89, 89, 89, 89, 89,
  89, 89, 108, 755, 108, 495, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 559, 89, 89, 89, 89, 89, 564, 89, 89,
  89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 534, 89, 89, 728, 89, 730, 89,
  732, 89, 108, 108, 108, 108, 738, 108, 740, 108, 0, 89, 89, 89, 685, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 716,
  108, 108, 108, 108, 108, 108, 723, 89, 89, 742, 108, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 672,
  108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 490, 108, 108, 108, 108, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 86, 0,
  86, 88, 88, 88, 88, 92, 111, 92, 92, 92, 92, 111, 111, 111, 111, 111, 111, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299,
  10299, 10299, 62, 63, 64, 0, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 10299, 10299, 0, 0, 0,
  0, 0, 0, 0, 0, 258, 0, 0, 0, 0, 0, 0, 35909, 35909, 35909, 35909, 35909, 35909, 35909, 35909, 35909, 35909, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 269, 365, 89, 89, 269, 162, 271, 89, 89, 89, 89, 89, 89, 279, 89, 89, 89, 89, 284, 89, 89,
  89, 301, 89, 89, 89, 89, 89, 89, 89, 89, 11573, 269, 207, 108, 0, 89, 89, 684, 89, 89, 89, 89, 89, 89, 89, 89, 108,
  108, 694, 420, 421, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 640, 89, 89, 562, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108,
  108, 108, 108, 108, 108, 108, 677, 108, 108, 108, 89, 89, 602, 603, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 0, 89, 89, 89, 89, 707, 89, 709, 108, 108, 108, 108, 619, 620, 108, 108, 108, 108, 108, 0, 0, 0,
  0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 643, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 108, 108, 482, 108, 108, 657, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 455, 89, 89, 89, 89, 727,
  89, 89, 89, 89, 89, 89, 108, 108, 108, 737, 108, 108, 108, 108, 108, 108, 108, 476, 477, 108, 108, 108, 108, 108, 108,
  108, 108, 334, 108, 108, 108, 108, 108, 108, 108, 108, 108, 544, 108, 108, 108, 0, 0, 0, 0, 0, 0, 64, 0, 0, 71, 71,
  71, 71, 71, 71, 71, 71, 71, 71, 93, 112, 93, 93, 93, 93, 112, 112, 112, 112, 112, 112, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 145, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 454, 89, 89, 89,
  89, 89, 180, 89, 89, 89, 89, 89, 89, 89, 89, 89, 0, 108, 108, 108, 108, 108, 108, 89, 89, 788, 789, 89, 89, 108, 108,
  792, 793, 108, 108, 108, 225, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 89, 89, 89, 89, 89, 663, 89, 664,
  665, 89, 89, 0, 0, 0, 10299, 10299, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 174, 89, 89, 0, 0, 0,
  0, 0, 261, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 269, 162, 272, 89, 89, 89, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 573, 108, 445, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
  89, 296, 108, 471, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 586, 108, 108, 108, 108, 108,
  539, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 89, 89, 89, 89, 662, 89, 89, 89, 89, 89, 89, 289, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 89, 390, 89, 89, 89, 89, 0, 0, 0, 0, 0, 89, 89, 89, 89, 556, 89, 89, 89, 89, 89, 89, 89,
  607, 89, 108, 108, 108, 108, 613, 108, 108, 89, 89, 89, 729, 89, 89, 89, 89, 108, 108, 108, 108, 108, 739, 108, 108,
  0, 745, 89, 89, 747, 89, 749, 89, 89, 89, 89, 754, 108, 108, 89, 89, 89, 89, 108, 108, 108, 108, 89, 89, 108, 108, 89,
  108, 89, 108, 89, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 62, 62, 62, 62, 0, 0, 0, 64, 0, 65, 72, 72, 72, 72, 72,
  72, 72, 72, 72, 72, 94, 113, 94, 94, 94, 94, 113, 113, 113, 113, 113, 113, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299,
  10299, 10299, 62, 63, 64, 89, 185, 89, 189, 89, 89, 194, 197, 200, 89, 0, 108, 108, 108, 108, 213, 108, 108, 223, 108,
  230, 108, 234, 108, 108, 239, 242, 245, 108, 0, 251, 0, 0, 0, 0, 0, 0, 106496, 106496, 106496, 106496, 106496, 106496,
  106496, 106496, 106496, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 507, 0, 0, 252, 10299,
  10299, 0, 0, 253, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 269, 162, 89, 89, 89, 89, 89, 89, 89, 89, 280, 89,
  89, 283, 89, 89, 89, 108, 525, 526, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 431, 0, 0, 0, 0, 297, 89,
  89, 89, 89, 89, 89, 89, 89, 306, 89, 89, 11573, 269, 207, 108, 0, 89, 683, 89, 89, 89, 89, 89, 689, 89, 89, 89, 108,
  693, 108, 0, 89, 89, 89, 89, 686, 89, 688, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 654, 108, 108, 108, 108, 108, 331, 108, 108, 108, 108, 108, 108, 108, 108, 337, 108, 108, 89, 89, 89, 89, 108,
  108, 108, 108, 89, 89, 108, 108, 801, 802, 354, 355, 0, 357, 0, 0, 0, 0, 0, 0, 0, 0, 269, 365, 366, 89, 89, 89, 370,
  89, 89, 89, 373, 89, 89, 89, 89, 89, 89, 89, 89, 89, 464, 89, 89, 89, 89, 108, 108, 89, 382, 89, 89, 89, 384, 385,
  386, 89, 89, 89, 89, 391, 89, 393, 89, 89, 89, 398, 11573, 365, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  545, 108, 0, 0, 0, 89, 89, 397, 89, 11573, 365, 399, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 479, 108, 108,
  108, 108, 108, 407, 108, 108, 410, 108, 108, 108, 108, 108, 415, 108, 108, 108, 417, 418, 419, 108, 108, 108, 108,
  424, 108, 426, 108, 108, 108, 430, 108, 0, 0, 0, 432, 89, 446, 447, 89, 449, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
  89, 89, 11573, 269, 207, 108, 89, 89, 459, 460, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 715, 108, 108, 108,
  108, 108, 108, 108, 0, 89, 89, 89, 765, 89, 766, 89, 89, 108, 108, 472, 473, 108, 475, 108, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 108, 480, 108, 108, 108, 108, 108, 108, 108, 485, 486, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 108, 0, 0, 351, 0, 0, 0, 0, 548, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 11573, 269, 207,
  311, 89, 563, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 531, 108, 108, 108, 108, 89,
  601, 89, 89, 89, 89, 606, 608, 89, 108, 108, 612, 108, 108, 108, 108, 108, 108, 108, 489, 108, 108, 108, 108, 108,
  108, 108, 0, 615, 108, 108, 618, 108, 108, 108, 108, 623, 625, 108, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89,
  599, 89, 631, 89, 89, 89, 89, 89, 89, 89, 89, 637, 89, 89, 89, 89, 89, 290, 89, 89, 292, 89, 89, 89, 89, 89, 89, 89,
  291, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 517, 89, 89, 89, 89, 89, 89, 108, 645, 108, 108, 108, 108, 108, 108, 108,
  108, 651, 108, 108, 108, 108, 108, 108, 108, 542, 108, 108, 108, 108, 108, 0, 0, 0, 89, 89, 660, 89, 89, 89, 89, 89,
  89, 89, 89, 203, 89, 0, 108, 108, 108, 108, 108, 108, 108, 658, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
  11573, 269, 207, 312, 89, 668, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 679, 695, 108, 108,
  108, 108, 108, 108, 108, 702, 89, 89, 89, 89, 89, 89, 89, 89, 387, 388, 89, 89, 89, 89, 89, 89, 89, 89, 712, 108, 108,
  108, 108, 108, 108, 108, 108, 108, 722, 0, 89, 89, 89, 108, 714, 108, 108, 108, 718, 108, 108, 108, 108, 0, 89, 89,
  89, 89, 748, 89, 750, 89, 89, 89, 108, 108, 108, 726, 89, 89, 89, 89, 89, 89, 89, 108, 108, 736, 108, 108, 108, 108,
  108, 108, 108, 108, 582, 108, 108, 108, 108, 108, 108, 108, 108, 108, 478, 108, 108, 108, 108, 108, 108, 756, 108,
  758, 108, 108, 108, 108, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 782, 108, 108, 108, 786, 89,
  89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 674, 108, 675, 676, 108, 108, 108, 108, 0, 0, 0, 0, 95, 114, 95, 95, 95,
  95, 114, 114, 114, 114, 114, 114, 0, 0, 0, 0, 0, 0, 0, 130, 0, 10299, 10299, 10299, 62, 63, 64, 181, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 0, 108, 108, 108, 108, 108, 108, 108, 236, 238, 108, 108, 247, 108, 0, 0, 0, 108, 108, 108, 226,
  108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 89, 89, 89, 661, 89, 89, 89, 89, 89, 89, 89, 196, 89, 89, 0,
  108, 108, 108, 108, 108, 0, 0, 0, 0, 499, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 452, 89, 89, 89, 89, 89, 89, 89,
  89, 515, 89, 89, 89, 89, 89, 89, 89, 89, 568, 89, 89, 108, 108, 108, 108, 108, 781, 108, 108, 108, 108, 108, 89, 89,
  89, 89, 89, 89, 108, 108, 108, 108, 527, 528, 108, 530, 108, 108, 108, 108, 108, 108, 108, 795, 89, 89, 89, 797, 108,
  108, 108, 89, 89, 108, 108, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 775, 89, 89, 89, 89, 89, 303, 89, 89, 89,
  89, 89, 89, 11573, 269, 207, 108, 0, 0, 0, 64, 0, 0, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 96, 115, 96, 96, 96, 96,
  115, 115, 115, 115, 115, 115, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 10299, 10299,
  0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 177, 89, 341, 108, 108, 108, 108, 108, 108, 108, 108, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 89, 89, 669, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 0, 0, 0, 0, 0, 680, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 574, 0, 0,
  0, 64, 0, 0, 74, 84, 84, 84, 84, 84, 84, 84, 84, 84, 97, 116, 97, 97, 97, 97, 116, 116, 116, 116, 116, 116, 116, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0, 0, 0,
  143, 0, 148, 0, 151, 0, 153, 0, 269, 162, 89, 89, 89, 275, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 0, 108, 108, 108,
  108, 108, 108, 108, 315, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 251, 0, 328, 108, 108,
  108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 547, 0, 108, 108, 108, 344, 108, 108, 108, 108,
  348, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 171, 89, 89, 108, 108, 108, 423, 108, 108, 108, 108, 108, 108, 108,
  108, 0, 0, 0, 0, 0, 0, 0, 0, 144, 0, 149, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 169, 89, 89, 89, 0, 0, 549, 0, 0,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 560, 89, 89, 89, 510, 89, 89, 89, 89, 89, 516, 89, 89, 89, 89, 89, 89, 731, 89,
  733, 108, 108, 108, 108, 108, 108, 108, 741, 108, 108, 108, 108, 578, 108, 108, 108, 108, 108, 583, 108, 108, 585,
  108, 108, 89, 89, 89, 89, 108, 108, 108, 108, 89, 799, 108, 800, 89, 108, 108, 108, 108, 108, 108, 649, 108, 108, 108,
  108, 652, 108, 108, 108, 108, 108, 108, 233, 108, 237, 108, 240, 108, 108, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 520, 89, 89, 587, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 570, 108, 108,
  108, 108, 710, 711, 89, 108, 108, 108, 108, 717, 108, 719, 720, 721, 108, 0, 89, 89, 89, 89, 89, 687, 89, 89, 89, 89,
  89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 89, 89, 89, 89, 779, 89, 89, 108, 108, 108, 771, 108, 772, 108, 108,
  108, 89, 89, 89, 89, 89, 89, 304, 89, 89, 89, 89, 308, 11573, 269, 207, 108, 0, 0, 0, 64, 0, 0, 75, 75, 75, 75, 75,
  75, 75, 75, 75, 75, 98, 117, 98, 98, 98, 98, 117, 117, 117, 117, 117, 117, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299,
  10299, 10299, 62, 63, 64, 136, 0, 0, 0, 0, 0, 0, 140, 0, 0, 0, 0, 0, 0, 0, 0, 0, 362, 0, 0, 269, 365, 89, 89, 216,
  108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 659, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 0,
  108, 108, 108, 211, 108, 269, 162, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 285, 108, 342, 108, 108, 108,
  108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 0, 0, 131, 10299, 10299, 10299, 62, 63, 64, 89, 89, 369, 89, 89, 89, 89, 89, 89,
  89, 89, 89, 378, 89, 89, 89, 89, 565, 89, 89, 567, 89, 89, 569, 108, 108, 108, 108, 108, 108, 108, 320, 108, 108, 323,
  108, 108, 108, 108, 108, 108, 108, 108, 543, 108, 108, 108, 108, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 666, 89,
  108, 108, 108, 108, 411, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 629, 0, 0, 0, 0, 0, 0, 551, 89,
  89, 554, 89, 89, 89, 89, 89, 89, 89, 89, 89, 453, 89, 89, 89, 89, 89, 89, 656, 108, 0, 0, 0, 89, 89, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 108, 108, 572, 108, 108, 108, 757, 108, 759, 108, 108, 108, 0, 763, 89, 89, 89, 89, 89, 89, 89,
  89, 609, 108, 611, 108, 108, 108, 614, 108, 89, 769, 108, 108, 108, 108, 108, 108, 108, 108, 89, 89, 89, 89, 89, 89,
  372, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 307, 89, 11573, 269, 207, 108, 0, 0, 0, 64, 0, 0, 76, 76, 76, 76, 76, 76,
  76, 76, 76, 76, 99, 118, 99, 99, 99, 99, 118, 118, 118, 118, 118, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299,
  10299, 62, 63, 64, 217, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 0, 0, 139264,
  139426, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 182272,
  139264, 139264, 187392, 269, 162, 89, 89, 89, 89, 276, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 293, 89, 89, 295, 89,
  89, 108, 108, 108, 316, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 135168, 0, 0, 108, 108, 343,
  108, 108, 108, 108, 108, 108, 0, 0, 0, 352, 0, 0, 0, 0, 0, 0, 0, 0, 139425, 139425, 139425, 139425, 139425, 139425,
  139425, 139425, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 139470, 0, 139425, 139425, 89,
  89, 383, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 469, 433, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 365,
  89, 89, 89, 89, 11573, 0, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 336, 108, 108, 108, 108, 108,
  108, 108, 474, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 326, 108, 108, 108, 108, 681, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 691, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 89, 89, 777, 778, 89, 89, 0, 0, 0, 64,
  0, 0, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 100, 119, 100, 100, 100, 100, 119, 119, 119, 119, 119, 119, 119, 0, 0,
  0, 0, 0, 0, 129, 0, 0, 10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 0, 0, 138, 0, 0, 0, 146, 0, 0, 0, 0, 0, 0, 0, 0, 89,
  89, 89, 89, 89, 175, 89, 89, 0, 156, 0, 157, 0, 0, 0, 0, 89, 89, 163, 89, 89, 89, 89, 89, 462, 89, 89, 89, 89, 89, 89,
  466, 89, 468, 108, 182, 89, 89, 89, 89, 89, 89, 89, 89, 204, 0, 108, 108, 208, 108, 108, 89, 89, 89, 796, 108, 108,
  108, 798, 89, 89, 108, 108, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 650, 108, 108, 108, 108, 655, 108, 108,
  108, 227, 108, 108, 108, 108, 108, 108, 108, 108, 249, 0, 0, 0, 0, 0, 0, 0, 141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 440, 0, 0,
  365, 89, 89, 89, 287, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 380, 89, 458, 89, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 467, 108, 108, 108, 108, 108, 108, 346, 108, 108, 251, 0, 0, 0, 353, 0, 0, 0, 0, 0, 0, 41984,
  41984, 41984, 41984, 41984, 41984, 41984, 41984, 41984, 41984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103424, 10299, 0,
  0, 108, 108, 484, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 493, 494, 0, 0, 0, 498, 0, 0, 500, 0, 0, 89,
  89, 89, 89, 505, 506, 89, 89, 89, 524, 108, 108, 108, 108, 108, 108, 108, 108, 108, 532, 108, 108, 108, 108, 108, 108,
  762, 0, 89, 89, 89, 89, 89, 89, 767, 768, 508, 89, 89, 89, 89, 89, 513, 89, 89, 89, 89, 89, 519, 89, 89, 89, 89,
  11573, 365, 108, 108, 108, 108, 108, 108, 108, 108, 405, 108, 535, 108, 108, 108, 108, 108, 541, 108, 108, 108, 108,
  108, 108, 0, 0, 0, 0, 0, 0, 0, 142, 0, 0, 0, 0, 0, 0, 0, 0, 55, 0, 0, 0, 0, 10299, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89,
  89, 89, 557, 89, 89, 89, 89, 89, 512, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 0, 108, 108, 108, 108, 214, 575, 108,
  108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 133120, 0, 600, 89, 89, 89, 604, 89, 89, 89,
  89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 724, 89, 108, 616, 617, 108, 108, 108, 621, 108, 108, 108,
  108, 0, 0, 0, 0, 0, 0, 89, 594, 89, 89, 89, 597, 89, 89, 89, 89, 108, 108, 108, 646, 108, 108, 108, 108, 108, 108,
  108, 108, 653, 108, 108, 108, 108, 108, 108, 412, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 244, 108, 108, 0,
  0, 0, 108, 108, 697, 108, 108, 108, 108, 108, 0, 89, 89, 89, 706, 89, 89, 89, 89, 11573, 365, 108, 108, 108, 108, 108,
  403, 108, 108, 108, 406, 108, 743, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 89, 776, 89, 89, 89, 780, 108, 108, 783, 784, 108, 108, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 673, 108,
  108, 108, 108, 108, 108, 108, 108, 108, 251, 0, 0, 0, 0, 0, 0, 89, 108, 805, 806, 89, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 24702, 24702, 24702, 24702, 24702, 24702, 0, 0, 0, 64, 0, 0, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 101, 120, 101,
  101, 101, 101, 120, 120, 120, 120, 120, 120, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 155, 0,
  0, 0, 155, 0, 0, 0, 89, 89, 89, 167, 170, 89, 176, 89, 89, 89, 632, 89, 89, 89, 89, 89, 89, 89, 89, 639, 89, 89, 89,
  89, 11573, 365, 108, 108, 108, 108, 108, 108, 404, 108, 108, 108, 108, 108, 108, 108, 622, 108, 108, 108, 0, 0, 0, 0,
  0, 0, 89, 89, 89, 89, 596, 89, 89, 89, 89, 89, 89, 187, 190, 89, 89, 89, 198, 201, 89, 0, 108, 108, 108, 212, 215,
  108, 221, 108, 108, 108, 232, 235, 108, 108, 108, 243, 246, 108, 0, 0, 0, 0, 0, 0, 0, 360, 0, 0, 0, 0, 269, 365, 89,
  89, 298, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 11573, 269, 207, 108, 0, 588, 0, 590, 591, 592, 89, 89, 595, 89,
  89, 89, 89, 598, 89, 89, 89, 448, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 521, 89, 0, 0, 0, 0, 0, 552,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 561, 108, 108, 108, 108, 108, 579, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 108, 627, 0, 0, 0, 0, 89, 89, 89, 670, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 325, 108, 108,
  108, 803, 804, 89, 108, 89, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39936, 39936, 39936, 39936, 39936, 39936, 0, 0, 0, 0,
  102, 121, 102, 102, 102, 102, 121, 121, 121, 121, 121, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63,
  64, 269, 162, 89, 89, 89, 89, 89, 89, 89, 89, 89, 282, 89, 89, 89, 89, 371, 89, 89, 89, 89, 89, 89, 89, 89, 89, 379,
  89, 0, 0, 434, 0, 0, 0, 0, 0, 0, 0, 0, 0, 365, 89, 89, 89, 89, 11573, 365, 108, 108, 108, 108, 402, 108, 108, 108,
  108, 108, 108, 108, 333, 108, 108, 335, 108, 108, 108, 108, 108, 108, 89, 787, 89, 89, 89, 89, 108, 791, 108, 108,
  108, 108, 537, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 0, 438, 0, 0, 0, 0, 365, 89, 89,
  89, 89, 11573, 365, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 491, 108, 108, 0, 218, 108, 108, 108,
  108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 53, 54, 0, 0, 0, 0, 0, 10301, 0, 0, 89, 108, 108, 108,
  108, 108, 648, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 626, 0, 628, 0, 0, 0, 0, 0, 0, 64, 0, 0, 79, 79, 79,
  79, 79, 79, 79, 79, 79, 79, 103, 122, 103, 103, 103, 103, 122, 122, 122, 122, 122, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 0, 158, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 610, 108, 108, 108,
  108, 108, 108, 269, 162, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 286, 367, 89, 89, 89, 89, 89, 89, 89, 89,
  89, 376, 89, 89, 89, 89, 89, 566, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 529, 108, 108, 108, 108, 108, 108,
  108, 108, 409, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 250, 127, 0, 0, 0, 0, 0, 435, 436, 0,
  0, 0, 0, 0, 0, 365, 89, 89, 89, 89, 11573, 365, 108, 108, 400, 108, 108, 108, 108, 108, 108, 108, 108, 108, 134144,
  349, 0, 0, 0, 0, 0, 108, 108, 108, 108, 108, 487, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 89, 89, 705, 89, 89,
  89, 89, 108, 108, 108, 108, 108, 700, 108, 108, 0, 89, 89, 89, 89, 89, 89, 89, 89, 752, 89, 108, 108, 108, 108, 108,
  108, 108, 785, 108, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 89, 89, 89, 89, 89, 89, 108,
  108, 108, 108, 0, 0, 0, 64, 0, 66, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 104, 123, 104, 104, 104, 104, 123, 123,
  123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 128, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64, 0, 0, 0, 147, 0, 0, 0, 0, 89,
  89, 89, 89, 89, 89, 89, 89, 108, 735, 108, 108, 108, 108, 108, 108, 183, 89, 89, 89, 89, 89, 89, 89, 89, 89, 0, 108,
  108, 108, 108, 108, 108, 108, 413, 108, 108, 108, 108, 108, 108, 108, 108, 108, 429, 108, 108, 0, 0, 0, 0, 108, 108,
  108, 228, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 67, 67, 67, 67, 67, 67, 67, 13379, 13379,
  13379, 13379, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 0, 0, 0, 10299, 10299, 0, 0, 0, 0, 0, 0, 257, 0, 0, 0,
  0, 0, 0, 0, 0, 361, 0, 363, 364, 269, 365, 89, 89, 269, 162, 89, 89, 274, 89, 89, 277, 89, 89, 281, 89, 89, 89, 89,
  89, 605, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 89, 725, 108, 314, 108, 108, 317, 108, 108,
  321, 108, 108, 108, 108, 108, 108, 108, 108, 108, 250, 350, 0, 0, 0, 0, 0, 108, 108, 329, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 108, 108, 108, 108, 327, 108, 108, 483, 108, 108, 108, 108, 108, 488, 108, 108, 108, 108, 108,
  108, 492, 108, 0, 0, 589, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 465, 89, 89, 108, 108, 0, 0, 497, 0, 0,
  0, 0, 0, 0, 89, 89, 89, 89, 89, 89, 89, 199, 89, 89, 0, 108, 108, 108, 108, 108, 108, 536, 108, 108, 108, 540, 108,
  108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 10299, 0, 0, 108, 108,
  577, 108, 108, 108, 108, 108, 108, 108, 108, 584, 108, 108, 108, 108, 108, 108, 108, 581, 108, 108, 108, 108, 108,
  108, 108, 108, 0, 89, 704, 89, 89, 89, 708, 89, 108, 696, 108, 698, 108, 108, 108, 108, 0, 89, 89, 89, 89, 89, 89, 89,
  751, 89, 89, 108, 108, 108, 108, 108, 108, 108, 760, 108, 108, 0, 89, 764, 89, 89, 89, 89, 89, 89, 450, 451, 89, 89,
  89, 89, 89, 89, 89, 89, 374, 89, 89, 377, 89, 89, 89, 89, 89, 108, 770, 108, 108, 108, 108, 108, 108, 108, 89, 89, 89,
  89, 89, 89, 463, 89, 89, 89, 89, 89, 89, 89, 108, 108, 0, 0, 0, 64, 0, 0, 81, 81, 85, 81, 85, 81, 85, 85, 85, 85, 105,
  124, 105, 105, 105, 105, 124, 124, 124, 124, 124, 124, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63,
  64, 184, 186, 89, 89, 89, 89, 89, 89, 89, 89, 0, 108, 108, 209, 108, 108, 108, 108, 108, 108, 701, 108, 0, 89, 89, 89,
  89, 89, 89, 89, 89, 734, 108, 108, 108, 108, 108, 108, 108, 108, 108, 624, 108, 0, 0, 0, 0, 0, 108, 108, 224, 229,
  231, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 359, 0, 0, 0, 0, 0, 269, 365, 89, 89, 0, 260, 0, 0, 0,
  0, 0, 0, 262, 263, 0, 0, 260, 0, 0, 0, 0, 0, 0, 437, 0, 0, 0, 0, 0, 365, 442, 89, 89, 269, 162, 89, 273, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 392, 89, 89, 89, 299, 300, 89, 89, 89, 89, 89, 89, 89, 89, 89, 11573, 269,
  207, 108, 0, 682, 89, 89, 89, 89, 89, 89, 89, 690, 89, 89, 692, 108, 108, 108, 108, 108, 108, 580, 108, 108, 108, 108,
  108, 108, 108, 108, 108, 108, 416, 108, 108, 108, 108, 108, 313, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 108, 338, 108, 108, 108, 108, 330, 108, 108, 332, 108, 108, 108, 108, 108, 108, 108, 108, 339,
  340, 89, 368, 89, 89, 89, 89, 89, 89, 89, 375, 89, 89, 89, 89, 89, 89, 635, 89, 89, 89, 89, 638, 89, 89, 89, 89, 381,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 394, 395, 89, 89, 89, 11573, 365, 108, 108, 108, 401, 108,
  108, 108, 108, 108, 108, 89, 89, 89, 89, 790, 89, 108, 108, 108, 108, 108, 408, 108, 108, 108, 108, 108, 108, 414,
  108, 108, 108, 108, 108, 108, 108, 108, 322, 108, 108, 108, 108, 108, 108, 108, 108, 108, 134144, 0, 0, 0, 0, 0, 0, 0,
  496, 0, 0, 0, 0, 0, 0, 0, 502, 89, 89, 89, 89, 89, 89, 634, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 294, 89, 89,
  89, 89, 108, 108, 108, 538, 108, 108, 108, 108, 108, 108, 108, 108, 108, 546, 0, 0, 0, 0, 0, 0, 104531, 104531,
  104531, 104531, 104531, 104531, 104531, 104531, 104531, 104531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89,
  89, 89, 89, 89, 0, 0, 0, 0, 0, 89, 89, 89, 555, 89, 89, 558, 89, 89, 89, 89, 461, 89, 89, 89, 89, 89, 89, 89, 89, 89,
  108, 108, 108, 576, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 25600, 133370, 0, 667, 89,
  89, 108, 108, 671, 108, 108, 108, 108, 108, 108, 108, 108, 678, 108, 108, 108, 108, 108, 318, 108, 108, 108, 108, 108,
  108, 108, 108, 108, 108, 241, 108, 108, 0, 0, 0, 108, 108, 744, 89, 89, 89, 89, 89, 89, 89, 89, 89, 753, 108, 108,
  108, 108, 108, 108, 319, 108, 108, 108, 108, 324, 108, 108, 108, 108, 108, 108, 108, 427, 428, 108, 108, 108, 0, 0, 0,
  0, 0, 0, 0, 0, 89, 89, 164, 89, 89, 89, 89, 179, 0, 0, 0, 64, 0, 0, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 106, 125,
  106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 64,
  108, 222, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 12288, 12288, 12288, 12288, 12288,
  12288, 12288, 12288, 12288, 12288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 145, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 0,
  0, 0, 0, 0, 0, 269, 365, 89, 89, 89, 188, 89, 192, 89, 195, 89, 89, 0, 108, 108, 108, 210, 108, 108, 108, 422, 108,
  108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 0, 0, 439, 0, 441, 441, 365, 89, 89, 444, 0, 0, 0, 0, 0, 89,
  553, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 389, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 761, 108, 0, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 89, 89, 108, 108, 108, 108, 108, 108, 108, 108, 794, 108, 89, 89, 89, 89, 108, 108, 108,
  108, 89, 89, 108, 108, 89, 108, 108, 108, 108, 108, 108, 773, 774, 108, 89, 89, 89, 89, 89, 89, 511, 89, 89, 89, 89,
  89, 89, 89, 89, 89, 89, 89, 108, 571, 108, 108, 108, 219, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
  0, 0, 0, 0, 0, 0, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 0, 11371, 0, 0, 20480, 20480,
  11371, 11371, 11371, 11371, 11371, 11371, 0, 0, 0, 10299, 10299, 0, 0, 0, 0, 0, 256, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89,
  89, 166, 89, 89, 89, 89, 269, 162, 89, 89, 89, 89, 89, 89, 278, 89, 89, 89, 89, 89, 89, 89, 305, 89, 89, 89, 89,
  11573, 269, 207, 108, 0, 0, 356, 0, 0, 0, 0, 0, 0, 0, 0, 0, 269, 365, 89, 89, 89, 288, 89, 89, 89, 89, 89, 89, 89, 89,
  89, 89, 89, 89, 0, 0, 207, 108, 89, 523, 89, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 533, 108, 108,
  108, 108, 108, 425, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 593, 89, 89, 89, 89, 89, 89, 89, 89, 89, 636, 89,
  89, 89, 89, 641, 89, 220, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 27648, 0,
  139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 139264, 139471, 139264, 139264,
  139264, 108, 108, 108, 108, 345, 108, 108, 108, 108, 0, 0, 0, 0, 0, 0, 0, 0, 89, 89, 89, 89, 89, 173, 89, 89, 0, 0,
  103424, 0, 0, 0, 0, 0, 0, 103424, 0, 103424, 0, 0, 0, 0, 0, 0, 0, 0, 501, 89, 503, 504, 89, 89, 89, 89, 302, 89, 89,
  89, 89, 89, 89, 89, 11573, 269, 207, 108, 104531, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240,
  0, 0, 105472, 0, 0, 0, 0, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
  139264, 0, 135168, 229376, 0, 106496, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 10299, 10299, 10299, 62, 63, 138240, 0, 270,
  139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 190464, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 230400, 139264, 139264, 139264, 0, 0, 207, 139264, 12288, 0, 0, 133120, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 138240, 201728, 215040, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 190464, 0, 197632, 198656
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  202, 206, 210, 214, 218, 223, 253, 272, 233, 676, 239, 294, 240, 271, 271, 244, 219, 294, 294, 226, 271, 288, 677,
  294, 295, 271, 228, 322, 294, 270, 261, 323, 268, 271, 251, 280, 229, 294, 287, 257, 270, 279, 265, 276, 259, 284,
  292, 299, 300, 304, 308, 575, 312, 316, 383, 329, 320, 327, 582, 333, 414, 338, 676, 549, 348, 676, 353, 359, 363,
  501, 361, 676, 369, 376, 364, 444, 388, 492, 380, 407, 387, 393, 405, 411, 372, 418, 396, 247, 420, 533, 424, 401,
  428, 438, 448, 452, 431, 441, 456, 434, 460, 399, 465, 469, 473, 658, 344, 477, 481, 485, 489, 682, 496, 500, 671,
  505, 509, 513, 515, 519, 676, 517, 521, 525, 589, 531, 559, 537, 541, 546, 542, 553, 542, 557, 563, 567, 573, 579,
  586, 569, 593, 665, 604, 597, 601, 608, 613, 612, 617, 621, 625, 629, 633, 637, 641, 676, 646, 355, 461, 676, 389,
  676, 676, 648, 676, 676, 652, 235, 676, 676, 342, 676, 340, 235, 676, 349, 676, 334, 662, 676, 669, 365, 676, 642,
  676, 675, 687, 642, 676, 675, 681, 655, 686, 527, 676, 676, 676, 676, 676, 676, 676, 235, 691, 695, 699, 702, 706,
  710, 712, 716, 720, 724, 728, 732, 736, 740, 1085, 747, 917, 1175, 1175, 1175, 806, 1175, 1172, 766, 808, 786, 775,
  775, 775, 812, 1175, 1084, 1092, 1175, 1175, 782, 1175, 806, 808, 808, 808, 770, 775, 775, 845, 1175, 798, 997, 987,
  814, 883, 808, 808, 768, 774, 813, 790, 808, 808, 775, 775, 775, 814, 775, 775, 790, 808, 808, 809, 775, 775, 775,
  775, 779, 809, 775, 775, 789, 808, 808, 811, 775, 788, 808, 808, 811, 775, 775, 775, 794, 775, 812, 808, 808, 808,
  808, 810, 811, 775, 803, 808, 775, 803, 810, 803, 826, 842, 828, 1175, 1030, 858, 861, 863, 865, 869, 873, 1175, 1032,
  900, 905, 1175, 1175, 790, 808, 808, 1185, 901, 1175, 1175, 796, 1028, 911, 1175, 1175, 1175, 816, 922, 927, 1175,
  1175, 815, 819, 1175, 1175, 821, 1073, 926, 1175, 1175, 1175, 817, 837, 931, 1175, 1175, 895, 1175, 915, 935, 945,
  956, 972, 988, 1175, 1175, 1175, 818, 1175, 1225, 965, 1175, 836, 1175, 799, 939, 1016, 955, 761, 943, 979, 762, 1175,
  837, 753, 887, 970, 987, 1175, 1175, 1175, 891, 836, 964, 797, 976, 984, 988, 1175, 848, 1175, 1175, 1004, 741, 980,
  987, 1175, 1175, 941, 953, 941, 954, 1007, 1175, 915, 1015, 946, 954, 986, 1175, 1108, 996, 986, 882, 1175, 876, 880,
  1137, 998, 1175, 1137, 1141, 1175, 1138, 741, 1021, 1021, 1141, 1175, 1139, 1000, 1137, 1011, 1175, 950, 954, 760,
  1175, 1140, 741, 1138, 999, 1175, 1139, 1000, 1020, 1138, 741, 1020, 1025, 1175, 1175, 1175, 896, 1069, 1041, 1041,
  1041, 1045, 1045, 1045, 1048, 906, 850, 1175, 1173, 1078, 1083, 1175, 822, 1074, 1079, 1175, 849, 1175, 1174, 1177,
  1089, 756, 1135, 1107, 1175, 962, 1175, 797, 1113, 1118, 1207, 1123, 1129, 1175, 1175, 1175, 935, 1117, 1206, 1122,
  1128, 1083, 742, 1173, 1103, 1134, 1184, 1175, 1175, 1033, 1152, 1145, 1166, 1128, 1083, 743, 1102, 1158, 1184, 1175,
  1175, 1035, 1175, 958, 1130, 1175, 1175, 1137, 878, 957, 1129, 1175, 1156, 1160, 1175, 1175, 1175, 992, 990, 1164,
  1124, 1175, 1014, 945, 921, 1166, 1170, 1172, 1200, 1166, 1170, 1175, 1175, 1151, 1146, 990, 1164, 1124, 1219, 1183,
  1175, 1175, 991, 1192, 1197, 1065, 1175, 1175, 989, 1056, 854, 1190, 1067, 1182, 1175, 1031, 1175, 838, 1175, 1189,
  1193, 1175, 1033, 1203, 1147, 1136, 966, 1191, 1101, 1100, 1174, 1096, 1100, 1175, 1098, 1213, 1095, 1099, 1175, 1096,
  1099, 1175, 1097, 1212, 1211, 1175, 1098, 1174, 1096, 1097, 1101, 832, 830, 834, 832, 830, 834, 1217, 1223, 1229,
  1230, 1059, 1175, 1175, 907, 1175, 1094, 1234, 1236, 1246, 1238, 1240, 1240, 1242, 1175, 1175, 1175, 1036, 889, 750,
  1175, 1175, 1177, 819, 1175, 1176, 818, 1175, 1036, 1175, 1175, 1053, 758, 1049, 820, 1037, 893, 1175, 1062, 1193,
  1173, 816, 820, 1175, 1175, 1177, 1112, 1034, 1175, 1175, 1175, 1175, 807, 1033, 1175, 1175, 1175, 1178, 1034, 1175,
  1175, 1034, 1175, 131330, 147712, 164096, 196864, 393472, 655616, 268566784, 537002240, 131328, 131328, 131328,
  131328, 134349312, 213248, 426240, 2490624, 393472, 131328, 393552, 2490624, 393472, -1065473792, -1065473792,
  -1065473792, -1065408256, -1065473792, -964806400, -964740864, -696370944, -964724480, -696305408, -964691712,
  -696289024, 131488, 132512, 197024, 459168, 917920, 983456, 25396670, 126059966, 131302846, 131564990, 131302846,
  131564990, -1040728642, 256, 131072, 2, 268435456, 536870912, 0, 0, 0, -2147483648, 0, 134218240, 16, 16, 64, 0, 3, 0,
  1, 24, 2048, 4096, 32768, 262144, 8388608, 16777216, 67108864, 134217728, 805306368, -2147483648, 128, 160, 128, 128,
  1024, 1152, 1056, 1152, 1184, 1152, 1152, 1152, 1152, 1152, 16777228, 14, 0, 8, 0, 2, 1024, 1056, 1152, 1152, 0, 128,
  128, 128, 8, 8, 0, 0, 0, 32768, 1536, 8192, 32768, 1152, 1152, 128, 128, 32, 128, 128, 128, 128, 1152, 1152, 1152, 0,
  0, 0, 2, 4, 8, 0, 0, 0, 3, 492, 1152, 1152, 128, 1152, 0, 0, 0, 2097152, 4194304, 33554432, 0, 0, 0, 4194304, 0, 2048,
  128, 1152, 128, 1152, 12, 8, 0, 16, 131072, -2147483648, 0, 0, 177211679, 177211679, 177211679, 177211711, 177244447,
  177211711, 177244479, 177260959, 177260959, 177260959, 177260959, -4608, -4608, -4608, -4608, -4544, -4544, -4544,
  -4544, -4512, -4512, -4257, 0, 1024, 8192, 786432, 2097152, 16777216, 805306368, 0, 0, 0, 128, 1048576, 176160768, 0,
  0, 1, 8, 0, 2, 0, 0, 7, 8, 0, 11776, 245760, 3932160, 264241152, -268435456, -268435456, 0, 0, 0, 16, 0, 1048576,
  8388608, 33554432, 134217728, 32768, 49152, 0, 0, 8192, -2147483648, 2097152, 12582912, 16777216, 33554432, 67108864,
  67108864, 134217728, 1879048192, -2147483648, 0, 2048, 1048576, 8388608, 134217728, 1536, 2048, 8192, 49152, 32768,
  49152, 0, 1536, 8192, 32768, 65536, 131072, 786432, 1048576, 2097152, 1536, 8192, 49152, 65536, 131072, 786432,
  2097152, 4194304, 8388608, 16777216, 100663296, 134217728, 0, 4194304, 0, 134217728, 0, 0, 0, 64, 4194304, 16777216,
  67108864, 134217728, 805306368, 1073741824, 8192, 32768, 131072, 786432, 2097152, 4194304, 16777216, 134217728,
  2097152, 4194304, 16777216, 805306368, -2147483648, 0, 0, 0, 32, 64, 24576, 524288, 8192, 32768, 786432, 2097152,
  16777216, 536870912, 0, 0, 1024, 786432, 2097152, 16777216, 134217728, 805306368, -2147483648, 524288, 16777216,
  536870912, 0, 3584, 8192, 49152, 65536, 131072, 1024, 524288, 536870912, 0, 0, 524288, 0, 524288, 0, 49152, 0, 0,
  4096, 0, 0, 0, 4, 0, 0, 0, 8, 25467623, 25467623, 25467623, 25467623, 2147352559, 2147352559, 2147352559, 2147352559,
  0, 0, 0, 228, 3, 196, 2560, 4096, 0, 4096, 4194304, 4194304, 0, 0, 64, 24576, 3145728, 4194304, 16777216, 100663296,
  0, 67108864, 25467591, 25467623, 492, 3584, 4096, 122880, 262144, 262144, 7864320, 8388608, 1056964608, 1073741824,
  1073741824, 0, 0, 0, 512, 131584, 4, 64, 128, 512, 16, 16, 0, 0, 0, 16384, 2097152, 4194304, 33554432, 67108864, 0, 0,
  4, 64, 96, 0, 0, 0, 1536, 4, 8, 96, 128, 256, 256, 1536, 2048, 4096, 24576, 524288, 7340032, 8388608, 16777216,
  100663296, 536870912, 100663296, 134217728, 268435456, 536870912, 1073741824, 0, 4096, 8388608, 16777216, 0, 0, 0,
  1024, 524288, 2097152, 16777216, 536870912, 4096, 24576, 65536, 524288, 3145728, 4194304, 4, 32, 64, 256, 1024,
  67108864, 0, 64, 8388608, 16777216, 0, 32, 0, 24576, 524288, 3145728, 4194304, 8388608, 16777216, 100663296,
  536870912, 0, 0, 67108864, 0, 0, 0, 0, 1, 2, 4, 64, 16777216, 32, 0, 0, 0, 11776, 32, 64, 24576, 3145728, 4194304,
  16777216, 33554432, 67108864, 67108864, 0, 67108864, 64, 8388608, 16777216, 32, 64, 256, 24576, 32768, 65536, 262144,
  524288, 4194304, 33554432, 67108864, 67108864, 0, 0, 2097152, 4194304, 0, 0, 67108864, 64, 2097152, 4194304, 0,
  4194304, 0, 8388608, 0, 4194304, 4194304, 4194304, 4194304, 233, 233, 235, 249, 235, 235, 15, 15, 15, 15, 239, 0, 235,
  235, 235, 235
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "NCName",
  "QName",
  "S",
  "CommentContents",
  "Wildcard",
  "EOF",
  "'!'",
  "'!='",
  "'#'",
  "'$'",
  "'('",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "':)'",
  "'::'",
  "':='",
  "'<'",
  "'<<'",
  "'<='",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'@'",
  "'['",
  "']'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'attribute'",
  "'cast'",
  "'castable'",
  "'child'",
  "'comment'",
  "'descendant'",
  "'descendant-or-self'",
  "'div'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty-sequence'",
  "'eq'",
  "'every'",
  "'except'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'in'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'le'",
  "'let'",
  "'lt'",
  "'mod'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'node'",
  "'of'",
  "'or'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'typeswitch'",
  "'union'",
  "'{'",
  "'|'",
  "'||'",
  "'}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 1024
    return
      if ($result != 0) then
      (
        $result mod 128 - 1,
        $begin,
        $end - $result idiv 128
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 3
    let $i0 := $t * 806 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(13, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 27) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 9) then                  (: CommentContents :)
            let $state := p:shiftT(9, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:shiftT(17, $input, $state)                (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:shiftT(27, $input, $state)                (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 8) then                        (: S^WS :)
      let $state := p:shiftT(8, $input, $state)             (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'is' :)
      let $state := p:shift(71, $input, $state)             (: 'is' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: '<<' :)
      let $state := p:shift(31, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(36, $input, $state)             (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: '=' :)
      let $state := p:shift(33, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: '!=' :)
      let $state := p:shift(13, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '<' :)
      let $state := p:shift(30, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: '<=' :)
      let $state := p:shift(32, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '>' :)
      let $state := p:shift(34, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(35, $input, $state)             (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 57) then                       (: 'eq' :)
      let $state := p:shift(57, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ne' :)
      let $state := p:shift(79, $input, $state)             (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'lt' :)
      let $state := p:shift(75, $input, $state)             (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'le' :)
      let $state := p:shift(73, $input, $state)             (: 'le' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'gt' :)
      let $state := p:shift(65, $input, $state)             (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(64, $input, $state)             (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TypeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleTypeName", $count, $begin, $end)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' |
                                                               ']' | 'and' | 'castable' | 'div' | 'else' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:shift(37, $input, $state)             (: '?' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                               'union' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 39) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '@' :)
      let $state := p:shift(38, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(37, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'child' :)
      let $state := p:shift(48, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'descendant' :)
      let $state := p:shift(50, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 45) then                       (: 'attribute' :)
      let $state := p:shift(45, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'self' :)
      let $state := p:shift(91, $input, $state)             (: 'self' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: 'descendant-or-self' :)
      let $state := p:shift(51, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: 'following-sibling' :)
      let $state := p:shift(61, $input, $state)             (: 'following-sibling' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: 'following' :)
      let $state := p:shift(60, $input, $state)             (: 'following' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(77, $input, $state)             (: 'namespace' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 45) then                           (: 'attribute' :)
      let $state := p:lookahead2W(33, $input, $state)       (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (48,                           (: 'child' :)
                              50,                           (: 'descendant' :)
                              51,                           (: 'descendant-or-self' :)
                              60,                           (: 'following' :)
                              61,                           (: 'following-sibling' :)
                              77,                           (: 'namespace' :)
                              91)) then                     (: 'self' :)
      let $state := p:lookahead2W(31, $input, $state)       (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 3629                           (: 'attribute' '::' :)
          or $state[$p:lk] = 3632                           (: 'child' '::' :)
          or $state[$p:lk] = 3634                           (: 'descendant' '::' :)
          or $state[$p:lk] = 3635                           (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 3644                           (: 'following' '::' :)
          or $state[$p:lk] = 3645                           (: 'following-sibling' '::' :)
          or $state[$p:lk] = 3661                           (: 'namespace' '::' :)
          or $state[$p:lk] = 3675) then                     (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(37, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(24, $input, $state)                 (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: Wildcard :)
      let $state := p:shift(10, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (45,                                (: 'attribute' :)
                         49,                                (: 'comment' :)
                         53,                                (: 'document-node' :)
                         54,                                (: 'element' :)
                         78,                                (: 'namespace-node' :)
                         80,                                (: 'node' :)
                         86,                                (: 'processing-instruction' :)
                         89,                                (: 'schema-attribute' :)
                         90,                                (: 'schema-element' :)
                         94)) then                          (: 'text' :)
      let $state := p:lookahead2W(30, $input, $state)       (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2093                           (: 'attribute' '(' :)
          or $state[$p:lk] = 2097                           (: 'comment' '(' :)
          or $state[$p:lk] = 2101                           (: 'document-node' '(' :)
          or $state[$p:lk] = 2102                           (: 'element' '(' :)
          or $state[$p:lk] = 2126                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 2128                           (: 'node' '(' :)
          or $state[$p:lk] = 2134                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 2137                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 2138                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 2142) then                     (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'parent' :)
      let $state := p:shift(83, $input, $state)             (: 'parent' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 41) then                       (: 'ancestor' :)
      let $state := p:shift(41, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'preceding-sibling' :)
      let $state := p:shift(85, $input, $state)             (: 'preceding-sibling' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'preceding' :)
      let $state := p:shift(84, $input, $state)             (: 'preceding' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(42, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(6, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(28, $input, $state)             (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 24) then                       (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(37, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (41,                                (: 'ancestor' :)
                         42,                                (: 'ancestor-or-self' :)
                         83,                                (: 'parent' :)
                         84,                                (: 'preceding' :)
                         85)) then                          (: 'preceding-sibling' :)
      let $state := p:lookahead2W(31, $input, $state)       (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 24                             (: '..' :)
          or $state[$p:lk] = 3625                           (: 'ancestor' '::' :)
          or $state[$p:lk] = 3626                           (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 3667                           (: 'parent' '::' :)
          or $state[$p:lk] = 3668                           (: 'preceding' '::' :)
          or $state[$p:lk] = 3669) then                     (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                               'union' | '|' | '||' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(39, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(40, $input, $state)                 (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(100, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(103, $input, $state)                (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:shift(37, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 19) then                       (: '*' :)
      let $state := p:shift(19, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(20, $input, $state)             (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(38, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedItemType", $count, $begin, $end)
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicOrUnionType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(16, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 21) then                         (: ',' :)
        $state
      else
        let $state := p:shift(21, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(38, $input, $state)     (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(63, $input, $state)                 (: 'function' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(39, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(8, $input, $state)            (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shift(44, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(38, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedFunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(63, $input, $state)                 (: 'function' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(5, $input, $state)            (: S^WS | ('(' ':') | '*' :)
  let $state := p:shift(19, $input, $state)                 (: '*' :)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyFunctionTest", $count, $begin, $end)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 63) then                           (: 'function' :)
      let $state := p:lookahead2W(3, $input, $state)        (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 2111) then                     (: 'function' '(' :)
          let $state := p:lookahead3W(41, $input, $state)   (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 313407) then                   (: 'function' '(' '*' :)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(80, $input, $state)                 (: 'node' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(78, $input, $state)                 (: 'namespace-node' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceNodeTest", $count, $begin, $end)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(94, $input, $state)                 (: 'text' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(49, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(86, $input, $state)                 (: 'processing-instruction' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | NCName | S^WS | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 6) then                    (: NCName :)
          let $state := p:shift(6, $input, $state)          (: NCName :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(4, $input, $state)          (: StringLiteral :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(89, $input, $state)                 (: 'schema-attribute' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '*' :)
      let $state := p:shift(19, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(45, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(16, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: ',' :)
          let $state := p:shift(21, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(36, $input, $state)   (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(90, $input, $state)                 (: 'schema-element' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 19) then                       (: '*' :)
      let $state := p:shift(19, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(54, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(16, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 21) then                   (: ',' :)
          let $state := p:shift(21, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(36, $input, $state)   (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(17, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 37) then               (: '?' :)
              let $state := p:shift(37, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(53, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 54) then                   (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 45) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (45,                                (: 'attribute' :)
                         49,                                (: 'comment' :)
                         53,                                (: 'document-node' :)
                         54,                                (: 'element' :)
                         63,                                (: 'function' :)
                         72,                                (: 'item' :)
                         78,                                (: 'namespace-node' :)
                         80,                                (: 'node' :)
                         86,                                (: 'processing-instruction' :)
                         89,                                (: 'schema-attribute' :)
                         90,                                (: 'schema-element' :)
                         94)) then                          (: 'text' :)
      let $state := p:lookahead2W(27, $input, $state)       (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'and' | 'div' | 'else' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                               'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2093                           (: 'attribute' '(' :)
          or $state[$p:lk] = 2097                           (: 'comment' '(' :)
          or $state[$p:lk] = 2101                           (: 'document-node' '(' :)
          or $state[$p:lk] = 2102                           (: 'element' '(' :)
          or $state[$p:lk] = 2126                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 2128                           (: 'node' '(' :)
          or $state[$p:lk] = 2134                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 2137                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 2138                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 2142) then                     (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 2120) then                     (: 'item' '(' :)
      let $state := p:shift(72, $input, $state)             (: 'item' :)
      let $state := p:lookahead1W(3, $input, $state)        (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(16, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(4, $input, $state)        (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(18, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 2111) then                     (: 'function' '(' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 16) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 56) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(27, $input, $state)       (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'and' | 'div' | 'else' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                               'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2104) then                     (: 'empty-sequence' '(' :)
      let $state := p:shift(56, $input, $state)             (: 'empty-sequence' :)
      let $state := p:lookahead1W(3, $input, $state)        (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(16, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(4, $input, $state)        (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(18, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' |
                                                               ']' | 'and' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'union' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 19                         (: '*' :)
              or $state[$p:l1] = 20                         (: '+' :)
              or $state[$p:l1] = 37) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(44, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(38, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(15, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(16, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 21) then                         (: ',' :)
        $state
      else
        let $state := p:shift(21, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(2, $input, $state)      (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(63, $input, $state)                 (: 'function' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(15, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(18, $input, $state)           (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: 'as' :)
      let $state := p:shift(44, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(38, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(12, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InlineFunctionExpr", $count, $begin, $end)
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(1, $input, $state)            (: S^WS | '#' | ('(' ':') :)
  let $state := p:shift(14, $input, $state)                 (: '#' :)
  let $state := p:lookahead1W(0, $input, $state)            (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(1, $input, $state)                  (: IntegerLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamedFunctionRef", $count, $begin, $end)
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: 'function' :)
      let $state := p:parse-InlineFunctionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NamedFunctionRef($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionItemExpr", $count, $begin, $end)
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(37, $input, $state)                 (: '?' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentPlaceholder", $count, $begin, $end)
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '?' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Argument", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(16, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 21) then                         (: ',' :)
        $state
      else
        let $state := p:shift(21, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(46, $input, $state)     (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(47, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | ')' | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentList", $count, $begin, $end)
};

(:~
 : Parse FunctionEQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:shift(5, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionEQName", $count, $begin, $end)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArgumentList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(23, $input, $state)                 (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(45, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | ')' | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 18) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(15, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:shift(1, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:shift(2, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(3, $input, $state)              (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:shift(4, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (5,                                 (: URIQualifiedName :)
                         7,                                 (: QName^Token :)
                         41,                                (: 'ancestor' :)
                         42,                                (: 'ancestor-or-self' :)
                         43,                                (: 'and' :)
                         46,                                (: 'cast' :)
                         47,                                (: 'castable' :)
                         48,                                (: 'child' :)
                         50,                                (: 'descendant' :)
                         51,                                (: 'descendant-or-self' :)
                         52,                                (: 'div' :)
                         55,                                (: 'else' :)
                         57,                                (: 'eq' :)
                         58,                                (: 'every' :)
                         59,                                (: 'except' :)
                         60,                                (: 'following' :)
                         61,                                (: 'following-sibling' :)
                         62,                                (: 'for' :)
                         64,                                (: 'ge' :)
                         65,                                (: 'gt' :)
                         66,                                (: 'idiv' :)
                         69,                                (: 'instance' :)
                         70,                                (: 'intersect' :)
                         71,                                (: 'is' :)
                         73,                                (: 'le' :)
                         74,                                (: 'let' :)
                         75,                                (: 'lt' :)
                         76,                                (: 'mod' :)
                         77,                                (: 'namespace' :)
                         79,                                (: 'ne' :)
                         82,                                (: 'or' :)
                         83,                                (: 'parent' :)
                         84,                                (: 'preceding' :)
                         85,                                (: 'preceding-sibling' :)
                         87,                                (: 'return' :)
                         88,                                (: 'satisfies' :)
                         91,                                (: 'self' :)
                         92,                                (: 'some' :)
                         96,                                (: 'to' :)
                         97,                                (: 'treat' :)
                         99)) then                          (: 'union' :)
      let $state := p:lookahead2W(14, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 15) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 16) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 23) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 2053                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 2055                           (: QName^Token '(' :)
          or $state[$p:lk] = 2089                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 2090                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 2091                           (: 'and' '(' :)
          or $state[$p:lk] = 2094                           (: 'cast' '(' :)
          or $state[$p:lk] = 2095                           (: 'castable' '(' :)
          or $state[$p:lk] = 2096                           (: 'child' '(' :)
          or $state[$p:lk] = 2098                           (: 'descendant' '(' :)
          or $state[$p:lk] = 2099                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 2100                           (: 'div' '(' :)
          or $state[$p:lk] = 2103                           (: 'else' '(' :)
          or $state[$p:lk] = 2105                           (: 'eq' '(' :)
          or $state[$p:lk] = 2106                           (: 'every' '(' :)
          or $state[$p:lk] = 2107                           (: 'except' '(' :)
          or $state[$p:lk] = 2108                           (: 'following' '(' :)
          or $state[$p:lk] = 2109                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 2110                           (: 'for' '(' :)
          or $state[$p:lk] = 2112                           (: 'ge' '(' :)
          or $state[$p:lk] = 2113                           (: 'gt' '(' :)
          or $state[$p:lk] = 2114                           (: 'idiv' '(' :)
          or $state[$p:lk] = 2117                           (: 'instance' '(' :)
          or $state[$p:lk] = 2118                           (: 'intersect' '(' :)
          or $state[$p:lk] = 2119                           (: 'is' '(' :)
          or $state[$p:lk] = 2121                           (: 'le' '(' :)
          or $state[$p:lk] = 2122                           (: 'let' '(' :)
          or $state[$p:lk] = 2123                           (: 'lt' '(' :)
          or $state[$p:lk] = 2124                           (: 'mod' '(' :)
          or $state[$p:lk] = 2125                           (: 'namespace' '(' :)
          or $state[$p:lk] = 2127                           (: 'ne' '(' :)
          or $state[$p:lk] = 2130                           (: 'or' '(' :)
          or $state[$p:lk] = 2131                           (: 'parent' '(' :)
          or $state[$p:lk] = 2132                           (: 'preceding' '(' :)
          or $state[$p:lk] = 2133                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 2135                           (: 'return' '(' :)
          or $state[$p:lk] = 2136                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 2139                           (: 'self' '(' :)
          or $state[$p:lk] = 2140                           (: 'some' '(' :)
          or $state[$p:lk] = 2144                           (: 'to' '(' :)
          or $state[$p:lk] = 2145                           (: 'treat' '(' :)
          or $state[$p:lk] = 2147) then                     (: 'union' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 16                               (: '(' :)
      and $state[$p:l1] != 39) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 39) then                 (: '[' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpr", $count, $begin, $end)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 63) then                           (: 'function' :)
      let $state := p:lookahead2W(30, $input, $state)       (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (41,                           (: 'ancestor' :)
                              42,                           (: 'ancestor-or-self' :)
                              48,                           (: 'child' :)
                              50,                           (: 'descendant' :)
                              51,                           (: 'descendant-or-self' :)
                              60,                           (: 'following' :)
                              61,                           (: 'following-sibling' :)
                              77,                           (: 'namespace' :)
                              83,                           (: 'parent' :)
                              84,                           (: 'preceding' :)
                              85,                           (: 'preceding-sibling' :)
                              91)) then                     (: 'self' :)
      let $state := p:lookahead2W(35, $input, $state)       (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                               'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              7,                            (: QName^Token :)
                              43,                           (: 'and' :)
                              46,                           (: 'cast' :)
                              47,                           (: 'castable' :)
                              52,                           (: 'div' :)
                              55,                           (: 'else' :)
                              57,                           (: 'eq' :)
                              58,                           (: 'every' :)
                              59,                           (: 'except' :)
                              62,                           (: 'for' :)
                              64,                           (: 'ge' :)
                              65,                           (: 'gt' :)
                              66,                           (: 'idiv' :)
                              69,                           (: 'instance' :)
                              70,                           (: 'intersect' :)
                              71,                           (: 'is' :)
                              73,                           (: 'le' :)
                              74,                           (: 'let' :)
                              75,                           (: 'lt' :)
                              76,                           (: 'mod' :)
                              79,                           (: 'ne' :)
                              82,                           (: 'or' :)
                              87,                           (: 'return' :)
                              88,                           (: 'satisfies' :)
                              92,                           (: 'some' :)
                              96,                           (: 'to' :)
                              97,                           (: 'treat' :)
                              99)) then                     (: 'union' :)
      let $state := p:lookahead2W(32, $input, $state)       (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4                              (: StringLiteral :)
          or $state[$p:lk] = 15                             (: '$' :)
          or $state[$p:lk] = 16                             (: '(' :)
          or $state[$p:lk] = 23                             (: '.' :)
          or $state[$p:lk] = 1797                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 1799                           (: QName^Token '#' :)
          or $state[$p:lk] = 1833                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 1834                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 1835                           (: 'and' '#' :)
          or $state[$p:lk] = 1838                           (: 'cast' '#' :)
          or $state[$p:lk] = 1839                           (: 'castable' '#' :)
          or $state[$p:lk] = 1840                           (: 'child' '#' :)
          or $state[$p:lk] = 1842                           (: 'descendant' '#' :)
          or $state[$p:lk] = 1843                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 1844                           (: 'div' '#' :)
          or $state[$p:lk] = 1847                           (: 'else' '#' :)
          or $state[$p:lk] = 1849                           (: 'eq' '#' :)
          or $state[$p:lk] = 1850                           (: 'every' '#' :)
          or $state[$p:lk] = 1851                           (: 'except' '#' :)
          or $state[$p:lk] = 1852                           (: 'following' '#' :)
          or $state[$p:lk] = 1853                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 1854                           (: 'for' '#' :)
          or $state[$p:lk] = 1856                           (: 'ge' '#' :)
          or $state[$p:lk] = 1857                           (: 'gt' '#' :)
          or $state[$p:lk] = 1858                           (: 'idiv' '#' :)
          or $state[$p:lk] = 1861                           (: 'instance' '#' :)
          or $state[$p:lk] = 1862                           (: 'intersect' '#' :)
          or $state[$p:lk] = 1863                           (: 'is' '#' :)
          or $state[$p:lk] = 1865                           (: 'le' '#' :)
          or $state[$p:lk] = 1866                           (: 'let' '#' :)
          or $state[$p:lk] = 1867                           (: 'lt' '#' :)
          or $state[$p:lk] = 1868                           (: 'mod' '#' :)
          or $state[$p:lk] = 1869                           (: 'namespace' '#' :)
          or $state[$p:lk] = 1871                           (: 'ne' '#' :)
          or $state[$p:lk] = 1874                           (: 'or' '#' :)
          or $state[$p:lk] = 1875                           (: 'parent' '#' :)
          or $state[$p:lk] = 1876                           (: 'preceding' '#' :)
          or $state[$p:lk] = 1877                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 1879                           (: 'return' '#' :)
          or $state[$p:lk] = 1880                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 1883                           (: 'self' '#' :)
          or $state[$p:lk] = 1884                           (: 'some' '#' :)
          or $state[$p:lk] = 1888                           (: 'to' '#' :)
          or $state[$p:lk] = 1889                           (: 'treat' '#' :)
          or $state[$p:lk] = 1891                           (: 'union' '#' :)
          or $state[$p:lk] = 2053                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 2055                           (: QName^Token '(' :)
          or $state[$p:lk] = 2089                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 2090                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 2091                           (: 'and' '(' :)
          or $state[$p:lk] = 2094                           (: 'cast' '(' :)
          or $state[$p:lk] = 2095                           (: 'castable' '(' :)
          or $state[$p:lk] = 2096                           (: 'child' '(' :)
          or $state[$p:lk] = 2098                           (: 'descendant' '(' :)
          or $state[$p:lk] = 2099                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 2100                           (: 'div' '(' :)
          or $state[$p:lk] = 2103                           (: 'else' '(' :)
          or $state[$p:lk] = 2105                           (: 'eq' '(' :)
          or $state[$p:lk] = 2106                           (: 'every' '(' :)
          or $state[$p:lk] = 2107                           (: 'except' '(' :)
          or $state[$p:lk] = 2108                           (: 'following' '(' :)
          or $state[$p:lk] = 2109                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 2110                           (: 'for' '(' :)
          or $state[$p:lk] = 2111                           (: 'function' '(' :)
          or $state[$p:lk] = 2112                           (: 'ge' '(' :)
          or $state[$p:lk] = 2113                           (: 'gt' '(' :)
          or $state[$p:lk] = 2114                           (: 'idiv' '(' :)
          or $state[$p:lk] = 2117                           (: 'instance' '(' :)
          or $state[$p:lk] = 2118                           (: 'intersect' '(' :)
          or $state[$p:lk] = 2119                           (: 'is' '(' :)
          or $state[$p:lk] = 2121                           (: 'le' '(' :)
          or $state[$p:lk] = 2122                           (: 'let' '(' :)
          or $state[$p:lk] = 2123                           (: 'lt' '(' :)
          or $state[$p:lk] = 2124                           (: 'mod' '(' :)
          or $state[$p:lk] = 2125                           (: 'namespace' '(' :)
          or $state[$p:lk] = 2127                           (: 'ne' '(' :)
          or $state[$p:lk] = 2130                           (: 'or' '(' :)
          or $state[$p:lk] = 2131                           (: 'parent' '(' :)
          or $state[$p:lk] = 2132                           (: 'preceding' '(' :)
          or $state[$p:lk] = 2133                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 2135                           (: 'return' '(' :)
          or $state[$p:lk] = 2136                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 2139                           (: 'self' '(' :)
          or $state[$p:lk] = 2140                           (: 'some' '(' :)
          or $state[$p:lk] = 2144                           (: 'to' '(' :)
          or $state[$p:lk] = 2145                           (: 'treat' '(' :)
          or $state[$p:lk] = 2147) then                     (: 'union' '(' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25                                 (: '/' :)
    and $state[$p:l1] != 26) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25) then                   (: '/' :)
          let $state := p:shift(25, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(26, $input, $state)         (: '//' :)
          return $state
      let $state := p:lookahead1W(42, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '.' | '..' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25) then                       (: '/' :)
      let $state := p:shift(25, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(48, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '.' | '..' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '@' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 11                         (: EOF :)
              or $state[$p:l1] = 12                         (: '!' :)
              or $state[$p:l1] = 13                         (: '!=' :)
              or $state[$p:l1] = 18                         (: ')' :)
              or $state[$p:l1] = 19                         (: '*' :)
              or $state[$p:l1] = 20                         (: '+' :)
              or $state[$p:l1] = 21                         (: ',' :)
              or $state[$p:l1] = 22                         (: '-' :)
              or $state[$p:l1] = 30                         (: '<' :)
              or $state[$p:l1] = 31                         (: '<<' :)
              or $state[$p:l1] = 32                         (: '<=' :)
              or $state[$p:l1] = 33                         (: '=' :)
              or $state[$p:l1] = 34                         (: '>' :)
              or $state[$p:l1] = 35                         (: '>=' :)
              or $state[$p:l1] = 36                         (: '>>' :)
              or $state[$p:l1] = 40                         (: ']' :)
              or $state[$p:l1] = 101                        (: '|' :)
              or $state[$p:l1] = 102                        (: '||' :)
              or $state[$p:l1] = 103) then                  (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 26) then                       (: '//' :)
      let $state := p:shift(26, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(42, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '.' | '..' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 12) then                           (: '!' :)
      $state
    else
      let $state := p:shift(12, $input, $state)             (: '!' :)
      let $state := p:lookahead1W(43, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '.' | '..' | '/' |
                                                               '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleMapExpr", $count, $begin, $end)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SimpleMapExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(44, $input, $state)         (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
    return
      if ($state[$p:l1] != 20                               (: '+' :)
      and $state[$p:l1] != 22) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 22) then                 (: '-' :)
            let $state := p:shift(22, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(20, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: 'cast' :)
      let $state := p:shift(46, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(8, $input, $state)        (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(44, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(36, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                               'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: 'castable' :)
      let $state := p:shift(47, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(8, $input, $state)        (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(44, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(36, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                               'treat' | 'union' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 97) then                       (: 'treat' :)
      let $state := p:shift(97, $input, $state)             (: 'treat' :)
      let $state := p:lookahead1W(8, $input, $state)        (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(44, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(38, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                               'union' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: 'instance' :)
      let $state := p:shift(69, $input, $state)             (: 'instance' :)
      let $state := p:lookahead1W(10, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(81, $input, $state)             (: 'of' :)
      let $state := p:lookahead1W(38, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(22, $input, $state)         (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'union' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 59                               (: 'except' :)
      and $state[$p:l1] != 70) then                         (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 70) then                 (: 'intersect' :)
            let $state := p:shift(70, $input, $state)       (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(59, $input, $state)       (: 'except' :)
            return $state
        let $state := p:lookahead1W(44, $input, $state)     (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 99                                 (: 'union' :)
    and $state[$p:l1] != 101) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 99) then                   (: 'union' :)
          let $state := p:shift(99, $input, $state)         (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(101, $input, $state)        (: '|' :)
          return $state
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 19                                 (: '*' :)
    and $state[$p:l1] != 52                                 (: 'div' :)
    and $state[$p:l1] != 66                                 (: 'idiv' :)
    and $state[$p:l1] != 76) then                           (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 19) then                   (: '*' :)
          let $state := p:shift(19, $input, $state)         (: '*' :)
          return $state
        else if ($state[$p:l1] = 52) then                   (: 'div' :)
          let $state := p:shift(52, $input, $state)         (: 'div' :)
          return $state
        else if ($state[$p:l1] = 66) then                   (: 'idiv' :)
          let $state := p:shift(66, $input, $state)         (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(76, $input, $state)         (: 'mod' :)
          return $state
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 20                                 (: '+' :)
    and $state[$p:l1] != 22) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 20) then                   (: '+' :)
          let $state := p:shift(20, $input, $state)         (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(22, $input, $state)         (: '-' :)
          return $state
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 96) then                       (: 'to' :)
      let $state := p:shift(96, $input, $state)             (: 'to' :)
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 102) then                          (: '||' :)
      $state
    else
      let $state := p:shift(102, $input, $state)            (: '||' :)
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConcatExpr", $count, $begin, $end)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 11                            (: EOF :)
         and $state[$p:l1] != 18                            (: ')' :)
         and $state[$p:l1] != 21                            (: ',' :)
         and $state[$p:l1] != 40                            (: ']' :)
         and $state[$p:l1] != 43                            (: 'and' :)
         and $state[$p:l1] != 55                            (: 'else' :)
         and $state[$p:l1] != 82                            (: 'or' :)
         and $state[$p:l1] != 87                            (: 'return' :)
         and $state[$p:l1] != 88                            (: 'satisfies' :)
         and $state[$p:l1] != 103) then                     (: '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 57                         (: 'eq' :)
              or $state[$p:l1] = 64                         (: 'ge' :)
              or $state[$p:l1] = 65                         (: 'gt' :)
              or $state[$p:l1] = 73                         (: 'le' :)
              or $state[$p:l1] = 75                         (: 'lt' :)
              or $state[$p:l1] = 79) then                   (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 31                         (: '<<' :)
              or $state[$p:l1] = 36                         (: '>>' :)
              or $state[$p:l1] = 71) then                   (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 43) then                           (: 'and' :)
      $state
    else
      let $state := p:shift(43, $input, $state)             (: 'and' :)
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 82) then                           (: 'or' :)
      $state
    else
      let $state := p:shift(82, $input, $state)             (: 'or' :)
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(67, $input, $state)                 (: 'if' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(16, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(18, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(11, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(95, $input, $state)                 (: 'then' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:shift(55, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: ',' :)
      $state
    else
      let $state := p:shift(21, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(2, $input, $state)        (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(15, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(36, $input, $state)       (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(9, $input, $state)        (: S^WS | ('(' ':') | 'in' :)
      let $state := p:shift(68, $input, $state)             (: 'in' :)
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'some' :)
      let $state := p:shift(92, $input, $state)             (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(58, $input, $state)             (: 'every' :)
      return $state
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(15, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(68, $input, $state)                 (: 'in' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(88, $input, $state)                 (: 'satisfies' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Parse SimpleLetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleLetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(15, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(7, $input, $state)            (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(29, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleLetBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SimpleLetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleLetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: ',' :)
      $state
    else
      let $state := p:shift(21, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(2, $input, $state)        (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SimpleLetBinding($input, $state)
      return p:parse-SimpleLetClause-1($input, $state)
};

(:~
 : Parse SimpleLetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleLetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(74, $input, $state)                 (: 'let' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SimpleLetBinding($input, $state)
  let $state := p:parse-SimpleLetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleLetClause", $count, $begin, $end)
};

(:~
 : Parse LetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SimpleLetClause($input, $state)
  let $state := p:shift(87, $input, $state)                 (: 'return' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetExpr", $count, $begin, $end)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 7) then                        (: QName^Token :)
      let $state := p:shift(7, $input, $state)              (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 41) then                       (: 'ancestor' :)
      let $state := p:shift(41, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(42, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 43) then                       (: 'and' :)
      let $state := p:shift(43, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: 'cast' :)
      let $state := p:shift(46, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 47) then                       (: 'castable' :)
      let $state := p:shift(47, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: 'child' :)
      let $state := p:shift(48, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'descendant' :)
      let $state := p:shift(50, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: 'descendant-or-self' :)
      let $state := p:shift(51, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 52) then                       (: 'div' :)
      let $state := p:shift(52, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'else' :)
      let $state := p:shift(55, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'eq' :)
      let $state := p:shift(57, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: 'every' :)
      let $state := p:shift(58, $input, $state)             (: 'every' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'except' :)
      let $state := p:shift(59, $input, $state)             (: 'except' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: 'following' :)
      let $state := p:shift(60, $input, $state)             (: 'following' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: 'following-sibling' :)
      let $state := p:shift(61, $input, $state)             (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'for' :)
      let $state := p:shift(62, $input, $state)             (: 'for' :)
      return $state
    else if ($state[$p:l1] = 64) then                       (: 'ge' :)
      let $state := p:shift(64, $input, $state)             (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'gt' :)
      let $state := p:shift(65, $input, $state)             (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'idiv' :)
      let $state := p:shift(66, $input, $state)             (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'instance' :)
      let $state := p:shift(69, $input, $state)             (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'intersect' :)
      let $state := p:shift(70, $input, $state)             (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'is' :)
      let $state := p:shift(71, $input, $state)             (: 'is' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'le' :)
      let $state := p:shift(73, $input, $state)             (: 'le' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'let' :)
      let $state := p:shift(74, $input, $state)             (: 'let' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'lt' :)
      let $state := p:shift(75, $input, $state)             (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'mod' :)
      let $state := p:shift(76, $input, $state)             (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'namespace' :)
      let $state := p:shift(77, $input, $state)             (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'ne' :)
      let $state := p:shift(79, $input, $state)             (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'or' :)
      let $state := p:shift(82, $input, $state)             (: 'or' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'parent' :)
      let $state := p:shift(83, $input, $state)             (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'preceding' :)
      let $state := p:shift(84, $input, $state)             (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'preceding-sibling' :)
      let $state := p:shift(85, $input, $state)             (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'return' :)
      let $state := p:shift(87, $input, $state)             (: 'return' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'satisfies' :)
      let $state := p:shift(88, $input, $state)             (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'self' :)
      let $state := p:shift(91, $input, $state)             (: 'self' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'some' :)
      let $state := p:shift(92, $input, $state)             (: 'some' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'to' :)
      let $state := p:shift(96, $input, $state)             (: 'to' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'treat' :)
      let $state := p:shift(97, $input, $state)             (: 'treat' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(99, $input, $state)             (: 'union' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: 'attribute' :)
      let $state := p:shift(45, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'comment' :)
      let $state := p:shift(49, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: 'document-node' :)
      let $state := p:shift(53, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'element' :)
      let $state := p:shift(54, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'empty-sequence' :)
      let $state := p:shift(56, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 63) then                       (: 'function' :)
      let $state := p:shift(63, $input, $state)             (: 'function' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'if' :)
      let $state := p:shift(67, $input, $state)             (: 'if' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'item' :)
      let $state := p:shift(72, $input, $state)             (: 'item' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'namespace-node' :)
      let $state := p:shift(78, $input, $state)             (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'node' :)
      let $state := p:shift(80, $input, $state)             (: 'node' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'processing-instruction' :)
      let $state := p:shift(86, $input, $state)             (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'schema-attribute' :)
      let $state := p:shift(89, $input, $state)             (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'schema-element' :)
      let $state := p:shift(90, $input, $state)             (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'switch' :)
      let $state := p:shift(93, $input, $state)             (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'text' :)
      let $state := p:shift(94, $input, $state)             (: 'text' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'typeswitch' :)
      let $state := p:shift(98, $input, $state)             (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:shift(5, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EQName", $count, $begin, $end)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Parse SimpleForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(15, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(36, $input, $state)           (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'attribute' |
                                                               'cast' | 'castable' | 'child' | 'comment' |
                                                               'descendant' | 'descendant-or-self' | 'div' |
                                                               'document-node' | 'element' | 'else' | 'empty-sequence' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'or' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(9, $input, $state)            (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(68, $input, $state)                 (: 'in' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleForBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SimpleForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: ',' :)
      $state
    else
      let $state := p:shift(21, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(2, $input, $state)        (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SimpleForBinding($input, $state)
      return p:parse-SimpleForClause-1($input, $state)
};

(:~
 : Parse SimpleForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:shift(62, $input, $state)                 (: 'for' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SimpleForBinding($input, $state)
  let $state := p:parse-SimpleForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleForClause", $count, $begin, $end)
};

(:~
 : Parse ForExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SimpleForClause($input, $state)
  let $state := p:shift(87, $input, $state)                 (: 'return' :)
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForExpr", $count, $begin, $end)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 67) then                           (: 'if' :)
      let $state := p:lookahead2W(30, $input, $state)       (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                               'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (58,                           (: 'every' :)
                              62,                           (: 'for' :)
                              74,                           (: 'let' :)
                              92)) then                     (: 'some' :)
      let $state := p:lookahead2W(34, $input, $state)       (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                               'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1982) then                     (: 'for' '$' :)
      let $state := p:parse-ForExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 1994) then                     (: 'let' '$' :)
      let $state := p:parse-LetExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 1978                           (: 'every' '$' :)
          or $state[$p:lk] = 2012) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 2115) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 21) then                           (: ',' :)
      $state
    else
      let $state := p:shift(21, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(44, $input, $state)       (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Parse XPath.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XPath($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(44, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '(' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'attribute' | 'cast' |
                                                               'castable' | 'child' | 'comment' | 'descendant' |
                                                               'descendant-or-self' | 'div' | 'document-node' |
                                                               'element' | 'else' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'if' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' |
                                                               'or' | 'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:shift(11, $input, $state)                 (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XPath", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:shift, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shiftT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 8) then                                 (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 17) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 128 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 16384 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol XPath from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XPath($s as xs:string) as item()*
{
  let $state := p:parse-XPath($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
