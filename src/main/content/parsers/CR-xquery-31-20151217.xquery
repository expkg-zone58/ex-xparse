xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun Mar 27, 2016 22:57 (UTC+01) by REx v5.37 which is Copyright (c) 1979-2016 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: CR-xquery-31-20151217.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the CR-xquery-31-20151217 grammar.
 :)
module namespace p="CR-xquery-31-20151217";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 40, 41,
  42, 43, 44, 45, 46, 47, 48, 49, 30, 30, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 38,
  38
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 355, 371,
  387, 423, 423, 423, 415, 339, 331, 339, 331, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 440, 440, 440, 440, 440, 440, 440, 324, 339, 339, 339, 339, 339, 339, 339, 339, 401, 423, 423, 424, 422,
  423, 423, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 338, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 69, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 38, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
  30, 30, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  38, 38, 38, 30, 30, 38, 38, 38, 38, 38, 38, 38, 68, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 38, 30, 38, 30, 30, 38
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 47108, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205,
  11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 8960, 8976, 9043, 8998, 9043, 9043, 9043, 9012, 9041,
  9043, 8982, 9043, 9025, 9059, 11205, 14818, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316,
  9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205,
  11205, 14709, 10483, 10510, 10524, 11205, 10494, 11913, 11205, 14818, 11205, 10536, 24400, 18143, 14389, 11205, 11205,
  12700, 9235, 9993, 10552, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708,
  9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545,
  27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741,
  9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375,
  9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993,
  13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 10578,
  11205, 15859, 11205, 11205, 10606, 10258, 10599, 11205, 11205, 15697, 10627, 11902, 11205, 14818, 11205, 17869, 11205,
  18143, 14389, 11205, 11205, 12700, 9235, 9993, 10247, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228,
  9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542,
  9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833,
  14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888,
  9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171,
  10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205,
  11205, 11205, 10664, 10741, 11205, 14557, 10715, 11205, 10741, 14709, 10693, 10733, 10706, 10744, 10760, 11913, 11205,
  21648, 11205, 22171, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10155, 9102, 9123, 9162, 21004, 11205,
  18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368,
  9405, 9464, 10284, 9513, 9542, 10819, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655,
  10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848,
  20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617,
  10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408,
  10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 9489, 11205, 14557, 10849, 11205, 14875, 10870, 10912, 11205,
  12739, 10930, 10942, 11913, 11205, 14818, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316,
  9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205, 11205, 14557, 21177, 11205,
  21173, 10958, 10912, 11008, 11205, 12780, 12792, 11913, 11205, 14818, 11205, 10536, 11205, 18143, 14389, 11205, 11205,
  12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708,
  9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545,
  27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741,
  9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375,
  9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993,
  13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205,
  11205, 14557, 11205, 11205, 11205, 25074, 11029, 11205, 11205, 11205, 13978, 11880, 11205, 14818, 11205, 10536, 11205,
  18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228,
  9251, 9274, 11047, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542,
  9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833,
  14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888,
  9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171,
  10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205,
  11205, 11205, 10461, 11063, 11205, 16106, 11205, 11205, 11133, 11084, 11126, 11205, 11205, 16127, 11154, 11891, 11205,
  14818, 11205, 10536, 11204, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316, 11222, 9123, 9162, 21004, 11205,
  18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368,
  9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655,
  10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848,
  20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617,
  10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408,
  10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11243, 11276, 11279, 11269, 11276, 11253, 11295, 11337, 11350,
  11362, 11308, 11321, 11913, 11205, 12406, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316,
  9102, 11378, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 18389, 11205, 14557, 11440, 11205,
  15066, 14709, 11431, 11465, 11470, 11500, 11511, 11913, 11205, 13728, 11205, 10536, 11205, 18143, 14389, 11205, 11205,
  12700, 9235, 9993, 10316, 9102, 11486, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708,
  9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545,
  27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741,
  9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375,
  9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993,
  13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 17476,
  11205, 14557, 11205, 11205, 11205, 14709, 11527, 11542, 11547, 11563, 11575, 11913, 11205, 14818, 11205, 10536, 11205,
  18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228,
  9251, 9274, 11591, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542,
  11607, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833,
  14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888,
  9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171,
  10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205,
  11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 11633, 11651, 11656, 11635, 11672, 11913, 11205,
  14818, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 24391, 11205,
  18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368,
  9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655,
  10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848,
  20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617,
  10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408,
  10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 23090, 11205, 14557, 15830, 11205, 23091, 14709, 11714, 11741,
  11746, 11205, 11725, 11913, 11205, 14818, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316,
  9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 11762, 11205, 11205, 14557, 11205, 11205,
  11205, 14709, 11786, 11804, 11809, 11788, 11825, 11869, 11205, 14818, 11205, 10536, 11205, 20493, 17233, 11205, 11205,
  18622, 16571, 18342, 18192, 11205, 17296, 16651, 24391, 27901, 20493, 12040, 16879, 11205, 18623, 22834, 22834, 21691,
  18342, 18342, 18342, 22407, 11205, 11205, 11031, 10717, 25777, 12039, 17232, 27909, 22834, 22834, 22834, 20351, 18342,
  18342, 18342, 10611, 11940, 11205, 11205, 26837, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205,
  11205, 11205, 9631, 12040, 10214, 16485, 22834, 16022, 22641, 18342, 17277, 11205, 20641, 20492, 27324, 22834, 11960,
  18342, 20961, 24429, 24768, 12030, 22829, 24899, 18342, 23418, 25908, 27439, 12056, 12074, 17272, 11205, 21815, 12090,
  12123, 23621, 12146, 27138, 23290, 18620, 25094, 9326, 12162, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205,
  11205, 11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205, 11205, 12185, 10912, 11205, 11205, 10648, 12221, 11913,
  11205, 14818, 11205, 22538, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 12258, 11205, 17296, 11205, 21004,
  11205, 20493, 12040, 16879, 11205, 18623, 22834, 22834, 21691, 18342, 18342, 18342, 19280, 11205, 11205, 11031, 11205,
  11205, 12039, 17232, 27909, 22834, 22834, 22834, 20351, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038,
  16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022,
  18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342,
  19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624,
  17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 25418, 11205, 14557, 11205,
  11205, 11205, 14709, 12284, 12303, 12333, 12287, 12317, 11913, 11205, 14818, 11205, 10536, 24881, 18143, 12349, 11205,
  11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297,
  12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516,
  9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704,
  9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961,
  14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303,
  9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461,
  12433, 11205, 14557, 11205, 11205, 11205, 12385, 12422, 12433, 11205, 18957, 12452, 25933, 11205, 14818, 11205, 10984,
  11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 27393, 11205, 17296, 11205, 19555, 11205, 20493, 12040, 16879,
  11205, 18623, 22834, 22834, 21691, 18342, 18342, 18342, 24926, 11205, 11205, 14902, 12489, 11205, 12039, 17232, 27909,
  22834, 22834, 22834, 20351, 18342, 18342, 18342, 12510, 11205, 11205, 24018, 11205, 12038, 16879, 22833, 22834, 22834,
  12534, 18342, 18342, 18342, 12583, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 12602, 18342, 18342, 17277, 11205,
  11205, 20492, 27324, 22834, 16044, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832,
  20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112,
  19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 16794, 11205, 19509, 23185, 11205, 18824, 14709, 12664,
  13631, 12689, 11205, 12724, 15287, 11205, 22311, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 14141, 12815, 13374,
  12881, 9102, 12765, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 12808, 13297, 12831, 13113, 13377, 12868, 12907,
  13595, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 12948, 14149, 12987, 13500, 12961, 13407, 13365, 13200, 27421,
  14786, 9561, 27538, 12436, 9589, 9619, 13493, 13015, 14017, 12999, 13031, 13583, 13060, 14073, 9675, 9704, 9741, 9778,
  13085, 13100, 13311, 13129, 13160, 13191, 13216, 9848, 20255, 18142, 13241, 12932, 13465, 13069, 13267, 9930, 9961,
  14375, 9603, 12842, 13175, 12971, 10011, 10039, 13283, 13251, 13327, 10081, 13343, 13393, 13423, 13451, 13355, 13481,
  12849, 12922, 12852, 14008, 13516, 13552, 13568, 13044, 13144, 13616, 11205, 11205, 11205, 11205, 11205, 11205, 10461,
  27302, 11205, 14557, 14200, 11205, 11205, 14709, 13647, 13687, 13692, 11205, 13672, 11913, 11205, 14818, 11205, 10536,
  11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212,
  9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 13708, 9350, 9368, 9405, 9464, 10284, 9513,
  9542, 9532, 10287, 9516, 9545, 13744, 14786, 9561, 21418, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659,
  10833, 13781, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 13817, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893,
  13858, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141,
  10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205,
  11205, 11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205, 11205, 11205, 13908, 13923, 13928, 22449, 13944, 11913,
  11205, 14818, 11205, 10536, 11205, 18143, 13994, 11205, 11205, 12700, 9235, 9993, 14033, 9102, 9123, 9162, 21004,
  11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350,
  9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121,
  9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848,
  20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617,
  10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408,
  10424, 11205, 11205, 11205, 11205, 11205, 11205, 14059, 10914, 11205, 14557, 11205, 11205, 11205, 14709, 14089, 14116,
  14130, 11205, 14100, 11924, 11205, 14818, 11205, 10536, 11205, 18143, 14165, 11205, 11205, 12700, 9235, 9993, 14181,
  9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 14216, 13759, 11205, 14557, 11205, 11205,
  11205, 14709, 14252, 14279, 14284, 11205, 14263, 14300, 11205, 14818, 11205, 10536, 11205, 18143, 14328, 11205, 11205,
  12700, 9235, 9993, 9477, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258,
  9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421,
  14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778,
  9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382,
  9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832,
  9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 14344, 11205, 11205,
  14557, 14400, 11205, 11205, 14709, 10912, 25622, 14404, 12242, 14360, 11913, 11205, 14818, 11205, 10536, 25251, 18143,
  14389, 11205, 11205, 12700, 9235, 9993, 14420, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251,
  9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532,
  10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073,
  9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909,
  9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233,
  10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205,
  11205, 10461, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 10912, 11205, 11205, 22956, 14465, 11913, 11205, 14818,
  11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143,
  9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464,
  10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109,
  10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878,
  9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097,
  10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205,
  11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807,
  9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205,
  11205, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205,
  15692, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 14573, 11205, 11205, 24018, 11205,
  12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 12583, 11205, 11205, 14597, 12040, 10214, 22834, 22834,
  26388, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16044, 18342, 18342, 11205, 16363, 20493, 22829, 24899,
  18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094,
  18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557,
  11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233,
  11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913, 22834,
  22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 15692, 11205, 12039, 17232, 27909, 22834, 22834, 22834,
  23348, 18342, 18342, 18342, 14573, 11205, 11205, 24018, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342,
  18342, 12583, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 26388, 18342, 18342, 17277, 11205, 11205, 20492, 27324,
  22834, 16044, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205,
  21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205,
  11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646,
  20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296,
  11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205,
  11205, 15692, 14615, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 14573, 11205, 11205, 24018,
  11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 12583, 11205, 11205, 11205, 12040, 10214, 22834,
  22834, 26388, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16044, 18342, 18342, 11205, 11205, 20493, 22829,
  24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620,
  25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205,
  14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493,
  17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913,
  22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 15692, 11205, 12039, 17232, 27909, 22834, 22834,
  22834, 23348, 18342, 18342, 18342, 14573, 11205, 11205, 24018, 14632, 12038, 16879, 22833, 22834, 22834, 15778, 18342,
  18342, 18342, 12583, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 26388, 18342, 18342, 17277, 11205, 11205, 20492,
  27324, 22834, 16044, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272,
  11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989,
  11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562,
  17646, 20807, 9146, 11205, 14818, 11205, 27579, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205,
  17296, 11205, 27579, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205,
  11205, 11205, 15692, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 14573, 11205, 11205,
  24018, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 12583, 11205, 11205, 11205, 12040, 10214,
  22834, 22834, 26388, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16044, 18342, 18342, 11205, 11205, 20493,
  22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114,
  18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205,
  11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205,
  20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205,
  27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834,
  22834, 22834, 23348, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778,
  18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205,
  20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113,
  17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102,
  11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554,
  10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 17081,
  11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280,
  11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 11205, 11205,
  11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040,
  10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205,
  20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993,
  20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507,
  11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 27229, 9146, 11205, 14818, 11205, 11205,
  11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879,
  11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909,
  22834, 22834, 22834, 23348, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834,
  15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205,
  11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832,
  20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112,
  19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14650,
  14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342,
  18192, 11205, 17296, 11205, 11205, 15505, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342,
  19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 11205,
  11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205,
  12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205,
  11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114,
  15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205,
  14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 12749, 14675, 14687, 9146, 11205, 14818, 11205,
  11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040,
  16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232,
  27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834,
  22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277,
  11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439,
  22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170,
  24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709,
  14529, 14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571,
  18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342,
  18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342,
  11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205,
  11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 24208, 20492, 27324, 22834, 16672, 18342, 18342,
  11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151,
  20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205,
  11205, 14703, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 11205, 14818,
  11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493,
  12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039,
  17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833,
  22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342,
  17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205,
  27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110,
  25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205, 11205,
  14709, 14725, 14745, 14775, 14729, 14759, 11913, 11205, 14818, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700,
  9235, 9993, 10316, 9102, 9123, 9162, 21004, 23648, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281,
  14811, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786,
  9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794,
  9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986,
  9389, 13842, 14834, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995,
  13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205, 11205, 14557,
  11205, 11205, 11205, 14709, 10912, 11205, 11205, 11205, 13978, 11913, 11205, 14818, 11205, 10536, 11205, 18143, 14389,
  11205, 11205, 12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274,
  9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287,
  9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675,
  9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930,
  9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274,
  10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205,
  14863, 14900, 11205, 14557, 11205, 11205, 11205, 14709, 14918, 13796, 13801, 11205, 14943, 14974, 11205, 14818, 11205,
  10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 13873, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196,
  9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284,
  9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125,
  9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893,
  9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141,
  10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205,
  11205, 11205, 11205, 15001, 15023, 11205, 14557, 11205, 11205, 11205, 14709, 10912, 11205, 11205, 26359, 15043, 17822,
  11205, 14818, 11205, 10536, 11205, 11188, 14389, 11205, 11205, 12700, 9235, 9993, 15082, 9102, 9123, 9162, 21004,
  11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350,
  9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121,
  9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848,
  20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617,
  10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408,
  10424, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 15111, 14557, 17775, 15128, 24715, 25404, 15146, 15161,
  15175, 15191, 15203, 25038, 15219, 15349, 11205, 15239, 15275, 15303, 10206, 15341, 15365, 15381, 15408, 15444, 15480,
  11205, 17296, 12362, 11205, 23084, 21893, 12040, 15496, 11205, 24048, 22834, 22834, 15521, 18342, 18342, 20380, 19280,
  17452, 10583, 11205, 15692, 11205, 15537, 25976, 15560, 16194, 22834, 24804, 15610, 15648, 18342, 23054, 14573, 15668,
  11205, 15685, 11205, 15713, 25597, 15766, 17527, 22834, 15778, 15794, 18444, 18342, 15818, 10642, 20405, 15856, 12040,
  10214, 22834, 21231, 15875, 18342, 23885, 27255, 15943, 11205, 20492, 27324, 20683, 16044, 18342, 15970, 11205, 11205,
  20493, 27468, 21961, 15587, 15989, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 16009,
  20114, 15918, 25094, 16038, 21979, 16060, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507,
  11205, 16083, 14557, 11205, 16103, 11205, 15007, 14529, 16122, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205,
  11205, 20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879,
  11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 18702, 27661, 11205, 16143, 24750, 27909,
  22834, 22834, 17032, 23348, 18342, 18342, 17609, 14573, 11205, 11205, 24018, 11205, 12038, 16879, 22833, 22834, 22834,
  15778, 18342, 18342, 18342, 12583, 11205, 21884, 11205, 16161, 16180, 22834, 22834, 26388, 16217, 18342, 17277, 11205,
  11205, 20492, 27324, 22834, 16044, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832,
  20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 16250, 16237, 18624, 17276, 20110, 25170, 24112,
  19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 14480, 14557, 11205, 11205, 11206, 25459, 16266,
  16281, 16295, 16311, 16323, 9146, 11205, 10971, 11205, 16339, 11205, 20493, 17233, 11205, 11205, 18622, 24652, 15973,
  18192, 22491, 17296, 16359, 16379, 9497, 16397, 16437, 15544, 11205, 16459, 16509, 22834, 21842, 16532, 18342, 18342,
  19280, 16548, 19251, 11205, 15692, 17008, 25589, 17232, 27909, 19477, 16568, 16587, 23348, 21924, 21554, 18342, 14573,
  11205, 11205, 10335, 11205, 12038, 16879, 22833, 22834, 24076, 15778, 18342, 18342, 22736, 12583, 11205, 11205, 11205,
  12040, 10214, 22834, 22834, 26388, 18342, 18342, 17277, 11205, 11205, 20492, 16606, 21790, 16044, 22603, 18342, 16631,
  11205, 20493, 16667, 16688, 26947, 19278, 11205, 27439, 22832, 23046, 25547, 11205, 21815, 17647, 17274, 24151, 20114,
  15993, 20114, 16710, 19111, 18624, 17276, 20110, 25170, 24112, 24363, 16748, 11205, 11205, 11205, 11205, 11205, 11205,
  14507, 11205, 25813, 14557, 11205, 16790, 14958, 9725, 16810, 16825, 16833, 16849, 16861, 9146, 11205, 14818, 11205,
  11205, 11205, 20493, 16877, 21017, 21012, 16895, 16571, 12100, 18192, 22761, 16911, 27778, 11205, 11205, 11770, 16950,
  16989, 25390, 17024, 17048, 16474, 21842, 17068, 19858, 17116, 19280, 11205, 25121, 21641, 15692, 11205, 12039, 17232,
  27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 17136, 11205, 9945, 24018, 11205, 12038, 16879, 12640, 22834,
  22834, 17179, 17208, 18342, 17120, 12583, 11205, 11205, 22413, 17228, 17551, 22834, 17249, 26388, 17270, 26816, 17277,
  11205, 17293, 21732, 27324, 17312, 16044, 26083, 17349, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 25280, 27439,
  22832, 24526, 17212, 11205, 21815, 17647, 17274, 24151, 20114, 20055, 22685, 26471, 16067, 18624, 17276, 20110, 25170,
  24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 20075, 14557, 23474, 15058, 17890, 15259,
  17369, 17385, 17399, 17415, 17427, 9146, 14430, 17150, 17443, 17468, 11097, 17492, 17543, 23505, 17567, 20837, 17595,
  17631, 18192, 23825, 17663, 22159, 12398, 13721, 20493, 12040, 15316, 19260, 27913, 17719, 17741, 25840, 18450, 17615,
  27284, 17770, 17791, 17807, 17857, 17885, 26127, 17906, 17947, 17963, 18000, 15392, 18016, 18053, 22744, 22103, 18083,
  14573, 18099, 15223, 24018, 18122, 23849, 26722, 16615, 22834, 18159, 18179, 22117, 21612, 23867, 18218, 27994, 18234,
  18250, 16145, 10214, 19904, 18271, 26388, 25890, 27116, 22009, 25741, 23685, 20492, 18287, 18313, 16044, 22357, 18341,
  11205, 18359, 11415, 18405, 18430, 18466, 18495, 11205, 18525, 18550, 16694, 25505, 13435, 21815, 9431, 20471, 18566,
  18414, 12547, 15743, 18582, 15632, 10884, 18611, 20110, 21504, 18640, 19102, 11989, 11205, 11205, 11205, 11205, 11205,
  11205, 14507, 11205, 11205, 14557, 9861, 9862, 9857, 23520, 18676, 18726, 18734, 18750, 18762, 9146, 11205, 18778,
  11205, 11205, 11205, 20493, 17233, 11205, 11205, 19207, 16571, 9441, 18192, 26605, 17296, 18820, 11205, 15130, 21047,
  12040, 16879, 11205, 14847, 22834, 22834, 21842, 24254, 18342, 18342, 19280, 11205, 11205, 11205, 15692, 11205, 12039,
  17232, 27909, 22834, 22834, 17520, 23348, 18342, 18342, 18840, 14573, 11205, 11205, 24018, 11205, 12038, 16879, 22833,
  22834, 22834, 15778, 18342, 18342, 18342, 12583, 11205, 11205, 23109, 16164, 10214, 22834, 21090, 26388, 18342, 23228,
  17277, 11205, 11205, 20492, 27324, 22834, 16044, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 25512, 11205,
  27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110,
  19981, 24112, 19952, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 27851, 11205,
  27859, 18861, 18876, 18884, 18900, 18912, 9146, 11205, 14818, 11205, 22565, 11205, 20493, 17233, 11205, 11205, 18622,
  16571, 18342, 18479, 11205, 17296, 11205, 11205, 22920, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342,
  18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 18928, 18342, 18342,
  18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205,
  11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 18952, 20492, 27324, 22834, 16672, 18342,
  18342, 25129, 10183, 18973, 22829, 24899, 18342, 19278, 11205, 18997, 19032, 19060, 19093, 11205, 19136, 19173, 24105,
  24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 18660, 19189, 11989, 11205, 11205, 11205, 11205,
  11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 11205,
  15954, 11205, 11205, 14440, 20493, 16443, 11205, 11205, 14043, 19910, 19223, 19241, 11205, 13225, 22303, 25069, 11205,
  20493, 12040, 16879, 11205, 27913, 22834, 20554, 21842, 18342, 18342, 15802, 19280, 11205, 11205, 11205, 11205, 11205,
  12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 25564, 11205, 11205, 11205, 11205, 12038, 16879,
  22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 21572, 11205, 11205, 12040, 10214, 22834, 26928, 16022, 18342,
  18342, 19276, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278,
  11205, 27439, 22832, 20113, 17272, 11205, 21815, 16732, 26887, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276,
  20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 14616, 19296, 14616, 19345,
  27675, 27683, 19380, 19395, 19409, 19425, 19437, 9146, 11205, 11449, 11205, 11205, 25953, 19453, 17233, 19506, 19501,
  12891, 16571, 19525, 18192, 11205, 17296, 23245, 11205, 11205, 20493, 23908, 25768, 19544, 18791, 26038, 22834, 19571,
  25220, 26810, 16221, 19587, 16999, 19608, 27568, 19624, 19642, 12039, 16409, 27909, 22834, 22834, 19658, 19679, 18342,
  18342, 19703, 11205, 11205, 22892, 19739, 11205, 12038, 16879, 19764, 22834, 22834, 15778, 19785, 18342, 18342, 11205,
  19802, 10775, 11169, 12040, 10214, 26199, 22834, 16022, 18342, 19856, 12107, 11205, 11205, 10023, 19874, 21223, 19926,
  19968, 23722, 19997, 11205, 20014, 17506, 23209, 23937, 20051, 20071, 20091, 22832, 20113, 17272, 20130, 21815, 17647,
  17274, 24151, 20114, 15993, 20147, 18620, 25094, 18624, 17276, 20163, 20199, 24112, 19102, 12617, 11205, 11205, 11205,
  11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 10326, 11205, 20230, 20271, 20286, 20294, 20310, 20322, 9146,
  27973, 14818, 14634, 23165, 11205, 11110, 17233, 11205, 17091, 20338, 16571, 20375, 17192, 14491, 17296, 11205, 22443,
  14490, 23806, 12040, 20396, 11205, 15095, 10795, 24055, 20421, 19070, 20437, 20454, 20487, 26354, 11205, 19355, 11205,
  11205, 20509, 17232, 27909, 20531, 20553, 22834, 20570, 20586, 18342, 18342, 11205, 19748, 11205, 20616, 11205, 12038,
  20632, 22833, 19663, 25672, 15778, 18342, 24534, 19717, 11013, 11205, 11205, 11205, 20657, 10214, 20679, 22834, 16022,
  23944, 18342, 26781, 11205, 27709, 11840, 11853, 22834, 16672, 20699, 18342, 11068, 11205, 20718, 22829, 24899, 18342,
  19278, 23134, 27439, 22832, 20742, 15428, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 17931,
  26462, 20766, 25170, 15621, 20794, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 20823, 11205,
  12473, 11205, 14709, 20853, 20868, 20876, 20892, 20904, 9146, 16931, 14818, 11205, 20920, 11205, 9688, 17233, 11205,
  16934, 20938, 16571, 20954, 18192, 11205, 20977, 11205, 21033, 11205, 20493, 12040, 16879, 11205, 17163, 22834, 25665,
  21063, 20464, 18343, 22363, 22042, 22546, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 21079, 19485, 22834, 23348,
  21114, 15458, 18342, 11205, 21138, 11205, 22985, 21154, 12038, 16879, 24304, 22834, 18030, 27216, 25226, 18342, 21193,
  11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834,
  16672, 18342, 18342, 12236, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815,
  17647, 17274, 21212, 23990, 21247, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205,
  11205, 11205, 11205, 11205, 14507, 11205, 11205, 21270, 11205, 9970, 16926, 21315, 21331, 21347, 21355, 21371, 21383,
  9146, 24946, 14818, 21446, 11205, 20131, 10677, 21399, 21434, 19816, 21462, 21478, 21520, 18192, 16641, 27630, 11205,
  11205, 21536, 20493, 12040, 16879, 9107, 27913, 16493, 22834, 21842, 18342, 21552, 18342, 19280, 21570, 26995, 11205,
  14449, 11205, 21588, 17232, 27909, 26255, 22834, 22834, 23348, 21610, 18342, 18342, 11205, 11205, 14581, 11205, 21628,
  21664, 24614, 21687, 22834, 21707, 18325, 18342, 22510, 25724, 27587, 21723, 21748, 18710, 26158, 20103, 21769, 19150,
  16022, 26679, 23766, 17277, 11393, 11687, 21806, 27324, 21838, 16672, 19687, 18342, 13765, 11205, 10195, 16965, 21858,
  15464, 21874, 11205, 17691, 12558, 21909, 24354, 14513, 21940, 17647, 21977, 24151, 21995, 19202, 22031, 12631, 22058,
  18624, 17276, 20110, 20778, 22088, 19102, 15904, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 22145,
  11205, 12586, 15112, 27758, 22187, 22202, 22210, 22226, 22238, 9146, 22254, 14818, 18370, 11205, 22270, 22276, 22292,
  11698, 22327, 24512, 22343, 22379, 18192, 11205, 17296, 24839, 11205, 22429, 20493, 24742, 16879, 11205, 27913, 20537,
  26653, 9334, 18342, 22465, 15422, 22486, 11205, 10992, 15325, 11406, 27890, 12039, 20663, 9420, 22834, 17327, 27343,
  23348, 18342, 22507, 20183, 22526, 26743, 22562, 11205, 11205, 12038, 16879, 22833, 22581, 22834, 15778, 18342, 22602,
  18342, 11205, 23656, 10467, 11205, 12040, 10214, 22834, 22834, 18595, 18342, 18342, 17277, 19364, 11205, 20492, 18534,
  10803, 17254, 26698, 18342, 22619, 11205, 27002, 19467, 24899, 22638, 19278, 11205, 27439, 22832, 20113, 17272, 22657,
  22676, 17984, 15652, 12205, 12567, 22015, 22701, 18620, 25094, 18624, 17276, 20110, 23735, 23779, 19102, 11975, 11205,
  11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 24190, 22760, 22777, 22816, 14554, 15840, 22851,
  22863, 9146, 11205, 22879, 11205, 11205, 11205, 20493, 17233, 11205, 22915, 18622, 16571, 18342, 18192, 26560, 17296,
  11205, 22936, 22972, 20493, 23008, 16879, 26558, 27913, 23031, 24799, 18297, 18845, 24693, 18342, 23070, 11205, 11205,
  23107, 22950, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 23125, 11205, 11205, 23150,
  10439, 20726, 26178, 22833, 23201, 22834, 15574, 20438, 23225, 18342, 11205, 23244, 11205, 11205, 12040, 10214, 22834,
  23261, 18804, 18342, 26315, 17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829,
  24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17353, 23279, 20114, 12169, 20114, 18620,
  25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205,
  14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 22622, 11205, 23692,
  17233, 23314, 23319, 23335, 19769, 23372, 23393, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913,
  22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834,
  22834, 23409, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342,
  18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205, 20492,
  27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 19016, 20113, 23448,
  11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989,
  11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14985, 23470, 11205, 23466, 14709, 23490, 23549, 23557,
  23573, 23585, 9146, 11205, 23601, 20992, 18136, 18509, 17833, 23637, 12673, 23672, 23975, 23708, 23751, 18192, 11205,
  17296, 24497, 23795, 23822, 23841, 26171, 16879, 11205, 22791, 12066, 26260, 21842, 23865, 23883, 20178, 19280, 11205,
  11205, 27033, 19626, 11205, 23901, 26018, 9639, 16590, 22834, 12648, 23924, 22470, 18342, 18067, 11205, 10854, 23960,
  24013, 11205, 18981, 24034, 22833, 21098, 24071, 24092, 18342, 22394, 24128, 21164, 11205, 24144, 18380, 12040, 10214,
  24167, 22834, 16022, 24262, 18342, 19077, 11205, 24186, 20492, 27324, 22834, 16973, 18342, 26762, 11205, 24206, 20493,
  20029, 27362, 18342, 19278, 24224, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 23450, 27491, 24245, 24278, 20114,
  16762, 18651, 24299, 17276, 20110, 22129, 24320, 22714, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205,
  11205, 26585, 11205, 9086, 24379, 24416, 24452, 24550, 24558, 24574, 24586, 19329, 11205, 14818, 11205, 14191, 11205,
  24602, 24630, 23179, 19310, 24668, 16571, 24684, 18192, 24709, 17296, 11205, 11205, 11205, 24467, 24731, 23015, 24766,
  24784, 24820, 22834, 21842, 19941, 23298, 18342, 19280, 25807, 27038, 24836, 11205, 11205, 12039, 17232, 24641, 22834,
  22834, 22834, 23348, 18342, 18342, 18342, 11205, 12518, 11205, 15027, 27530, 24855, 24872, 24897, 17052, 19889, 19044,
  18342, 9448, 24915, 24942, 11205, 11205, 11205, 21594, 19009, 23263, 21784, 16022, 18342, 21492, 17277, 16343, 24962,
  24979, 27324, 21955, 25004, 19723, 22727, 11205, 11138, 20493, 22829, 24899, 18342, 19278, 16552, 25054, 22832, 25090,
  20750, 25110, 21815, 17647, 17274, 24151, 25145, 15993, 20114, 12003, 25186, 21254, 26224, 25207, 25170, 24112, 19102,
  11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14795, 11205, 11205, 25242, 25267, 25303, 25318,
  25332, 25348, 25360, 9146, 14599, 14818, 25376, 18691, 21410, 13883, 25440, 23432, 23427, 25475, 25491, 25528, 18192,
  12198, 22072, 25563, 15025, 26122, 25580, 20515, 25613, 25638, 25654, 22835, 25688, 21842, 25719, 23356, 26306, 12130,
  20243, 11205, 25740, 11205, 11179, 25757, 25793, 25829, 25856, 16724, 16516, 25869, 15750, 25885, 26074, 11205, 25906,
  25924, 16087, 25949, 25969, 24482, 15927, 17978, 17333, 26633, 24345, 25992, 26286, 13970, 11205, 9573, 11205, 26010,
  17703, 18037, 26034, 17754, 20600, 26054, 25191, 26107, 11205, 26143, 14538, 26194, 19157, 24335, 25994, 9164, 9352,
  20493, 15728, 17725, 26215, 25019, 11205, 27403, 26240, 26276, 25160, 26339, 26375, 21299, 21122, 24151, 20114, 15993,
  20114, 18620, 25094, 26404, 23997, 26420, 26447, 24112, 19102, 15890, 11205, 11205, 11205, 11205, 11205, 11205, 14507,
  11205, 11205, 14557, 11205, 15669, 11205, 14709, 26487, 26502, 26510, 26526, 26538, 9146, 11205, 25287, 19998, 11205,
  11205, 20493, 17233, 11205, 11205, 21285, 16571, 25542, 18192, 26554, 17296, 11205, 24963, 26576, 22992, 12040, 16879,
  11205, 23533, 22834, 22834, 22586, 26296, 18342, 18342, 20214, 16381, 26601, 11205, 24229, 9138, 13892, 17919, 19829,
  16201, 26621, 26649, 23348, 26064, 26669, 26695, 11205, 9719, 11205, 11205, 11205, 26714, 16879, 21822, 22834, 22834,
  16774, 26091, 18342, 18342, 26738, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 15594, 11205,
  25424, 20492, 14659, 22834, 16672, 26759, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832,
  20113, 17272, 11205, 24988, 17647, 26778, 24151, 20114, 15993, 20114, 18620, 25094, 10217, 26323, 20110, 25170, 19120,
  26797, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 15253, 14884, 17678, 14529,
  26832, 18202, 26853, 26865, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 24283, 16571, 26881,
  18192, 11205, 17296, 11205, 11205, 11205, 18106, 12040, 21671, 11205, 26907, 22834, 22834, 21842, 20359, 18342, 18342,
  19280, 11205, 11205, 11944, 11205, 11205, 24856, 17232, 26903, 22834, 26923, 22834, 23348, 18342, 26944, 18342, 11205,
  11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205, 11205, 11205,
  12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 26963, 20492, 27324, 22834, 16672, 18342, 18342, 11205,
  11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 12467, 21815, 17647, 17274, 24151, 20114,
  15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205,
  14507, 11205, 11205, 24436, 11205, 18255, 11205, 26981, 27018, 27054, 27062, 27078, 27090, 9146, 11205, 14818, 11205,
  11205, 11205, 20493, 17233, 11205, 11205, 18622, 12014, 19528, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040,
  16879, 11205, 27913, 22834, 22834, 21842, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232,
  27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342, 11205, 11205, 11205, 25030, 11205, 12038, 16879, 22833, 22834,
  22834, 15778, 18342, 18342, 18342, 11205, 23614, 11205, 11205, 12040, 10214, 20035, 18163, 16022, 18342, 27106, 27132,
  11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439,
  22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170,
  24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14703, 11205, 11205, 14557, 11205, 11205, 11205, 14709,
  14529, 14554, 12268, 27154, 27166, 9146, 11205, 12369, 11205, 11205, 22660, 22899, 17233, 27182, 27187, 27203, 16571,
  27245, 18192, 11205, 17296, 13656, 14927, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 25703, 18342, 18342,
  20702, 26431, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342, 18342,
  11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 27271, 18342, 18342, 18342, 17100, 11205, 11205,
  11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342,
  11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151,
  20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205,
  11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205, 14709, 14529, 14554, 10562, 17646, 20807, 9146, 27300, 14818,
  11205, 21753, 11205, 20493, 17233, 11205, 11205, 10786, 22800, 19225, 18192, 11205, 17296, 11205, 11205, 11205, 20493,
  12040, 16879, 11205, 27913, 22834, 22834, 19840, 18342, 18342, 19786, 19280, 19321, 11205, 11205, 11205, 20922, 12039,
  27318, 27909, 22834, 24170, 22834, 23348, 18342, 23377, 18342, 11205, 25451, 11205, 11205, 11205, 17841, 16879, 27340,
  27359, 22834, 10896, 21196, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 27378, 18342, 18342,
  18936, 11205, 11205, 20492, 27324, 22834, 16672, 18342, 18342, 27419, 11205, 27437, 22829, 24899, 18342, 19278, 11205,
  27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110,
  25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205, 11205, 11205, 14507, 11205, 11205, 14557, 11205, 11205, 11205,
  14709, 27455, 14554, 10562, 17646, 20807, 9146, 11205, 14818, 11205, 11205, 11205, 20493, 17233, 11205, 11205, 18622,
  16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205, 27913, 22834, 22834, 21842, 18342,
  18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834, 22834, 22834, 23348, 18342, 18342,
  18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778, 18342, 18342, 18342, 11205, 11205,
  11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205, 20492, 27324, 22834, 16672, 18342,
  18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113, 17272, 11205, 21815, 17647, 17274,
  24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102, 11989, 11205, 11205, 11205, 11205,
  11205, 11205, 10461, 11205, 11205, 11227, 27484, 27615, 27507, 27554, 27603, 10445, 27519, 27626, 27646, 13959, 11205,
  14818, 11205, 17579, 11205, 18143, 14389, 11205, 11205, 12700, 10376, 9993, 27699, 9102, 9123, 9162, 21004, 11205,
  18143, 9180, 9196, 9212, 9228, 9251, 9274, 27725, 12708, 9258, 9281, 27750, 13600, 11205, 11031, 9313, 9350, 9368,
  9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655,
  10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848,
  20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617,
  10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408,
  10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205, 27774, 14709, 27794, 27821,
  27826, 11205, 27805, 11913, 11205, 14818, 11205, 10536, 11205, 18143, 14389, 12494, 11205, 12700, 9235, 9993, 10316,
  9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 9297, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205, 11205, 14557, 11205, 11205,
  11205, 19592, 27842, 14231, 14236, 11205, 27875, 11913, 11205, 14818, 11205, 16421, 11205, 18143, 14389, 11205, 11205,
  12700, 9235, 9993, 10316, 9102, 9123, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 27929, 12708,
  9258, 9281, 27732, 13600, 11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545,
  27421, 14786, 9561, 27538, 12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741,
  9778, 9794, 9810, 9832, 9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375,
  9382, 9986, 9389, 13842, 10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993,
  13832, 9995, 13530, 13536, 10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 10461, 11205,
  11205, 14557, 11205, 11205, 11205, 14709, 10912, 11205, 11205, 11205, 14312, 9146, 11205, 14818, 11205, 11205, 11205,
  20493, 17233, 11205, 11205, 18622, 16571, 18342, 18192, 11205, 17296, 11205, 11205, 11205, 20493, 12040, 16879, 11205,
  18623, 22834, 22834, 21691, 18342, 18342, 18342, 19280, 11205, 11205, 11205, 11205, 11205, 12039, 17232, 27909, 22834,
  22834, 22834, 20351, 18342, 18342, 18342, 11205, 11205, 11205, 11205, 11205, 12038, 16879, 22833, 22834, 22834, 15778,
  18342, 18342, 18342, 11205, 11205, 11205, 11205, 12040, 10214, 22834, 22834, 16022, 18342, 18342, 17277, 11205, 11205,
  20492, 27324, 22834, 16672, 18342, 18342, 11205, 11205, 20493, 22829, 24899, 18342, 19278, 11205, 27439, 22832, 20113,
  17272, 11205, 21815, 17647, 17274, 24151, 20114, 15993, 20114, 18620, 25094, 18624, 17276, 20110, 25170, 24112, 19102,
  11989, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 11205, 9080, 11205, 9070, 27945,
  27950, 26965, 27966, 10535, 11205, 11205, 11205, 10536, 11205, 18143, 14389, 11205, 11205, 12700, 9235, 9993, 27734,
  9102, 27989, 9162, 21004, 11205, 18143, 9180, 9196, 9212, 9228, 9251, 9274, 27725, 12708, 9258, 9281, 27732, 13600,
  11205, 11031, 9313, 9350, 9368, 9405, 9464, 10284, 9513, 9542, 9532, 10287, 9516, 9545, 27421, 14786, 9561, 27538,
  12436, 9589, 9619, 10121, 9655, 10829, 10109, 10125, 9659, 10833, 14073, 9675, 9704, 9741, 9778, 9794, 9810, 9832,
  9762, 9804, 9826, 9756, 9848, 20255, 18142, 9878, 9893, 9914, 9888, 9909, 9930, 9961, 14375, 9382, 9986, 9389, 13842,
  10011, 10039, 10055, 11617, 10065, 10081, 10097, 10141, 10171, 10233, 10274, 10303, 9993, 13832, 9995, 13530, 13536,
  10351, 10367, 10392, 10408, 10424, 11205, 11205, 11205, 11205, 11205, 11205, 0, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 0,
  37076, 37076, 37076, 37076, 0, 0, 39127, 39127, 37076, 37076, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127,
  39127, 39127, 39127, 0, 0, 37076, 39127, 37076, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127,
  39127, 39127, 39127, 251, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 22528, 24576,
  39127, 39127, 39127, 39127, 39127, 39127, 39127, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 39127, 20480, 39127, 39127, 39127,
  39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 39127, 0, 0, 0, 37076, 0, 0,
  39127, 0, 528384, 218, 219, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247,
  0, 0, 0, 0, 0, 0, 690176, 0, 0, 702464, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 824, 0, 0, 0, 796672, 0, 0, 0, 843776, 0,
  0, 0, 0, 0, 0, 0, 0, 251, 251, 0, 0, 0, 0, 0, 1014, 0, 1016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 219, 0, 0, 0, 0, 0, 0,
  694272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1603, 555008, 555008, 555008, 761856, 555008, 555008, 780288,
  555008, 788480, 555008, 555008, 806912, 813056, 819200, 555008, 833536, 555008, 849920, 555008, 555008, 555008,
  907264, 555008, 555008, 555008, 0, 0, 0, 761856, 0, 780288, 788480, 0, 0, 806912, 813056, 819200, 0, 833536, 849920,
  907264, 0, 0, 0, 0, 849920, 0, 813056, 849920, 0, 0, 0, 796672, 0, 0, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 557056, 557056, 557056, 557056, 557056, 557056, 761856,
  557056, 557056, 557056, 557056, 780288, 557056, 788480, 557056, 792576, 557056, 557056, 806912, 557056, 813056,
  819200, 557056, 557056, 557056, 806912, 557056, 813056, 819200, 557056, 557056, 557056, 833536, 557056, 557056,
  849920, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 907264, 557056, 557056,
  557056, 557056, 557056, 557056, 907264, 557056, 557056, 557056, 557056, 557056, 557056, 637, 0, 0, 640, 811008, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 776192, 0, 817152, 0, 0, 0, 0, 0, 0, 377, 1876, 377, 377, 377, 377, 377, 377, 377, 377, 880, 377,
  377, 377, 637, 45942, 827, 640, 0, 665600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1615, 0, 686080, 555008,
  555008, 555008, 555008, 555008, 555008, 743424, 555008, 555008, 759808, 555008, 776192, 555008, 555008, 0, 0, 0,
  557056, 557056, 557056, 557056, 557056, 716800, 731136, 733184, 557056, 557056, 749568, 557056, 557056, 557056,
  557056, 557056, 557056, 854016, 555008, 555008, 817152, 825344, 555008, 555008, 555008, 555008, 555008, 555008,
  555008, 555008, 686080, 0, 743424, 0, 0, 0, 0, 0, 1056, 0, 0, 0, 0, 827, 377, 377, 377, 377, 377, 377, 377, 1766, 377,
  377, 399, 399, 399, 399, 399, 399, 663, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1336, 399, 399, 399, 399, 399,
  399, 0, 0, 0, 825344, 0, 0, 825344, 0, 0, 0, 557056, 557056, 686080, 557056, 557056, 557056, 0, 0, 0, 0, 0, 2, 0,
  88064, 147456, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 771, 0, 0, 0, 0, 0, 557056, 776192, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 817152, 821248, 825344, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 0, 557056, 686080, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 911360, 557056, 557056, 557056, 557056, 557056, 557056, 905216,
  929792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 835584, 0, 0, 0, 0, 0, 0, 0, 1384, 0, 0, 0, 0, 1389, 0, 0, 0, 0, 0, 555008, 704512,
  706560, 555008, 555008, 555008, 555008, 751616, 555008, 555008, 555008, 790528, 555008, 555008, 0, 0, 0, 557639,
  557639, 557639, 557639, 557639, 717383, 731719, 733767, 557639, 557639, 750151, 845824, 555008, 555008, 555008,
  555008, 555008, 555008, 555008, 555008, 706560, 0, 790528, 0, 0, 0, 0, 0, 0, 0, 1396, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  827, 377, 377, 377, 377, 1061, 751616, 557056, 557056, 557056, 557056, 557056, 557056, 790528, 557056, 557056, 557056,
  808960, 557056, 557056, 841728, 845824, 557056, 557056, 557056, 557056, 0, 0, 851968, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  815104, 0, 0, 0, 0, 0, 0, 447, 0, 0, 0, 315, 315, 315, 315, 530, 315, 0, 0, 0, 899072, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  724992, 784384, 0, 0, 0, 0, 0, 1181, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 22528, 24576, 0, 259, 259, 931840, 0, 0,
  741376, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 894976, 557056, 909312, 557056, 919552, 557056, 557056, 931840, 557056, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 557056, 555008, 555008, 555008, 724992, 555008, 555008, 753664, 555008, 784384, 555008,
  555008, 851968, 555008, 555008, 555008, 894976, 909312, 919552, 931840, 0, 0, 0, 0, 909312, 919552, 557056, 688128,
  557056, 557056, 557056, 712704, 557056, 557056, 724992, 557056, 557056, 557056, 557056, 557056, 753664, 763904,
  557056, 557056, 557056, 784384, 557056, 557056, 557056, 557056, 557056, 784384, 557056, 557056, 557056, 557056,
  557056, 851968, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 894976, 557056, 909312, 557056, 919552,
  557056, 0, 0, 827392, 0, 847872, 0, 876544, 880640, 933888, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 765952, 555008, 555008, 876544, 555008, 892928, 0, 765952, 0, 0, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 765952, 557056, 557056, 794624, 557056, 557056, 827392, 557056, 557056,
  858112, 557056, 827392, 557056, 557056, 858112, 557056, 557056, 876544, 557056, 557056, 892928, 901120, 557056,
  557056, 557056, 935936, 0, 0, 0, 0, 557056, 0, 0, 0, 0, 720896, 0, 0, 733184, 749568, 0, 0, 0, 0, 0, 927744, 0, 0, 0,
  0, 0, 1194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1203, 800768, 0, 0, 0, 854016, 0, 888832, 0, 731136, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  264, 0, 265, 266, 0, 0, 0, 557056, 557056, 557056, 557056, 557056, 557056, 854016, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 770048, 757760,
  782336, 0, 0, 870400, 0, 913408, 925696, 0, 679936, 872448, 0, 0, 0, 0, 0, 0, 0, 1527, 1528, 0, 1530, 1531, 315, 1533,
  315, 315, 798720, 0, 0, 0, 0, 0, 0, 0, 555008, 708608, 555008, 555008, 802816, 555008, 555008, 708608, 802816, 0,
  681984, 557056, 557056, 708608, 557056, 557056, 557056, 745472, 557056, 557056, 778240, 802816, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 923648, 0, 714752, 0, 0, 0, 829440, 0, 0, 921600, 0, 0, 0, 0,
  0, 0, 862208, 0, 692224, 0, 878592, 692224, 714752, 555008, 804864, 878592, 804864, 557056, 692224, 696320, 714752,
  557056, 557056, 557056, 557056, 0, 0, 0, 0, 536576, 0, 0, 0, 0, 557056, 557056, 557056, 557056, 704512, 706560,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 751616, 557056, 557056, 557056, 772096,
  804864, 829440, 866304, 557056, 878592, 557056, 557056, 557056, 921600, 557056, 692224, 696320, 714752, 557056,
  557056, 557056, 0, 0, 0, 0, 0, 2, 6, 0, 0, 0, 0, 697, 701, 557056, 557056, 772096, 804864, 829440, 866304, 557056,
  878592, 557056, 557056, 557056, 921600, 0, 0, 0, 0, 0, 0, 0, 1608, 0, 0, 0, 1611, 0, 0, 0, 0, 0, 0, 0, 1622, 0, 0,
  1625, 315, 315, 315, 315, 315, 315, 315, 548, 315, 315, 315, 0, 0, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 377, 377,
  1882, 377, 837632, 0, 0, 0, 0, 0, 823296, 0, 937984, 739328, 739328, 557056, 735232, 739328, 557056, 557056, 557056,
  0, 0, 0, 0, 0, 2, 6, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 59677, 24576, 0, 0, 0, 557056, 557056, 557056, 557056,
  557056, 557056, 917504, 557056, 735232, 739328, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  743424, 557056, 557056, 557056, 557056, 759808, 557056, 557056, 557056, 776192, 557056, 557056, 557056, 917504, 0, 0,
  0, 0, 839680, 0, 0, 0, 0, 0, 557056, 557056, 557056, 0, 0, 0, 0, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1213, 0, 1004, 0, 0, 0, 0, 0, 0, 557056, 557056, 755712, 557056, 831488, 557056, 557056, 557056, 884736,
  557056, 557056, 755712, 557056, 831488, 557056, 557056, 557056, 884736, 722944, 0, 0, 0, 0, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557693, 0, 557056, 557696, 557056, 557056,
  557056, 557056, 557056, 0, 0, 0, 0, 684032, 557056, 557056, 557056, 557056, 882688, 684032, 557056, 557056, 557056,
  557056, 882688, 729088, 0, 0, 860160, 557056, 774144, 868352, 557056, 557056, 774144, 868352, 557056, 768000, 786432,
  737280, 557056, 737280, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 874496, 874496, 0, 0, 0, 0, 0, 1222,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415744, 0, 415744, 0, 0, 0, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1388,
  0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55628, 55628, 55628, 0, 0, 2, 2, 3, 47108, 5, 6, 0,
  55628, 55628, 0, 55628, 55628, 332, 332, 332, 332, 332, 332, 332, 55628, 332, 55628, 55628, 55628, 55628, 55628,
  55628, 55628, 55628, 55628, 55628, 55628, 0, 0, 0, 0, 0, 0, 0, 0, 528384, 0, 0, 0, 0, 0, 0, 0, 0, 557056, 557056,
  557056, 0, 694, 0, 694, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 377, 377, 377, 377, 377, 59392, 0, 0, 218, 59392,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 984, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1173, 0, 0, 0, 218, 218, 218, 218, 0, 0, 218, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 1368, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 90532, 90532, 90532, 90532, 90532, 0, 2, 567500, 47108, 5, 6, 208, 0, 0, 0, 0, 0, 208, 0, 0, 0, 0,
  0, 0, 448, 520, 0, 0, 315, 523, 315, 315, 531, 315, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 61440, 61440, 0,
  0, 61440, 61440, 61440, 61440, 61440, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112640, 61440, 61440, 0,
  61440, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 61440, 0, 0, 0,
  2, 2, 567500, 47108, 5, 6, 0, 0, 0, 0, 0, 1382, 0, 0, 0, 0, 1387, 0, 0, 0, 0, 0, 0, 0, 492, 377, 377, 377, 377, 377,
  377, 377, 377, 849, 377, 377, 377, 377, 377, 377, 377, 377, 1555, 377, 377, 377, 377, 377, 377, 377, 557056, 557056,
  557056, 1109, 0, 0, 1114, 0, 557056, 686080, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 886784, 890880,
  557056, 557056, 557056, 903168, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 65536, 65536, 65536, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1187, 1188, 1189, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 65536, 0, 0, 22528, 24576, 65536, 0,
  0, 0, 0, 0, 0, 1875, 377, 377, 1877, 377, 1879, 377, 377, 377, 377, 0, 0, 0, 0, 1113, 0, 0, 0, 0, 399, 1313, 399, 0,
  20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 65536, 0, 0, 65536, 0, 0, 0, 65536, 65536,
  65536, 65536, 65536, 0, 0, 65536, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 67584, 0, 0, 0, 0, 67584, 0, 22528,
  24576, 0, 0, 0, 0, 0, 0, 458, 0, 0, 0, 251, 251, 251, 0, 0, 0, 0, 0, 0, 488, 280, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 982,
  0, 0, 0, 0, 0, 0, 0, 0, 67584, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1361, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 532480, 557056, 557056, 557056, 557056, 557056, 907264, 557056, 557056, 557056, 557056,
  557056, 557056, 884, 0, 0, 887, 69632, 0, 0, 219, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1601, 0, 0, 0, 0, 0, 219,
  0, 0, 0, 0, 0, 0, 0, 0, 22528, 69921, 0, 0, 0, 0, 0, 0, 501, 0, 0, 0, 0, 0, 507, 0, 0, 0, 0, 0, 0, 519, 0, 0, 0, 315,
  315, 315, 315, 529, 315, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1612, 0, 0, 0,
  219, 219, 219, 219, 0, 0, 219, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 1394, 1395, 0, 0, 1398, 0, 0, 0, 0, 0, 0, 0,
  0, 1017, 0, 0, 0, 0, 0, 0, 0, 0, 0, 425984, 555008, 555008, 555008, 555008, 555008, 555008, 18432, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229, 219, 690176, 0, 0, 702464, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415744, 251, 0,
  415744, 0, 0, 216, 216, 0, 0, 216, 216, 71896, 216, 216, 216, 216, 216, 216, 216, 71896, 216, 216, 216, 216, 216, 216,
  216, 216, 216, 71896, 216, 216, 216, 216, 216, 255, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216,
  216, 216, 216, 252, 216, 216, 216, 216, 216, 216, 71896, 216, 216, 216, 216, 216, 216, 22528, 24576, 216, 216, 216,
  216, 71896, 71896, 216, 71896, 71896, 71896, 71896, 71896, 71896, 71935, 71935, 71935, 71935, 71896, 71896, 71896, 0,
  0, 2, 2, 3, 47108, 5, 6, 0, 216, 20480, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 71896, 71896, 71896,
  71896, 71896, 216, 216, 216, 216, 216, 216, 216, 216, 71896, 216, 71896, 71896, 71896, 71896, 71896, 71896, 71896,
  71896, 0, 0, 0, 216, 0, 796672, 0, 0, 0, 843776, 0, 0, 0, 0, 0, 0, 0, 0, 565710, 565710, 0, 0, 0, 0, 0, 1499, 0, 0, 0,
  0, 0, 1502, 1503, 0, 0, 0, 0, 0, 0, 1005, 0, 495, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1624, 315, 1626, 315, 315, 315, 1629, 0,
  20480, 0, 0, 0, 0, 0, 0, 77824, 0, 0, 77824, 0, 0, 0, 0, 77824, 77824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 461, 251, 251, 251,
  0, 0, 0, 0, 0, 77824, 0, 0, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 0, 0, 0,
  0, 796672, 0, 0, 0, 843776, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 77824, 0, 77824, 0, 77824, 0, 0, 0, 0,
  77824, 77824, 77824, 0, 0, 2, 2, 0, 47108, 5, 6, 63488, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 79872,
  79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 0, 0, 0, 0,
  0, 45454, 79872, 0, 0, 0, 0, 79872, 0, 0, 79872, 79872, 45454, 45454, 45454, 45454, 45454, 79872, 79872, 45454, 0, 0,
  2, 2, 3, 47108, 5, 6, 0, 557056, 557056, 557056, 557056, 557056, 907264, 557056, 557056, 557056, 557056, 557056,
  557056, 637, 0, 45056, 640, 557056, 557056, 557056, 0, 0, 0, 0, 45056, 557056, 686080, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 923648, 681984, 557056, 557056, 708608, 557056, 557056, 557056, 745472, 0, 20480, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920,
  81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 2, 2,
  3, 47108, 5, 6, 0, 0, 0, 0, 0, 1512, 0, 0, 0, 0, 1516, 0, 0, 0, 0, 0, 0, 0, 566, 0, 0, 569, 0, 0, 0, 0, 572, 0, 20480,
  83968, 83968, 83968, 83968, 83968, 0, 83968, 0, 0, 0, 0, 0, 0, 83968, 83968, 83968, 0, 0, 2, 2, 3, 47108, 5, 6, 0,
  83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 0, 0,
  0, 0, 0, 0, 2, 3, 205, 5, 6, 0, 209, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 786, 315, 315, 315, 315, 315, 0, 20480, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 86016, 86016, 86016, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016,
  86016, 86016, 86016, 86016, 86016, 86016, 0, 0, 0, 0, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 26824,
  26824, 2, 2, 3, 0, 5, 6, 0, 0, 0, 0, 0, 1525, 0, 0, 0, 0, 0, 315, 1532, 315, 315, 315, 315, 315, 315, 1539, 0, 0, 0,
  377, 377, 377, 1545, 377, 377, 427, 0, 0, 0, 0, 0, 0, 0, 528384, 218, 219, 0, 0, 0, 0, 0, 0, 0, 0, 528384, 431, 432,
  0, 0, 0, 0, 0, 0, 0, 0, 528384, 218, 10673, 0, 0, 0, 0, 0, 0, 0, 0, 528384, 10670, 219, 0, 0, 0, 0, 0, 0, 0, 0,
  528384, 218, 219, 0, 0, 0, 0, 0, 0, 0, 0, 528384, 218, 219, 0, 0, 106496, 0, 0, 0, 0, 0, 1179, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1001, 0, 0, 377, 377, 377, 377, 1563, 377, 377, 377, 377, 377, 377, 0, 0, 0, 0, 399, 0, 0, 377, 377,
  399, 399, 377, 399, 1948, 1949, 377, 399, 377, 399, 0, 0, 377, 377, 399, 399, 377, 399, 377, 399, 377, 399, 377, 399,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1847, 377, 377, 377, 377, 377, 377, 628, 377, 377, 377, 377, 377, 377, 0, 399, 399, 0, 0,
  0, 1619, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 0, 0, 1705,
  377, 377, 377, 377, 377, 377, 1711, 377, 377, 377, 377, 377, 377, 377, 850, 377, 377, 377, 377, 377, 377, 377, 377,
  1723, 399, 399, 399, 399, 399, 399, 1729, 1761, 377, 1762, 1763, 377, 377, 377, 377, 377, 377, 399, 399, 399, 399,
  399, 399, 662, 399, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 1491, 0, 0, 0, 0, 399, 399, 1773, 399, 1774, 1775,
  399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 0, 949, 0, 0, 0, 955, 0, 377, 377, 377, 1797, 377, 377, 377, 399, 1801, 399,
  399, 399, 399, 399, 399, 1807, 399, 1885, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 1816, 1817, 0,
  377, 377, 377, 0, 0, 279, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 0, 0, 708, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  315, 377, 377, 377, 1792, 377, 90532, 90532, 90532, 90532, 0, 0, 90532, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0,
  0, 0, 1596, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 135168, 135168, 135168, 135168, 399, 399, 399, 92160, 0, 0, 0,
  26824, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 396, 396, 396, 396, 396, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 94541, 94541, 94541, 94541, 94541, 94541, 0, 94541, 94541, 0, 0, 0, 0, 0, 0, 0, 94541, 0, 94541, 94541, 94541,
  94541, 94541, 94541, 0, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 94541, 94541, 94541, 94541, 94541, 94541, 94541, 94541, 94541,
  94541, 94541, 0, 0, 0, 0, 220, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008,
  0, 96256, 0, 0, 0, 0, 0, 0, 734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 0, 0, 465, 0, 0, 280, 0, 0, 0, 0, 0, 0,
  0, 0, 22528, 24576, 0, 0, 0, 0, 0, 0, 750, 489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565710, 565710, 565710, 0, 0, 0, 0,
  20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 751616, 845824, 280, 280, 280,
  280, 0, 0, 280, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 1746, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0,
  0, 0, 0, 0, 0, 756, 1004, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 421888, 0, 0, 0, 945, 1169, 0, 0, 0, 0, 951, 1171, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1185, 0, 0, 0, 0, 0, 377, 377, 377, 377, 1300, 0, 0, 0, 1113, 1306, 0, 0, 0, 399, 399, 399, 0,
  0, 0, 0, 0, 1814, 0, 0, 0, 0, 377, 377, 377, 377, 1708, 1709, 1710, 377, 377, 377, 377, 377, 377, 377, 399, 399, 399,
  1802, 399, 399, 399, 399, 399, 1169, 0, 1171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 244, 268, 377, 377, 377,
  1300, 1452, 0, 0, 0, 0, 1306, 1454, 0, 0, 0, 0, 399, 0, 0, 377, 377, 399, 399, 1946, 1947, 377, 399, 377, 399, 377,
  399, 0, 0, 0, 0, 1842, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 1263, 377, 377, 377, 377, 377, 377, 377, 377, 1099,
  377, 377, 377, 377, 377, 377, 1105, 0, 20480, 0, 0, 0, 222, 0, 0, 100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 568, 570, 0, 0,
  0, 0, 0, 100573, 100352, 100352, 100573, 100352, 100352, 100573, 100352, 100352, 100352, 100352, 0, 0, 0, 0, 0, 0, 0,
  0, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 761856,
  557056, 557056, 0, 0, 0, 0, 100352, 100573, 100352, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 65536,
  0, 0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 377, 397, 397, 397, 377, 796672, 0, 0, 0, 843776, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  565711, 0, 0, 0, 0, 0, 67584, 0, 67584, 67584, 67584, 67584, 67584, 67584, 67584, 67584, 67584, 0, 0, 67584, 0, 0, 2,
  2, 3, 47108, 5, 6, 0, 849920, 0, 0, 0, 796672, 0, 0, 557639, 557639, 557639, 557639, 557639, 557639, 557639, 557639,
  557639, 557639, 557639, 557639, 557639, 638, 557695, 557695, 807495, 557639, 813639, 819783, 557639, 557639, 557639,
  834119, 557639, 557639, 850503, 557639, 557639, 557639, 557639, 557639, 557639, 854599, 557639, 557639, 557639,
  557639, 557639, 557639, 557639, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 0, 0,
  557695, 557695, 780927, 557695, 789119, 557695, 793215, 557695, 557695, 807551, 557695, 813695, 819839, 557695,
  557695, 557695, 0, 0, 0, 0, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377, 377, 592, 377, 377, 377, 377, 834175, 557695,
  557695, 850559, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 907903, 557695, 0,
  718848, 0, 0, 0, 0, 0, 0, 0, 557639, 557639, 557639, 557639, 557639, 557639, 766535, 557639, 557639, 795207, 557639,
  557639, 827975, 557639, 557639, 858695, 0, 0, 0, 825344, 0, 0, 825344, 0, 0, 0, 557056, 557639, 686663, 557639,
  557639, 557639, 0, 0, 0, 0, 0, 557695, 686719, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 698368, 0, 0,
  0, 0, 0, 0, 856064, 778240, 557639, 776775, 557639, 557639, 557639, 557639, 557639, 557639, 557639, 817735, 821831,
  825927, 557639, 557639, 557639, 557639, 0, 0, 0, 0, 536576, 0, 0, 0, 0, 557695, 557695, 557695, 752199, 557639,
  557639, 557639, 557639, 557639, 557639, 791111, 557639, 557639, 557639, 809543, 557639, 557639, 842311, 846407,
  557695, 705151, 707199, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 752255, 557695,
  557695, 557695, 557695, 557695, 0, 0, 0, 0, 684615, 557639, 557639, 557639, 557639, 883271, 684671, 557695, 557695,
  557695, 887423, 891519, 557695, 557695, 557695, 903807, 557695, 557695, 557695, 557695, 557695, 557695, 557695,
  557695, 557695, 557695, 557695, 766591, 557695, 557695, 795263, 557695, 909312, 919552, 931840, 0, 0, 0, 0, 909312,
  919552, 557639, 688711, 557639, 557639, 557639, 713287, 557639, 725575, 557639, 557639, 557639, 557639, 557639,
  754247, 764487, 557639, 557639, 557639, 784967, 557639, 557639, 557639, 557639, 557639, 907847, 557639, 557639,
  557639, 557639, 557639, 557639, 637, 0, 0, 640, 557639, 932423, 557639, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 557695,
  557695, 557695, 557695, 883327, 729088, 0, 0, 860160, 557639, 774727, 868935, 557639, 557695, 774783, 868991, 688767,
  557695, 557695, 557695, 713343, 557695, 557695, 725631, 557695, 557695, 557695, 557695, 557695, 754303, 764543,
  557695, 557695, 557695, 717439, 731775, 733823, 557695, 557695, 750207, 557695, 557695, 557695, 557695, 557695,
  557695, 854655, 557695, 557695, 785023, 557695, 557695, 557695, 557695, 557695, 852607, 557695, 557695, 557695,
  557695, 557695, 557695, 557695, 557695, 557695, 911999, 557695, 557695, 557695, 557695, 557695, 557695, 895615,
  557695, 909951, 557695, 920191, 557695, 557695, 932479, 557695, 0, 0, 0, 0, 0, 0, 0, 0, 0, 725, 0, 0, 0, 251, 251, 0,
  765952, 555008, 555008, 876544, 555008, 892928, 0, 765952, 0, 0, 557639, 557639, 557639, 557639, 557639, 557639,
  557639, 924231, 682623, 557695, 557695, 709247, 557695, 557695, 557695, 746111, 557695, 828031, 557695, 557695,
  858751, 557695, 557695, 877183, 557695, 557695, 893567, 901759, 557695, 557695, 557695, 936575, 802816, 0, 682567,
  557639, 557639, 709191, 557639, 557639, 557639, 746055, 557639, 557639, 778823, 803399, 557639, 557639, 557639,
  557639, 762439, 557639, 557639, 557639, 557639, 780871, 557639, 789063, 557639, 793159, 557639, 557639, 852551,
  557639, 557639, 557639, 557639, 557639, 557639, 557639, 895559, 557639, 909895, 557639, 920135, 557639, 557695,
  557695, 778879, 803455, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 924287, 0, 714752, 0,
  878592, 692224, 714752, 555008, 804864, 878592, 804864, 557639, 692807, 696903, 715335, 557639, 557639, 557639,
  557639, 557639, 557639, 918087, 557695, 735871, 739967, 557695, 557695, 557695, 557695, 557695, 557695, 817791,
  821887, 825983, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695, 557695,
  557695, 557695, 557695, 557695, 762495, 557695, 557695, 772679, 805447, 830023, 866887, 557639, 879175, 557639,
  557639, 557639, 922183, 557695, 692863, 696959, 715391, 557695, 557695, 557695, 557695, 557695, 744063, 557695,
  557695, 557695, 557695, 760447, 557695, 557695, 557695, 776831, 557695, 557695, 557695, 772735, 805503, 830079,
  866943, 557695, 879231, 557695, 557695, 557695, 922239, 0, 0, 0, 0, 0, 0, 0, 1747, 1748, 0, 0, 0, 1752, 0, 0, 0,
  837632, 0, 0, 0, 0, 0, 823296, 0, 937984, 739328, 739328, 557639, 735815, 739911, 557639, 557639, 877127, 557639,
  557639, 893511, 901703, 557639, 557639, 557639, 936519, 0, 0, 0, 0, 557695, 557695, 557695, 918143, 0, 0, 0, 0,
  839680, 0, 0, 0, 0, 0, 557639, 557639, 557639, 557639, 705095, 707143, 557639, 557639, 557639, 557639, 557639, 557639,
  557639, 557639, 557639, 557639, 557639, 557639, 911943, 557639, 557639, 557639, 557695, 557695, 748159, 557695,
  557695, 557695, 557695, 557695, 557695, 557695, 700416, 0, 727040, 884736, 0, 0, 0, 0, 0, 0, 557056, 557056, 747520,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 700416, 0, 727040, 884736, 0, 0, 0, 0, 557639, 557639, 756295,
  557639, 832071, 557639, 557639, 557639, 885319, 557695, 557695, 756351, 557695, 832127, 557695, 557695, 557695,
  885375, 722944, 0, 0, 0, 0, 557639, 557639, 557639, 557639, 557639, 557639, 557695, 557695, 557695, 791167, 557695,
  557695, 557695, 809599, 557695, 557695, 842367, 846463, 557695, 557695, 557695, 557695, 557695, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 759808, 0, 0, 0, 557695, 768000, 786432, 737863, 557639, 737919, 557695, 557639, 557695, 557639,
  557695, 557639, 557695, 875079, 875135, 0, 0, 0, 0, 0, 100352, 100352, 100352, 100352, 100352, 100352, 100574, 100352,
  100574, 100352, 100352, 0, 20480, 0, 0, 0, 0, 0, 108544, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 108544, 108544, 108544, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 108544, 108544, 108544, 108544, 108544,
  108544, 108544, 108544, 108544, 108544, 108544, 0, 0, 0, 0, 0, 811008, 0, 0, 28672, 0, 0, 0, 14336, 0, 0, 776192, 0,
  817152, 0, 0, 0, 0, 0, 0, 767, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 102400, 0, 0, 0, 218, 0, 0, 0, 218, 0, 219, 0,
  0, 0, 219, 0, 0, 0, 704512, 0, 0, 0, 0, 0, 129024, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1600, 0, 0, 0, 0, 218, 0, 219, 0,
  0, 0, 710656, 0, 0, 0, 0, 0, 0, 0, 753664, 0, 0, 0, 0, 0, 145408, 145408, 145408, 145408, 145408, 145408, 145408,
  145408, 145408, 145408, 145408, 0, 0, 0, 0, 0, 557056, 931840, 557056, 637, 0, 0, 0, 637, 0, 640, 0, 0, 0, 640, 0,
  557056, 0, 718848, 0, 0, 0, 0, 0, 0, 0, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 698368, 0, 0, 0, 0, 0,
  0, 856064, 778240, 557056, 557056, 876544, 557056, 557056, 892928, 901120, 557056, 557056, 557056, 935936, 637, 0,
  640, 0, 557056, 557056, 557056, 0, 0, 0, 0, 0, 202, 1100202, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 315, 315, 315, 315, 315,
  315, 315, 315, 315, 315, 315, 315, 315, 1037, 315, 0, 110890, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110926, 110926,
  0, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 110926, 0, 0, 0, 0,
  0, 111013, 111013, 111013, 111013, 110926, 110926, 111015, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 153600, 0, 0,
  528384, 218, 219, 0, 0, 0, 0, 0, 0, 0, 1356, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 555008, 555008,
  555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 557639,
  557639, 748103, 557639, 557639, 557639, 557639, 557639, 557639, 557639, 887367, 891463, 557639, 557639, 557639,
  903751, 557639, 557639, 557639, 557056, 557056, 557056, 0, 0, 0, 118784, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377,
  589, 377, 377, 377, 377, 377, 0, 2, 3, 47108, 5, 6, 0, 0, 124928, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 710656, 0, 0,
  0, 0, 0, 0, 0, 753664, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125263, 125263, 125263, 0, 0, 2, 2, 3,
  47108, 5, 6, 0, 125263, 125263, 0, 125263, 125263, 124928, 124928, 124928, 124928, 124928, 125263, 124928, 125263,
  124928, 125263, 125263, 125263, 125263, 125263, 125263, 125263, 125263, 125263, 125263, 125263, 0, 0, 0, 0, 0, 0, 0,
  0, 557639, 557639, 557639, 557639, 557639, 557639, 557639, 557639, 744007, 557639, 557639, 557639, 557639, 760391,
  557639, 557639, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 57344, 0,
  120832, 0, 131072, 557056, 557056, 557056, 0, 0, 0, 120832, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 434, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 108544, 108544, 0, 0, 108544, 108544, 0, 0, 2, 3, 47108, 5, 6, 0, 0, 0, 129024, 0, 0, 0, 0, 129024, 0, 0, 0, 0,
  0, 424250, 424250, 424250, 424250, 424250, 424250, 424250, 424250, 424250, 424250, 424250, 0, 0, 0, 0, 0, 0, 20480, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 129360, 129360, 129360, 0, 0, 2, 2, 3, 47108, 0, 6, 0, 129360, 129360, 0, 129360,
  129360, 129360, 129360, 129360, 129360, 129360, 129360, 129360, 129360, 129360, 129360, 129360, 0, 0, 0, 0, 129024, 0,
  137216, 0, 0, 0, 0, 0, 0, 528384, 218, 219, 98304, 0, 0, 0, 0, 0, 0, 0, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 555008,
  555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 0, 0, 0, 126976, 133120, 0, 2, 3,
  47108, 573646, 6, 0, 0, 0, 0, 210, 0, 0, 0, 0, 210, 135168, 135168, 135168, 135168, 0, 0, 135168, 0, 0, 2, 2, 3,
  47108, 573646, 6, 0, 0, 0, 0, 0, 864256, 0, 0, 0, 0, 555008, 555008, 555008, 733184, 555008, 555008, 555008, 555008,
  555008, 555008, 555008, 555008, 555008, 555008, 555008, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 557056, 557056, 557056, 0, 122880, 0, 122880, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 444, 445, 0, 0, 0, 0, 0, 0, 0, 0,
  503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1006, 0, 0, 0, 0, 0, 0, 139264, 139264, 139264, 139264, 0, 0, 139264, 0, 0, 2, 2, 3,
  47108, 5, 6, 0, 0, 0, 0, 227, 228, 229, 230, 231, 232, 0, 0, 0, 0, 0, 0, 0, 0, 709, 0, 0, 0, 0, 0, 0, 0, 0, 26824, 2,
  3, 47108, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1751, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315,
  315, 315, 0, 0, 0, 0, 377, 377, 377, 377, 377, 1547, 0, 0, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0,
  1169, 0, 0, 0, 0, 0, 1171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1199, 0, 0, 0, 0, 0, 0, 1391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 450, 0, 1010, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 1218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 480, 0, 0, 20480, 0, 0, 0, 0, 0, 300, 0, 315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 377, 377, 1544, 377, 377,
  377, 400, 397, 397, 397, 397, 397, 397, 397, 397, 397, 397, 400, 400, 400, 400, 400, 397, 397, 400, 26824, 26824, 2,
  2, 3, 47108, 5, 6, 0, 26825, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 20480, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 0, 143360, 143360, 0, 0,
  0, 0, 0, 0, 0, 143360, 0, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 0, 0, 2, 2, 3, 47108, 5, 6, 0,
  143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 0, 0, 0, 0, 0, 0, 0, 0,
  808960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 0, 0, 0, 251, 0, 0, 557056, 557056, 557056, 557056, 557056, 0, 151552, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 0, 0, 0, 770048, 757760, 782336, 0, 0, 870400, 0, 913408, 925696, 0, 679936,
  872448, 114688, 0, 0, 0, 0, 0, 0, 827, 377, 377, 377, 377, 377, 377, 377, 839, 377, 0, 202, 3, 47108, 5, 207, 0, 0, 0,
  0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 65536, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 213, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 752, 752, 0, 20480, 0, 0, 0, 0, 0, 0, 145408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 753, 0, 0, 757, 0,
  0, 0, 145408, 0, 0, 0, 145408, 145408, 145408, 0, 0, 202, 202, 3, 47108, 5, 1100202, 0, 0, 0, 0, 234, 273, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 233, 0, 0, 428, 0, 0, 0, 0, 0, 528384, 218, 219, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 251, 0, 0, 0,
  203, 3, 47108, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 290, 290, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 760, 0, 0, 0, 422, 422, 422, 422, 0, 0, 422, 0, 0, 1083817, 203, 3, 47108, 5, 6, 0, 0, 0, 0, 235, 258,
  237, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77824, 77824, 0, 0, 0, 0, 557056, 557056, 557056, 0, 0, 695, 0, 0, 696, 6, 0,
  0, 149504, 0, 0, 0, 0, 0, 0, 827, 377, 377, 377, 377, 377, 377, 835, 377, 377, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 244, 223, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 775, 0, 0, 20480, 0, 0, 0, 223, 0, 0, 308, 316,
  316, 316, 316, 316, 316, 337, 337, 316, 337, 337, 358, 358, 358, 358, 358, 358, 369, 358, 369, 358, 358, 358, 358,
  358, 358, 358, 358, 316, 358, 358, 378, 378, 378, 378, 378, 401, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378,
  401, 401, 401, 401, 401, 378, 378, 401, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 438, 439, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1201, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 490, 0, 0, 0, 494, 0, 0, 0, 0, 0, 260, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 235, 22528, 24576, 0, 0, 0, 0, 435, 0, 0, 0, 0, 0, 0, 0, 0, 0, 506, 0, 0, 0, 0, 0, 0, 0, 75776, 528384, 218,
  219, 0, 104448, 0, 0, 0, 0, 513, 0, 0, 517, 0, 0, 0, 521, 0, 315, 315, 525, 315, 315, 315, 315, 315, 315, 810, 315,
  812, 0, 0, 0, 0, 0, 0, 0, 0, 0, 997, 0, 0, 1000, 0, 0, 0, 0, 555, 0, 0, 0, 0, 0, 0, 452, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  251, 251, 251, 0, 0, 0, 555, 0, 555, 0, 0, 0, 438, 0, 0, 0, 0, 0, 0, 0, 578, 579, 0, 0, 0, 521, 0, 490, 521, 0, 377,
  377, 588, 377, 377, 377, 377, 377, 377, 377, 1083, 377, 377, 377, 377, 1086, 1087, 377, 1089, 377, 613, 615, 377, 620,
  377, 623, 377, 377, 634, 377, 377, 377, 0, 399, 399, 399, 399, 399, 928, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 1738, 399, 399, 399, 0, 0, 399, 645, 399, 399, 399, 399, 399, 399, 670, 672, 399, 677, 399, 680, 399, 399, 399,
  399, 399, 1144, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1666, 1667, 399, 399, 399, 399, 691, 399, 399, 0, 0,
  0, 0, 26824, 2, 6, 0, 0, 0, 0, 698, 702, 315, 315, 315, 315, 809, 315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 770,
  0, 0, 0, 0, 0, 0, 377, 377, 873, 377, 377, 377, 377, 377, 377, 377, 377, 377, 637, 45942, 827, 640, 0, 315, 315, 315,
  315, 315, 1032, 315, 315, 315, 315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 816, 0, 0, 0, 0, 0, 0, 1055, 0, 0, 0, 0, 0,
  827, 377, 377, 1059, 377, 377, 377, 377, 0, 1303, 0, 0, 1113, 0, 1309, 0, 0, 399, 399, 399, 399, 399, 399, 1662, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 1492, 0, 0, 0, 377, 377, 377, 1110, 1113, 45942, 1115, 1113, 399,
  399, 1119, 399, 399, 399, 399, 399, 0, 0, 0, 0, 377, 1930, 377, 377, 377, 377, 399, 399, 1859, 399, 399, 399, 399,
  399, 399, 399, 1867, 1868, 399, 399, 399, 1129, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 0, 1781,
  0, 0, 1176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 269, 0, 0, 0, 1207, 0, 1209, 0, 0, 0, 0, 0, 1004, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 218, 0, 0, 315, 315, 1234, 1235, 315, 315, 315, 315, 315, 315, 315, 315,
  1242, 315, 315, 0, 0, 0, 377, 377, 1637, 377, 377, 377, 377, 377, 377, 1642, 377, 377, 377, 377, 377, 377, 1828, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 1134, 399, 399, 399, 399, 399, 399, 1252, 377, 377, 377, 377, 377, 1262, 377,
  1264, 377, 377, 1267, 377, 377, 377, 377, 0, 0, 0, 0, 1113, 0, 0, 0, 0, 399, 399, 399, 399, 399, 1316, 399, 1318, 399,
  399, 1321, 399, 399, 399, 399, 399, 399, 399, 399, 931, 399, 399, 399, 399, 399, 399, 399, 1169, 0, 1171, 0, 0, 1355,
  0, 0, 0, 0, 0, 1360, 0, 0, 0, 0, 0, 0, 0, 83968, 0, 83968, 0, 0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 389, 389, 389, 389, 389,
  0, 0, 1392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 218, 218, 1450, 377, 377, 0, 1452, 0, 0, 0, 0, 0, 1454, 0, 0,
  0, 0, 399, 0, 0, 377, 1944, 399, 1945, 377, 399, 377, 399, 377, 399, 377, 399, 0, 0, 377, 377, 399, 399, 377, 399,
  377, 399, 1950, 1951, 377, 399, 0, 0, 0, 1841, 0, 0, 1844, 1845, 0, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1266,
  377, 377, 377, 377, 377, 0, 0, 0, 1498, 0, 0, 0, 0, 0, 0, 1501, 0, 0, 0, 0, 0, 0, 0, 459, 460, 0, 251, 251, 251, 0, 0,
  0, 399, 399, 1583, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 681, 399, 399, 399, 399, 399,
  1674, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377, 377, 399, 399, 399, 1810, 0, 1812, 0, 0, 0, 1815, 0, 0,
  1818, 377, 377, 377, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399, 0, 0, 1871, 0, 0, 1874, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 1452, 0, 1454, 0, 399, 1896, 0, 377, 377, 377, 377, 377, 377, 377, 377, 377, 399, 399, 399,
  399, 399, 1862, 399, 399, 399, 399, 0, 0, 0, 224, 225, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1214, 0, 0, 0, 0,
  226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 219, 219, 0, 0, 315, 0, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219,
  219, 219, 219, 219, 1008, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1414, 315, 315,
  1405, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1413, 315, 315, 315, 315, 315, 1415, 0, 0,
  0, 0, 0, 377, 377, 377, 1421, 1422, 377, 377, 377, 377, 377, 377, 1069, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  1071, 377, 377, 377, 377, 377, 377, 399, 399, 1458, 1459, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  935, 399, 399, 399, 1853, 377, 1855, 377, 399, 399, 399, 399, 1861, 399, 1863, 399, 1865, 399, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 377, 377, 377, 377, 1851, 377, 292, 20480, 292, 299, 299, 299, 299, 0, 309, 317, 317, 317, 317, 317, 317, 338, 338,
  317, 353, 355, 359, 359, 359, 367, 367, 368, 359, 368, 359, 368, 368, 368, 368, 368, 368, 368, 368, 317, 368, 368,
  379, 379, 379, 379, 379, 402, 379, 379, 379, 379, 379, 379, 379, 379, 379, 379, 402, 402, 402, 402, 402, 379, 379,
  402, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 485, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1504, 0, 0, 0, 0,
  731, 713, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1613, 0, 0, 0, 745, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 970, 0,
  0, 0, 0, 780, 0, 0, 0, 0, 0, 0, 315, 787, 315, 315, 315, 315, 315, 315, 315, 1044, 315, 315, 315, 315, 0, 0, 0, 0, 0,
  0, 0, 528384, 0, 0, 0, 0, 0, 0, 0, 428032, 315, 315, 315, 315, 797, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315,
  315, 553, 0, 0, 0, 0, 0, 0, 0, 0, 816, 0, 0, 827, 828, 377, 831, 377, 377, 377, 377, 838, 377, 377, 377, 377, 377,
  860, 377, 377, 862, 377, 864, 377, 377, 377, 377, 377, 377, 377, 1430, 377, 377, 377, 377, 377, 377, 377, 377, 851,
  377, 377, 377, 377, 377, 377, 377, 842, 377, 377, 377, 377, 377, 848, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  1100, 1101, 377, 377, 377, 377, 377, 889, 399, 892, 399, 399, 399, 399, 899, 399, 903, 399, 399, 399, 399, 399, 909,
  0, 0, 0, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1689, 0, 0, 377, 377, 1078, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 0, 399, 399, 377, 1091, 1092, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 1075, 377, 315, 1536, 315, 315, 315, 315, 0, 0, 1540, 0, 377, 377, 377, 377, 377, 377, 377, 377, 1265,
  377, 377, 377, 1269, 377, 1271, 0, 0, 0, 1595, 0, 0, 0, 0, 0, 1598, 0, 0, 0, 0, 0, 0, 0, 0, 710, 711, 0, 0, 0, 0, 0,
  0, 0, 0, 736, 0, 738, 0, 0, 0, 0, 0, 1630, 315, 0, 0, 1634, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 0,
  0, 0, 0, 399, 377, 377, 377, 377, 1647, 1648, 377, 377, 377, 377, 377, 377, 377, 377, 399, 399, 1725, 399, 399, 399,
  399, 399, 399, 1839, 0, 1840, 0, 0, 0, 0, 0, 0, 377, 377, 377, 1850, 377, 377, 377, 377, 377, 377, 1082, 377, 377,
  377, 377, 377, 377, 377, 377, 377, 1767, 377, 399, 399, 399, 399, 399, 399, 1943, 0, 0, 377, 377, 399, 399, 377, 399,
  377, 399, 377, 399, 377, 399, 0, 0, 0, 0, 0, 1843, 0, 0, 1846, 377, 1848, 377, 377, 377, 377, 0, 0, 0, 1305, 1113, 0,
  0, 0, 1311, 399, 399, 399, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 222, 0, 0, 0, 20480, 0, 0, 0, 0, 0,
  301, 310, 318, 318, 318, 318, 318, 318, 339, 339, 318, 339, 356, 360, 360, 360, 360, 360, 360, 360, 360, 360, 360,
  360, 318, 360, 360, 380, 380, 380, 380, 380, 403, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 403, 403, 403,
  403, 403, 380, 380, 403, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 315, 538, 315, 315, 315, 315, 315, 315, 315, 315, 315,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 377, 605, 0, 0, 719, 0, 0, 0, 722, 723,
  0, 0, 0, 0, 0, 251, 251, 0, 0, 0, 0, 241, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 447, 0, 0, 0, 0, 0, 0, 0, 315, 315, 796,
  315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 804, 315, 315, 0, 0, 0, 377, 1636, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 1565, 377, 377, 0, 0, 0, 0, 399, 315, 806, 315, 315, 315, 315, 315, 315, 315, 813, 0, 0, 0, 0, 0,
  0, 0, 0, 965, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1019, 0, 0, 1022, 0, 0, 0, 722, 0, 0, 0, 0, 0, 827, 829, 377, 377, 377, 377,
  377, 377, 377, 377, 1098, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 846, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 1282, 377, 377, 890, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 907, 399,
  399, 399, 0, 0, 0, 0, 200, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 519, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1358, 0, 0, 0, 0, 0, 0, 399,
  923, 399, 925, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1350, 1351, 399, 399, 0, 1169, 0, 0, 0, 0,
  0, 1171, 0, 0, 0, 0, 0, 1174, 0, 0, 0, 0, 0, 457, 0, 0, 0, 0, 251, 251, 251, 0, 0, 0, 0, 0, 0, 827, 377, 377, 377,
  377, 377, 377, 836, 377, 377, 1296, 1297, 377, 377, 0, 0, 0, 0, 1113, 0, 0, 0, 0, 399, 399, 399, 0, 0, 0, 0, 200, 2,
  6, 0, 0, 0, 0, 699, 703, 399, 399, 399, 1317, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1740, 399,
  0, 0, 1404, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 0, 377, 377, 377,
  377, 1441, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 0, 0, 0, 0, 1567, 399, 1457, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1509, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 251, 251, 0, 377, 377, 1550, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1559, 377, 377, 377, 377, 377,
  1081, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1291, 377, 377, 1293, 377, 377, 399, 399, 399, 1584, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1780, 0, 1782, 0, 0, 20480, 0, 0, 236, 0, 236, 302, 311, 319, 319,
  319, 319, 319, 319, 340, 350, 340, 319, 340, 340, 361, 361, 361, 361, 361, 361, 370, 361, 370, 361, 361, 361, 361,
  361, 361, 361, 361, 319, 361, 361, 381, 381, 381, 381, 381, 404, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381,
  404, 404, 404, 404, 404, 381, 381, 404, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 468, 469, 0, 471, 0, 0, 474, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 966, 0, 0, 0, 0, 0, 0, 482, 0, 0, 0, 0, 0, 0, 489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0,
  0, 0, 0, 0, 514, 515, 0, 0, 518, 0, 0, 0, 0, 315, 315, 315, 527, 315, 315, 0, 0, 0, 377, 377, 377, 377, 377, 377, 377,
  377, 1641, 377, 377, 377, 377, 377, 377, 1096, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1279, 377, 377, 377, 377,
  377, 377, 535, 315, 541, 315, 544, 315, 547, 315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 377, 377, 1420, 377, 377, 377, 377,
  0, 0, 0, 468, 0, 0, 0, 518, 0, 559, 0, 576, 0, 0, 0, 0, 0, 0, 0, 528384, 0, 0, 0, 0, 0, 0, 417792, 0, 611, 377, 616,
  377, 377, 622, 625, 629, 377, 377, 377, 377, 377, 0, 399, 399, 399, 399, 399, 1158, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 918, 399, 399, 399, 399, 399, 399, 399, 648, 399, 399, 659, 399, 668, 399, 673, 399, 399, 679, 682,
  686, 399, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 399, 399, 399, 399, 399, 399, 0, 718, 0, 0, 0, 0, 0, 0, 0,
  0, 726, 727, 0, 251, 251, 0, 0, 0, 0, 275, 0, 0, 0, 0, 275, 0, 22528, 24576, 0, 0, 0, 0, 0, 0, 1697, 0, 315, 315,
  1700, 1701, 315, 315, 315, 0, 1416, 0, 0, 0, 0, 1419, 377, 377, 377, 377, 377, 1423, 377, 843, 377, 377, 377, 847,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1654, 377, 377, 399, 399, 377, 857, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 866, 377, 377, 377, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1456, 399, 399, 399, 943, 399, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 257, 0, 223, 957, 0, 959, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 0, 973, 974, 0,
  976, 0, 0, 0, 0, 981, 0, 0, 0, 0, 986, 0, 0, 0, 0, 429, 0, 0, 0, 528384, 218, 219, 0, 0, 0, 0, 0, 0, 0, 455, 0, 0,
  315, 315, 315, 315, 315, 315, 315, 315, 1239, 315, 315, 315, 315, 315, 0, 0, 0, 991, 0, 0, 0, 0, 0, 0, 0, 999, 0, 0,
  0, 0, 0, 0, 0, 528384, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 1003, 0, 1004, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 256, 0,
  256, 0, 0, 315, 1027, 1028, 315, 315, 315, 315, 315, 1034, 315, 315, 1036, 315, 315, 315, 315, 315, 315, 1043, 315,
  315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 377, 377, 377, 377, 1878, 377, 1880, 377, 377, 377, 315, 1040, 315, 315, 315,
  1042, 315, 315, 315, 315, 315, 315, 0, 0, 0, 1051, 0, 0, 1054, 0, 0, 0, 0, 0, 959, 959, 827, 1058, 377, 377, 1060,
  377, 377, 377, 377, 377, 1276, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1768, 399, 399, 399, 399, 399, 1062,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1073, 377, 377, 377, 1076, 1090, 377, 377, 377, 377, 1095, 377,
  1097, 377, 377, 377, 377, 377, 1103, 377, 377, 377, 377, 377, 377, 1289, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  1431, 377, 377, 377, 1434, 377, 377, 377, 377, 1108, 0, 1113, 45942, 0, 1113, 1118, 399, 399, 1120, 399, 1122, 399,
  399, 399, 399, 399, 1159, 399, 399, 399, 399, 399, 399, 1165, 399, 1167, 399, 399, 399, 1155, 399, 1157, 399, 399,
  399, 399, 399, 1163, 399, 399, 399, 399, 1168, 0, 0, 1178, 0, 0, 0, 1182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315,
  315, 315, 793, 1217, 0, 0, 0, 0, 0, 0, 0, 1225, 0, 1227, 0, 0, 1230, 0, 0, 0, 0, 0, 487, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 555008, 555008, 555008, 555008, 555008, 555008, 377, 377, 1285, 1286, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 1448, 377, 377, 377, 377, 1298, 377, 0, 0, 0, 0, 1113, 0, 0, 0, 0, 399, 399, 399, 0, 0, 0, 0,
  26824, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 394, 394, 394, 394, 394, 1169, 0, 1171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1363, 0, 1379, 1380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1390, 0, 0, 0, 0, 1393, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 249, 0, 0, 0, 0, 1437, 377, 1439, 377, 377, 377, 377, 377, 377, 1446, 377, 377, 377, 377, 377, 1449, 315, 315,
  1537, 315, 315, 315, 0, 0, 0, 1541, 377, 377, 377, 377, 377, 377, 377, 878, 377, 377, 377, 377, 637, 45942, 827, 640,
  1548, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1557, 377, 377, 377, 377, 0, 0, 0, 0, 1113, 0, 0, 0, 0, 399,
  399, 1314, 1582, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 922, 0, 0, 1605,
  1606, 0, 1607, 0, 0, 0, 1609, 1610, 0, 0, 0, 0, 0, 0, 0, 473, 0, 475, 0, 0, 0, 0, 0, 0, 0, 0, 1397, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 77824, 0, 0, 0, 0, 0, 0, 315, 1631, 1632, 1633, 0, 377, 377, 377, 1638, 377, 377, 377, 377, 377, 377, 377,
  399, 399, 399, 399, 1803, 399, 399, 399, 399, 1643, 377, 377, 1646, 377, 377, 377, 377, 377, 1651, 1653, 377, 1655,
  1656, 399, 399, 399, 399, 399, 1333, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 904, 399, 399, 399, 908, 399,
  399, 1660, 399, 399, 399, 399, 399, 399, 399, 1665, 399, 399, 1668, 399, 399, 399, 0, 0, 0, 0, 26824, 2, 6, 0, 0, 0,
  0, 699, 703, 399, 399, 1673, 1675, 399, 1677, 1678, 0, 0, 0, 0, 1682, 0, 1684, 0, 0, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0,
  0, 0, 510, 0, 0, 0, 0, 1694, 0, 0, 0, 0, 315, 315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 1542, 377, 377, 377, 377, 377,
  0, 0, 377, 377, 1707, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1715, 0, 1784, 0, 0, 1787, 1788, 0, 0, 0, 0,
  315, 377, 377, 377, 377, 1793, 1838, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377, 1849, 377, 377, 377, 0, 0, 0, 1453, 0, 1111,
  0, 0, 0, 1455, 0, 1116, 399, 1884, 399, 399, 1886, 399, 1888, 399, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 1921, 399, 399, 399, 1925, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 399,
  1858, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 377, 377, 1931, 1932, 377, 377, 399, 293, 20480, 293, 293,
  293, 293, 293, 0, 293, 320, 320, 320, 320, 320, 320, 0, 0, 0, 0, 466, 0, 0, 0, 466, 0, 491, 0, 0, 0, 0, 0, 0, 0, 995,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1399, 0, 0, 1402, 0, 0, 0, 0, 320, 254, 254, 293, 293, 293, 293, 293, 293, 293, 293,
  293, 293, 293, 320, 293, 293, 382, 382, 382, 382, 382, 405, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 405,
  405, 405, 405, 405, 382, 382, 405, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 453, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251,
  251, 0, 0, 0, 0, 0, 0, 827, 377, 377, 377, 377, 377, 834, 377, 377, 377, 0, 0, 1304, 0, 0, 0, 0, 0, 1310, 0, 0, 0,
  399, 0, 0, 0, 714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 0, 0, 0, 399, 399, 399, 1156, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 906, 399, 399, 399, 399, 294, 20480, 294, 294, 294, 294, 294, 303, 294, 321, 321,
  321, 321, 321, 321, 341, 341, 321, 341, 341, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 321, 362, 362,
  383, 383, 383, 383, 383, 406, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 406, 406, 406, 406, 406, 383, 383,
  406, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 377, 377, 377, 1111, 1113, 45942, 1116, 1113, 399, 399, 399, 399, 399,
  399, 399, 399, 1488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 280, 280, 280, 280, 280,
  1616, 0, 0, 0, 0, 0, 1621, 0, 0, 0, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1243, 0, 1692, 0,
  0, 0, 1696, 0, 0, 1699, 315, 315, 315, 315, 315, 315, 0, 0, 0, 1418, 0, 0, 377, 377, 377, 377, 377, 377, 377, 377,
  1712, 377, 377, 377, 377, 377, 0, 0, 377, 1706, 377, 377, 377, 377, 377, 377, 377, 1713, 377, 377, 377, 377, 0, 0, 0,
  0, 1113, 0, 0, 0, 0, 1312, 399, 399, 1716, 377, 377, 377, 377, 377, 377, 377, 399, 1724, 399, 399, 399, 399, 399, 399,
  896, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1489, 1490, 0, 0, 0, 0, 0, 399, 1731, 399, 399, 399, 399, 1734, 399,
  399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 377, 377, 377, 377, 399, 399, 399, 1860, 399, 399, 399, 399, 399, 399, 0, 0,
  0, 0, 377, 377, 377, 377, 1933, 377, 399, 1754, 0, 315, 315, 1755, 315, 315, 0, 377, 377, 377, 377, 377, 1758, 377,
  377, 377, 377, 377, 377, 1443, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1566, 377, 0, 0, 0, 0, 399, 377, 377, 377,
  377, 1764, 377, 377, 377, 377, 377, 399, 399, 399, 399, 399, 1770, 399, 1935, 1936, 399, 399, 0, 0, 0, 0, 377, 377,
  377, 377, 399, 399, 399, 0, 1811, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 377, 606, 399, 646, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 689, 399, 399, 692, 399, 0, 0, 0, 0, 26824, 2, 6, 0, 0, 0,
  0, 0, 0, 0, 0, 980, 0, 0, 0, 0, 0, 0, 0, 0, 0, 821, 0, 0, 0, 0, 0, 0, 399, 1484, 399, 399, 399, 399, 399, 399, 399, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 516, 0, 0, 0, 0, 563, 0, 0,
  0, 0, 0, 0, 0, 964, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 219, 0, 0, 0, 434, 0, 0, 238, 0, 0, 0, 0, 0, 0, 0, 263, 0, 0, 0,
  0, 0, 0, 0, 0, 996, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1500, 0, 0, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 304, 0, 322, 322, 322,
  322, 322, 322, 342, 342, 322, 342, 342, 363, 342, 342, 342, 342, 342, 371, 342, 371, 342, 342, 342, 342, 342, 342,
  342, 342, 322, 342, 342, 384, 384, 384, 384, 384, 407, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 407, 407,
  407, 407, 407, 384, 384, 407, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315,
  528, 315, 315, 0, 0, 0, 377, 377, 377, 377, 1639, 377, 377, 377, 377, 377, 377, 377, 1070, 377, 377, 377, 377, 377,
  377, 377, 377, 1084, 377, 377, 377, 377, 377, 377, 377, 0, 0, 0, 556, 0, 0, 0, 556, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 253, 0, 0, 399, 399, 649, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 685, 399, 399, 817,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 822, 0, 0, 0, 0, 0, 0, 0, 488, 752, 0, 0, 0, 756, 0, 0, 0, 377, 377, 377, 874, 377, 377,
  377, 377, 879, 377, 377, 377, 637, 45942, 827, 640, 399, 940, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288,
  288, 0, 0, 0, 972, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 987, 0, 1002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1009, 0, 0, 0, 1011, 1012, 0, 0, 1015, 0, 0, 0, 0, 0, 0, 0, 0, 1025, 377, 377, 377, 377, 1094, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 1281, 377, 377, 377, 1106, 377, 377, 0, 1113, 45942, 0, 1113, 399, 399, 399,
  399, 399, 399, 399, 399, 1576, 399, 399, 399, 399, 399, 399, 399, 399, 1154, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 1166, 399, 399, 399, 399, 399, 1344, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1578, 399, 399,
  399, 399, 399, 0, 1205, 0, 0, 0, 0, 0, 0, 1212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1184, 0, 0, 0, 0, 0, 0, 0, 377, 377, 377,
  1261, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 636, 377, 0, 399, 399, 1315, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 938, 0, 0, 0, 1366, 0, 0, 0, 1370, 0, 1372, 0, 0, 0, 1375, 0, 0, 0,
  0, 0, 554, 0, 0, 448, 0, 575, 0, 520, 0, 0, 0, 0, 0, 0, 970, 0, 0, 0, 827, 377, 377, 377, 377, 377, 377, 877, 377,
  377, 377, 377, 377, 637, 45942, 827, 640, 399, 1470, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 921, 399, 315, 315, 315, 315, 1538, 315, 0, 0, 0, 0, 377, 1543, 377, 377, 1546, 377, 377, 377, 377, 377, 1288,
  377, 377, 377, 377, 377, 377, 377, 377, 1294, 377, 377, 377, 377, 377, 1428, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 635, 377, 377, 0, 399, 399, 1560, 377, 377, 1562, 377, 377, 377, 1564, 377, 377, 377, 0, 0, 0, 0, 399, 399,
  399, 399, 894, 399, 399, 901, 399, 399, 905, 399, 399, 399, 399, 399, 0, 0, 0, 0, 1940, 377, 377, 377, 1942, 399, 399,
  1568, 399, 399, 1571, 399, 399, 399, 399, 399, 399, 399, 399, 1579, 399, 399, 399, 399, 0, 0, 0, 0, 0, 1914, 377, 377,
  377, 377, 377, 1920, 1592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 481, 0, 0, 1618, 0, 0, 0, 0, 0, 1623, 0, 315,
  315, 315, 315, 1628, 315, 315, 0, 0, 0, 1635, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1432, 377, 377, 377,
  377, 377, 399, 1672, 399, 399, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377, 1821, 0, 0, 0, 1685, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 235, 236, 237, 0, 0, 0, 0, 0, 1695, 0, 0, 0, 315, 315, 315, 315, 315, 315, 315, 0, 0, 1417, 0,
  0, 0, 377, 377, 377, 377, 377, 377, 377, 377, 377, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1742, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 377, 1823, 377, 1825, 1826, 1827, 377, 399, 399, 399, 399, 1833, 399, 1835, 1836,
  1837, 0, 0, 377, 377, 377, 1900, 377, 1901, 377, 377, 377, 399, 399, 399, 1906, 399, 399, 399, 399, 926, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 1164, 399, 399, 399, 399, 1907, 399, 399, 399, 0, 0, 0, 0, 0, 377, 377,
  377, 377, 377, 377, 399, 399, 399, 399, 944, 0, 0, 0, 0, 0, 0, 950, 0, 0, 0, 956, 262, 0, 0, 0, 0, 0, 0, 282, 0, 0, 0,
  22528, 24576, 0, 0, 0, 0, 0, 0, 963, 0, 0, 0, 0, 968, 0, 0, 0, 0, 0, 0, 0, 794624, 0, 0, 0, 0, 897024, 892928, 0, 0,
  295, 20480, 295, 295, 295, 295, 295, 0, 295, 323, 323, 323, 323, 323, 323, 343, 343, 323, 343, 343, 364, 364, 364,
  364, 364, 364, 364, 364, 364, 364, 364, 323, 364, 374, 385, 385, 385, 385, 385, 408, 385, 385, 385, 385, 385, 385,
  385, 385, 385, 385, 408, 408, 408, 408, 408, 385, 385, 408, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 486, 519, 0, 480,
  0, 0, 0, 0, 377, 377, 377, 377, 594, 377, 377, 377, 0, 0, 45942, 0, 0, 399, 399, 399, 399, 399, 399, 399, 399, 902,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 651, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  934, 399, 399, 399, 399, 805, 315, 315, 315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1386, 0, 0, 0, 0, 0,
  0, 871, 377, 377, 377, 377, 377, 377, 377, 377, 881, 377, 377, 637, 45942, 827, 640, 910, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1328, 399, 399, 924, 399, 399, 399, 399, 399, 399, 932, 399, 399,
  399, 399, 399, 399, 897, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1778, 399, 399, 0, 0, 0, 0, 399, 399, 942, 399,
  399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 315, 0, 315, 315, 315, 1030, 315, 315, 315, 315, 315,
  315, 315, 315, 315, 315, 315, 802, 315, 803, 315, 315, 315, 377, 1064, 1065, 377, 377, 1068, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 852, 377, 377, 377, 377, 377, 1077, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 870, 377, 377, 377, 1111, 1113, 45942, 1116, 1113, 399, 399, 399, 399, 399, 399, 1124, 1125, 399,
  399, 1128, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1137, 399, 399, 399, 399, 399, 1460, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 1468, 0, 0, 1206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1216, 315, 315, 315, 315, 1247, 315,
  315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1515, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 1407, 315, 315, 315, 315, 315,
  315, 315, 315, 315, 315, 315, 1048, 315, 0, 0, 0, 0, 377, 377, 377, 1426, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 1558, 377, 377, 399, 399, 1570, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  936, 399, 399, 0, 0, 0, 0, 1620, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1240, 1241, 315, 315,
  315, 377, 377, 377, 377, 1720, 377, 377, 377, 399, 399, 399, 399, 399, 399, 399, 399, 1736, 399, 399, 399, 399, 399,
  1741, 0, 0, 0, 1898, 377, 377, 377, 377, 377, 377, 377, 377, 1904, 399, 399, 399, 399, 0, 0, 0, 0, 0, 377, 377, 1916,
  1917, 377, 377, 399, 1934, 399, 399, 399, 399, 0, 0, 0, 0, 377, 377, 377, 377, 399, 399, 399, 399, 377, 377, 399,
  26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 576, 0, 0, 377,
  377, 377, 591, 377, 377, 602, 377, 0, 20480, 0, 0, 0, 0, 0, 305, 0, 324, 324, 324, 324, 324, 324, 344, 352, 324, 344,
  344, 344, 344, 344, 344, 344, 344, 344, 344, 344, 344, 344, 324, 344, 344, 386, 386, 386, 386, 386, 409, 386, 386,
  386, 386, 386, 386, 386, 386, 386, 386, 409, 409, 409, 409, 409, 386, 386, 409, 26824, 27048, 2, 2, 3, 47108, 5, 6, 0,
  0, 483, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1024, 0, 0, 447, 0, 0, 0, 0, 0, 0, 377, 377, 377, 377, 595, 377,
  377, 607, 399, 399, 399, 652, 399, 399, 664, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1588, 399, 399, 399, 399,
  399, 399, 0, 0, 0, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 476, 477, 0, 0, 0, 0, 0,
  0, 0, 530432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 758, 0, 0, 0, 0, 0, 714, 0, 0, 0, 0, 315, 315, 315, 315, 791, 315, 377, 872, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 637, 45942, 827, 640, 377, 377, 377, 1066, 377, 377, 377, 377, 377, 377, 1072, 377, 377, 377, 377, 377,
  377, 377, 1444, 377, 377, 377, 377, 377, 377, 377, 377, 1278, 377, 1280, 377, 377, 377, 377, 377, 1126, 399, 399, 399,
  399, 399, 399, 1132, 399, 399, 399, 399, 399, 399, 399, 399, 1777, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 1180, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1190, 0, 0, 1219, 0, 0, 0, 0, 0, 0, 1226, 0, 0, 0, 0, 0, 0, 0, 0, 1357, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399, 399, 1343, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 1326, 1327, 399, 0, 0, 1785, 0, 0, 0, 0, 0, 0, 0, 315, 377, 377, 377, 377, 377, 377, 377, 1554, 377, 377, 377,
  377, 377, 377, 377, 377, 1445, 377, 377, 377, 377, 377, 377, 377, 399, 1809, 399, 0, 0, 0, 1813, 0, 0, 0, 0, 0, 0,
  377, 377, 377, 377, 377, 377, 377, 1881, 377, 377, 0, 0, 241, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 241, 0, 0, 0, 0, 481,
  0, 0, 0, 377, 377, 377, 377, 377, 601, 377, 377, 377, 377, 377, 377, 1765, 377, 377, 377, 399, 399, 399, 399, 1769,
  399, 0, 265, 0, 0, 0, 0, 265, 0, 265, 0, 0, 22528, 24576, 265, 0, 241, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 325, 325, 325,
  325, 325, 325, 345, 351, 351, 325, 351, 345, 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 325, 351, 351,
  387, 387, 387, 387, 387, 410, 387, 387, 387, 387, 387, 387, 387, 387, 387, 387, 410, 410, 410, 410, 410, 387, 387,
  410, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 315, 539, 315, 315, 315, 545, 315, 315, 315, 552, 315, 0, 0, 0, 0, 0, 0,
  0, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 915456, 28672, 0, 0, 0, 0, 554, 0, 0, 0, 0, 562, 0, 0, 0, 0, 0, 571, 0, 467, 0,
  0, 0, 0, 472, 0, 0, 0, 0, 0, 478, 0, 0, 0, 554, 448, 581, 0, 0, 0, 0, 0, 377, 584, 377, 377, 596, 377, 377, 608, 377,
  377, 377, 618, 377, 377, 377, 377, 633, 377, 377, 377, 377, 0, 399, 399, 399, 399, 399, 1473, 399, 399, 399, 399, 399,
  1479, 399, 399, 399, 399, 0, 0, 0, 0, 0, 377, 1915, 377, 377, 377, 1919, 399, 641, 399, 399, 653, 399, 399, 665, 399,
  399, 399, 675, 399, 399, 399, 399, 690, 710, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 776, 399, 912, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1151, 1152, 0, 958, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1376, 0, 0, 315, 315, 315, 315, 1031, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1411, 315, 315, 315, 315, 315,
  399, 1127, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1339, 1340, 0, 0, 0, 0, 1221, 0,
  1223, 0, 0, 0, 0, 0, 1229, 0, 0, 0, 0, 0, 0, 994, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 0, 73728, 0, 0, 0,
  1233, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 0, 0, 815, 0, 0, 0, 0, 0, 377, 377, 1260, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 637, 0, 0, 640, 377, 1284, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 1295, 0, 1365, 0, 0, 1367, 0, 0, 0, 1371, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1529, 0, 315, 315,
  315, 315, 1535, 0, 0, 0, 0, 1381, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 492, 0, 0, 0, 0, 1424, 377, 377, 377, 1427, 377,
  1429, 377, 377, 377, 377, 377, 377, 377, 1435, 377, 377, 377, 377, 377, 1442, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 1556, 377, 377, 377, 377, 377, 1520, 1521, 0, 0, 1524, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 0, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1268, 377, 377, 377, 377, 377, 377, 1551, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 377, 637, 45942, 827, 640, 377, 1644, 1645, 377, 377, 377, 377, 1649, 377, 377, 377,
  377, 377, 377, 399, 1658, 1671, 399, 399, 399, 399, 399, 399, 0, 0, 1680, 0, 0, 0, 0, 0, 0, 0, 0, 1385, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 785, 315, 315, 315, 315, 315, 315, 377, 1717, 377, 377, 377, 377, 377, 377, 399, 399, 399, 399, 1726,
  1727, 1728, 399, 399, 399, 399, 1130, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1138, 0, 0, 315, 315, 315,
  315, 315, 0, 377, 377, 377, 377, 377, 377, 1759, 377, 377, 377, 377, 377, 1553, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 1652, 377, 377, 377, 399, 399, 1771, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 0,
  0, 1895, 377, 1795, 377, 377, 377, 377, 377, 399, 399, 399, 399, 399, 399, 1805, 399, 399, 399, 399, 399, 1486, 399,
  399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 1820, 377, 1822, 377, 377, 377, 377, 377, 377, 399, 399, 399, 1832, 399,
  399, 399, 399, 399, 0, 0, 0, 0, 947, 0, 0, 0, 953, 0, 0, 377, 1854, 377, 1856, 399, 399, 399, 399, 399, 399, 399,
  1864, 399, 1866, 0, 0, 0, 0, 0, 721, 0, 0, 724, 0, 0, 0, 0, 251, 251, 0, 399, 1922, 1923, 399, 399, 0, 0, 0, 0, 377,
  377, 377, 377, 377, 377, 399, 399, 399, 399, 1143, 399, 399, 399, 399, 1146, 1147, 399, 1149, 1150, 399, 399, 399,
  399, 399, 1319, 399, 399, 399, 1323, 399, 1325, 399, 399, 399, 399, 0, 0, 0, 0, 0, 377, 377, 377, 377, 1918, 377, 399,
  0, 0, 0, 242, 243, 244, 245, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 739, 0, 0, 0, 0, 0, 0, 0,
  528384, 0, 0, 0, 0, 0, 493, 0, 0, 244, 20480, 244, 244, 244, 244, 244, 0, 312, 326, 326, 326, 326, 326, 326, 346, 346,
  326, 354, 357, 365, 365, 365, 365, 365, 365, 365, 365, 365, 365, 365, 326, 365, 365, 388, 388, 388, 388, 388, 411,
  388, 388, 388, 388, 388, 388, 388, 388, 388, 388, 411, 411, 411, 411, 411, 388, 388, 411, 26824, 26824, 2, 2, 3,
  47108, 5, 6, 0, 436, 0, 0, 0, 440, 441, 442, 443, 0, 0, 0, 0, 0, 0, 0, 451, 0, 436, 497, 498, 499, 0, 0, 0, 0, 0, 505,
  0, 0, 0, 0, 0, 315, 315, 526, 315, 315, 534, 315, 315, 315, 543, 315, 315, 315, 315, 550, 315, 315, 0, 0, 0, 0, 0, 0,
  0, 735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565711, 75776, 565711, 0, 75776, 0, 442, 0, 573, 0, 0, 0, 505, 0, 0, 0, 0, 0, 0,
  569, 505, 505, 377, 614, 617, 377, 377, 377, 626, 630, 377, 377, 377, 377, 377, 0, 399, 399, 399, 399, 399, 1573, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 933, 399, 399, 399, 399, 399, 399, 647, 650, 399, 657, 399, 399, 399,
  671, 674, 399, 399, 399, 683, 687, 399, 399, 399, 399, 1332, 399, 1334, 399, 399, 399, 399, 399, 1337, 399, 399, 399,
  399, 399, 768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1400, 1401, 0, 0, 0, 0, 0, 0, 764, 0, 0, 0, 0, 0, 0, 0, 0, 0, 774, 0,
  0, 0, 0, 0, 749, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111013, 111013, 111013, 111013, 111013, 399, 399, 399, 913, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1135, 399, 399, 399, 399, 399, 941, 399, 399, 399, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 713, 0, 0, 0, 0, 399, 399, 1141, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  1338, 399, 399, 0, 0, 0, 1170, 0, 699, 0, 0, 0, 1172, 0, 703, 0, 0, 0, 0, 0, 0, 0, 528872, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 967, 0, 0, 969, 0, 0, 0, 0, 1191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 495, 0, 0, 377, 377, 377, 377, 1275, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 883, 637, 45942, 827, 640, 1329, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 1581, 0, 0, 1594, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 0, 399, 399,
  1661, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1467, 399, 399, 0, 0, 1744, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 509, 0, 0, 0, 0, 315, 315, 315, 315, 315, 0, 1756, 377, 377, 377, 377, 377, 377, 377, 399, 399,
  1831, 399, 399, 399, 399, 399, 399, 377, 377, 1824, 377, 377, 377, 377, 399, 1830, 399, 399, 399, 1834, 399, 399, 399,
  399, 399, 0, 1938, 1939, 0, 377, 377, 377, 377, 399, 399, 399, 399, 399, 399, 1586, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 1346, 399, 399, 399, 399, 399, 399, 399, 399, 1133, 399, 399, 399, 1136, 399, 399, 399, 267, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 717, 0, 278, 0, 0, 0, 0, 278, 0, 278, 0, 0, 22528, 24576, 278, 0, 0, 0, 0, 0, 754, 827,
  377, 830, 377, 377, 377, 377, 377, 377, 377, 632, 377, 377, 377, 377, 377, 0, 399, 399, 0, 20480, 0, 0, 0, 0, 0, 306,
  0, 315, 315, 315, 315, 315, 315, 0, 0, 0, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 856, 412, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 412, 412, 412, 412, 412, 389, 389, 412, 26824, 26824,
  2, 2, 3, 47108, 5, 6, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 0, 0, 0, 0, 0, 0, 1195, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 315, 315, 315, 315, 533, 315, 0, 454, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 772, 0, 0, 0, 0, 0, 0, 746,
  0, 0, 0, 0, 0, 0, 0, 0, 755, 0, 759, 0, 0, 0, 0, 0, 760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 139264, 139264,
  139264, 139264, 712, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 773, 0, 0, 0, 0, 0, 0, 1210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315,
  315, 315, 790, 315, 315, 315, 795, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 0, 814, 0, 0,
  0, 0, 0, 377, 377, 845, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 854, 377, 377, 377, 377, 377, 1721,
  377, 377, 399, 399, 399, 399, 399, 399, 399, 399, 1162, 399, 399, 399, 399, 399, 399, 399, 939, 399, 399, 399, 399, 0,
  0, 0, 0, 948, 0, 0, 0, 954, 0, 0, 0, 0, 0, 766, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83968, 0, 0, 0, 0, 0, 0, 989, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1403, 0, 0, 0, 949, 0, 0, 0, 0, 0, 955, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1688, 0, 0, 0,
  0, 0, 0, 1204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1215, 0, 0, 0, 0, 486, 0, 0, 0, 486, 0, 0, 0, 0, 495, 0, 0, 0,
  0, 0, 563, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 222, 222, 0, 0, 0, 377, 377, 377, 1274, 377, 377, 1277, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 1650, 377, 377, 377, 377, 377, 399, 399, 399, 399, 1331, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 1481, 399, 399, 1364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 743, 377, 1438,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1436, 0, 0, 0, 1786, 0, 0, 0, 1789, 0, 0,
  315, 377, 377, 377, 377, 377, 377, 377, 1829, 399, 399, 399, 399, 399, 399, 399, 399, 916, 399, 399, 399, 399, 399,
  399, 399, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 377, 377, 377,
  377, 597, 377, 377, 377, 0, 1113, 45942, 0, 1113, 399, 399, 399, 399, 399, 399, 399, 399, 917, 399, 399, 919, 399,
  399, 399, 399, 399, 399, 399, 654, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1148, 399, 399, 399,
  399, 399, 399, 693, 0, 0, 0, 0, 26824, 2, 6, 0, 0, 0, 0, 700, 704, 377, 377, 377, 1112, 1113, 45942, 1117, 1113, 399,
  399, 399, 399, 399, 399, 399, 399, 0, 1679, 0, 0, 0, 0, 0, 0, 0, 0, 0, 560, 0, 565, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1730,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 1783, 0, 246, 0, 0, 0, 0, 0, 246, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 256, 0, 258, 0, 246, 20480, 246, 246, 246, 246, 246, 0, 246, 327, 327, 327, 327, 327, 327,
  0, 0, 0, 0, 559, 0, 564, 0, 567, 0, 0, 0, 0, 0, 567, 0, 0, 0, 0, 254, 0, 0, 0, 0, 254, 254, 22528, 24576, 0, 0, 0, 0,
  0, 0, 827, 377, 377, 377, 377, 377, 377, 837, 377, 377, 0, 0, 327, 0, 0, 246, 246, 246, 246, 246, 246, 246, 246, 246,
  246, 246, 327, 246, 246, 390, 390, 390, 390, 390, 413, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 413, 413,
  413, 413, 413, 390, 390, 413, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 455, 456, 0, 0, 0, 0, 0, 251, 251, 251,
  0, 0, 0, 0, 0, 0, 1369, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 377, 1791, 377, 377, 377, 536, 315, 315, 315, 315, 546,
  315, 315, 551, 315, 315, 0, 0, 0, 0, 0, 0, 0, 769, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1373, 0, 0, 0, 0, 0, 0, 568, 0, 0,
  574, 0, 0, 0, 0, 500, 0, 0, 577, 0, 0, 0, 0, 0, 0, 1513, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 532, 315,
  377, 377, 377, 619, 621, 377, 377, 631, 377, 377, 377, 377, 377, 0, 399, 399, 399, 399, 399, 1585, 399, 399, 1587,
  399, 399, 399, 1589, 399, 399, 399, 399, 0, 1910, 0, 0, 1913, 377, 377, 377, 377, 377, 377, 399, 642, 399, 399, 399,
  399, 660, 399, 399, 399, 399, 676, 678, 399, 399, 688, 399, 399, 399, 399, 1472, 399, 399, 399, 399, 399, 399, 399,
  1480, 399, 399, 399, 399, 399, 0, 1927, 1928, 0, 377, 377, 377, 377, 377, 377, 399, 0, 0, 0, 747, 0, 0, 0, 0, 0, 0,
  754, 0, 0, 0, 0, 0, 0, 0, 783, 0, 0, 315, 315, 315, 789, 315, 315, 0, 0, 763, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  715, 0, 0, 0, 778, 779, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 315, 1238, 315, 315, 315, 315, 315, 315, 315,
  399, 891, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1352, 399, 911, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1482, 399, 1026, 315, 315, 315, 315, 315, 315, 315, 315, 315,
  315, 315, 315, 315, 315, 315, 800, 315, 315, 315, 315, 315, 315, 377, 1107, 377, 0, 1113, 45942, 0, 1113, 399, 399,
  399, 399, 1121, 399, 399, 399, 399, 399, 399, 1663, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1463, 399, 399, 399,
  399, 399, 399, 0, 0, 0, 0, 1193, 0, 0, 0, 0, 1198, 0, 0, 1200, 0, 1202, 0, 0, 0, 0, 570, 0, 0, 570, 377, 585, 377,
  377, 377, 377, 603, 377, 377, 377, 377, 377, 1799, 377, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1892, 0, 0, 0, 0,
  1894, 0, 0, 0, 0, 0, 1208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1004, 0, 0, 0, 0, 315, 1244, 1245, 315, 315, 315, 315,
  315, 315, 0, 0, 0, 0, 1255, 0, 0, 0, 0, 0, 785, 827, 377, 377, 377, 377, 377, 377, 377, 377, 377, 863, 377, 377, 377,
  377, 377, 377, 1283, 377, 377, 377, 1287, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1292, 377, 377, 377,
  377, 377, 377, 377, 1299, 0, 0, 0, 0, 1113, 0, 0, 0, 0, 399, 399, 399, 399, 399, 399, 1776, 399, 399, 399, 399, 399,
  0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 399, 1341, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 1353, 1378, 0, 0, 0, 0, 0, 1383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 377, 377, 377, 377, 377, 377, 377, 1425, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1088, 377, 0, 0, 0, 1510, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 267, 0, 0, 0, 0, 1604, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1518, 0, 0, 0, 0, 0, 1686, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1007, 0, 0, 0, 0, 377, 377, 377, 377, 1798, 377, 377, 1800, 399, 399, 399, 399, 399, 399, 399, 399,
  900, 399, 399, 399, 399, 399, 399, 399, 399, 1462, 399, 399, 399, 399, 399, 399, 399, 1808, 399, 399, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 377, 377, 377, 377, 598, 377, 377, 377, 0, 0, 0, 1872, 1873, 0, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 1270, 377, 399, 399, 399, 1924, 399, 1926, 0, 0, 1929, 377, 377, 377, 377, 377, 377, 399,
  399, 399, 399, 1572, 399, 1574, 399, 399, 1577, 399, 399, 399, 399, 399, 399, 1320, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 1735, 399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 377, 377, 377, 1941, 399, 399, 399, 270, 0, 271, 0, 0, 0, 0,
  0, 271, 0, 0, 276, 0, 0, 0, 0, 0, 0, 0, 530432, 751, 0, 0, 0, 0, 0, 0, 0, 0, 0, 504, 0, 0, 0, 0, 0, 0, 0, 0, 0, 271,
  0, 0, 0, 283, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 0, 0, 1597, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 250, 0, 251, 0, 0,
  296, 20480, 296, 296, 296, 296, 296, 0, 313, 328, 328, 328, 328, 328, 328, 0, 0, 0, 0, 707, 781, 782, 0, 0, 0, 315,
  315, 788, 315, 792, 315, 315, 315, 315, 315, 1248, 1249, 315, 315, 0, 0, 0, 0, 0, 1256, 0, 0, 0, 0, 732, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 742, 0, 0, 0, 0, 569, 0, 0, 569, 377, 377, 590, 593, 377, 600, 377, 377, 377, 377, 377, 377, 1722, 377,
  399, 399, 399, 399, 399, 399, 399, 399, 1335, 399, 399, 399, 399, 399, 399, 399, 0, 247, 328, 0, 0, 313, 313, 313,
  313, 313, 313, 313, 313, 313, 313, 313, 328, 372, 375, 391, 391, 391, 391, 391, 414, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 414, 414, 414, 414, 414, 391, 391, 414, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 516, 0, 0,
  0, 0, 0, 0, 315, 524, 315, 315, 315, 315, 315, 315, 315, 1250, 315, 0, 0, 0, 0, 0, 0, 1257, 315, 540, 315, 315, 315,
  315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 962, 0, 0, 827, 377, 377, 377, 377, 377, 377, 624, 377, 377, 377,
  377, 377, 377, 0, 399, 399, 516, 0, 563, 0, 0, 0, 0, 0, 377, 586, 377, 377, 377, 377, 377, 609, 643, 399, 399, 399,
  399, 399, 666, 399, 399, 399, 399, 399, 399, 399, 399, 399, 915, 399, 399, 399, 399, 399, 920, 399, 399, 0, 0, 705, 0,
  0, 707, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 223, 277, 223, 0, 794, 315, 315, 315, 315, 315, 315, 315, 315, 315, 801,
  315, 315, 315, 315, 315, 315, 315, 799, 315, 315, 315, 315, 315, 315, 315, 315, 1045, 315, 315, 315, 0, 0, 0, 0, 0,
  818, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1614, 0, 0, 825, 826, 0, 818, 0, 827, 377, 377, 377, 377, 833, 377,
  377, 840, 377, 377, 377, 377, 859, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1102, 377, 377, 377, 377,
  377, 844, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 855, 0, 0, 990, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 741, 0, 0, 1231, 0, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 1038, 315, 315,
  315, 1246, 315, 315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 1258, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 399, 399, 399, 1342, 399, 399, 399, 399, 399, 399, 399, 399, 1348,
  399, 399, 399, 399, 399, 0, 0, 0, 945, 0, 0, 0, 951, 0, 0, 0, 0, 949, 0, 955, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 448,
  449, 0, 0, 1507, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 761, 0, 0, 0, 1523, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315,
  315, 315, 0, 377, 377, 377, 377, 377, 377, 377, 1760, 377, 1561, 377, 377, 377, 377, 377, 377, 377, 377, 377, 0, 1304,
  0, 1310, 399, 399, 399, 399, 1676, 399, 399, 0, 0, 0, 1681, 0, 0, 0, 0, 0, 0, 0, 1211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218,
  219, 0, 0, 0, 0, 435, 0, 0, 1693, 0, 0, 0, 0, 1698, 315, 315, 315, 315, 315, 315, 1703, 0, 0, 0, 0, 748, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 286, 286, 0, 0, 0, 377, 377, 1718, 377, 377, 377, 377, 377, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 0, 0, 0, 1743, 0, 0, 0, 0, 0, 0, 0, 1749, 1750, 0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1599, 0, 0, 1602, 0, 0, 1794, 377, 1796, 377, 377, 377, 377, 399, 399, 399, 399, 399, 1804, 399, 1806, 399, 399, 399,
  399, 1732, 399, 399, 399, 399, 1737, 399, 399, 399, 399, 0, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 399, 377, 377,
  377, 377, 1857, 399, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0, 0, 1493, 0, 0, 0, 0, 377, 1899, 377, 377, 377,
  377, 377, 377, 377, 399, 1905, 399, 399, 399, 399, 399, 895, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1324,
  399, 399, 399, 399, 399, 0, 0, 272, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  272, 0, 0, 0, 284, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 0, 0, 1687, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 251, 251, 251, 464, 0,
  0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 329, 329, 329, 329, 329, 329, 347, 347, 329, 347, 347, 366, 366, 347, 347, 347, 347,
  366, 347, 366, 347, 347, 347, 347, 347, 347, 347, 347, 329, 373, 376, 392, 392, 392, 392, 392, 415, 392, 392, 392,
  392, 392, 392, 392, 392, 392, 392, 415, 415, 415, 415, 415, 392, 392, 415, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 466,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0, 0, 820, 0, 0, 0, 0, 0, 823, 0, 723, 0, 0, 0, 0, 0, 281, 257, 0,
  257, 0, 0, 22528, 24576, 257, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1517, 0, 0, 0, 0, 537, 315, 542,
  315, 315, 315, 315, 549, 315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 1183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 229, 22528, 24576,
  0, 291, 291, 466, 0, 0, 522, 0, 565, 582, 0, 377, 587, 377, 377, 377, 377, 604, 610, 612, 377, 377, 377, 377, 377,
  627, 377, 377, 377, 377, 377, 377, 0, 399, 399, 399, 399, 399, 1733, 399, 399, 399, 399, 399, 399, 399, 399, 0, 0, 0,
  0, 0, 1683, 0, 0, 0, 644, 399, 399, 399, 399, 661, 667, 669, 399, 399, 399, 399, 399, 684, 399, 399, 399, 399, 658,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1739, 399, 399, 0, 0, 730, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1175, 777, 0, 0, 0, 708, 0, 0, 0, 784, 0, 315, 315, 315, 315, 315, 315, 1033, 315, 315, 315, 315, 315, 315,
  315, 315, 315, 1252, 0, 0, 1254, 0, 0, 0, 315, 315, 807, 808, 315, 315, 315, 315, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  135168, 0, 135168, 0, 135168, 0, 0, 0, 819, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 819, 765, 0, 0, 0, 730, 819, 0, 827,
  377, 377, 377, 832, 377, 377, 377, 377, 377, 377, 861, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1290, 377, 377,
  377, 377, 377, 377, 377, 377, 858, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 868, 869, 377, 377, 377, 377,
  875, 377, 377, 377, 377, 377, 377, 377, 637, 45942, 827, 640, 399, 399, 399, 893, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 1349, 399, 399, 399, 399, 988, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1506, 0, 315,
  315, 1029, 315, 315, 315, 315, 315, 315, 1035, 315, 315, 315, 315, 315, 315, 315, 811, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1018, 0, 0, 0, 0, 0, 0, 1039, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 315, 0, 1050, 0, 0, 0, 0, 0, 962, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 234, 0, 0, 0, 0, 0, 1053, 0, 0, 0, 0, 0, 963, 1057, 1050, 827, 377, 377, 377, 377,
  377, 377, 876, 377, 377, 377, 882, 377, 637, 45942, 827, 640, 1063, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 1074, 377, 377, 377, 0, 1113, 45942, 0, 1113, 399, 399, 399, 399, 399, 1123, 399, 399, 399, 399, 399, 1142, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1465, 399, 399, 399, 399, 0, 1177, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1690, 1691, 0, 0, 0, 1192, 0, 0, 0, 1196, 1197, 0, 0, 0, 0, 0, 0, 0, 0, 217, 218, 219, 0, 0, 0, 0, 0,
  0, 0, 0, 1220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 508, 0, 0, 0, 0, 1232, 315, 315, 315, 315, 1236, 315, 315, 315,
  315, 315, 315, 315, 315, 315, 1047, 315, 315, 0, 0, 0, 0, 399, 1330, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 1591, 399, 315, 315, 1406, 315, 315, 315, 315, 1409, 315, 315, 315, 315, 315, 315, 315, 315, 1046,
  315, 315, 1049, 0, 0, 0, 0, 377, 377, 377, 1440, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 853, 377,
  377, 377, 399, 399, 399, 1471, 399, 399, 399, 399, 399, 1477, 399, 399, 399, 399, 399, 399, 1131, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 1160, 1161, 399, 399, 399, 399, 399, 399, 399, 399, 1575, 399, 399, 399, 399, 399, 399, 399,
  399, 1322, 399, 399, 399, 399, 399, 399, 399, 1496, 1497, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1505, 0, 0, 0, 0, 765,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1021, 0, 1023, 0, 0, 0, 0, 1522, 0, 0, 0, 1526, 0, 0, 0, 0, 315, 315, 315, 1534, 315,
  315, 315, 315, 315, 1408, 315, 315, 315, 1410, 315, 315, 1412, 315, 315, 315, 315, 315, 798, 315, 315, 315, 315, 315,
  315, 315, 315, 315, 315, 0, 1253, 0, 0, 0, 0, 0, 377, 1549, 377, 377, 1552, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 1433, 377, 377, 377, 377, 1659, 399, 399, 399, 399, 399, 399, 1664, 399, 399, 399, 399, 399, 399, 399,
  399, 1890, 399, 399, 0, 1893, 0, 0, 0, 0, 0, 1704, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1714,
  377, 377, 377, 377, 1067, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 865, 377, 377, 377, 377, 377, 377,
  377, 1719, 377, 377, 377, 377, 399, 399, 399, 399, 399, 399, 399, 399, 1345, 399, 399, 1347, 399, 399, 399, 399, 399,
  399, 898, 399, 399, 399, 399, 399, 399, 399, 399, 399, 929, 930, 399, 399, 399, 399, 399, 399, 399, 399, 1475, 399,
  399, 399, 399, 399, 399, 399, 399, 1891, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1745, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1753, 0,
  0, 0, 0, 961, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 422, 422, 422, 422, 422, 0, 0, 315, 315, 315, 315, 315, 0, 377, 377,
  377, 377, 1757, 377, 377, 377, 0, 1452, 0, 0, 0, 0, 0, 1454, 0, 0, 0, 0, 399, 1869, 1870, 0, 0, 0, 0, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 1883, 0, 1897, 377, 377, 377, 377, 377, 377, 1902, 1903, 377, 399, 399, 399, 399, 399,
  0, 0, 0, 946, 0, 0, 0, 952, 0, 0, 0, 399, 1908, 1909, 399, 0, 0, 1911, 1912, 0, 377, 377, 377, 377, 377, 377, 399,
  399, 399, 399, 1887, 399, 1889, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 377, 377, 377, 377, 1852, 0, 20480, 0,
  0, 0, 0, 0, 0, 0, 330, 330, 330, 330, 330, 330, 348, 348, 330, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
  348, 348, 330, 348, 348, 393, 393, 393, 393, 393, 416, 393, 393, 393, 393, 393, 393, 393, 393, 393, 393, 416, 416,
  416, 416, 416, 393, 393, 416, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 706, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  712, 0, 0, 0, 716, 0, 0, 762, 0, 0, 0, 0, 0, 0, 762, 0, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 975,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 714, 0, 0, 0, 377, 377, 377, 1079, 377, 377, 377, 377, 377, 377, 377, 1085, 377,
  377, 377, 377, 0, 0, 1304, 0, 1113, 0, 0, 1310, 0, 399, 399, 399, 377, 377, 377, 1093, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 867, 377, 377, 377, 1139, 399, 399, 399, 399, 399, 399, 399, 1145, 399, 399, 399, 399,
  399, 399, 399, 1461, 399, 399, 399, 1464, 399, 1466, 399, 399, 399, 1153, 399, 399, 399, 399, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 1580, 399, 399, 0, 0, 315, 315, 315, 315, 315, 1237, 315, 315, 315, 315, 315, 315, 315,
  315, 1251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1354, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1186, 0, 0, 0, 0, 399, 1569, 399,
  399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1590, 399, 399, 399, 1772, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 0, 0, 0, 0, 0, 0, 1495, 399, 399, 399, 1937, 399, 0, 0, 0, 0, 377, 377, 377, 377, 399, 399,
  399, 399, 399, 914, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1478, 399, 399, 399, 399, 399, 260, 0, 315, 275,
  275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1228, 0, 0, 0, 0, 417, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 417,
  417, 417, 417, 417, 394, 394, 417, 26824, 26824, 2, 2, 3, 47108, 5, 6, 0, 399, 399, 399, 655, 399, 399, 399, 399, 399,
  399, 399, 399, 399, 399, 399, 399, 1779, 399, 0, 0, 0, 0, 1052, 0, 0, 0, 0, 0, 0, 0, 0, 0, 827, 377, 377, 377, 377,
  377, 377, 377, 377, 841, 377, 377, 377, 377, 1080, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1447, 377,
  377, 377, 377, 399, 1140, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1669, 1670, 399, 0,
  1508, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 249, 0, 0, 0, 0, 249, 0, 249, 0, 0, 22528, 24576, 249, 0,
  0, 0, 0, 0, 977, 978, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 1627, 315, 315, 315, 297, 20480, 297, 297, 297, 297,
  297, 0, 297, 331, 331, 331, 331, 331, 331, 0, 0, 0, 0, 992, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983, 0, 985, 0, 0, 0, 0,
  331, 0, 0, 297, 297, 297, 297, 297, 297, 297, 297, 297, 297, 297, 331, 297, 297, 395, 395, 395, 395, 395, 418, 395,
  395, 395, 395, 395, 395, 395, 395, 395, 395, 418, 418, 418, 418, 418, 395, 395, 418, 26824, 26824, 2, 2, 3, 47108, 5,
  6, 0, 1469, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1474, 399, 1476, 399, 399, 399,
  399, 399, 399, 1483, 399, 399, 399, 1485, 399, 399, 399, 399, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1819, 377, 377, 419,
  396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 419, 419, 419, 419, 419, 396, 396, 419, 26824, 26824, 2, 2, 3,
  47108, 5, 6, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0, 0, 580, 0, 0, 0, 0, 0, 0, 377, 377,
  377, 377, 599, 377, 377, 377, 377, 0, 1302, 0, 0, 1113, 0, 1308, 0, 0, 399, 399, 399, 399, 377, 377, 399, 26824,
  27048, 2, 2, 3, 47108, 5, 6, 0, 399, 399, 399, 656, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 1487,
  399, 399, 0, 0, 0, 0, 0, 1494, 0, 377, 377, 377, 377, 1301, 0, 0, 0, 1113, 1307, 0, 0, 0, 399, 399, 399, 399, 399,
  927, 399, 399, 399, 399, 399, 399, 399, 399, 399, 937, 0, 437, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0,
  315, 315, 315, 315, 1041, 315, 315, 315, 315, 315, 315, 315, 0, 0, 0, 0, 377, 377, 377, 377, 377, 377, 0, 377, 1259,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1104, 377, 377, 1272, 1273, 377, 377, 377, 377,
  377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 1657, 399, 377, 377, 1451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399,
  399, 399, 488, 0, 0, 0, 26824, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 1702, 315, 0, 0, 1593, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 704512, 0, 0, 1617, 0, 0, 0, 0, 0, 0, 0, 0, 315, 315, 315, 315, 315, 315, 315, 0, 0,
  20480, 0, 0, 0, 0, 0, 307, 0, 315, 315, 315, 315, 315, 315, 0, 0, 0, 377, 377, 377, 377, 377, 377, 377, 377, 1640,
  377, 377, 0, 415744, 0, 0, 415744, 0, 415744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315, 1790, 377, 377, 377, 377, 0, 0, 0,
  415744, 0, 0, 415744, 415744, 0, 0, 0, 0, 0, 0, 415744, 0, 0, 0, 0, 415744, 415744, 0, 415744, 0, 0, 0, 0, 0, 0, 0,
  1224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 915456, 0, 0, 0, 0, 0, 415744, 0, 0, 415744, 0, 0, 0, 415744, 0, 0, 0, 416031,
  416031, 415744, 0, 0, 0, 0, 0, 993, 0, 0, 0, 0, 998, 0, 0, 0, 0, 0, 0, 0, 489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1359, 0,
  0, 1362, 0, 0, 0, 416031, 0, 0, 0, 0, 415744, 0, 0, 0, 415744, 0, 415744, 0, 415744, 0, 0, 0, 415744, 415744, 0, 0, 0,
  0, 0, 415744, 415744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 251, 251, 729, 0, 415744, 0, 0, 415744, 415744, 0, 0,
  0, 2, 1083392, 3, 47108, 5, 6, 0, 0, 0, 0, 1004, 0, 0, 0, 0, 0, 0, 0, 0, 1008, 0, 0, 0, 0, 0, 274, 0, 0, 0, 0, 0, 0,
  0, 238, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 557056, 557056, 557056, 0, 0, 0, 0, 0, 1083392, 6, 0, 0, 0, 0, 0, 0, 0,
  0, 1514, 0, 0, 0, 0, 0, 0, 1519, 557056, 557056, 557056, 557056, 557056, 907264, 557056, 557056, 557056, 557056,
  557056, 557056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 557056, 557056, 557056, 557056, 557056, 0, 0, 1083392, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 243, 244, 22528, 24576, 0, 245, 245, 0, 419840, 0, 419840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 740,
  0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 420189, 420189, 420189, 0, 0, 2, 2, 3, 47108, 5, 6, 0,
  420189, 420189, 0, 420189, 420189, 420189, 420189, 420189, 420189, 420189, 420189, 420189, 420189, 420189, 420189,
  420189, 0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 424250, 0, 0, 0, 0, 0, 0, 0, 0, 261, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  22528, 24576, 0, 0, 0, 0, 0, 423936, 314, 424250, 424250, 424250, 0, 0, 2, 2, 3, 47108, 5, 6, 0, 0, 0, 0, 1013, 0, 0,
  0, 0, 0, 1020, 0, 0, 0, 0, 0, 0, 0, 768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 827, 377, 377, 377, 377, 377, 377, 377, 377,
  377, 557056, 557056, 557056, 557056, 557056, 907264, 557056, 557056, 557056, 557056, 557056, 557056, 885, 0, 0, 888,
  53248, 53248, 0, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 53248, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 53248, 53248, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0, 0, 0, 796672, 0, 0, 0, 843776, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1374, 0, 0, 0, 1377
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  427, 432, 431, 436, 440, 444, 448, 1516, 560, 452, 459, 632, 465, 471, 850, 480, 454, 486, 582, 583, 542, 499, 1515,
  1244, 461, 492, 521, 496, 542, 467, 1515, 474, 455, 520, 503, 542, 507, 1515, 852, 519, 525, 542, 529, 698, 535, 540,
  548, 1265, 554, 544, 703, 536, 558, 564, 568, 572, 576, 580, 587, 591, 595, 599, 605, 603, 609, 613, 617, 621, 1084,
  1515, 666, 946, 1515, 1515, 625, 1515, 488, 1515, 1515, 1515, 1515, 1515, 476, 1515, 1237, 1515, 1515, 1515, 1515,
  1515, 1515, 1515, 1262, 1515, 1515, 1515, 1515, 1515, 1515, 1264, 1515, 1515, 1515, 1515, 909, 1515, 1515, 1515, 1260,
  1515, 1515, 924, 1515, 1515, 1515, 1515, 1515, 1515, 1515, 1515, 1515, 1515, 1435, 631, 636, 800, 643, 647, 651, 655,
  482, 760, 1119, 659, 513, 663, 675, 672, 681, 687, 691, 1291, 697, 958, 702, 1533, 943, 896, 707, 683, 1515, 737,
  1285, 712, 716, 720, 726, 725, 668, 1418, 510, 730, 721, 736, 741, 1549, 747, 1429, 1432, 1366, 753, 757, 764, 768,
  1166, 772, 776, 780, 791, 784, 993, 788, 1515, 1515, 804, 810, 817, 821, 825, 829, 835, 879, 839, 639, 843, 1149, 806,
  1359, 1095, 847, 1130, 856, 1515, 866, 1515, 876, 883, 1098, 887, 893, 1538, 900, 1515, 906, 917, 921, 1198, 1515,
  930, 902, 936, 940, 952, 1515, 956, 962, 966, 970, 550, 627, 979, 1201, 983, 987, 997, 1337, 1001, 1510, 1005, 1009,
  1013, 1017, 1021, 1025, 1515, 1032, 1036, 1040, 1044, 1048, 1052, 1057, 1475, 1063, 1067, 1071, 693, 1286, 1075, 1477,
  1112, 1491, 1079, 1083, 743, 1515, 1472, 1442, 1088, 1092, 749, 1515, 872, 1515, 1102, 1109, 1484, 531, 1515, 862,
  708, 1498, 1116, 1123, 1515, 1127, 1449, 1134, 1138, 1191, 926, 813, 990, 1526, 1105, 1142, 1146, 1156, 1160, 1170,
  1028, 1163, 1174, 1515, 1515, 1515, 932, 515, 1178, 1182, 1186, 1190, 869, 1257, 797, 1195, 1207, 1211, 1515, 1215,
  1219, 1228, 1232, 1236, 1241, 1053, 1248, 1254, 1269, 1222, 1276, 1203, 1284, 889, 1290, 1295, 1299, 1303, 830, 1307,
  889, 1313, 794, 1317, 1321, 1325, 831, 1250, 1331, 1272, 1335, 1341, 1345, 1224, 1349, 1353, 1363, 1370, 1356, 1374,
  1381, 1385, 1377, 1389, 1393, 1397, 1515, 677, 1401, 1405, 1409, 1413, 1417, 1309, 1422, 1507, 1426, 1515, 1280, 1515,
  1439, 1460, 1515, 1446, 1515, 1278, 1515, 1453, 1327, 1459, 1464, 1469, 1515, 1481, 1515, 1488, 1152, 973, 732, 1515,
  1495, 1515, 1488, 1504, 975, 1514, 1481, 1465, 1520, 1530, 1515, 1537, 1542, 1500, 911, 859, 1546, 1455, 913, 948,
  1523, 1515, 1515, 1515, 1515, 1515, 1059, 1553, 1647, 1561, 1568, 1565, 1568, 1568, 1568, 1583, 1577, 1567, 1575,
  1572, 1581, 1587, 1594, 1597, 1591, 1601, 1605, 1609, 1613, 1617, 1621, 1625, 2399, 2876, 2876, 1639, 1733, 1733,
  1752, 1733, 1645, 2876, 2876, 1732, 1733, 1699, 1759, 1703, 1703, 1662, 1798, 1651, 1657, 1626, 2876, 1681, 2876,
  2876, 1996, 2876, 2125, 2365, 2876, 2876, 1943, 2996, 1733, 1752, 2876, 2876, 1948, 2876, 1733, 1641, 2876, 1672,
  1699, 1699, 1677, 1703, 1703, 1705, 1662, 1699, 1699, 1709, 1713, 1703, 1703, 1798, 2876, 1684, 2025, 2876, 1719,
  2876, 2876, 2437, 2763, 1751, 1698, 1699, 1699, 1699, 1699, 1699, 1699, 1723, 1727, 1703, 1765, 2876, 2876, 2028,
  2699, 1640, 1672, 1699, 1699, 1703, 1699, 1738, 1703, 1703, 1703, 1703, 1704, 2876, 1703, 1703, 2876, 2876, 2083,
  2425, 1742, 1699, 1699, 1700, 1703, 1716, 2876, 2876, 2151, 2846, 1749, 1699, 1699, 1702, 1703, 1717, 2876, 1757,
  1673, 1703, 1764, 2498, 1673, 1703, 1765, 1672, 1701, 1716, 2604, 1699, 1699, 1699, 1668, 1703, 1718, 1672, 1745,
  1717, 2500, 1763, 2500, 1763, 1744, 1770, 1773, 2143, 2279, 1777, 1781, 1785, 1789, 1662, 1662, 1662, 1664, 1808,
  1796, 1660, 1806, 1812, 1792, 1816, 1820, 1824, 1827, 1831, 1835, 1839, 1753, 2669, 3185, 1857, 1865, 2876, 2876,
  2388, 2369, 1874, 2876, 2876, 2876, 1699, 2059, 1980, 1998, 2876, 1753, 2220, 3199, 1901, 1905, 1909, 1913, 1916,
  1920, 1921, 1925, 1929, 2093, 1936, 2723, 1875, 2876, 2876, 2819, 1965, 2324, 1766, 1972, 2752, 1977, 1984, 2876,
  1848, 2876, 2876, 2216, 2876, 2580, 2005, 2754, 2876, 1849, 2876, 2876, 2513, 3044, 1988, 1994, 2876, 2876, 2518,
  2044, 2588, 2004, 2876, 2595, 2009, 2017, 2876, 2876, 2612, 2876, 2040, 2876, 2876, 2876, 1731, 1875, 2876, 2876,
  2876, 1734, 2058, 2876, 2876, 2876, 1968, 2579, 2876, 2876, 1842, 2048, 2876, 2221, 1878, 2055, 2876, 2876, 2876,
  2100, 2057, 2876, 2876, 2876, 2101, 2099, 2012, 2876, 2876, 2650, 2292, 2013, 2876, 2876, 2876, 2244, 2430, 2064,
  2876, 2876, 2654, 2658, 2621, 2080, 2876, 2876, 2673, 2680, 2088, 2092, 2876, 2000, 2058, 2876, 1844, 2995, 1947,
  1952, 1959, 2876, 2732, 2706, 2097, 2105, 2876, 1999, 2106, 2110, 2114, 2876, 2113, 2876, 2911, 2876, 2470, 2468,
  2876, 2994, 2469, 2667, 2140, 2666, 2665, 2467, 2468, 2467, 2468, 2774, 2995, 2668, 3074, 2824, 2158, 2890, 2448,
  2876, 1882, 1932, 1889, 2299, 2123, 2876, 2876, 2733, 2241, 2149, 2129, 2134, 2876, 1938, 2876, 2076, 2147, 2155,
  2164, 1885, 2168, 2179, 2172, 2177, 2173, 2183, 2183, 2183, 2185, 2876, 2876, 2876, 2251, 2953, 2387, 2124, 2876,
  2357, 2196, 2201, 2207, 2213, 2225, 2900, 2026, 2229, 2263, 2270, 2277, 2876, 1990, 2876, 2876, 1733, 1733, 2298,
  2304, 2308, 2876, 2026, 2632, 2876, 2026, 2697, 1877, 2966, 2350, 2995, 2876, 2026, 2759, 2876, 2027, 2686, 1877,
  2387, 2124, 2294, 2191, 2878, 2876, 2733, 2878, 2876, 1897, 1556, 2876, 3085, 2876, 2876, 2733, 2253, 2328, 2338,
  2995, 2876, 2032, 2187, 2038, 2347, 2354, 2876, 2876, 2733, 2392, 2361, 2876, 2369, 2876, 2050, 2876, 2876, 2400,
  2876, 2865, 2875, 1626, 2374, 2257, 2385, 3008, 2912, 2774, 2876, 2051, 2876, 2876, 2431, 2450, 2766, 2770, 2876,
  2876, 2758, 2729, 3016, 2092, 2879, 2374, 2257, 2398, 2404, 2876, 2130, 2024, 2876, 1853, 2876, 2876, 2286, 2876,
  2777, 2947, 2420, 2773, 2948, 2421, 2876, 2876, 2873, 1866, 2876, 3201, 3015, 2370, 2879, 2506, 2160, 2413, 2140,
  1800, 2331, 2876, 2137, 2751, 2876, 2876, 2649, 2878, 2915, 1894, 2435, 1802, 2150, 2876, 2441, 2876, 3154, 1895,
  2399, 2582, 2743, 2876, 2142, 2668, 2470, 2572, 2333, 2876, 2573, 1896, 3145, 2876, 3144, 3143, 2460, 3152, 2484,
  2119, 2466, 2455, 2459, 2458, 2300, 2457, 1973, 2460, 2455, 2465, 2475, 2482, 2623, 2507, 2623, 2488, 2492, 2496,
  2876, 2142, 2876, 2776, 2876, 3191, 2664, 2504, 2876, 3188, 2792, 2511, 2517, 2522, 2534, 2538, 2541, 2544, 2548,
  2551, 2552, 2556, 2556, 2556, 2559, 2876, 2876, 2876, 2299, 2876, 3192, 2876, 2876, 2876, 3223, 2577, 1939, 3171,
  2830, 2587, 2876, 2592, 2525, 2599, 2615, 2603, 2608, 2619, 2876, 2020, 2115, 2638, 2876, 2733, 2643, 2676, 2876,
  2876, 2876, 2407, 2932, 2570, 2876, 3134, 2681, 2840, 1892, 2876, 2203, 2197, 2257, 2312, 2318, 2322, 2906, 1877,
  2019, 2466, 2931, 2876, 1691, 3211, 2876, 2932, 3141, 2876, 2867, 2646, 2932, 2876, 2583, 2876, 2259, 2876, 2192,
  2710, 2876, 2876, 2716, 2876, 2913, 2717, 2876, 2283, 2876, 2292, 3071, 2930, 2876, 2075, 1689, 2876, 1557, 2721,
  2876, 2742, 2876, 2582, 2743, 2430, 2704, 2876, 2334, 2235, 2876, 1955, 1626, 3177, 2749, 2852, 2876, 2851, 2728,
  3173, 1842, 2775, 2876, 2774, 2876, 2394, 2876, 2705, 2876, 2777, 2098, 2139, 2777, 2876, 2141, 2776, 2782, 2712,
  2790, 2796, 2799, 2811, 2805, 2808, 2801, 2815, 2815, 2815, 2818, 2876, 2876, 2876, 2416, 2828, 2876, 2314, 2026,
  2768, 2772, 2876, 2084, 2876, 2876, 2876, 3162, 2876, 2834, 2838, 2941, 2844, 2876, 2231, 2850, 2856, 2876, 2342,
  2920, 2861, 2876, 2159, 3022, 2528, 2876, 2876, 2981, 2876, 1653, 2876, 2876, 2561, 2341, 2876, 3131, 2865, 2871,
  2876, 2876, 2876, 2461, 2237, 2883, 2888, 2876, 2471, 3219, 2138, 2894, 2904, 2876, 2876, 2957, 2343, 2876, 3206,
  2466, 3073, 2823, 2992, 2876, 2427, 2876, 2876, 2429, 2876, 2876, 2876, 1639, 2823, 2910, 2876, 2159, 2876, 2876,
  2252, 2563, 2293, 2876, 2876, 3062, 2876, 2876, 3054, 2884, 1877, 2876, 2876, 2876, 2034, 2897, 2876, 2876, 2876,
  2682, 2876, 2857, 2876, 2919, 2972, 2158, 2376, 2924, 2876, 2745, 2946, 2929, 2936, 2940, 2876, 2876, 3138, 2878,
  2938, 2876, 2876, 2288, 2376, 2925, 2744, 2945, 2149, 2876, 2876, 2250, 2952, 1877, 2876, 2876, 3159, 2059, 2824,
  1633, 2378, 1694, 2963, 2876, 2876, 2299, 2914, 1894, 3164, 2876, 2285, 2342, 2970, 2778, 2976, 1961, 2876, 2985,
  2876, 2287, 2989, 3178, 2977, 2380, 2381, 3013, 2876, 2530, 2248, 2669, 2876, 3000, 1877, 2876, 2581, 2705, 1687,
  3001, 2876, 2786, 3005, 3012, 2477, 2117, 2066, 2785, 2118, 2069, 3014, 3034, 3020, 3212, 3028, 3027, 2363, 2067,
  2068, 2363, 3026, 2067, 1635, 3032, 1635, 3032, 3081, 3083, 3038, 3050, 3059, 3046, 3041, 3068, 3078, 3089, 3093,
  3097, 3101, 3105, 3112, 3109, 3115, 3120, 3118, 3124, 3128, 2876, 2876, 2876, 2732, 2059, 2116, 2876, 3149, 2649,
  2876, 2209, 2876, 2634, 2091, 2876, 1866, 1876, 2876, 1870, 2876, 2722, 1954, 2669, 2026, 1634, 2730, 2876, 1752,
  2650, 2876, 2265, 2876, 2639, 2092, 2451, 2876, 3053, 2876, 2876, 3216, 2876, 2116, 2876, 2876, 2138, 2873, 2873,
  2876, 2876, 2876, 2866, 2959, 2733, 2876, 2876, 2662, 2876, 2567, 1634, 2579, 2876, 1752, 2932, 2876, 3168, 2876,
  2876, 2690, 2026, 1693, 2734, 3064, 2876, 2876, 2693, 2273, 2627, 2876, 3182, 2876, 2876, 2703, 3071, 2876, 2875,
  2876, 1861, 2060, 2117, 2137, 2873, 2478, 2876, 2630, 3155, 2445, 2266, 2876, 2876, 2876, 2876, 1631, 3055, 2876,
  1860, 2285, 2876, 2874, 2876, 2727, 2876, 2738, 2117, 2876, 2753, 2876, 2731, 2876, 2877, 2410, 2876, 2876, 2876,
  2947, 2026, 3196, 2876, 3205, 3210, 2872, 2876, 2876, 2732, 1627, 2073, 3588, 3391, 3475, 3529, 3532, 3532, 3543,
  3517, 3515, 3233, 3239, 3252, 3251, 3253, 3254, 3746, 3746, 3746, 3746, 3254, 3795, 3259, 3746, 3257, 3746, 3746,
  3235, 3252, 3665, 3746, 3746, 3746, 3374, 3234, 3236, 3237, 3261, 3266, 3272, 3274, 3275, 3273, 3262, 3267, 3268,
  3268, 3270, 3274, 3277, 3263, 3279, 3290, 3281, 3287, 3283, 3282, 3289, 3284, 3285, 3292, 3285, 3285, 3294, 3296,
  3588, 3728, 3653, 3302, 3532, 3744, 3532, 3747, 3760, 3546, 3532, 3532, 3532, 3225, 3532, 3699, 3375, 3532, 3532,
  3543, 3532, 3516, 3532, 3659, 3659, 3659, 3532, 3532, 3659, 3305, 3532, 3532, 3224, 3240, 3314, 3336, 3532, 3732,
  3598, 3532, 3741, 3532, 3226, 3761, 3344, 3761, 3761, 3761, 3761, 3378, 3762, 3692, 3692, 3322, 3333, 3532, 3692,
  3692, 3692, 3690, 3692, 3707, 3322, 3334, 3532, 3655, 3372, 3532, 3225, 3532, 3402, 3515, 3532, 3532, 3517, 3532,
  3517, 3532, 3532, 3532, 3721, 3696, 3692, 3692, 3692, 3692, 3314, 3314, 3314, 3314, 3315, 3316, 3692, 3692, 3708,
  3708, 3338, 3334, 3335, 3314, 3314, 3314, 3532, 3532, 3532, 3362, 3692, 3707, 3708, 3708, 3338, 3334, 3334, 3335,
  3532, 3662, 3659, 3659, 3659, 3659, 3734, 3692, 3707, 3338, 3335, 3659, 3532, 3696, 3692, 3690, 3314, 3314, 3532,
  3659, 3659, 3734, 3532, 3532, 3532, 3298, 3532, 3660, 3692, 3692, 3308, 3312, 3314, 3314, 3315, 3532, 3532, 3532,
  3361, 3315, 3696, 3690, 3691, 3691, 3691, 3315, 3226, 3227, 3343, 3762, 3347, 3422, 3414, 3358, 3359, 3761, 3394,
  3399, 3396, 3413, 3415, 3761, 3400, 3426, 3428, 3398, 3412, 3761, 3761, 3532, 3532, 3226, 3717, 3381, 3881, 3418,
  3535, 3761, 3761, 3762, 3761, 3420, 3421, 3424, 3416, 3429, 3431, 3433, 3433, 3434, 3436, 3438, 3454, 3442, 3441,
  3440, 3453, 3532, 3226, 3343, 3348, 3762, 3444, 3345, 3446, 3448, 3451, 3450, 3451, 3452, 3456, 3532, 3225, 3532,
  3532, 3390, 3600, 3458, 3532, 3532, 3532, 3373, 3532, 3662, 3464, 3591, 3532, 3905, 3573, 3532, 3246, 3532, 3546,
  3532, 3298, 3532, 3532, 3532, 3386, 3471, 3532, 3540, 3300, 3329, 3888, 3528, 3591, 3532, 3532, 3532, 3403, 3589,
  3694, 3479, 3532, 3247, 3248, 3641, 3515, 3373, 3482, 3532, 3318, 3532, 3532, 3751, 3532, 3532, 3532, 3626, 3576,
  3577, 3480, 3484, 3487, 3487, 3488, 3489, 3485, 3491, 3492, 3494, 3496, 3500, 3499, 3499, 3498, 3499, 3499, 3502,
  3503, 3503, 3503, 3503, 3504, 3505, 3505, 3507, 3505, 3509, 3511, 3532, 3325, 3747, 3255, 3246, 3715, 3532, 3532,
  3243, 3225, 3532, 3532, 3695, 3532, 3326, 3480, 3532, 3532, 3532, 3467, 3744, 3520, 3532, 3532, 3243, 3246, 3532,
  3331, 3566, 3532, 3532, 3297, 3532, 3555, 3331, 3559, 3532, 3327, 3828, 3591, 3363, 3532, 3532, 3532, 3472, 3516,
  3750, 3532, 3316, 3373, 3316, 3664, 3386, 3653, 3523, 3303, 3744, 3575, 3532, 3532, 3327, 3375, 3669, 3899, 3532,
  3532, 3330, 3532, 3532, 3532, 3404, 3831, 3324, 3532, 3532, 3532, 3529, 3406, 3532, 3705, 3697, 3831, 3570, 3525,
  3532, 3898, 3561, 3532, 3532, 3371, 3476, 3743, 3405, 3515, 3532, 3532, 3532, 3535, 3245, 3715, 3532, 3936, 3532,
  3532, 3379, 3700, 3657, 3660, 3698, 3569, 3562, 3532, 3697, 3898, 3570, 3525, 3368, 3882, 3532, 3532, 3512, 3532,
  3532, 3697, 3887, 3552, 3524, 3532, 3532, 3532, 3536, 3532, 3600, 3303, 3532, 3532, 3516, 3676, 3661, 3532, 3532,
  3744, 3527, 3532, 3532, 3516, 3750, 3516, 3404, 3831, 3524, 3532, 3349, 3683, 3727, 3552, 3743, 3657, 3698, 3527,
  3525, 3532, 3532, 3532, 3540, 3515, 3532, 3526, 3532, 3532, 3657, 3697, 3887, 3404, 3831, 3515, 3532, 3532, 3514,
  3532, 3532, 3579, 3581, 3532, 3532, 3532, 3542, 3532, 3532, 3516, 3588, 3594, 3596, 3532, 3532, 3532, 3547, 3512,
  3744, 3532, 3532, 3662, 3603, 3745, 3605, 3532, 3372, 3532, 3532, 3532, 3309, 3532, 3532, 3532, 3340, 3243, 3546,
  3532, 3389, 3532, 3532, 3532, 3548, 3607, 3512, 3611, 3532, 3375, 3532, 3532, 3532, 3750, 3560, 3532, 3532, 3893,
  3249, 3249, 3613, 3618, 3620, 3618, 3618, 3618, 3618, 3622, 3622, 3618, 3618, 3615, 3617, 3624, 3624, 3624, 3624,
  3532, 3532, 3530, 3568, 3629, 3532, 3532, 3532, 3550, 3626, 3529, 3532, 3535, 3543, 3376, 3392, 3532, 3532, 3533,
  3626, 3535, 3631, 3532, 3532, 3533, 3656, 3535, 3633, 3627, 3532, 3386, 3523, 3303, 3635, 3532, 3532, 3532, 3551,
  3640, 3535, 3633, 3628, 3648, 3650, 3532, 3532, 3533, 3862, 3649, 3628, 3532, 3532, 3533, 3875, 3229, 3595, 3747,
  3532, 3386, 3888, 3528, 3242, 3525, 3532, 3532, 3533, 3884, 3720, 3722, 3664, 3652, 3591, 3532, 3532, 3533, 3936,
  3532, 3668, 3532, 3532, 3534, 3532, 3532, 3532, 3667, 3676, 3596, 3816, 3532, 3364, 3328, 3523, 3529, 3532, 3528,
  3535, 3886, 3600, 3532, 3532, 3535, 3532, 3532, 3532, 3866, 3533, 3532, 3532, 3532, 3560, 3513, 3672, 3532, 3532,
  3532, 3583, 3543, 3532, 3674, 3380, 3685, 3374, 3386, 3388, 3528, 3751, 3734, 3532, 3532, 3563, 3532, 3532, 3712,
  3715, 3660, 3678, 3557, 3532, 3532, 3565, 3572, 3535, 3349, 3718, 3381, 3738, 3552, 3532, 3532, 3532, 3647, 3383,
  3385, 3323, 3889, 3532, 3532, 3532, 3752, 3744, 3717, 3380, 3382, 3384, 3700, 3387, 3570, 3386, 3937, 3609, 3532,
  3389, 3654, 3241, 3583, 3594, 3661, 3532, 3542, 3532, 3371, 3585, 3890, 3225, 3525, 3532, 3532, 3532, 3681, 3532,
  3543, 3349, 3532, 3732, 3532, 3532, 3532, 3885, 3532, 3935, 3532, 3532, 3583, 3594, 3532, 3229, 3595, 3532, 3532,
  3600, 3529, 3532, 3750, 3532, 3532, 3532, 3228, 3712, 3689, 3679, 3532, 3401, 3231, 3532, 3228, 3750, 3532, 3243,
  3725, 3532, 3245, 3830, 3354, 3717, 3381, 3686, 3323, 3609, 3323, 3389, 3532, 3532, 3654, 3532, 3532, 3532, 3390,
  3532, 3532, 3713, 3532, 3532, 3655, 3751, 3583, 3532, 3890, 3670, 3748, 3587, 3864, 3532, 3407, 3532, 3532, 3789,
  3743, 3532, 3583, 3543, 3392, 3532, 3472, 3864, 3532, 3532, 3532, 3653, 3740, 3743, 3532, 3532, 3532, 3655, 3532,
  3532, 3532, 3544, 3516, 3864, 3532, 3532, 3696, 3532, 3532, 3533, 3702, 3591, 3516, 3588, 3743, 3532, 3702, 3591,
  3764, 3532, 3764, 3532, 3392, 3246, 3246, 3532, 3532, 3696, 3692, 3692, 3690, 3532, 3729, 3532, 3532, 3702, 3591,
  3516, 3892, 3591, 3532, 3532, 3709, 3299, 3701, 3532, 3532, 3532, 3658, 3226, 3590, 3607, 3532, 3469, 3644, 3532,
  3473, 3532, 3532, 3890, 3744, 3226, 3369, 3605, 3591, 3512, 3390, 3769, 3768, 3771, 3773, 3774, 3777, 3779, 3781,
  3783, 3774, 3774, 3775, 3774, 3774, 3774, 3785, 3786, 3786, 3786, 3786, 3787, 3532, 3532, 3730, 3473, 3389, 3532,
  3655, 3789, 3891, 3532, 3515, 3532, 3532, 3749, 3737, 3552, 3532, 3734, 3532, 3532, 3730, 3532, 3532, 3532, 3516,
  3518, 3703, 3532, 3532, 3532, 3662, 3792, 3794, 3797, 3532, 3531, 3532, 3567, 3645, 3532, 3533, 3799, 3310, 3532,
  3532, 3532, 3692, 3532, 3806, 3808, 3810, 3533, 3807, 3809, 3704, 3532, 3532, 3804, 3553, 3591, 3532, 3532, 3743,
  3532, 3516, 3743, 3638, 3818, 3531, 3532, 3533, 3539, 3532, 3532, 3532, 3657, 3698, 3821, 3532, 3532, 3532, 3700,
  3228, 3755, 3838, 3819, 3801, 3601, 3532, 3533, 3372, 3532, 3532, 3753, 3541, 3756, 3839, 3693, 3365, 3802, 3601,
  3298, 3700, 3465, 3532, 3532, 3532, 3656, 3532, 3532, 3532, 3546, 3754, 3517, 3676, 3317, 3366, 3523, 3531, 3460,
  3341, 3532, 3532, 3532, 3706, 3715, 3663, 3365, 3523, 3535, 3517, 3341, 3532, 3533, 3814, 3904, 3245, 3715, 3353,
  3523, 3591, 3532, 3371, 3742, 3532, 3532, 3744, 3532, 3402, 3516, 3750, 3532, 3532, 3757, 3878, 3543, 3517, 3353,
  3591, 3532, 3353, 3532, 3532, 3532, 3728, 3329, 3517, 3354, 3532, 3532, 3532, 3731, 3532, 3532, 3532, 3533, 3228,
  3390, 3532, 3532, 3521, 3516, 3833, 3532, 3532, 3532, 3730, 3352, 3751, 3751, 3532, 3532, 3758, 3532, 3532, 3532,
  3480, 3535, 3370, 3743, 3532, 3532, 3532, 3835, 3877, 3532, 3535, 3349, 3683, 3382, 3686, 3323, 3609, 3532, 3532,
  3532, 3599, 3532, 3532, 3532, 3545, 3532, 3877, 3532, 3661, 3532, 3661, 3532, 3543, 3758, 3837, 3532, 3532, 3766,
  3887, 3759, 3841, 3355, 3356, 3843, 3846, 3846, 3851, 3853, 3848, 3846, 3846, 3849, 3846, 3846, 3846, 3409, 3845,
  3410, 3853, 3853, 3853, 3853, 3532, 3532, 3532, 3747, 3367, 3525, 3532, 3661, 3895, 3730, 3408, 3532, 3532, 3792,
  3800, 3461, 3532, 3532, 3857, 3462, 3859, 3532, 3532, 3823, 3826, 3867, 3869, 3532, 3532, 3824, 3532, 3868, 3532,
  3532, 3532, 3751, 3354, 3532, 3866, 3871, 3532, 3532, 3758, 3532, 3599, 3529, 3536, 3532, 3532, 3532, 3753, 3756,
  3873, 3532, 3532, 3532, 3757, 3532, 3532, 3532, 3532, 3226, 3532, 3532, 3721, 3880, 3597, 3475, 3570, 3938, 3591,
  3532, 3532, 3855, 3532, 3876, 3722, 3664, 3474, 3790, 3341, 3532, 3535, 3536, 3643, 3522, 3939, 3532, 3532, 3886,
  3828, 3757, 3532, 3679, 3532, 3532, 3532, 3543, 3392, 3532, 3752, 3468, 3670, 3532, 3696, 3532, 3732, 3729, 3532,
  3532, 3560, 3532, 3532, 3532, 3812, 3532, 3532, 3722, 3664, 3700, 3475, 3306, 3532, 3532, 3532, 3861, 3352, 3687,
  3532, 3532, 3532, 3760, 3717, 3720, 3722, 3700, 3608, 3591, 3866, 3656, 3532, 3532, 3931, 3532, 3887, 3591, 3532,
  3532, 3535, 3675, 3684, 3744, 3525, 3696, 3758, 3679, 3532, 3230, 3532, 3297, 3532, 3532, 3533, 3885, 3722, 3591,
  3532, 3901, 3351, 3723, 3750, 3525, 3661, 3757, 3532, 3599, 3529, 3532, 3532, 3532, 3459, 3532, 3748, 3351, 3660,
  3591, 3546, 3532, 3297, 3532, 3535, 3713, 3660, 3885, 3733, 3264, 3532, 3532, 3532, 3890, 3225, 3532, 3696, 3532,
  3543, 3360, 3532, 3532, 3710, 3660, 3532, 3532, 3532, 3676, 3532, 3516, 3676, 3264, 3532, 3298, 3719, 3719, 3719,
  3532, 3243, 3298, 3298, 3532, 3299, 3299, 3226, 3719, 3532, 3532, 3532, 3537, 3584, 3750, 3532, 3532, 3299, 3532,
  3532, 3532, 3538, 3586, 3532, 3532, 3532, 3711, 3732, 3735, 3532, 3543, 3532, 3532, 3751, 3534, 3367, 3719, 3543,
  3532, 3532, 3543, 3532, 3710, 3532, 3298, 3309, 3532, 3299, 3716, 3298, 3542, 3350, 3244, 3319, 3320, 3532, 3932,
  3585, 3585, 3903, 3907, 3917, 3917, 3919, 3921, 3908, 3909, 3910, 3910, 3923, 3910, 3910, 3911, 3911, 3923, 3912,
  3913, 3913, 3913, 3913, 3915, 3913, 3913, 3914, 3925, 3927, 3929, 3532, 3532, 3532, 3556, 3389, 3532, 3535, 3517,
  3677, 3532, 3709, 3532, 3532, 3576, 3532, 3532, 3748, 3587, 3881, 3532, 3863, 3532, 3532, 3532, 3583, 3532, 3702,
  3591, 3532, 3714, 3709, 3532, 3226, 3532, 3583, 3885, 3721, 3897, 3477, 3753, 3584, 3750, 3532, 3592, 3532, 3532,
  3742, 3532, 3535, 3532, 3532, 3543, 3546, 3533, 3228, 3586, 3532, 3596, 3375, 3532, 3226, 3226, 3532, 3226, 3886,
  3687, 3465, 3934, 3532, 3532, 3532, 3637, 3532, 3533, 3229, 3656, 3546, 3532, 3532, 3535, 3370, 3536, 3542, 3532,
  3532, 3532, 3710, 3228, 3532, 3532, 3532, 3655, 3371, 3585, 3590, 1073872896, 131072, 0, 16, 2, 4, 32, 0, 24, 262146,
  262160, 262160, 33816576, 278528, 278544, 268566528, 131072, 131072, 36, 0, 32, 8, 128, 0, 37, 1140850690, 1140883458,
  537133056, 537133056, -2147221504, -2147221504, 262144, -2147483648, 262174, -2147221504, 10560, -2147221504,
  537149440, 278530, 772014080, 32768, -2147483648, 537149440, 772014080, 168034304, 168034304, 235143168, 168034304,
  235143168, 772014080, 772014080, 235143168, -1375469568, 772030464, -1375469568, 32800, 163872, 2392096, 294944,
  -2147188704, 294944, -2145091522, -2145091522, 294944, 537165856, 294944, 294944, 163840, -2111537090, -2145091522,
  772046880, 772046880, -1910210498, 4096, 0, 1024, 0, 1280, 16777216, 1073741824, -2147483648, 16384, 134217728,
  -2147483648, 32800, 2097152, 0, 55296, 2129920, 2129952, 2129920, 2129920, 0, 65536, 786432, 0, 68608, 1056, 32,
  2097152, 50331648, 0, 329728, 0, 524288, 2097152, 4194304, 0, 147456, 2129920, 2097184, 2097184, 2129920, 12, 32,
  2097184, 1024, 268435456, -2147483648, 1073774592, 16, 21, 53, 48, 80, 16, 32, 1024, 4096, 524288, 3145728, 0, 526336,
  526336, 268435472, 16, 48, 0, 716800, 998244352, 0, 786432, 3145728, 4194304, 131072, 8388608, 2048, 8192, 64, 0,
  262144, 524288, 0, 520, 131088, 16, 1024, 6144, 8192, 16384, 98304, 262144, 1048576, 2097152, 117440512, 134217728, 0,
  1048576, 4194304, -2147483648, 17, 24, 1048848, 1572880, 17, 304, 48, 16, 131072, 33554432, 12288, 131072, 58720256,
  0, 1576960, 201326592, 201326592, 201326594, 48, 524304, 524304, 1048592, 1048592, 1114416, 17, 16, 165675008, 272,
  272, 262160, 524560, 272, 84, 20, -165649452, -165649452, 372, -165649451, -165649451, -701430800, -701430800,
  -164559888, -700906512, -164535312, -700906508, -164535312, -164535308, -164273164, -164535308, -164535312, 21, 112,
  85, 117, 140515349, 140539925, 140540605, 140540573, 140540573, -164535308, -164535308, -164273168, -164273164,
  -26141771, 163577856, 0, 3145728, 67108864, 0, 3674112, 100663296, 536870912, -2147483648, 12582912, 0, 4194304,
  786432, 4, 128, 4096, 1572864, 8388608, 16777216, 8388608, -2147483648, 65536, 268435456, 16, 1076887552, 1076887552,
  344064064, 327303168, -2097135583, 327303168, 327303168, 50348065, 50348065, -1020248031, 276971585, 276971585,
  310526017, 310526019, 327303233, 277235779, 327303267, 327303265, 327303265, 277235779, 327303265, 998961152,
  998961152, 998961706, 998961706, 998961770, 998961706, 998961249, 998961249, 998961771, 0, 8388608, 131072, 268435456,
  0, 128, 256, -2147483648, 343932928, 0, 16777216, 67108864, 268435456, 536870912, 0, 33554432, 268435456, 1073741824,
  0, -1073741824, 0, 0, 1, 0, 2, 0, 3, 4, 0, 4, 8, 0, 8, 8, 16, 0, 12, 14, -2097152000, 0, 50331648, 134217728,
  536870912, -1023410176, 0, 67108864, 1073741824, 276824064, 0, 134217728, 805306368, 0, 201326592, 310378496,
  327155712, 0, 41943040, 58720256, 134217728, 268435456, 411648, 0, 239075328, 75497472, 0, 268435456, 268500992, 8192,
  131072, 524288, 268435456, 1, 4, 64, 64, 256, 4096, 65536, 0, -2147483648, 0, -1879048192, 32, 8192, 32768, 262144,
  1572864, 0, 2097152, 268435456, -1073741824, 36, 134225920, 8388608, 536870912, 8192, 8388608, 134217728, 1073741824,
  4, 536870912, -2143288824, 1141162274, 271057920, 271188992, 271057920, 1412220194, 1412220194, 405275648, 405275685,
  1420608802, 1412220194, 1597898226, 1597898226, 2, 67108864, 1342177280, 0, 536870912, 288, 311296, 1312, 2932736,
  2621440, 268435456, 2752512, 0, 1073741824, 1060, 0, 1140850690, 11321344, 0, 1610612736, 0, 2, 7664, 4055040,
  251658240, 1342177280, 512, 4194304, 8388608, 0, 8192, 0, 12288, 16384, 16384, 32768, 0, 16384, 65536, 262144, 8768,
  2, 288, 16384, 131072, 536870912, 10485760, 0, 2, 496, 1024, 16384, 262144, 2097152, 1073741824, 2, 1073741824, 448,
  6144, 24576, 98304, 1048576, 134217728, 256, 32768, 2129920, 32768, 32768, 65536, 264192, 0, 32768, 131072, 524288,
  524288, 1048576, 8, 4194304, -805306368, 0, 28672, 32768, 32, 32, 128, 1024, 2, 32, 256, 256, 1024, 32, 448, 1024,
  1024, 2048, 4096, 49152, -2147483648, 256, 2097152, 8192, 65536, 1048576, 0, 2048, 0, 4096, 16384, 0, 5120, 6144,
  65536, 2097152, 128, 65536, 16777216, 33554432, 0, 131072, 262144, 262144, 0, 192, 256, 0, 256, 1, 2, 8, 384, 512, 0,
  512, 2, 16, 16, 20, 128, 33554432, 8192, 16777280, -2147467264, -2147467264, 0, -2147467264, 131104, -1879031808,
  -800795773, -800795773, -800795757, -800795773, 1079284611, 1078236035, 1078760323, -800795773, 1615106947,
  1616155523, -800795901, -800793725, -729950321, -729950321, 0, 64, 16777216, 134217728, 1, 898, 36864, 262144,
  268444864, 5242880, 1073741824, 770, 53248, 262144, 4194304, 67108864, 914, 0, 1, 1934, 53248, 851968, 74448896,
  -805306368, 32, 131072, 2, 384, 4194304, 1073741824, 256, 20480, 32768, 400, 0, 2, 128, 8256, 256, 262144, 1048576,
  536870912, 256, 524288, 33554432, 256, 3145728, 1, 4194560, 1075838976, 512, 1024, 20480, 2, 526336, 56, 1579008,
  201334784, 202905600, 202905600, 68687872, 68687872, 202905600, 739907584, 1278744576, -1650598715, -1650598715, 56,
  0, 1708032, 738197504, 1275068416, 0, 1, 1220, 2048, 65536, 33554432, 2, 2048, 10342400, -1660944384, 0, 8192,
  33554432, 3670016, 0, 4, 1216, 2048, 537001984, 0, 49152, 65536, 50331648, 268435456, 4, 192, 1024, 524288, 8388608,
  67108864, 134217728, 8388608, 33554432, 134217728, 134225924, 512, 2097152, 49152, 524288, 58720256, 268435456, 1,
  192, 1088, 512, 4096, 138412032, 49216, 65, 12297, 61505, 61505, 62529, 327, 327, 1351, 1351, 1089, 65, 1089, 12289,
  12305, 12289, 62529, 61505, 16711, 33095, 62791, 62791, 61767, 0, 1, 64, 68608, 4, 256, 16384, 50331648, 67108864,
  402653184, -2147483648
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "StringConstructorChars",
  "S",
  "S",
  "CommentContents",
  "PragmaContents",
  "Wildcard",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "EOF",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'=>'",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "']``'",
  "'``['",
  "'`{'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'array'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'exponent-separator'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'map'",
  "'minus-sign'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}`'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 2048
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1951 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 4 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer)
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(61, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 19) then                 (: CommentContents :)
            let $state := p:consumeT(19, $input, $state)    (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(36, $input, $state)              (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consumeT(49, $input, $state)              (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 18) then                       (: S^WS :)
      let $state := p:consumeT(18, $input, $state)          (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(157, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(123, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(181, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 202) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(119, $input, $state)          (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(195, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(119, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(189, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(105, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'variable' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 195) then                      (: 'variable' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotatedDecl", $count, $begin, $end)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDefaultValue", $count, $begin, $end)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 137) then                      (: 'is' :)
      let $state := p:consume(137, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:consume(57, $input, $state)           (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(64, $input, $state)           (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:consume(27, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:consume(53, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:consume(58, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(63, $input, $state)           (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 115) then                      (: 'eq' :)
      let $state := p:consume(115, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ne' :)
      let $state := p:consume(150, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'lt' :)
      let $state := p:consume(143, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'le' :)
      let $state := p:consume(140, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'gt' :)
      let $state := p:consume(128, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(124, $input, $state)          (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TypeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleTypeName", $count, $begin, $end)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'and' | 'ascending' | 'case' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Parse ArrowFunctionSpecifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrowFunctionSpecifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrowFunctionSpecifier", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(156, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 67) then                       (: '@' :)
      let $state := p:consume(67, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(176, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:consume(91, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'descendant' :)
      let $state := p:consume(102, $input, $state)          (: 'descendant' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'attribute' :)
      let $state := p:consume(83, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'self' :)
      let $state := p:consume(176, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'descendant-or-self' :)
      let $state := p:consume(103, $input, $state)          (: 'descendant-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'following-sibling' :)
      let $state := p:consume(121, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(120, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 83) then                           (: 'attribute' :)
      let $state := p:lookahead2W(163, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (91,                           (: 'child' :)
                              102,                          (: 'descendant' :)
                              103,                          (: 'descendant-or-self' :)
                              120,                          (: 'following' :)
                              121,                          (: 'following-sibling' :)
                              176)) then                    (: 'self' :)
      let $state := p:lookahead2W(160, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 12883                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12891                          (: 'child' '::' :)
          or $state[$p:lk] = 12902                          (: 'descendant' '::' :)
          or $state[$p:lk] = 12903                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 12920                          (: 'following' '::' :)
          or $state[$p:lk] = 12921                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 12976) then                    (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(176, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(44, $input, $state)               (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (83,                                (: 'attribute' :)
                         93,                                (: 'comment' :)
                         108,                               (: 'document-node' :)
                         109,                               (: 'element' :)
                         149,                               (: 'namespace-node' :)
                         154,                               (: 'node' :)
                         170,                               (: 'processing-instruction' :)
                         174,                               (: 'schema-attribute' :)
                         175,                               (: 'schema-element' :)
                         184)) then                         (: 'text' :)
      let $state := p:lookahead2W(159, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8787                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8797                           (: 'comment' '(' :)
          or $state[$p:lk] = 8812                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8813                           (: 'element' '(' :)
          or $state[$p:lk] = 8853                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 8858                           (: 'node' '(' :)
          or $state[$p:lk] = 8874                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8878                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8879                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8888) then                     (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 162) then                      (: 'parent' :)
      let $state := p:consume(162, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'ancestor' :)
      let $state := p:consume(76, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'preceding-sibling' :)
      let $state := p:consume(167, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'preceding' :)
      let $state := p:consume(166, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(77, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(50, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(176, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (76,                                (: 'ancestor' :)
                         77,                                (: 'ancestor-or-self' :)
                         162,                               (: 'parent' :)
                         166,                               (: 'preceding' :)
                         167)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(160, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 44                             (: '..' :)
          or $state[$p:lk] = 12876                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 12877                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 12962                          (: 'parent' '::' :)
          or $state[$p:lk] = 12966                          (: 'preceding' '::' :)
          or $state[$p:lk] = 12967) then                    (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(156, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Parse Lookup.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Lookup($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(141, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-KeySpecifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Lookup", $count, $begin, $end)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(70, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Parse KeySpecifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeySpecifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KeySpecifier", $count, $begin, $end)
};

(:~
 : Parse UnaryLookup.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryLookup($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(141, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-KeySpecifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryLookup", $count, $begin, $end)
};

(:~
 : Parse StringConstructorInterpolation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConstructorInterpolation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(74, $input, $state)               (: '`{' :)
  let $state := p:lookahead1W(195, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 207) then                     (: '}`' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(207, $input, $state)              (: '}`' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConstructorInterpolation", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production StringConstructorContent (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConstructorContent-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(17, $input, $state)          (: ']``' | '`{' :)
    return
      if ($state[$p:l1] != 74) then                         (: '`{' :)
        $state
      else
        let $state := p:parse-StringConstructorInterpolation($input, $state)
        let $state := p:lookahead1(1, $input, $state)       (: StringConstructorChars :)
        let $state := p:consume(16, $input, $state)         (: StringConstructorChars :)
        return p:parse-StringConstructorContent-1($input, $state)
};

(:~
 : Parse StringConstructorContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConstructorContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(1, $input, $state)             (: StringConstructorChars :)
  let $state := p:consume(16, $input, $state)               (: StringConstructorChars :)
  let $state := p:parse-StringConstructorContent-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConstructorContent", $count, $begin, $end)
};

(:~
 : Parse StringConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(73, $input, $state)               (: '``[' :)
  let $state := p:parse-StringConstructorContent($input, $state)
  let $state := p:consume(72, $input, $state)               (: ']``' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConstructor", $count, $begin, $end)
};

(:~
 : Parse CurlyArrayConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurlyArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(202, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(194, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 206) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(206, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurlyArrayConstructor", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SquareArrayConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40) then                           (: ',' :)
      $state
    else
      let $state := p:consume(40, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-SquareArrayConstructor-1($input, $state)
};

(:~
 : Parse SquareArrayConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SquareArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(69, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | ']' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 70) then                      (: ']' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-SquareArrayConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(70, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SquareArrayConstructor", $count, $begin, $end)
};

(:~
 : Parse ArrayConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69) then                       (: '[' :)
      let $state := p:parse-SquareArrayConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CurlyArrayConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayConstructor", $count, $begin, $end)
};

(:~
 : Parse MapValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapValueExpr", $count, $begin, $end)
};

(:~
 : Parse MapKeyExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapKeyExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapKeyExpr", $count, $begin, $end)
};

(:~
 : Parse MapConstructorEntry.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapConstructorEntry($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MapKeyExpr($input, $state)
  let $state := p:consume(48, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-MapValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapConstructorEntry", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MapConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40) then                           (: ',' :)
      $state
    else
      let $state := p:consume(40, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MapConstructorEntry($input, $state)
      return p:parse-MapConstructor-1($input, $state)
};

(:~
 : Parse MapConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(144, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(202, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(194, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 206) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MapConstructorEntry($input, $state)
      let $state := p:parse-MapConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(206, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapConstructor", $count, $begin, $end)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-InlineFunctionExpr-1($input, $state)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(123, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(181, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InlineFunctionExpr", $count, $begin, $end)
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(29, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(18, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamedFunctionRef", $count, $begin, $end)
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 123) then                          (: 'function' :)
      let $state := p:lookahead2W(64, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 8827) then                     (: 'function' '(' :)
      let $state := p:parse-InlineFunctionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NamedFunctionRef($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionItemExpr", $count, $begin, $end)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(170, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(138, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 202) then                      (: '{' :)
      let $state := p:consume(202, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:consume(206, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(93, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(184, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Parse EnclosedURIExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedURIExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedURIExpr", $count, $begin, $end)
};

(:~
 : Parse EnclosedPrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedPrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedPrefixExpr", $count, $begin, $end)
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NCName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prefix", $count, $begin, $end)
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(148, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(138, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 202) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EnclosedPrefixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedURIExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompNamespaceConstructor", $count, $begin, $end)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(83, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 202) then                      (: '{' :)
      let $state := p:consume(202, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:consume(206, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Parse EnclosedContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedContentExpr", $count, $begin, $end)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(109, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 202) then                      (: '{' :)
      let $state := p:consume(202, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:consume(206, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedContentExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(107, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(59, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(15, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(4, $input, $state)         (: DirPIContents :)
      let $state := p:consume(23, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:consume(66, $input, $state)               (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(54, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(3, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(22, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:consume(42, $input, $state)               (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(55, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(5, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(24, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(11, $input, $state)            (: ']]>' :)
  let $state := p:consume(71, $input, $state)               (: ']]>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CDataSection", $count, $begin, $end)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: '{{' :)
      let $state := p:consume(203, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 208) then                      (: '}}' :)
      let $state := p:consume(208, $input, $state)          (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(123, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(124, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(16, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '"' :)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(28, $input, $state)           (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(33, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(33, $input, $state)           (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 17) then                         (: S :)
        $state
      else
        let $state := p:consume(17, $input, $state)         (: S :)
        let $state := p:lookahead1(175, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 17                      (: S :)
               and $state[$p:l1] != 47                      (: '/>' :)
               and $state[$p:l1] != 62) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(13, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:consume(60, $input, $state)     (: '=' :)
            let $state := p:lookahead1(20, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 17) then             (: S :)
                let $state := p:consume(17, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(129, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(53, $input, $state)               (: '<' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 47) then                       (: '/>' :)
      let $state := p:consume(47, $input, $state)           (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(62, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(56, $input, $state)           (: '</' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(14, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 17) then                   (: S :)
          let $state := p:consume(17, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:consume(62, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Parse NodeConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 54                             (: '<!--' :)
          or $state[$p:l1] = 59) then                       (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeConstructor", $count, $begin, $end)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(193, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(160, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(65, $input, $state)               (: '?' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentPlaceholder", $count, $begin, $end)
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 65) then                           (: '?' :)
      let $state := p:lookahead2W(146, $input, $state)      (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | ',' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9537                           (: '?' ')' :)
          or $state[$p:lk] = 10305) then                    (: '?' ',' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Argument", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(189, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(191, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentList", $count, $begin, $end)
};

(:~
 : Parse FunctionEQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionEQName", $count, $begin, $end)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArgumentList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(43, $input, $state)               (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(191, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 148) then                          (: 'namespace' :)
      let $state := p:lookahead2W(142, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 170) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(140, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (83,                           (: 'attribute' :)
                              109)) then                    (: 'element' :)
      let $state := p:lookahead2W(179, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (107,                          (: 'document' :)
                              160,                          (: 'ordered' :)
                              193)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(102, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (79,                           (: 'array' :)
                              93,                           (: 'comment' :)
                              144,                          (: 'map' :)
                              184)) then                    (: 'text' :)
      let $state := p:lookahead2W(65, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              76,                           (: 'ancestor' :)
                              77,                           (: 'ancestor-or-self' :)
                              78,                           (: 'and' :)
                              81,                           (: 'ascending' :)
                              87,                           (: 'case' :)
                              88,                           (: 'cast' :)
                              89,                           (: 'castable' :)
                              91,                           (: 'child' :)
                              92,                           (: 'collation' :)
                              97,                           (: 'count' :)
                              100,                          (: 'declare' :)
                              101,                          (: 'default' :)
                              102,                          (: 'descendant' :)
                              103,                          (: 'descendant-or-self' :)
                              104,                          (: 'descending' :)
                              106,                          (: 'div' :)
                              110,                          (: 'else' :)
                              111,                          (: 'empty' :)
                              114,                          (: 'end' :)
                              115,                          (: 'eq' :)
                              116,                          (: 'every' :)
                              117,                          (: 'except' :)
                              120,                          (: 'following' :)
                              121,                          (: 'following-sibling' :)
                              122,                          (: 'for' :)
                              124,                          (: 'ge' :)
                              126,                          (: 'group' :)
                              128,                          (: 'gt' :)
                              129,                          (: 'idiv' :)
                              131,                          (: 'import' :)
                              135,                          (: 'instance' :)
                              136,                          (: 'intersect' :)
                              137,                          (: 'is' :)
                              140,                          (: 'le' :)
                              142,                          (: 'let' :)
                              143,                          (: 'lt' :)
                              146,                          (: 'mod' :)
                              147,                          (: 'module' :)
                              150,                          (: 'ne' :)
                              156,                          (: 'only' :)
                              158,                          (: 'or' :)
                              159,                          (: 'order' :)
                              162,                          (: 'parent' :)
                              166,                          (: 'preceding' :)
                              167,                          (: 'preceding-sibling' :)
                              171,                          (: 'return' :)
                              172,                          (: 'satisfies' :)
                              176,                          (: 'self' :)
                              178,                          (: 'some' :)
                              179,                          (: 'stable' :)
                              180,                          (: 'start' :)
                              186,                          (: 'to' :)
                              187,                          (: 'treat' :)
                              188,                          (: 'try' :)
                              192,                          (: 'union' :)
                              194,                          (: 'validate' :)
                              198,                          (: 'where' :)
                              200)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(64, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8709                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8719                           (: QName^Token '(' :)
          or $state[$p:lk] = 8780                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8781                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8782                           (: 'and' '(' :)
          or $state[$p:lk] = 8785                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8791                           (: 'case' '(' :)
          or $state[$p:lk] = 8792                           (: 'cast' '(' :)
          or $state[$p:lk] = 8793                           (: 'castable' '(' :)
          or $state[$p:lk] = 8795                           (: 'child' '(' :)
          or $state[$p:lk] = 8796                           (: 'collation' '(' :)
          or $state[$p:lk] = 8801                           (: 'count' '(' :)
          or $state[$p:lk] = 8804                           (: 'declare' '(' :)
          or $state[$p:lk] = 8805                           (: 'default' '(' :)
          or $state[$p:lk] = 8806                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8807                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8808                           (: 'descending' '(' :)
          or $state[$p:lk] = 8810                           (: 'div' '(' :)
          or $state[$p:lk] = 8811                           (: 'document' '(' :)
          or $state[$p:lk] = 8814                           (: 'else' '(' :)
          or $state[$p:lk] = 8815                           (: 'empty' '(' :)
          or $state[$p:lk] = 8818                           (: 'end' '(' :)
          or $state[$p:lk] = 8819                           (: 'eq' '(' :)
          or $state[$p:lk] = 8820                           (: 'every' '(' :)
          or $state[$p:lk] = 8821                           (: 'except' '(' :)
          or $state[$p:lk] = 8824                           (: 'following' '(' :)
          or $state[$p:lk] = 8825                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8826                           (: 'for' '(' :)
          or $state[$p:lk] = 8828                           (: 'ge' '(' :)
          or $state[$p:lk] = 8830                           (: 'group' '(' :)
          or $state[$p:lk] = 8832                           (: 'gt' '(' :)
          or $state[$p:lk] = 8833                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8835                           (: 'import' '(' :)
          or $state[$p:lk] = 8839                           (: 'instance' '(' :)
          or $state[$p:lk] = 8840                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8841                           (: 'is' '(' :)
          or $state[$p:lk] = 8844                           (: 'le' '(' :)
          or $state[$p:lk] = 8846                           (: 'let' '(' :)
          or $state[$p:lk] = 8847                           (: 'lt' '(' :)
          or $state[$p:lk] = 8850                           (: 'mod' '(' :)
          or $state[$p:lk] = 8851                           (: 'module' '(' :)
          or $state[$p:lk] = 8852                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8854                           (: 'ne' '(' :)
          or $state[$p:lk] = 8860                           (: 'only' '(' :)
          or $state[$p:lk] = 8862                           (: 'or' '(' :)
          or $state[$p:lk] = 8863                           (: 'order' '(' :)
          or $state[$p:lk] = 8864                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8866                           (: 'parent' '(' :)
          or $state[$p:lk] = 8870                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8871                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8875                           (: 'return' '(' :)
          or $state[$p:lk] = 8876                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8880                           (: 'self' '(' :)
          or $state[$p:lk] = 8882                           (: 'some' '(' :)
          or $state[$p:lk] = 8883                           (: 'stable' '(' :)
          or $state[$p:lk] = 8884                           (: 'start' '(' :)
          or $state[$p:lk] = 8890                           (: 'to' '(' :)
          or $state[$p:lk] = 8891                           (: 'treat' '(' :)
          or $state[$p:lk] = 8892                           (: 'try' '(' :)
          or $state[$p:lk] = 8896                           (: 'union' '(' :)
          or $state[$p:lk] = 8897                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8898                           (: 'validate' '(' :)
          or $state[$p:lk] = 8902                           (: 'where' '(' :)
          or $state[$p:lk] = 8904) then                     (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 51872) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51905) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 108                            (: 'document-node' :)
          or $state[$p:lk] = 112                            (: 'empty-sequence' :)
          or $state[$p:lk] = 123                            (: 'function' :)
          or $state[$p:lk] = 130                            (: 'if' :)
          or $state[$p:lk] = 138                            (: 'item' :)
          or $state[$p:lk] = 149                            (: 'namespace-node' :)
          or $state[$p:lk] = 154                            (: 'node' :)
          or $state[$p:lk] = 174                            (: 'schema-attribute' :)
          or $state[$p:lk] = 175                            (: 'schema-element' :)
          or $state[$p:lk] = 183                            (: 'switch' :)
          or $state[$p:lk] = 191                            (: 'typeswitch' :)
          or $state[$p:lk] = 7429                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7439                           (: QName^Token '#' :)
          or $state[$p:lk] = 7500                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7501                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7502                           (: 'and' '#' :)
          or $state[$p:lk] = 7503                           (: 'array' '#' :)
          or $state[$p:lk] = 7505                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7507                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7511                           (: 'case' '#' :)
          or $state[$p:lk] = 7512                           (: 'cast' '#' :)
          or $state[$p:lk] = 7513                           (: 'castable' '#' :)
          or $state[$p:lk] = 7515                           (: 'child' '#' :)
          or $state[$p:lk] = 7516                           (: 'collation' '#' :)
          or $state[$p:lk] = 7517                           (: 'comment' '#' :)
          or $state[$p:lk] = 7521                           (: 'count' '#' :)
          or $state[$p:lk] = 7524                           (: 'declare' '#' :)
          or $state[$p:lk] = 7525                           (: 'default' '#' :)
          or $state[$p:lk] = 7526                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7527                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7528                           (: 'descending' '#' :)
          or $state[$p:lk] = 7530                           (: 'div' '#' :)
          or $state[$p:lk] = 7531                           (: 'document' '#' :)
          or $state[$p:lk] = 7533                           (: 'element' '#' :)
          or $state[$p:lk] = 7534                           (: 'else' '#' :)
          or $state[$p:lk] = 7535                           (: 'empty' '#' :)
          or $state[$p:lk] = 7538                           (: 'end' '#' :)
          or $state[$p:lk] = 7539                           (: 'eq' '#' :)
          or $state[$p:lk] = 7540                           (: 'every' '#' :)
          or $state[$p:lk] = 7541                           (: 'except' '#' :)
          or $state[$p:lk] = 7544                           (: 'following' '#' :)
          or $state[$p:lk] = 7545                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7546                           (: 'for' '#' :)
          or $state[$p:lk] = 7548                           (: 'ge' '#' :)
          or $state[$p:lk] = 7550                           (: 'group' '#' :)
          or $state[$p:lk] = 7552                           (: 'gt' '#' :)
          or $state[$p:lk] = 7553                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7555                           (: 'import' '#' :)
          or $state[$p:lk] = 7559                           (: 'instance' '#' :)
          or $state[$p:lk] = 7560                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7561                           (: 'is' '#' :)
          or $state[$p:lk] = 7564                           (: 'le' '#' :)
          or $state[$p:lk] = 7566                           (: 'let' '#' :)
          or $state[$p:lk] = 7567                           (: 'lt' '#' :)
          or $state[$p:lk] = 7568                           (: 'map' '#' :)
          or $state[$p:lk] = 7570                           (: 'mod' '#' :)
          or $state[$p:lk] = 7571                           (: 'module' '#' :)
          or $state[$p:lk] = 7572                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7574                           (: 'ne' '#' :)
          or $state[$p:lk] = 7580                           (: 'only' '#' :)
          or $state[$p:lk] = 7582                           (: 'or' '#' :)
          or $state[$p:lk] = 7583                           (: 'order' '#' :)
          or $state[$p:lk] = 7584                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7586                           (: 'parent' '#' :)
          or $state[$p:lk] = 7590                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7591                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7594                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7595                           (: 'return' '#' :)
          or $state[$p:lk] = 7596                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7600                           (: 'self' '#' :)
          or $state[$p:lk] = 7602                           (: 'some' '#' :)
          or $state[$p:lk] = 7603                           (: 'stable' '#' :)
          or $state[$p:lk] = 7604                           (: 'start' '#' :)
          or $state[$p:lk] = 7608                           (: 'text' '#' :)
          or $state[$p:lk] = 7610                           (: 'to' '#' :)
          or $state[$p:lk] = 7611                           (: 'treat' '#' :)
          or $state[$p:lk] = 7612                           (: 'try' '#' :)
          or $state[$p:lk] = 7616                           (: 'union' '#' :)
          or $state[$p:lk] = 7617                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7618                           (: 'validate' '#' :)
          or $state[$p:lk] = 7622                           (: 'where' '#' :)
          or $state[$p:lk] = 7624) then                     (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51856) then                    (: 'map' '{' :)
      let $state := p:parse-MapConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 69                             (: '[' :)
          or $state[$p:lk] = 51791) then                    (: 'array' '{' :)
      let $state := p:parse-ArrayConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 73) then                       (: '``[' :)
      let $state := p:parse-StringConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 65) then                       (: '?' :)
      let $state := p:parse-UnaryLookup($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NodeConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(164, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 65                               (: '?' :)
      and $state[$p:l1] != 69) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 69) then                 (: '[' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:l1] = 34) then                 (: '(' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ArgumentList($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Lookup($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpr", $count, $begin, $end)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 83) then                           (: 'attribute' :)
      let $state := p:lookahead2W(197, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:lk] eq 23635) then                    (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(63, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 25939) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28499) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 31315) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(115, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34643) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(93, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 40019) then               (: 'attribute' 'only' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 45907) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (20819,                    (: 'attribute' 'ascending' :)
                                  26707)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(134, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (24915,                    (: 'attribute' 'count' :)
                                  36435)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (29267,                    (: 'attribute' 'end' :)
                                  46163)) then              (: 'attribute' 'start' :)
          let $state := p:lookahead3W(125, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (32339,                    (: 'attribute' 'group' :)
                                  40787)) then              (: 'attribute' 'order' :)
          let $state := p:lookahead3W(82, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (22611,                    (: 'attribute' 'cast' :)
                                  22867,                    (: 'attribute' 'castable' :)
                                  47955)) then              (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (20051,                    (: 'attribute' 'and' :)
                                  22355,                    (: 'attribute' 'case' :)
                                  27219,                    (: 'attribute' 'div' :)
                                  28243,                    (: 'attribute' 'else' :)
                                  29523,                    (: 'attribute' 'eq' :)
                                  30035,                    (: 'attribute' 'except' :)
                                  31827,                    (: 'attribute' 'ge' :)
                                  32851,                    (: 'attribute' 'gt' :)
                                  33107,                    (: 'attribute' 'idiv' :)
                                  34899,                    (: 'attribute' 'intersect' :)
                                  35155,                    (: 'attribute' 'is' :)
                                  35923,                    (: 'attribute' 'le' :)
                                  36691,                    (: 'attribute' 'lt' :)
                                  37459,                    (: 'attribute' 'mod' :)
                                  38483,                    (: 'attribute' 'ne' :)
                                  40531,                    (: 'attribute' 'or' :)
                                  43859,                    (: 'attribute' 'return' :)
                                  44115,                    (: 'attribute' 'satisfies' :)
                                  47699,                    (: 'attribute' 'to' :)
                                  49235,                    (: 'attribute' 'union' :)
                                  50771)) then              (: 'attribute' 'where' :)
          let $state := p:lookahead3W(193, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 109) then                     (: 'element' :)
      let $state := p:lookahead2W(196, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:lk] eq 23661) then                    (: 'element' 'collation' :)
          let $state := p:lookahead3W(63, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 25965) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 28525) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 31341) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(115, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 34669) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(93, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 40045) then               (: 'element' 'only' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 45933) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (20845,                    (: 'element' 'ascending' :)
                                  26733)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(134, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (24941,                    (: 'element' 'count' :)
                                  36461)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (29293,                    (: 'element' 'end' :)
                                  46189)) then              (: 'element' 'start' :)
          let $state := p:lookahead3W(125, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (32365,                    (: 'element' 'group' :)
                                  40813)) then              (: 'element' 'order' :)
          let $state := p:lookahead3W(82, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (22637,                    (: 'element' 'cast' :)
                                  22893,                    (: 'element' 'castable' :)
                                  47981)) then              (: 'element' 'treat' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (20077,                    (: 'element' 'and' :)
                                  22381,                    (: 'element' 'case' :)
                                  27245,                    (: 'element' 'div' :)
                                  28269,                    (: 'element' 'else' :)
                                  29549,                    (: 'element' 'eq' :)
                                  30061,                    (: 'element' 'except' :)
                                  31853,                    (: 'element' 'ge' :)
                                  32877,                    (: 'element' 'gt' :)
                                  33133,                    (: 'element' 'idiv' :)
                                  34925,                    (: 'element' 'intersect' :)
                                  35181,                    (: 'element' 'is' :)
                                  35949,                    (: 'element' 'le' :)
                                  36717,                    (: 'element' 'lt' :)
                                  37485,                    (: 'element' 'mod' :)
                                  38509,                    (: 'element' 'ne' :)
                                  40557,                    (: 'element' 'or' :)
                                  43885,                    (: 'element' 'return' :)
                                  44141,                    (: 'element' 'satisfies' :)
                                  47725,                    (: 'element' 'to' :)
                                  49261,                    (: 'element' 'union' :)
                                  50797)) then              (: 'element' 'where' :)
          let $state := p:lookahead3W(193, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (79,                           (: 'array' :)
                              144)) then                    (: 'map' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (148,                          (: 'namespace' :)
                              170)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(168, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '{' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:lk] = (23700,                         (: 'namespace' 'collation' :)
                             23722)) then                   (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(63, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (26004,                    (: 'namespace' 'default' :)
                                  26026)) then              (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (28564,                    (: 'namespace' 'empty' :)
                                  28586)) then              (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = (31380,                    (: 'namespace' 'for' :)
                                  31402)) then              (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(115, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = (34708,                    (: 'namespace' 'instance' :)
                                  34730)) then              (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(93, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = (40084,                    (: 'namespace' 'only' :)
                                  40106)) then              (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = (45972,                    (: 'namespace' 'stable' :)
                                  45994)) then              (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (20884,                    (: 'namespace' 'ascending' :)
                                  26772,                    (: 'namespace' 'descending' :)
                                  20906,                    (: 'processing-instruction' 'ascending' :)
                                  26794)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(134, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (24980,                    (: 'namespace' 'count' :)
                                  36500,                    (: 'namespace' 'let' :)
                                  25002,                    (: 'processing-instruction' 'count' :)
                                  36522)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (29332,                    (: 'namespace' 'end' :)
                                  46228,                    (: 'namespace' 'start' :)
                                  29354,                    (: 'processing-instruction' 'end' :)
                                  46250)) then              (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(125, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (32404,                    (: 'namespace' 'group' :)
                                  40852,                    (: 'namespace' 'order' :)
                                  32426,                    (: 'processing-instruction' 'group' :)
                                  40874)) then              (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(82, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (22676,                    (: 'namespace' 'cast' :)
                                  22932,                    (: 'namespace' 'castable' :)
                                  48020,                    (: 'namespace' 'treat' :)
                                  22698,                    (: 'processing-instruction' 'cast' :)
                                  22954,                    (: 'processing-instruction' 'castable' :)
                                  48042)) then              (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (20116,                    (: 'namespace' 'and' :)
                                  22420,                    (: 'namespace' 'case' :)
                                  27284,                    (: 'namespace' 'div' :)
                                  28308,                    (: 'namespace' 'else' :)
                                  29588,                    (: 'namespace' 'eq' :)
                                  30100,                    (: 'namespace' 'except' :)
                                  31892,                    (: 'namespace' 'ge' :)
                                  32916,                    (: 'namespace' 'gt' :)
                                  33172,                    (: 'namespace' 'idiv' :)
                                  34964,                    (: 'namespace' 'intersect' :)
                                  35220,                    (: 'namespace' 'is' :)
                                  35988,                    (: 'namespace' 'le' :)
                                  36756,                    (: 'namespace' 'lt' :)
                                  37524,                    (: 'namespace' 'mod' :)
                                  38548,                    (: 'namespace' 'ne' :)
                                  40596,                    (: 'namespace' 'or' :)
                                  43924,                    (: 'namespace' 'return' :)
                                  44180,                    (: 'namespace' 'satisfies' :)
                                  47764,                    (: 'namespace' 'to' :)
                                  49300,                    (: 'namespace' 'union' :)
                                  50836,                    (: 'namespace' 'where' :)
                                  20138,                    (: 'processing-instruction' 'and' :)
                                  22442,                    (: 'processing-instruction' 'case' :)
                                  27306,                    (: 'processing-instruction' 'div' :)
                                  28330,                    (: 'processing-instruction' 'else' :)
                                  29610,                    (: 'processing-instruction' 'eq' :)
                                  30122,                    (: 'processing-instruction' 'except' :)
                                  31914,                    (: 'processing-instruction' 'ge' :)
                                  32938,                    (: 'processing-instruction' 'gt' :)
                                  33194,                    (: 'processing-instruction' 'idiv' :)
                                  34986,                    (: 'processing-instruction' 'intersect' :)
                                  35242,                    (: 'processing-instruction' 'is' :)
                                  36010,                    (: 'processing-instruction' 'le' :)
                                  36778,                    (: 'processing-instruction' 'lt' :)
                                  37546,                    (: 'processing-instruction' 'mod' :)
                                  38570,                    (: 'processing-instruction' 'ne' :)
                                  40618,                    (: 'processing-instruction' 'or' :)
                                  43946,                    (: 'processing-instruction' 'return' :)
                                  44202,                    (: 'processing-instruction' 'satisfies' :)
                                  47786,                    (: 'processing-instruction' 'to' :)
                                  49322,                    (: 'processing-instruction' 'union' :)
                                  50858)) then              (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(193, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (93,                           (: 'comment' :)
                              107,                          (: 'document' :)
                              160,                          (: 'ordered' :)
                              184,                          (: 'text' :)
                              193)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(167, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (112,                          (: 'empty-sequence' :)
                              130,                          (: 'if' :)
                              138,                          (: 'item' :)
                              183,                          (: 'switch' :)
                              191)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(158, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (76,                           (: 'ancestor' :)
                              77,                           (: 'ancestor-or-self' :)
                              91,                           (: 'child' :)
                              102,                          (: 'descendant' :)
                              103,                          (: 'descendant-or-self' :)
                              120,                          (: 'following' :)
                              121,                          (: 'following-sibling' :)
                              162,                          (: 'parent' :)
                              166,                          (: 'preceding' :)
                              167,                          (: 'preceding-sibling' :)
                              176)) then                    (: 'self' :)
      let $state := p:lookahead2W(166, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              78,                           (: 'and' :)
                              81,                           (: 'ascending' :)
                              87,                           (: 'case' :)
                              88,                           (: 'cast' :)
                              89,                           (: 'castable' :)
                              92,                           (: 'collation' :)
                              97,                           (: 'count' :)
                              100,                          (: 'declare' :)
                              101,                          (: 'default' :)
                              104,                          (: 'descending' :)
                              106,                          (: 'div' :)
                              108,                          (: 'document-node' :)
                              110,                          (: 'else' :)
                              111,                          (: 'empty' :)
                              114,                          (: 'end' :)
                              115,                          (: 'eq' :)
                              116,                          (: 'every' :)
                              117,                          (: 'except' :)
                              122,                          (: 'for' :)
                              123,                          (: 'function' :)
                              124,                          (: 'ge' :)
                              126,                          (: 'group' :)
                              128,                          (: 'gt' :)
                              129,                          (: 'idiv' :)
                              131,                          (: 'import' :)
                              135,                          (: 'instance' :)
                              136,                          (: 'intersect' :)
                              137,                          (: 'is' :)
                              140,                          (: 'le' :)
                              142,                          (: 'let' :)
                              143,                          (: 'lt' :)
                              146,                          (: 'mod' :)
                              147,                          (: 'module' :)
                              149,                          (: 'namespace-node' :)
                              150,                          (: 'ne' :)
                              154,                          (: 'node' :)
                              156,                          (: 'only' :)
                              158,                          (: 'or' :)
                              159,                          (: 'order' :)
                              171,                          (: 'return' :)
                              172,                          (: 'satisfies' :)
                              174,                          (: 'schema-attribute' :)
                              175,                          (: 'schema-element' :)
                              178,                          (: 'some' :)
                              179,                          (: 'stable' :)
                              180,                          (: 'start' :)
                              186,                          (: 'to' :)
                              187,                          (: 'treat' :)
                              188,                          (: 'try' :)
                              192,                          (: 'union' :)
                              194,                          (: 'validate' :)
                              198,                          (: 'where' :)
                              200)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(161, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4                              (: StringLiteral :)
          or $state[$p:lk] = 31                             (: '$' :)
          or $state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 34                             (: '(' :)
          or $state[$p:lk] = 43                             (: '.' :)
          or $state[$p:lk] = 53                             (: '<' :)
          or $state[$p:lk] = 54                             (: '<!--' :)
          or $state[$p:lk] = 59                             (: '<?' :)
          or $state[$p:lk] = 65                             (: '?' :)
          or $state[$p:lk] = 69                             (: '[' :)
          or $state[$p:lk] = 73                             (: '``[' :)
          or $state[$p:lk] = 1363                           (: 'attribute' URIQualifiedName :)
          or $state[$p:lk] = 1389                           (: 'element' URIQualifiedName :)
          or $state[$p:lk] = 3732                           (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 3754                           (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 3923                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 3949                           (: 'element' QName^Token :)
          or $state[$p:lk] = 7429                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7439                           (: QName^Token '#' :)
          or $state[$p:lk] = 7500                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7501                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7502                           (: 'and' '#' :)
          or $state[$p:lk] = 7503                           (: 'array' '#' :)
          or $state[$p:lk] = 7505                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7507                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7511                           (: 'case' '#' :)
          or $state[$p:lk] = 7512                           (: 'cast' '#' :)
          or $state[$p:lk] = 7513                           (: 'castable' '#' :)
          or $state[$p:lk] = 7515                           (: 'child' '#' :)
          or $state[$p:lk] = 7516                           (: 'collation' '#' :)
          or $state[$p:lk] = 7517                           (: 'comment' '#' :)
          or $state[$p:lk] = 7521                           (: 'count' '#' :)
          or $state[$p:lk] = 7524                           (: 'declare' '#' :)
          or $state[$p:lk] = 7525                           (: 'default' '#' :)
          or $state[$p:lk] = 7526                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7527                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7528                           (: 'descending' '#' :)
          or $state[$p:lk] = 7530                           (: 'div' '#' :)
          or $state[$p:lk] = 7531                           (: 'document' '#' :)
          or $state[$p:lk] = 7532                           (: 'document-node' '#' :)
          or $state[$p:lk] = 7533                           (: 'element' '#' :)
          or $state[$p:lk] = 7534                           (: 'else' '#' :)
          or $state[$p:lk] = 7535                           (: 'empty' '#' :)
          or $state[$p:lk] = 7536                           (: 'empty-sequence' '#' :)
          or $state[$p:lk] = 7538                           (: 'end' '#' :)
          or $state[$p:lk] = 7539                           (: 'eq' '#' :)
          or $state[$p:lk] = 7540                           (: 'every' '#' :)
          or $state[$p:lk] = 7541                           (: 'except' '#' :)
          or $state[$p:lk] = 7544                           (: 'following' '#' :)
          or $state[$p:lk] = 7545                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7546                           (: 'for' '#' :)
          or $state[$p:lk] = 7547                           (: 'function' '#' :)
          or $state[$p:lk] = 7548                           (: 'ge' '#' :)
          or $state[$p:lk] = 7550                           (: 'group' '#' :)
          or $state[$p:lk] = 7552                           (: 'gt' '#' :)
          or $state[$p:lk] = 7553                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7554                           (: 'if' '#' :)
          or $state[$p:lk] = 7555                           (: 'import' '#' :)
          or $state[$p:lk] = 7559                           (: 'instance' '#' :)
          or $state[$p:lk] = 7560                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7561                           (: 'is' '#' :)
          or $state[$p:lk] = 7562                           (: 'item' '#' :)
          or $state[$p:lk] = 7564                           (: 'le' '#' :)
          or $state[$p:lk] = 7566                           (: 'let' '#' :)
          or $state[$p:lk] = 7567                           (: 'lt' '#' :)
          or $state[$p:lk] = 7568                           (: 'map' '#' :)
          or $state[$p:lk] = 7570                           (: 'mod' '#' :)
          or $state[$p:lk] = 7571                           (: 'module' '#' :)
          or $state[$p:lk] = 7572                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7573                           (: 'namespace-node' '#' :)
          or $state[$p:lk] = 7574                           (: 'ne' '#' :)
          or $state[$p:lk] = 7578                           (: 'node' '#' :)
          or $state[$p:lk] = 7580                           (: 'only' '#' :)
          or $state[$p:lk] = 7582                           (: 'or' '#' :)
          or $state[$p:lk] = 7583                           (: 'order' '#' :)
          or $state[$p:lk] = 7584                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7586                           (: 'parent' '#' :)
          or $state[$p:lk] = 7590                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7591                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7594                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7595                           (: 'return' '#' :)
          or $state[$p:lk] = 7596                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7598                           (: 'schema-attribute' '#' :)
          or $state[$p:lk] = 7599                           (: 'schema-element' '#' :)
          or $state[$p:lk] = 7600                           (: 'self' '#' :)
          or $state[$p:lk] = 7602                           (: 'some' '#' :)
          or $state[$p:lk] = 7603                           (: 'stable' '#' :)
          or $state[$p:lk] = 7604                           (: 'start' '#' :)
          or $state[$p:lk] = 7607                           (: 'switch' '#' :)
          or $state[$p:lk] = 7608                           (: 'text' '#' :)
          or $state[$p:lk] = 7610                           (: 'to' '#' :)
          or $state[$p:lk] = 7611                           (: 'treat' '#' :)
          or $state[$p:lk] = 7612                           (: 'try' '#' :)
          or $state[$p:lk] = 7615                           (: 'typeswitch' '#' :)
          or $state[$p:lk] = 7616                           (: 'union' '#' :)
          or $state[$p:lk] = 7617                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7618                           (: 'validate' '#' :)
          or $state[$p:lk] = 7622                           (: 'where' '#' :)
          or $state[$p:lk] = 7624                           (: 'xquery' '#' :)
          or $state[$p:lk] = 8709                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8719                           (: QName^Token '(' :)
          or $state[$p:lk] = 8780                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8781                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8782                           (: 'and' '(' :)
          or $state[$p:lk] = 8785                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8791                           (: 'case' '(' :)
          or $state[$p:lk] = 8792                           (: 'cast' '(' :)
          or $state[$p:lk] = 8793                           (: 'castable' '(' :)
          or $state[$p:lk] = 8795                           (: 'child' '(' :)
          or $state[$p:lk] = 8796                           (: 'collation' '(' :)
          or $state[$p:lk] = 8801                           (: 'count' '(' :)
          or $state[$p:lk] = 8804                           (: 'declare' '(' :)
          or $state[$p:lk] = 8805                           (: 'default' '(' :)
          or $state[$p:lk] = 8806                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8807                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8808                           (: 'descending' '(' :)
          or $state[$p:lk] = 8810                           (: 'div' '(' :)
          or $state[$p:lk] = 8811                           (: 'document' '(' :)
          or $state[$p:lk] = 8814                           (: 'else' '(' :)
          or $state[$p:lk] = 8815                           (: 'empty' '(' :)
          or $state[$p:lk] = 8818                           (: 'end' '(' :)
          or $state[$p:lk] = 8819                           (: 'eq' '(' :)
          or $state[$p:lk] = 8820                           (: 'every' '(' :)
          or $state[$p:lk] = 8821                           (: 'except' '(' :)
          or $state[$p:lk] = 8824                           (: 'following' '(' :)
          or $state[$p:lk] = 8825                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8826                           (: 'for' '(' :)
          or $state[$p:lk] = 8827                           (: 'function' '(' :)
          or $state[$p:lk] = 8828                           (: 'ge' '(' :)
          or $state[$p:lk] = 8830                           (: 'group' '(' :)
          or $state[$p:lk] = 8832                           (: 'gt' '(' :)
          or $state[$p:lk] = 8833                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8835                           (: 'import' '(' :)
          or $state[$p:lk] = 8839                           (: 'instance' '(' :)
          or $state[$p:lk] = 8840                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8841                           (: 'is' '(' :)
          or $state[$p:lk] = 8844                           (: 'le' '(' :)
          or $state[$p:lk] = 8846                           (: 'let' '(' :)
          or $state[$p:lk] = 8847                           (: 'lt' '(' :)
          or $state[$p:lk] = 8850                           (: 'mod' '(' :)
          or $state[$p:lk] = 8851                           (: 'module' '(' :)
          or $state[$p:lk] = 8852                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8854                           (: 'ne' '(' :)
          or $state[$p:lk] = 8860                           (: 'only' '(' :)
          or $state[$p:lk] = 8862                           (: 'or' '(' :)
          or $state[$p:lk] = 8863                           (: 'order' '(' :)
          or $state[$p:lk] = 8864                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8866                           (: 'parent' '(' :)
          or $state[$p:lk] = 8870                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8871                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8875                           (: 'return' '(' :)
          or $state[$p:lk] = 8876                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8880                           (: 'self' '(' :)
          or $state[$p:lk] = 8882                           (: 'some' '(' :)
          or $state[$p:lk] = 8883                           (: 'stable' '(' :)
          or $state[$p:lk] = 8884                           (: 'start' '(' :)
          or $state[$p:lk] = 8890                           (: 'to' '(' :)
          or $state[$p:lk] = 8891                           (: 'treat' '(' :)
          or $state[$p:lk] = 8892                           (: 'try' '(' :)
          or $state[$p:lk] = 8896                           (: 'union' '(' :)
          or $state[$p:lk] = 8897                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8898                           (: 'validate' '(' :)
          or $state[$p:lk] = 8902                           (: 'where' '(' :)
          or $state[$p:lk] = 8904                           (: 'xquery' '(' :)
          or $state[$p:lk] = 19539                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 19565                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 19795                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 19821                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 20307                          (: 'attribute' 'array' :)
          or $state[$p:lk] = 20333                          (: 'element' 'array' :)
          or $state[$p:lk] = 21331                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 21357                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 23379                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 23405                          (: 'element' 'child' :)
          or $state[$p:lk] = 23891                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 23917                          (: 'element' 'comment' :)
          or $state[$p:lk] = 25683                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 25709                          (: 'element' 'declare' :)
          or $state[$p:lk] = 26195                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 26221                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 26451                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 26477                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 27475                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 27501                          (: 'element' 'document' :)
          or $state[$p:lk] = 27731                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 27757                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 27987                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 28013                          (: 'element' 'element' :)
          or $state[$p:lk] = 28755                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 28781                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 29779                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 29805                          (: 'element' 'every' :)
          or $state[$p:lk] = 30803                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 30829                          (: 'element' 'following' :)
          or $state[$p:lk] = 31059                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 31085                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 31571                          (: 'attribute' 'function' :)
          or $state[$p:lk] = 31597                          (: 'element' 'function' :)
          or $state[$p:lk] = 33363                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 33389                          (: 'element' 'if' :)
          or $state[$p:lk] = 33619                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 33645                          (: 'element' 'import' :)
          or $state[$p:lk] = 35411                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 35437                          (: 'element' 'item' :)
          or $state[$p:lk] = 36947                          (: 'attribute' 'map' :)
          or $state[$p:lk] = 36973                          (: 'element' 'map' :)
          or $state[$p:lk] = 37715                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 37741                          (: 'element' 'module' :)
          or $state[$p:lk] = 37971                          (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 37997                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 38227                          (: 'attribute' 'namespace-node' :)
          or $state[$p:lk] = 38253                          (: 'element' 'namespace-node' :)
          or $state[$p:lk] = 39507                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 39533                          (: 'element' 'node' :)
          or $state[$p:lk] = 41043                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 41069                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 41555                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 41581                          (: 'element' 'parent' :)
          or $state[$p:lk] = 42579                          (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 42605                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 42835                          (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 42861                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 43603                          (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 43629                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 44627                          (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 44653                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 44883                          (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 44909                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 45139                          (: 'attribute' 'self' :)
          or $state[$p:lk] = 45165                          (: 'element' 'self' :)
          or $state[$p:lk] = 45651                          (: 'attribute' 'some' :)
          or $state[$p:lk] = 45677                          (: 'element' 'some' :)
          or $state[$p:lk] = 46931                          (: 'attribute' 'switch' :)
          or $state[$p:lk] = 46957                          (: 'element' 'switch' :)
          or $state[$p:lk] = 47187                          (: 'attribute' 'text' :)
          or $state[$p:lk] = 47213                          (: 'element' 'text' :)
          or $state[$p:lk] = 48211                          (: 'attribute' 'try' :)
          or $state[$p:lk] = 48237                          (: 'element' 'try' :)
          or $state[$p:lk] = 48979                          (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 49005                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 49491                          (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 49517                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 49747                          (: 'attribute' 'validate' :)
          or $state[$p:lk] = 49773                          (: 'element' 'validate' :)
          or $state[$p:lk] = 51283                          (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 51309                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 51791                          (: 'array' '{' :)
          or $state[$p:lk] = 51795                          (: 'attribute' '{' :)
          or $state[$p:lk] = 51805                          (: 'comment' '{' :)
          or $state[$p:lk] = 51819                          (: 'document' '{' :)
          or $state[$p:lk] = 51821                          (: 'element' '{' :)
          or $state[$p:lk] = 51856                          (: 'map' '{' :)
          or $state[$p:lk] = 51860                          (: 'namespace' '{' :)
          or $state[$p:lk] = 51872                          (: 'ordered' '{' :)
          or $state[$p:lk] = 51882                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 51896                          (: 'text' '{' :)
          or $state[$p:lk] = 51905                          (: 'unordered' '{' :)
          or $state[$p:lk] = 13258323                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 13258349                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 13258388                       (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 13258410                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 13259091                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 13259117                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 13259156                       (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 13259178                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 13260627                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 13260653                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 13260692                       (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 13260714                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 13260883                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 13260909                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 13260948                       (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 13260970                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 13261139                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 13261165                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 13261204                       (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 13261226                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 13261907                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 13261933                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 13261972                       (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 13261994                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 13263187                       (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 13263213                       (: 'element' 'count' '{' :)
          or $state[$p:lk] = 13263252                       (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 13263274                       (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 13264211                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 13264237                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 13264276                       (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 13264298                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 13264979                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 13265005                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 13265044                       (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 13265066                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 13265491                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 13265517                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 13265556                       (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 13265578                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 13266515                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 13266541                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 13266580                       (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 13266602                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 13266771                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 13266797                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 13266836                       (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 13266858                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 13267539                       (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 13267565                       (: 'element' 'end' '{' :)
          or $state[$p:lk] = 13267604                       (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 13267626                       (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 13267795                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 13267821                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 13267860                       (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 13267882                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 13268307                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 13268333                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 13268372                       (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 13268394                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 13269587                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 13269613                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 13269652                       (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 13269674                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 13270099                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 13270125                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 13270164                       (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 13270186                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 13270611                       (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 13270637                       (: 'element' 'group' '{' :)
          or $state[$p:lk] = 13270676                       (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 13270698                       (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 13271123                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 13271149                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 13271188                       (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 13271210                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 13271379                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 13271405                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 13271444                       (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 13271466                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 13272915                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 13272941                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 13272980                       (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 13273002                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 13273171                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 13273197                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 13273236                       (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 13273258                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 13273427                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 13273453                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 13273492                       (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 13273514                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 13274195                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 13274221                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 13274260                       (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 13274282                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 13274707                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 13274733                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 13274772                       (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 13274794                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 13274963                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 13274989                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 13275028                       (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 13275050                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 13275731                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 13275757                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 13275796                       (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 13275818                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 13276755                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 13276781                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 13276820                       (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 13276842                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 13278291                       (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 13278317                       (: 'element' 'only' '{' :)
          or $state[$p:lk] = 13278356                       (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 13278378                       (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 13278803                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 13278829                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 13278868                       (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 13278890                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 13279059                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 13279085                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 13279124                       (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 13279146                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 13282131                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 13282157                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 13282196                       (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 13282218                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 13282387                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 13282413                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 13282452                       (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 13282474                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 13284179                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 13284205                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 13284244                       (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 13284266                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 13284435                       (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 13284461                       (: 'element' 'start' '{' :)
          or $state[$p:lk] = 13284500                       (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 13284522                       (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 13285971                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 13285997                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 13286036                       (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 13286058                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 13286227                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 13286253                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 13286292                       (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 13286314                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 13287507                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 13287533                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 13287572                       (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 13287594                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 13289043                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 13289069                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 13289108                       (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 13289130) then                 (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 45                                 (: '/' :)
    and $state[$p:l1] != 46) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 45) then                   (: '/' :)
          let $state := p:consume(45, $input, $state)       (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(46, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 45) then                       (: '/' :)
      let $state := p:consume(45, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(198, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ':' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' | ']' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 25                         (: EOF :)
              or $state[$p:l1] = 26                         (: '!' :)
              or $state[$p:l1] = 27                         (: '!=' :)
              or $state[$p:l1] = 37                         (: ')' :)
              or $state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 40                         (: ',' :)
              or $state[$p:l1] = 41                         (: '-' :)
              or $state[$p:l1] = 48                         (: ':' :)
              or $state[$p:l1] = 52                         (: ';' :)
              or $state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 58                         (: '<=' :)
              or $state[$p:l1] = 60                         (: '=' :)
              or $state[$p:l1] = 61                         (: '=>' :)
              or $state[$p:l1] = 62                         (: '>' :)
              or $state[$p:l1] = 63                         (: '>=' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 70                         (: ']' :)
              or $state[$p:l1] = 204                        (: '|' :)
              or $state[$p:l1] = 205                        (: '||' :)
              or $state[$p:l1] = 206                        (: '}' :)
              or $state[$p:l1] = 207) then                  (: '}`' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 46) then                       (: '//' :)
      let $state := p:consume(46, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | '``[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 26) then                           (: '!' :)
      $state
    else
      let $state := p:consume(26, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(188, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               '``[' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleMapExpr", $count, $begin, $end)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(35, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(173, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(12, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S :)
      let $state := p:consume(17, $input, $state)           (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:consume(20, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(6, $input, $state)             (: '#)' :)
  let $state := p:consume(30, $input, $state)               (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(70, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 139) then                      (: 'lax' :)
      let $state := p:consume(139, $input, $state)          (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(181, $input, $state)          (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(194, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 190) then                  (: 'type' :)
          let $state := p:consume(190, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(174, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 194) then                          (: 'validate' :)
      let $state := p:lookahead2W(170, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'lax' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'strict' |
                                                               'to' | 'treat' | 'type' | 'union' | 'where' | '{' | '|' |
                                                               '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 35778                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 46530                          (: 'validate' 'strict' :)
          or $state[$p:lk] = 48834                          (: 'validate' 'type' :)
          or $state[$p:lk] = 51906) then                    (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-SimpleMapExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 41) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 41) then                 (: '-' :)
            let $state := p:consume(41, $input, $state)     (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(39, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ArrowExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrowExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(154, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                               '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 61) then                         (: '=>' :)
        $state
      else
        let $state := p:consume(61, $input, $state)         (: '=>' :)
        let $state := p:lookahead1W(180, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '$' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-ArrowFunctionSpecifier($input, $state)
        let $state := p:lookahead1W(24, $input, $state)     (: S^WS | '(' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-ArgumentList($input, $state)
        return p:parse-ArrowExpr-1($input, $state)
};

(:~
 : Parse ArrowExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrowExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:parse-ArrowExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrowExpr", $count, $begin, $end)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ArrowExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:consume(88, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:consume(89, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | '|' |
                                                               '||' | '}' | '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 187) then                      (: 'treat' :)
      let $state := p:consume(187, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(181, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(150, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'union' | 'where' | '|' | '||' | '}' |
                                                               '}`' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 135) then                      (: 'instance' :)
      let $state := p:consume(135, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(155, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(181, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(149, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 117                              (: 'except' :)
      and $state[$p:l1] != 136) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 136) then                (: 'intersect' :)
            let $state := p:consume(136, $input, $state)    (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(117, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(189, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 192                                (: 'union' :)
    and $state[$p:l1] != 204) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 192) then                  (: 'union' :)
          let $state := p:consume(192, $input, $state)      (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(204, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '*' :)
    and $state[$p:l1] != 106                                (: 'div' :)
    and $state[$p:l1] != 129                                (: 'idiv' :)
    and $state[$p:l1] != 146) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '*' :)
          let $state := p:consume(38, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 106) then                  (: 'div' :)
          let $state := p:consume(106, $input, $state)      (: 'div' :)
          return $state
        else if ($state[$p:l1] = 129) then                  (: 'idiv' :)
          let $state := p:consume(129, $input, $state)      (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(146, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39                                 (: '+' :)
    and $state[$p:l1] != 41) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: '+' :)
          let $state := p:consume(39, $input, $state)       (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(41, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 186) then                      (: 'to' :)
      let $state := p:consume(186, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 205) then                          (: '||' :)
      $state
    else
      let $state := p:consume(205, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConcatExpr", $count, $begin, $end)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 62                             (: '>' :)
          or $state[$p:l1] = 63                             (: '>=' :)
          or $state[$p:l1] = 64                             (: '>>' :)
          or $state[$p:l1] = 115                            (: 'eq' :)
          or $state[$p:l1] = 124                            (: 'ge' :)
          or $state[$p:l1] = 128                            (: 'gt' :)
          or $state[$p:l1] = 137                            (: 'is' :)
          or $state[$p:l1] = 140                            (: 'le' :)
          or $state[$p:l1] = 143                            (: 'lt' :)
          or $state[$p:l1] = 150) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 115                        (: 'eq' :)
              or $state[$p:l1] = 124                        (: 'ge' :)
              or $state[$p:l1] = 128                        (: 'gt' :)
              or $state[$p:l1] = 140                        (: 'le' :)
              or $state[$p:l1] = 143                        (: 'lt' :)
              or $state[$p:l1] = 150) then                  (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 64                         (: '>>' :)
              or $state[$p:l1] = 137) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 78) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(78, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 158) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(158, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 21) then                       (: Wildcard :)
      let $state := p:consume(21, $input, $state)           (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(99, $input, $state)         (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 204) then                        (: '|' :)
        $state
      else
        let $state := p:consume(204, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(176, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorList", $count, $begin, $end)
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(90, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(176, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-CatchErrorList($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchClause", $count, $begin, $end)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(202, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(194, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 206) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(206, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Parse EnclosedTryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedTryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedTryTargetExpr", $count, $begin, $end)
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(188, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EnclosedTryTargetExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(37, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(136, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ':' | ';' | ']' |
                                                               'ascending' | 'case' | 'catch' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | '}' | '}`' :)
    return
      if ($state[$p:l1] != 90) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryCatchExpr", $count, $begin, $end)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(130, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(185, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:consume(110, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 204) then                        (: '|' :)
        $state
      else
        let $state := p:consume(204, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(181, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceTypeUnion", $count, $begin, $end)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(87, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(183, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:consume(171, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(191, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(101, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(171, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseOperand", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(87, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(189, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:consume(171, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40) then                           (: ',' :)
      $state
    else
      let $state := p:consume(40, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(36, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 87) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(183, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:consume(101, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(171, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40) then                           (: ',' :)
      $state
    else
      let $state := p:consume(40, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(132, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'some' :)
      let $state := p:consume(178, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(116, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(132, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(172, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(171, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnClause", $count, $begin, $end)
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(97, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CountClause", $count, $begin, $end)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81                             (: 'ascending' :)
          or $state[$p:l1] = 104) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 81) then                   (: 'ascending' :)
          let $state := p:consume(81, $input, $state)       (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(104, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111) then                      (: 'empty' :)
      let $state := p:consume(111, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(88, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 125) then                  (: 'greatest' :)
          let $state := p:consume(125, $input, $state)      (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(141, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:consume(92, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(189, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'order' :)
      let $state := p:consume(159, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(86, $input, $state)           (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(179, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(159, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(86, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Parse GroupingVariable.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingVariable", $count, $begin, $end)
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-GroupingVariable($input, $state)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51                             (: ':=' :)
          or $state[$p:l1] = 80) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 80) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:consume(92, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(23, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpecList", $count, $begin, $end)
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(126, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(86, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-GroupingSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupByClause", $count, $begin, $end)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(198, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 122                            (: 'for' :)
          or $state[$p:l1] = 142) then                      (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 198) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IntermediateClause", $count, $begin, $end)
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(177, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(199, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(132, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowEndCondition($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SlidingWindowClause", $count, $begin, $end)
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 156) then                      (: 'only' :)
      let $state := p:consume(156, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(114, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(197, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowEndCondition", $count, $begin, $end)
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NextItem", $count, $begin, $end)
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreviousItem", $count, $begin, $end)
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurrentItem", $count, $begin, $end)
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 169) then                      (: 'previous' :)
      let $state := p:consume(169, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 151) then                      (: 'next' :)
      let $state := p:consume(151, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(31, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowVars", $count, $begin, $end)
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(180, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(197, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowStartCondition", $count, $begin, $end)
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(189, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(199, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(132, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 114                            (: 'end' :)
          or $state[$p:l1] = 156) then                      (: 'only' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TumblingWindowClause", $count, $begin, $end)
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(122, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 189) then                      (: 'tumbling' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowClause", $count, $begin, $end)
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(51, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40) then                           (: ',' :)
      $state
    else
      let $state := p:consume(40, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LetBinding($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(142, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(82, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(75, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(111, $input, $state)              (: 'empty' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AllowingEmpty", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(80, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'allowing' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(132, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 40) then                           (: ',' :)
      $state
    else
      let $state := p:consume(40, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ForBinding($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(122, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 122) then                          (: 'for' :)
      let $state := p:lookahead2W(104, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8058) then                     (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 142) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 171) then                         (: 'return' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 122) then                          (: 'for' :)
      let $state := p:lookahead2W(169, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'sliding' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'tumbling' | 'union' | 'where' | '|' | '||' |
                                                               '}' | '}`' :)
      return $state
    else if ($state[$p:l1] eq 188) then                     (: 'try' :)
      let $state := p:lookahead2W(167, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '{' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (116,                          (: 'every' :)
                              142,                          (: 'let' :)
                              178)) then                    (: 'some' :)
      let $state := p:lookahead2W(165, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
      return $state
    else if ($state[$p:l1] = (130,                          (: 'if' :)
                              183,                          (: 'switch' :)
                              191)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(161, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8058                           (: 'for' '$' :)
          or $state[$p:lk] = 8078                           (: 'let' '$' :)
          or $state[$p:lk] = 45434                          (: 'for' 'sliding' :)
          or $state[$p:lk] = 48506) then                    (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8052                           (: 'every' '$' :)
          or $state[$p:lk] = 8114) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8887) then                     (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8895) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8834) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51900) then                    (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarValue", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedItemType", $count, $begin, $end)
};

(:~
 : Parse TypedArrayTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedArrayTest", $count, $begin, $end)
};

(:~
 : Parse AnyArrayTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyArrayTest", $count, $begin, $end)
};

(:~
 : Parse ArrayTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 79) then                           (: 'array' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8783) then                     (: 'array' '(' :)
          let $state := p:lookahead3W(185, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | '*' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2499151) then                  (: 'array' '(' '*' :)
      let $state := p:parse-AnyArrayTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedArrayTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayTest", $count, $begin, $end)
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicOrUnionType", $count, $begin, $end)
};

(:~
 : Parse TypedMapTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedMapTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(144, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedMapTest", $count, $begin, $end)
};

(:~
 : Parse AnyMapTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyMapTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(144, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyMapTest", $count, $begin, $end)
};

(:~
 : Parse MapTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 144) then                          (: 'map' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8848) then                     (: 'map' '(' :)
          let $state := p:lookahead3W(177, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | '*' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2499216) then                  (: 'map' '(' '*' :)
      let $state := p:parse-AnyMapTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedMapTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "MapTest", $count, $begin, $end)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '?' :)
      let $state := p:consume(65, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(39, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 112) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(157, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8816) then                     (: 'empty-sequence' '(' :)
      let $state := p:consume(112, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(155, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 39                         (: '+' :)
              or $state[$p:l1] = 65) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(181, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(123, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(184, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(80, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedFunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(123, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(38, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyFunctionTest", $count, $begin, $end)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(114, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(32, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 34) then                       (: '(' :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(114, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Literal($input, $state)
      let $state := p:parse-Annotation-1($input, $state)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Annotation", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 32) then                         (: '%' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 123) then                          (: 'function' :)
      let $state := p:lookahead2W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8827) then                     (: 'function' '(' :)
          let $state := p:lookahead3W(186, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2499195) then                  (: 'function' '(' '*' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(154, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(149, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceNodeTest", $count, $begin, $end)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(184, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(93, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(170, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(139, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(174, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(83, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(182, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(174, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(175, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:consume(38, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(109, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(182, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 40) then                   (: ',' :)
          let $state := p:consume(40, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(174, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(72, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 65) then               (: '?' :)
              let $state := p:consume(65, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(108, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(34, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 109) then                  (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(37, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 108) then                      (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (79,                                (: 'array' :)
                         83,                                (: 'attribute' :)
                         93,                                (: 'comment' :)
                         108,                               (: 'document-node' :)
                         109,                               (: 'element' :)
                         123,                               (: 'function' :)
                         138,                               (: 'item' :)
                         144,                               (: 'map' :)
                         149,                               (: 'namespace-node' :)
                         154,                               (: 'node' :)
                         170,                               (: 'processing-instruction' :)
                         174,                               (: 'schema-attribute' :)
                         175,                               (: 'schema-element' :)
                         184)) then                         (: 'text' :)
      let $state := p:lookahead2W(157, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' | '}`' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8787                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8797                           (: 'comment' '(' :)
          or $state[$p:lk] = 8812                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8813                           (: 'element' '(' :)
          or $state[$p:lk] = 8853                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 8858                           (: 'node' '(' :)
          or $state[$p:lk] = 8874                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8878                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8879                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8888) then                     (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8842) then                     (: 'item' '(' :)
      let $state := p:consume(138, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(24, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(34, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(25, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(37, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 8827) then                     (: 'function' '(' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8848) then                     (: 'map' '(' :)
      let $state := p:parse-MapTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8783) then                     (: 'array' '(' :)
      let $state := p:parse-ArrayTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(95, $input, $state)               (: 'context' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(138, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'as' :)
      let $state := p:consume(80, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(181, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:consume(51, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(189, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(119, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(74, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:consume(51, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(189, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(73, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(131, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(147, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(62, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:consume(148, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(137, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'at' :)
      let $state := p:consume(82, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:consume(148, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(137, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(60, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(101, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(109, $input, $state)          (: 'element' :)
      let $state := p:lookahead1W(50, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(148, $input, $state)          (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(73, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 40) then                         (: ',' :)
        $state
      else
        let $state := p:consume(40, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(131, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(173, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(100, $input, $state)          (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 4) then                       (: StringLiteral :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'at' :)
      let $state := p:consume(82, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 131) then                          (: 'import' :)
      let $state := p:lookahead2W(90, $input, $state)       (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 44419) then                    (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ModuleImport($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(148, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(137, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(60, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 99) then                       (: 'decimal-separator' :)
      let $state := p:consume(99, $input, $state)           (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'grouping-separator' :)
      let $state := p:consume(127, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'infinity' :)
      let $state := p:consume(133, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'minus-sign' :)
      let $state := p:consume(145, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'NaN' :)
      let $state := p:consume(68, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'percent' :)
      let $state := p:consume(165, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'per-mille' :)
      let $state := p:consume(164, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: 'zero-digit' :)
      let $state := p:consume(201, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'digit' :)
      let $state := p:consume(105, $input, $state)          (: 'digit' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'pattern-separator' :)
      let $state := p:consume(163, $input, $state)          (: 'pattern-separator' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(118, $input, $state)          (: 'exponent-separator' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DFPropertyName", $count, $begin, $end)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QName^Token :)
      let $state := p:consume(15, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'ancestor' :)
      let $state := p:consume(76, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(77, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'and' :)
      let $state := p:consume(78, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'ascending' :)
      let $state := p:consume(81, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:consume(87, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:consume(88, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:consume(89, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'child' :)
      let $state := p:consume(91, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:consume(92, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'count' :)
      let $state := p:consume(97, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'declare' :)
      let $state := p:consume(100, $input, $state)          (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'default' :)
      let $state := p:consume(101, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'descendant' :)
      let $state := p:consume(102, $input, $state)          (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'descendant-or-self' :)
      let $state := p:consume(103, $input, $state)          (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'descending' :)
      let $state := p:consume(104, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'div' :)
      let $state := p:consume(106, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'document' :)
      let $state := p:consume(107, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'else' :)
      let $state := p:consume(110, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'empty' :)
      let $state := p:consume(111, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'end' :)
      let $state := p:consume(114, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'eq' :)
      let $state := p:consume(115, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'every' :)
      let $state := p:consume(116, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'except' :)
      let $state := p:consume(117, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'following' :)
      let $state := p:consume(120, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'following-sibling' :)
      let $state := p:consume(121, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'for' :)
      let $state := p:consume(122, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'ge' :)
      let $state := p:consume(124, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'group' :)
      let $state := p:consume(126, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'gt' :)
      let $state := p:consume(128, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'idiv' :)
      let $state := p:consume(129, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'import' :)
      let $state := p:consume(131, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'instance' :)
      let $state := p:consume(135, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'intersect' :)
      let $state := p:consume(136, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'is' :)
      let $state := p:consume(137, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'le' :)
      let $state := p:consume(140, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'let' :)
      let $state := p:consume(142, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'lt' :)
      let $state := p:consume(143, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'mod' :)
      let $state := p:consume(146, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'module' :)
      let $state := p:consume(147, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'namespace' :)
      let $state := p:consume(148, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ne' :)
      let $state := p:consume(150, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'only' :)
      let $state := p:consume(156, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'or' :)
      let $state := p:consume(158, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'order' :)
      let $state := p:consume(159, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'ordered' :)
      let $state := p:consume(160, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'parent' :)
      let $state := p:consume(162, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'preceding' :)
      let $state := p:consume(166, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'preceding-sibling' :)
      let $state := p:consume(167, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'return' :)
      let $state := p:consume(171, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'satisfies' :)
      let $state := p:consume(172, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'self' :)
      let $state := p:consume(176, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 178) then                      (: 'some' :)
      let $state := p:consume(178, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'stable' :)
      let $state := p:consume(179, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'start' :)
      let $state := p:consume(180, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'to' :)
      let $state := p:consume(186, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'treat' :)
      let $state := p:consume(187, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'try' :)
      let $state := p:consume(188, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'union' :)
      let $state := p:consume(192, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 193) then                      (: 'unordered' :)
      let $state := p:consume(193, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'validate' :)
      let $state := p:consume(194, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 198) then                      (: 'where' :)
      let $state := p:consume(198, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(200, $input, $state)          (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(171, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79) then                       (: 'array' :)
      let $state := p:consume(79, $input, $state)           (: 'array' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'attribute' :)
      let $state := p:consume(83, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'comment' :)
      let $state := p:consume(93, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'document-node' :)
      let $state := p:consume(108, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'element' :)
      let $state := p:consume(109, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'empty-sequence' :)
      let $state := p:consume(112, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'function' :)
      let $state := p:consume(123, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'if' :)
      let $state := p:consume(130, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'item' :)
      let $state := p:consume(138, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'map' :)
      let $state := p:consume(144, $input, $state)          (: 'map' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'namespace-node' :)
      let $state := p:consume(149, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'node' :)
      let $state := p:consume(154, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'processing-instruction' :)
      let $state := p:consume(170, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'schema-attribute' :)
      let $state := p:consume(174, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'schema-element' :)
      let $state := p:consume(175, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'switch' :)
      let $state := p:consume(183, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'text' :)
      let $state := p:consume(184, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'typeswitch' :)
      let $state := p:consume(191, $input, $state)          (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(172, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EQName", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(135, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'exponent-separator' | 'grouping-separator' |
                                                               'infinity' | 'minus-sign' | 'pattern-separator' |
                                                               'per-mille' | 'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(60, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(19, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'decimal-format' :)
      let $state := p:consume(98, $input, $state)           (: 'decimal-format' :)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(101, $input, $state)          (: 'default' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(98, $input, $state)           (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DecimalFormatDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 134) then                      (: 'inherit' :)
      let $state := p:consume(134, $input, $state)          (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(152, $input, $state)          (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 168) then                      (: 'preserve' :)
      let $state := p:consume(168, $input, $state)          (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(153, $input, $state)          (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(96, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(40, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(101, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(159, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(111, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 125) then                      (: 'greatest' :)
      let $state := p:consume(125, $input, $state)          (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(141, $input, $state)          (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(161, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'ordered' :)
      let $state := p:consume(160, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(193, $input, $state)          (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(94, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 182) then                      (: 'strip' :)
      let $state := p:consume(182, $input, $state)          (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(168, $input, $state)          (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(84, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(101, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(92, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(85, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 168) then                      (: 'preserve' :)
      let $state := p:consume(168, $input, $state)          (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(182, $input, $state)          (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 100) then                          (: 'declare' :)
      let $state := p:lookahead2W(126, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' :)
      let $state :=
        if ($state[$p:lk] eq 25956) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(111, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 21860) then                    (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 6055268) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 21604) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 24164) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 41316) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10446180) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 24676) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(100, $input, $state)              (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(101, $input, $state)              (: 'default' :)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 109) then                      (: 'element' :)
      let $state := p:consume(109, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(123, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(148, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 100) then                        (: 'declare' :)
        let $state := p:lookahead2W(148, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'context' | 'copy-namespaces' |
                                                               'decimal-format' | 'default' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'option' | 'or' | 'ordering' | 'to' | 'treat' |
                                                               'union' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] eq 131) then                   (: 'import' :)
        let $state := p:lookahead2W(145, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'or' | 'schema' | 'to' |
                                                               'treat' | 'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 21604                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 21860                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 24164                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 24676                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 25188                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 25956                            (: 'declare' 'default' :)
      and $state[$p:lk] != 37763                            (: 'import' 'module' :)
      and $state[$p:lk] != 37988                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 41316                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 44419) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 100) then                    (: 'declare' :)
            let $state := p:lookahead2W(127, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] eq 25956) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(122, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 7169380                  (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 8086884) then            (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 37988) then              (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 131) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 100) then                        (: 'declare' :)
        let $state := p:lookahead2W(147, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'context' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                               'option' | 'or' | 'to' | 'treat' | 'union' | 'variable' |
                                                               '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 8292                             (: 'declare' '%' :)
      and $state[$p:lk] != 24420                            (: 'declare' 'context' :)
      and $state[$p:lk] != 31588                            (: 'declare' 'function' :)
      and $state[$p:lk] != 40292                            (: 'declare' 'option' :)
      and $state[$p:lk] != 50020) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 100) then                    (: 'declare' :)
            let $state := p:lookahead2W(121, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 24420) then              (: 'declare' 'context' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 40292) then              (: 'declare' 'option' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "URILiteral", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: NCName^Token :)
      let $state := p:consume(14, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'and' :)
      let $state := p:consume(78, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'ascending' :)
      let $state := p:consume(81, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'case' :)
      let $state := p:consume(87, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'cast' :)
      let $state := p:consume(88, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'castable' :)
      let $state := p:consume(89, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'collation' :)
      let $state := p:consume(92, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'count' :)
      let $state := p:consume(97, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'default' :)
      let $state := p:consume(101, $input, $state)          (: 'default' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'descending' :)
      let $state := p:consume(104, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'div' :)
      let $state := p:consume(106, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'else' :)
      let $state := p:consume(110, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'empty' :)
      let $state := p:consume(111, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'end' :)
      let $state := p:consume(114, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'eq' :)
      let $state := p:consume(115, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'except' :)
      let $state := p:consume(117, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'for' :)
      let $state := p:consume(122, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'ge' :)
      let $state := p:consume(124, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'group' :)
      let $state := p:consume(126, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'gt' :)
      let $state := p:consume(128, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'idiv' :)
      let $state := p:consume(129, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'instance' :)
      let $state := p:consume(135, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'intersect' :)
      let $state := p:consume(136, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'is' :)
      let $state := p:consume(137, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'le' :)
      let $state := p:consume(140, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'let' :)
      let $state := p:consume(142, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'lt' :)
      let $state := p:consume(143, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'mod' :)
      let $state := p:consume(146, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'ne' :)
      let $state := p:consume(150, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'only' :)
      let $state := p:consume(156, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'or' :)
      let $state := p:consume(158, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'order' :)
      let $state := p:consume(159, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'return' :)
      let $state := p:consume(171, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'satisfies' :)
      let $state := p:consume(172, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'stable' :)
      let $state := p:consume(179, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'start' :)
      let $state := p:consume(180, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'to' :)
      let $state := p:consume(186, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'treat' :)
      let $state := p:consume(187, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'union' :)
      let $state := p:consume(192, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(198, $input, $state)          (: 'where' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(147, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(148, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(137, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(60, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(52, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(200, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 113) then                      (: 'encoding' :)
      let $state := p:consume(113, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(196, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(19, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:lookahead1W(78, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 113) then                  (: 'encoding' :)
          let $state := p:consume(113, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(19, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 200) then                          (: 'xquery' :)
      let $state := p:lookahead2W(144, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'encoding' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'to' | 'treat' |
                                                               'union' | 'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 29128                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 50376) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 147) then                          (: 'module' :)
      let $state := p:lookahead2W(143, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '=>' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'namespace' | 'ne' | 'or' | 'to' | 'treat' |
                                                               'union' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 38035) then                    (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MainModule($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | '``[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Module($input, $state)
  let $state := p:consume(25, $input, $state)               (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 18) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
