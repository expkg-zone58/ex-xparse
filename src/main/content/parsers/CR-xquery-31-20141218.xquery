xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun Mar 27, 2016 23:15 (UTC+01) by REx v5.37 which is Copyright (c) 1979-2016 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: CR-xquery-31-20141218.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the CR-xquery-31-20141218 grammar.
 :)
module namespace p="CR-xquery-31-20141218";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk as xs:integer := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been consumed.
 :)
declare variable $p:b0 as xs:integer := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been consumed.
 :)
declare variable $p:e0 as xs:integer := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 as xs:integer := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 as xs:integer := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 as xs:integer := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 as xs:integer := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 as xs:integer := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 as xs:integer := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 as xs:integer := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 as xs:integer := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 as xs:integer := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error as xs:integer := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result as xs:integer := 14;

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 38, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 38,
  38
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 355, 371,
  387, 423, 423, 423, 415, 339, 331, 339, 331, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 440, 440, 440, 440, 440, 440, 440, 324, 339, 339, 339, 339, 339, 339, 339, 339, 401, 423, 423, 424, 422,
  423, 423, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423, 423,
  423, 423, 423, 423, 423, 423, 338, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 423, 68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 38, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
  30, 30, 30, 30, 34, 30, 30, 35, 30, 30, 30, 36, 30, 30, 37, 38, 39, 38, 30, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48,
  30, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  38, 38, 38, 30, 30, 38, 38, 38, 38, 38, 38, 38, 67, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
  67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 38, 30, 38, 30, 30, 38
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 45059, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 10824, 8890, 8894, 8832, 8894, 8894, 8894, 8860, 8894,
  8894, 8876, 8894, 8844, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848,
  25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541,
  27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368,
  9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643,
  9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967,
  9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248,
  10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541, 27541, 27541, 19127,
  19007, 10335, 10350, 27541, 10375, 8910, 27541, 20591, 27541, 27540, 10401, 9705, 8991, 27541, 27541, 8930, 13544,
  9605, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126,
  15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337,
  23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627,
  9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879,
  9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206,
  10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10460, 10420, 27541, 12012, 27541,
  27541, 8961, 10439, 8954, 27541, 27541, 22046, 10455, 10476, 27541, 20591, 27541, 10496, 27541, 9705, 8991, 27541,
  27541, 8930, 13544, 10869, 10518, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152,
  9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133,
  9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541,
  9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848,
  9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930,
  10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10552, 16701, 27541,
  11856, 27541, 27541, 16701, 19127, 23802, 10580, 10628, 16704, 10594, 8910, 27541, 13154, 27541, 10653, 27541, 9705,
  8991, 27541, 27541, 8930, 13544, 10869, 17272, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096,
  9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9592, 9229, 9248,
  9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039,
  9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820,
  21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930,
  9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380,
  12400, 27541, 10385, 10729, 27541, 12941, 10676, 27541, 27541, 10692, 10716, 10748, 8910, 27541, 20591, 27541, 27540,
  27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045,
  9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162,
  9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492,
  22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792,
  9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133,
  8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541,
  10380, 27541, 27541, 10385, 11938, 27541, 11934, 10769, 27541, 10785, 27541, 10804, 10819, 8910, 27541, 20591, 27541,
  27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010,
  9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931,
  9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277,
  9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771,
  9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087,
  10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541,
  27541, 10380, 27541, 27541, 10385, 27541, 27541, 27541, 11460, 27541, 27541, 27541, 27541, 13058, 10840, 27541, 20591,
  27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713,
  8980, 9010, 9045, 9073, 9096, 9119, 10864, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210,
  9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264,
  9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610,
  9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039,
  10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541,
  27541, 27541, 27541, 10753, 10885, 27541, 13920, 27541, 27541, 9522, 9755, 9515, 27541, 27541, 10660, 10904, 10930,
  27541, 20591, 27541, 10950, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 10144, 25147, 8947, 26098, 27541,
  13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376,
  9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472,
  10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693,
  9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025,
  10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541,
  27541, 27541, 27541, 27541, 27541, 10380, 10976, 10993, 10998, 10988, 10993, 11014, 11035, 11019, 11051, 11064, 11080,
  11095, 8910, 27541, 11121, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 11143,
  26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178,
  18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260,
  9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207,
  26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977,
  9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292,
  10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 12071, 27541, 10385, 17337, 27541, 27224, 19127, 26441, 11166,
  11173, 17324, 11189, 8910, 27541, 13977, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848,
  25147, 11222, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541,
  27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368,
  9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643,
  9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967,
  9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248,
  10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 20720, 27541, 10385, 27541, 27541, 27541, 19127,
  25494, 11245, 11252, 17619, 11268, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544,
  10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 11302, 9080, 9103, 9126,
  15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 10190, 9229, 9248, 9264, 9133, 9303, 9337,
  23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627,
  9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879,
  9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206,
  10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541,
  27541, 27541, 19127, 26389, 11323, 11330, 9029, 11346, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541,
  27541, 8930, 13544, 10869, 20848, 25147, 8947, 14858, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152,
  9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133,
  9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541,
  9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848,
  9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930,
  10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 21571, 27541,
  10385, 14690, 27541, 21572, 19127, 11383, 11430, 11437, 27541, 11396, 8910, 27541, 20591, 27541, 27540, 27541, 9705,
  8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096,
  9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248,
  9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039,
  9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820,
  21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930,
  9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 11453,
  27541, 27541, 10385, 27541, 27541, 27541, 19127, 23643, 11476, 11483, 25607, 11499, 8910, 27541, 20591, 27541, 27540,
  27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11527, 14858, 13838, 18667, 20062, 20064, 27541,
  10480, 15158, 15158, 15158, 11543, 11613, 11613, 23704, 27541, 27541, 27541, 11564, 11583, 11365, 20063, 19470, 15158,
  15158, 15158, 21416, 11613, 11613, 11613, 14721, 16520, 27541, 27541, 8964, 11364, 26547, 21867, 15158, 15158, 19827,
  11613, 11613, 11613, 11763, 27541, 27541, 25063, 11366, 23537, 22725, 15158, 19910, 21425, 11612, 17799, 27541, 23724,
  18668, 26550, 15158, 19902, 21425, 23610, 16371, 27541, 11630, 24964, 15158, 25896, 22575, 27541, 11654, 11676, 25277,
  11705, 15732, 11660, 11724, 24471, 15393, 14976, 11760, 11781, 19787, 21678, 26300, 11808, 25433, 19065, 21729, 21729,
  14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541, 27541, 27541, 11830, 27541,
  27541, 27541, 18205, 11846, 8910, 27541, 20591, 27541, 11872, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 24332,
  27541, 27541, 11889, 26098, 27541, 18667, 20062, 20064, 27541, 10480, 15158, 15158, 15158, 11543, 11613, 11613, 17801,
  27541, 27541, 27541, 11564, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 21416, 11613, 11613, 11613, 11763, 27541,
  27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 11366,
  23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 11763, 27541,
  18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718,
  26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541,
  10380, 11968, 27541, 10385, 27541, 27541, 27541, 19127, 27356, 11909, 11958, 24220, 11924, 8910, 27541, 20591, 27541,
  27540, 11988, 9705, 12007, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980,
  9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245,
  8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476,
  9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267,
  9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071,
  10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541,
  27541, 27541, 10380, 12028, 27541, 10385, 27541, 27541, 27541, 12045, 8914, 12028, 27541, 11229, 12061, 12095, 27541,
  20591, 15121, 12115, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 14102, 27541, 27541, 11889, 11893, 12132, 18667,
  20062, 20064, 27541, 10480, 15158, 15158, 15158, 11543, 11613, 11613, 26317, 27541, 27541, 27541, 12150, 27541, 11365,
  20063, 19470, 15158, 15158, 15158, 21416, 11613, 11613, 11613, 12174, 27541, 27541, 8994, 27541, 11364, 26547, 21867,
  15158, 15158, 24890, 11613, 11613, 11613, 12201, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 20093, 21425, 11613,
  17799, 27541, 27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541,
  14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433,
  19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 10502, 27541, 25867, 13162, 27541,
  12406, 19127, 19522, 12241, 12256, 27541, 12281, 12307, 27541, 12329, 27541, 27540, 27541, 9705, 8991, 27541, 27541,
  12782, 12631, 12515, 20848, 25147, 12353, 26098, 27541, 13405, 9713, 8980, 9010, 12376, 12495, 12422, 12620, 12510,
  12888, 12438, 12903, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 12464, 12770, 12480, 12783, 12974, 12857, 12531,
  12637, 12910, 9303, 9337, 23216, 27541, 9368, 9404, 13282, 12559, 12590, 12388, 13387, 12448, 12702, 13207, 9492,
  22039, 9508, 9541, 12606, 12653, 13107, 12669, 12691, 12718, 13247, 22207, 26586, 9693, 12757, 12574, 12799, 12834,
  12873, 12929, 9820, 21024, 9863, 12964, 13375, 13021, 9911, 9951, 12990, 13006, 12849, 13048, 13092, 13123, 13139,
  13178, 13194, 12730, 13311, 12543, 13314, 13258, 13345, 13233, 13274, 13298, 13330, 13361, 13403, 27541, 27541, 27541,
  27541, 27541, 27541, 10380, 25647, 27541, 10385, 12291, 27541, 27541, 19127, 16155, 13421, 13428, 27541, 13444, 8910,
  27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541,
  13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 13470, 18126, 19376,
  9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9742, 9303, 9337, 23475, 27541, 9368, 9404, 10260, 9452, 9472,
  10301, 10264, 9456, 9476, 10100, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 13486, 13533, 9643, 9665, 22207, 26586,
  9693, 9729, 13610, 13566, 13605, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999,
  10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317,
  27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541, 27541, 27541, 16706, 27479, 13626, 13633,
  14466, 13649, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 9556, 27541, 27541, 8930, 13544, 27458, 20848, 25147,
  8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541,
  9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404,
  10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665,
  22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983,
  9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280,
  10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 13682, 22316, 27541, 10385, 27541, 27541, 27541, 19127, 22318,
  13711, 13722, 27541, 13752, 13778, 27541, 20591, 27541, 27540, 27541, 9705, 13801, 27541, 27541, 8930, 13544, 13550,
  20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751,
  27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216,
  27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671,
  9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911,
  9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252,
  27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 13824, 13834, 27541, 10385, 27541, 27541, 27541,
  19127, 27523, 13854, 13861, 27541, 13877, 13915, 27541, 20591, 27541, 27540, 27541, 9705, 9381, 27541, 24912, 8930,
  13544, 9157, 13936, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103,
  9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337,
  23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627,
  9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879,
  9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206,
  10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 13962, 27541, 27541, 10385, 19996,
  27541, 27541, 19127, 27541, 13217, 19997, 25217, 13999, 8910, 27541, 20591, 27541, 27540, 14025, 9705, 8991, 27541,
  27541, 8930, 13544, 10236, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152,
  9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133,
  9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541,
  9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848,
  9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930,
  10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541,
  10385, 27541, 27541, 27541, 19127, 27541, 27541, 27541, 24676, 14044, 8910, 27541, 20591, 27541, 27540, 27541, 9705,
  8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096,
  9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248,
  9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039,
  9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820,
  21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930,
  9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 11851,
  27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541, 27541,
  27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541,
  19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 16127, 27541, 11365, 20063, 19470, 15158,
  15158, 15158, 24517, 11613, 11613, 11613, 25462, 27541, 27541, 8994, 27541, 11364, 26547, 21867, 15158, 15158, 19827,
  11613, 11613, 11613, 12201, 27541, 27541, 25862, 11366, 23537, 15158, 15158, 22751, 21425, 11613, 17799, 27541, 27541,
  18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541, 14118, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041,
  11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729,
  14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669,
  18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548,
  27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801,
  27541, 27541, 27541, 16127, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 25462, 27541,
  27541, 8994, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 12201, 27541, 27541, 27541, 11366,
  23537, 15158, 15158, 22751, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541,
  18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718,
  26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541,
  11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541,
  27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064,
  27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 16127, 14136, 11365, 20063, 19470,
  15158, 15158, 15158, 24517, 11613, 11613, 11613, 25462, 27541, 27541, 8994, 27541, 11364, 26547, 21867, 15158, 15158,
  19827, 11613, 11613, 11613, 12201, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 22751, 21425, 11613, 17799, 27541,
  27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967,
  26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729,
  21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127,
  25669, 18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311,
  11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613,
  17801, 27541, 27541, 27541, 16127, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 25462,
  27541, 27541, 8994, 20749, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 12201, 27541, 27541, 27541,
  11366, 23537, 15158, 15158, 22751, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763,
  27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042,
  14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541,
  27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541, 20591,
  27541, 16809, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 11972, 27541, 18667, 20062,
  20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 16127, 27541, 11365, 20063,
  19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 25462, 27541, 27541, 8994, 27541, 11364, 26547, 21867, 15158,
  15158, 19827, 11613, 11613, 11613, 12201, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 22751, 21425, 11613, 17799,
  27541, 27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120,
  24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065,
  21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541,
  19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158,
  26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613,
  11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613,
  11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 27541,
  27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613,
  11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690,
  26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541,
  27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541,
  20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 21705, 27541, 27541, 11889, 27541, 27541, 18667,
  20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365,
  20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867,
  15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613,
  17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541,
  14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433,
  19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541,
  27541, 19127, 25669, 18666, 13899, 26043, 21828, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541,
  15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097,
  11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613,
  11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541,
  27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425,
  11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614,
  22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541,
  27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 12741, 18666, 13899, 26043, 21554, 14077,
  27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 24033,
  18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541,
  11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547,
  21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425,
  11613, 17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801,
  27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682,
  25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541,
  27541, 27541, 19127, 25669, 18666, 22343, 14156, 14171, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541,
  27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158,
  14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613,
  11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763,
  27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 19251,
  21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039,
  11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541,
  27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554,
  14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541,
  27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541,
  27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364,
  26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910,
  21425, 11613, 17799, 27541, 27541, 14204, 26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896,
  17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429,
  21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 14229, 27541, 27541, 10385,
  27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664,
  27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158,
  15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517,
  11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613,
  11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550, 15158,
  19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660,
  26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541,
  27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 20597, 14250, 14300, 15300,
  14265, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848, 25147, 8947,
  26098, 14081, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541, 27541, 9178,
  18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404, 10260,
  9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207,
  26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 14333, 9951, 9967, 9983, 9977,
  9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280, 10292,
  10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 27541, 27541,
  27541, 27541, 13058, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 10869, 20848,
  25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126, 15751, 27541,
  27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368,
  9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643,
  9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967,
  9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248,
  10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 14349, 27541, 27541, 10385, 27541, 27541, 27541, 19127,
  20449, 14376, 14383, 9525, 14399, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544,
  11307, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126,
  15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337,
  23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627,
  9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879,
  9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206,
  10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 15951, 27541, 10385, 12948,
  27541, 10700, 15982, 19643, 19656, 14435, 14482, 14449, 14498, 19529, 20591, 14234, 14532, 24311, 14559, 14575, 9287,
  24109, 14591, 14628, 14662, 17463, 27541, 14678, 27541, 16449, 25512, 20062, 22996, 27541, 16905, 15158, 15158, 17659,
  14097, 11613, 11613, 14714, 14767, 26476, 27541, 16127, 27541, 22229, 26980, 10960, 14737, 15158, 26998, 11689, 15573,
  11613, 26511, 25462, 14763, 27541, 26701, 27541, 22633, 14783, 14799, 22936, 15158, 19827, 17908, 26224, 11613, 14839,
  26122, 22847, 15792, 11366, 23537, 15158, 22539, 14874, 21425, 11613, 14921, 14948, 27541, 18668, 26550, 15158, 15004,
  12223, 22569, 11763, 27541, 18669, 24964, 15043, 18467, 22400, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039,
  11614, 22690, 26042, 16022, 26042, 18841, 21678, 19818, 21682, 15079, 19065, 21729, 21729, 14988, 15731, 27541, 27541,
  27541, 27541, 27541, 27541, 11851, 27542, 15102, 10385, 27541, 15103, 27541, 23159, 25669, 16652, 13899, 26043, 21554,
  14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541,
  27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 26938, 16127,
  15120, 15137, 24241, 19470, 15158, 15158, 18008, 24517, 11613, 11613, 18080, 25462, 27541, 27541, 8994, 27541, 11364,
  26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 12201, 27541, 20271, 27541, 16574, 18267, 15157, 15158, 22751,
  15175, 11613, 17799, 27541, 27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541, 18669, 24964, 15158, 25896,
  17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 15198, 25429,
  21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 15214, 10385,
  27541, 27541, 11567, 10359, 15238, 15254, 15269, 15316, 15283, 14077, 15104, 20591, 10934, 27541, 27541, 11367, 18664,
  27541, 27541, 19269, 26311, 21172, 27541, 15340, 15332, 14181, 22827, 10612, 15357, 20064, 15390, 13076, 15409, 15158,
  15158, 15449, 26506, 11613, 17801, 15926, 16939, 27541, 16127, 21096, 23909, 20063, 19470, 27020, 22533, 15489, 24517,
  14638, 15511, 15530, 25462, 27541, 27541, 25312, 27541, 11364, 26547, 21867, 15158, 17391, 19827, 11613, 11613, 17199,
  12201, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 22751, 21425, 11613, 17799, 27541, 27541, 18668, 15549, 20166,
  23422, 12223, 15596, 20253, 27541, 18669, 15615, 20373, 25896, 15639, 27541, 14120, 24967, 16258, 22445, 15732, 11660,
  26039, 11614, 22690, 26042, 14718, 26042, 15659, 15683, 25429, 21682, 25433, 19065, 21729, 21061, 15717, 15731, 27541,
  27541, 27541, 27541, 27541, 27541, 11851, 27541, 12079, 10385, 27541, 15749, 15767, 14698, 25473, 15814, 15824, 15840,
  15855, 14077, 27541, 20591, 27541, 27541, 27541, 15881, 15900, 27541, 15916, 20966, 21910, 11548, 27541, 13499, 11889,
  15949, 27541, 24807, 22642, 15967, 17432, 15998, 15623, 19874, 15158, 16038, 16060, 16078, 17801, 27541, 19165, 13808,
  16127, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 25462, 16103, 13589, 16120, 27541,
  11364, 26547, 17542, 15158, 15158, 16143, 19423, 11613, 25897, 16178, 27541, 27541, 10788, 16200, 16308, 15158, 17581,
  22751, 16220, 17410, 17799, 27541, 9315, 24425, 16241, 14606, 16274, 16324, 21649, 11763, 27541, 18669, 24964, 15158,
  25896, 17801, 10117, 14120, 24967, 25395, 20205, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 16358, 19787, 16405,
  25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 11127,
  10385, 13983, 16443, 11150, 12158, 16465, 16481, 16496, 16543, 16510, 14077, 16559, 24582, 16595, 16621, 23670, 16637,
  16671, 24009, 16687, 16722, 17829, 16738, 27541, 16754, 16770, 16797, 18620, 18667, 20062, 16579, 26889, 19472, 21899,
  22718, 16826, 16842, 16858, 20345, 16874, 16899, 16921, 16955, 25993, 10404, 16990, 22142, 17006, 17042, 17081, 17097,
  17124, 17163, 18477, 17179, 17215, 26691, 27541, 17242, 17310, 17360, 19187, 21737, 17388, 22966, 25135, 26200, 11613,
  17407, 17426, 17448, 17484, 17506, 11366, 17534, 23590, 17558, 17605, 17635, 23365, 17683, 27541, 17708, 18668, 17372,
  17734, 23422, 17770, 17795, 11763, 9804, 24790, 17817, 17845, 17861, 24362, 17877, 23902, 23189, 17894, 27068, 16883,
  11660, 25372, 23744, 14962, 17935, 24480, 17667, 17972, 15086, 17988, 18024, 25433, 16087, 18049, 21729, 14988, 15731,
  27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 13735, 13736, 13731, 18096, 18112, 18147, 18157,
  18173, 18188, 14077, 12313, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 23582, 17108, 11548, 27541, 18228,
  18221, 27541, 27541, 18246, 18283, 20064, 27541, 19472, 18303, 15158, 15158, 18323, 11613, 11613, 17801, 27541, 27541,
  27541, 16127, 27541, 11365, 20063, 19470, 15158, 15158, 25548, 24517, 11613, 11613, 19296, 25462, 27541, 27541, 8994,
  27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 12201, 27541, 27541, 27541, 18360, 18379, 15158,
  22973, 22751, 21425, 11613, 18407, 27541, 27541, 18668, 26550, 15158, 23422, 12223, 11613, 11763, 27541, 18669, 24964,
  15158, 25896, 18409, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787,
  21678, 25429, 21682, 25433, 17779, 18425, 18814, 18453, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541,
  27541, 10385, 27541, 10110, 18230, 20020, 18493, 18506, 18516, 18532, 18547, 14077, 27541, 20591, 27541, 14054, 27541,
  11367, 18664, 27541, 27541, 15158, 26311, 11548, 18615, 27541, 11889, 27541, 27541, 18582, 20062, 20064, 27541, 19472,
  15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158,
  15158, 15562, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613,
  11613, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 11278, 18668,
  26550, 15158, 19251, 21425, 11613, 17692, 18600, 18636, 24964, 15158, 25896, 17801, 27541, 14888, 18685, 18721, 18750,
  15732, 18776, 18803, 18830, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 14823, 18857, 14988,
  15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666,
  13899, 26043, 21554, 14077, 27541, 18885, 27541, 27541, 18907, 11367, 18925, 27541, 27541, 18944, 18963, 15580, 27541,
  11206, 18989, 16162, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 25700, 14097, 11613, 15533, 17801, 27541,
  27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 11763, 19023, 27541,
  27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 19042, 27541, 11366, 23537,
  15158, 20517, 19910, 21425, 11613, 19060, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669,
  24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 15063, 22464, 22690, 26042, 14718, 26042,
  19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851,
  27541, 12913, 10385, 11991, 14309, 15019, 15027, 14360, 19081, 19096, 19143, 19110, 14077, 27541, 19159, 27541, 27541,
  23892, 19181, 19203, 9562, 27541, 19229, 18061, 11548, 27541, 27541, 11889, 13512, 27541, 18667, 16204, 23403, 25833,
  19472, 19249, 19267, 20974, 19285, 20188, 11613, 19319, 13517, 19342, 19362, 16934, 26431, 19392, 20479, 19470, 15158,
  15158, 24275, 19412, 11613, 11613, 19446, 19467, 27541, 20456, 22195, 27541, 11364, 26547, 16250, 15158, 15158, 19827,
  19488, 11613, 11613, 11763, 17718, 19508, 18344, 11366, 23537, 18947, 15158, 19910, 21425, 19545, 22427, 27541, 27541,
  17956, 19566, 19602, 19629, 19672, 27044, 19688, 27541, 9832, 19708, 19727, 19755, 19781, 19120, 16381, 24967, 26041,
  11613, 21092, 11660, 26039, 11614, 22690, 26042, 14718, 19803, 19843, 21678, 25429, 21682, 15667, 19890, 21729, 21729,
  20545, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 13659, 18909, 13032, 19932,
  19945, 19955, 19971, 19986, 14077, 16970, 20591, 27437, 20013, 16104, 20036, 18664, 16104, 20858, 17021, 19613, 21705,
  22182, 27541, 11889, 16184, 18928, 14140, 20059, 16300, 27541, 19472, 20080, 23440, 22373, 20109, 23698, 25028, 25420,
  17282, 27541, 21133, 27541, 27541, 21938, 20063, 19470, 20137, 20162, 15158, 15562, 20182, 20204, 11613, 11763, 16974,
  27541, 26932, 20221, 11364, 18655, 21867, 23342, 17754, 19827, 11613, 19451, 26610, 24617, 27541, 27541, 27541, 18646,
  23537, 25365, 15158, 19910, 20240, 11613, 17799, 20287, 12818, 20306, 26818, 20322, 19251, 20339, 11613, 22407, 27541,
  11356, 24964, 15158, 25896, 17801, 25083, 14120, 24967, 21052, 21284, 15732, 11660, 26039, 11614, 22690, 26042, 14718,
  26042, 19787, 21678, 14932, 11734, 11511, 19065, 25778, 20361, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541,
  11851, 27541, 15733, 10385, 27541, 12337, 27541, 19127, 14543, 20398, 20408, 20424, 20439, 14077, 17518, 20591, 12675,
  27541, 16810, 20472, 18664, 16810, 17514, 17057, 21523, 11548, 27541, 21761, 11889, 9430, 20495, 18667, 20062, 20064,
  27541, 19472, 20514, 21606, 23830, 20533, 11613, 20561, 26272, 20577, 20613, 27541, 27541, 27541, 11365, 20063, 19470,
  23865, 25753, 15158, 24517, 20630, 20908, 11613, 11763, 10154, 20665, 14188, 27335, 11364, 26547, 21867, 20684, 24182,
  20146, 15599, 11613, 21791, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541,
  27541, 18668, 26550, 15158, 19251, 21425, 11613, 16418, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967,
  26041, 11613, 15732, 11660, 26039, 11614, 10564, 17065, 20702, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729,
  21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 20736, 27541, 16427, 20770, 20781,
  22872, 20797, 20807, 20823, 20838, 14077, 23152, 9352, 23319, 27541, 14317, 20874, 20924, 20990, 21006, 21040, 21077,
  21112, 19026, 27541, 21128, 27541, 24748, 13890, 20062, 20064, 27541, 21149, 21871, 15158, 15158, 14097, 15694, 11613,
  17801, 14511, 11414, 27541, 19692, 27541, 18257, 20063, 19470, 24134, 15158, 15158, 24517, 21188, 11613, 11613, 11763,
  27541, 20498, 27541, 11105, 27406, 15374, 21209, 15158, 21232, 21253, 21281, 11613, 21300, 16342, 21336, 26451, 22114,
  21364, 21956, 21380, 21406, 19910, 21443, 18973, 17799, 22095, 21846, 21459, 26550, 25541, 19251, 21484, 11613, 19326,
  27541, 22672, 24507, 21512, 21539, 21588, 27541, 14061, 20888, 21622, 21638, 11765, 11660, 21672, 21701, 22690, 21721,
  21753, 21777, 18033, 21813, 21862, 21682, 25433, 11814, 21887, 21729, 15433, 15731, 27541, 27541, 27541, 27541, 27541,
  27541, 11851, 27541, 27541, 21926, 27541, 18131, 14028, 10637, 21972, 21988, 21998, 22014, 22029, 22062, 22078, 20591,
  22111, 12207, 22265, 22130, 22167, 22255, 11596, 22281, 18391, 22297, 27541, 27541, 11889, 22313, 25165, 22334, 19396,
  20064, 27541, 19472, 20323, 15158, 22359, 14097, 14646, 21797, 16335, 27541, 20224, 19346, 9388, 10914, 11365, 18287,
  25241, 15158, 17589, 15158, 22389, 11613, 17193, 16062, 18734, 10423, 26789, 27541, 27541, 11364, 26547, 21867, 24387,
  15158, 19827, 11613, 22423, 11613, 11763, 20668, 10732, 27541, 11366, 23537, 15158, 15158, 14747, 22443, 11613, 17799,
  22915, 27541, 18668, 20043, 15495, 19251, 22461, 22480, 25057, 27541, 18584, 26148, 15158, 22497, 17801, 27541, 14120,
  24967, 26041, 11613, 17950, 11638, 23557, 11614, 22519, 22555, 14718, 22591, 19787, 21678, 25429, 21682, 25433, 24405,
  26251, 21729, 20121, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 19916, 12116,
  21348, 16781, 18666, 14284, 22607, 22622, 14077, 20754, 20591, 27541, 27541, 27541, 11367, 18664, 11286, 27541, 15158,
  26311, 11548, 17878, 25308, 11889, 10528, 22666, 22688, 15367, 20064, 27541, 22706, 20957, 22741, 25705, 14097, 22767,
  22806, 26176, 22826, 27541, 20266, 10536, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613,
  22780, 27541, 27541, 22843, 22863, 14213, 15141, 21867, 17571, 15158, 24143, 11613, 22888, 11613, 11763, 22911, 27541,
  27541, 11366, 23537, 15158, 22931, 21390, 21425, 22503, 17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613,
  11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 22481, 22952,
  26042, 15643, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541,
  27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899, 26043, 21554, 14077, 27541,
  20591, 27541, 21564, 27541, 22989, 23012, 17294, 17290, 17749, 23039, 16044, 24648, 27541, 11889, 27541, 27541, 18667,
  20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365,
  20063, 19470, 15158, 15158, 15158, 16011, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867,
  15158, 15158, 19827, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613,
  17799, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541,
  14120, 19711, 26041, 23067, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433,
  19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 12185, 11204, 11873,
  11200, 13666, 23087, 23100, 23110, 23126, 23141, 14077, 11942, 24568, 17257, 19044, 25157, 23175, 23213, 23232, 23260,
  23276, 18437, 23292, 27541, 27541, 23308, 26871, 10604, 14275, 27412, 20064, 27541, 9321, 25003, 15158, 23341, 23358,
  26071, 15182, 17801, 27541, 27541, 13068, 27541, 23381, 23399, 14905, 19470, 23419, 23438, 19586, 23456, 21427, 11613,
  25336, 23472, 26528, 23491, 23507, 27541, 11364, 23531, 23553, 18705, 23573, 19856, 11613, 18760, 23606, 23626, 27541,
  23659, 24653, 11366, 23537, 25271, 15158, 19910, 23686, 11613, 23071, 27541, 18198, 18668, 26550, 15158, 14612, 21425,
  11613, 23720, 12813, 18669, 20948, 15158, 23740, 17801, 11406, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614,
  23760, 21161, 23796, 26042, 20649, 24396, 17650, 21682, 25433, 19065, 23818, 23853, 14988, 15731, 27541, 27541, 27541,
  27541, 27541, 27541, 11851, 27541, 27541, 13454, 27541, 15222, 23881, 23925, 23941, 23957, 23967, 23983, 23998, 24025,
  27541, 20591, 27541, 24031, 12099, 24049, 24087, 12099, 24098, 24125, 18869, 11548, 10009, 27541, 11889, 27541, 27541,
  12360, 24159, 18363, 14459, 15865, 24175, 23775, 15158, 24198, 11708, 11613, 17801, 23515, 27285, 24214, 27541, 27541,
  11365, 20063, 17490, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 11763, 20290, 27541, 20614, 24754, 24236, 15891,
  21601, 15158, 24257, 24299, 24327, 22810, 24348, 25210, 27541, 27541, 27541, 16389, 22151, 15158, 24378, 19910, 21425,
  26747, 17799, 27541, 24421, 18557, 26550, 24283, 24441, 24457, 26078, 11763, 10319, 18669, 24964, 15158, 25896, 17801,
  27541, 24496, 24533, 14814, 21193, 24554, 11660, 26039, 11614, 22690, 24598, 24614, 26042, 26960, 20900, 25429, 24633,
  23023, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 12265, 27541,
  27541, 24669, 24692, 15473, 24708, 24723, 24770, 24737, 14077, 27171, 9419, 14009, 24786, 24806, 24823, 24839, 27541,
  24850, 24866, 19739, 25732, 17468, 15798, 24906, 27541, 24928, 24939, 26020, 24955, 15293, 24983, 15158, 24881, 24999,
  25019, 15514, 25044, 21685, 22790, 27541, 25079, 27541, 14516, 23244, 25099, 25121, 25181, 21216, 21237, 24517, 25197,
  18072, 19303, 11763, 19002, 16605, 27541, 25233, 20937, 22650, 25257, 23197, 18307, 25293, 15701, 25328, 22895, 25822,
  27541, 26795, 27541, 16289, 22239, 25352, 25388, 19910, 25411, 25449, 17799, 25489, 25510, 22219, 25528, 25564, 23780,
  25589, 11613, 25623, 25643, 25663, 24060, 25685, 25721, 19765, 27541, 14120, 25748, 25769, 11792, 17139, 25794, 26352,
  25810, 22690, 26042, 14718, 26042, 19787, 21678, 21315, 25849, 25883, 25913, 21729, 21729, 21496, 15731, 27541, 27541,
  27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 16655, 27541, 19127, 9935, 25941, 25951, 25967, 25982,
  14077, 27541, 13581, 10848, 27541, 27541, 11367, 18664, 27541, 10844, 15057, 18787, 11548, 26459, 27541, 11889, 27541,
  13695, 18667, 26017, 20064, 27541, 19472, 26036, 15158, 15158, 26059, 11613, 11613, 19430, 26094, 26114, 27541, 9136,
  27179, 11365, 26138, 13785, 17026, 25925, 26345, 24517, 21656, 26164, 26192, 11763, 17147, 27541, 27541, 27541, 18566,
  26547, 21320, 15158, 15158, 20382, 16225, 11613, 11613, 18336, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910,
  21425, 11613, 19492, 27541, 10888, 18668, 25105, 15158, 19251, 26216, 11613, 11763, 27541, 18669, 24964, 15158, 25896,
  17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26240, 26267, 22690, 26042, 14718, 26042, 19787, 21678, 25429,
  26288, 25433, 19065, 21729, 26333, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385,
  27541, 14854, 22087, 26368, 14419, 26384, 13762, 26405, 26420, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664,
  27541, 27541, 18003, 24071, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 14900, 20064, 26475, 19472, 19581, 15158,
  15158, 26492, 11613, 11613, 17801, 27541, 27541, 27541, 26527, 27541, 11365, 26544, 26566, 15158, 24266, 15158, 24517,
  11613, 26602, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613,
  11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 9024, 18668, 26550, 15158,
  19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15464, 11660,
  26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541,
  27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 26001, 27541, 17344, 12029, 21265, 26626, 26639, 26649, 26665,
  26680, 14077, 27541, 20591, 27541, 27541, 27541, 11367, 18664, 27541, 27541, 20686, 26311, 23051, 27541, 27541, 11889,
  27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541,
  27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158, 24517, 11613, 11613, 11613, 11763, 27541, 27541, 23325, 27541,
  11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613, 11613, 11763, 15933, 27541, 27541, 11366, 23537, 19233, 15158,
  26717, 21425, 26739, 20641, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158,
  25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678,
  25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 14229, 27541, 27541,
  10385, 27541, 27541, 27541, 19127, 25669, 18666, 13946, 26763, 26778, 14077, 27541, 9926, 27541, 27541, 21838, 26811,
  26834, 26840, 10162, 18700, 15421, 11548, 27541, 27541, 26856, 23383, 26887, 18667, 20062, 20064, 27541, 19472, 15158,
  15158, 23837, 14097, 11613, 11613, 26905, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158,
  24517, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 25573, 11613, 11613,
  11613, 11744, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550,
  15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732,
  11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731,
  27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541, 27541, 10385, 27541, 27541, 27541, 19127, 25669, 18666, 13899,
  26043, 21554, 26921, 27541, 20591, 27541, 23638, 27541, 11367, 18664, 27541, 15341, 15159, 26311, 17919, 27541, 27541,
  11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472, 15158, 15158, 24538, 14097, 11613, 11613, 26954, 18891, 27541,
  27541, 27541, 27541, 26976, 21947, 19470, 15158, 15158, 26996, 24517, 11613, 12225, 11613, 11763, 9436, 27541, 27541,
  27541, 21468, 26547, 19868, 27014, 15158, 19827, 27036, 27060, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158,
  15158, 26580, 21425, 11613, 19550, 27541, 27541, 18668, 26550, 15158, 19251, 21425, 11613, 25602, 27541, 14413, 24964,
  15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787,
  21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731, 27541, 27541, 27541, 27541, 27541, 27541, 11851, 27541,
  27541, 10385, 27541, 27541, 27541, 19127, 17226, 18666, 13899, 26043, 21554, 14077, 27541, 20591, 27541, 27541, 27541,
  11367, 18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 19472,
  15158, 15158, 15158, 14097, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158,
  15158, 24517, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613,
  11613, 11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668,
  26550, 15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613,
  15732, 11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988,
  15731, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 26723, 27120, 27084, 27110, 27146, 27130, 27200,
  27162, 27195, 27094, 8910, 27541, 20591, 27541, 27216, 27541, 9705, 8991, 27541, 27541, 8930, 27240, 10869, 20848,
  25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 27264, 9080, 9103, 9126, 15751, 27541,
  27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368,
  9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643,
  9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967,
  9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248,
  10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541, 12134, 27283, 19127,
  9677, 27301, 27308, 27541, 27324, 8910, 27541, 20591, 27541, 27540, 27541, 9705, 8991, 27351, 27541, 8930, 13544,
  10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 9152, 9080, 9103, 9126,
  15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337,
  23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627,
  9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879,
  9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206,
  10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541, 10385, 27541,
  27541, 27541, 16527, 20712, 27372, 27379, 27541, 27395, 8910, 27541, 20591, 27541, 27428, 27541, 9705, 8991, 27541,
  27541, 8930, 13544, 10869, 20848, 25147, 8947, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 27453,
  9080, 9103, 9126, 15751, 27541, 27541, 9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133,
  9303, 9337, 23216, 27541, 9368, 9404, 10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541,
  9578, 9627, 9649, 9671, 9621, 9643, 9665, 22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848,
  9888, 9879, 9895, 9911, 9951, 9967, 9983, 9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930,
  10178, 10206, 10222, 10252, 27248, 10280, 10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 10380, 27541, 27541,
  10385, 27541, 27541, 27541, 19127, 27541, 27541, 27541, 27541, 15781, 14077, 27541, 20591, 27541, 27541, 27541, 11367,
  18664, 27541, 27541, 15158, 26311, 11548, 27541, 27541, 11889, 27541, 27541, 18667, 20062, 20064, 27541, 10480, 15158,
  15158, 15158, 11543, 11613, 11613, 17801, 27541, 27541, 27541, 27541, 27541, 11365, 20063, 19470, 15158, 15158, 15158,
  21416, 11613, 11613, 11613, 11763, 27541, 27541, 27541, 27541, 11364, 26547, 21867, 15158, 15158, 19827, 11613, 11613,
  11613, 11763, 27541, 27541, 27541, 11366, 23537, 15158, 15158, 19910, 21425, 11613, 17799, 27541, 27541, 18668, 26550,
  15158, 19251, 21425, 11613, 11763, 27541, 18669, 24964, 15158, 25896, 17801, 27541, 14120, 24967, 26041, 11613, 15732,
  11660, 26039, 11614, 22690, 26042, 14718, 26042, 19787, 21678, 25429, 21682, 25433, 19065, 21729, 21729, 14988, 15731,
  27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27541, 27474, 27541, 19213, 27495, 27502,
  25627, 27518, 27539, 27541, 27541, 27541, 27540, 27541, 9705, 8991, 27541, 27541, 8930, 13544, 9157, 20848, 25147,
  21016, 26098, 27541, 13405, 9713, 8980, 9010, 9045, 9073, 9096, 9119, 27264, 9080, 9103, 9126, 15751, 27541, 27541,
  9178, 18126, 19376, 9194, 9210, 9226, 9245, 8931, 9162, 9229, 9248, 9264, 9133, 9303, 9337, 23216, 27541, 9368, 9404,
  10260, 9452, 9472, 10301, 10264, 9456, 9476, 9277, 9492, 22039, 9508, 9541, 9578, 9627, 9649, 9671, 9621, 9643, 9665,
  22207, 26586, 9693, 9729, 13610, 9776, 27267, 9771, 9792, 9820, 21024, 9848, 9888, 9879, 9895, 9911, 9951, 9967, 9983,
  9977, 9999, 10025, 10055, 10039, 10071, 10087, 10133, 8930, 9057, 8930, 10178, 10206, 10222, 10252, 27248, 10280,
  10292, 10317, 27541, 27541, 27541, 27541, 27541, 27541, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072,
  37072, 37072, 244, 37072, 37072, 37072, 37072, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 35023, 37072, 37072, 37072, 37072,
  37072, 37072, 37072, 37072, 37072, 37072, 22528, 24576, 37072, 37072, 37072, 37072, 20480, 37072, 37072, 37072, 37072,
  37072, 37072, 37072, 37072, 37072, 0, 0, 35023, 37072, 35023, 37072, 37072, 35023, 35023, 37072, 37072, 37072, 37072,
  37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 37072, 0, 528384, 211, 212, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 210, 0, 0, 0, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 903168, 0, 0, 244, 244, 0, 0, 686080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1215, 0, 798720, 804864, 811008, 555008, 825344, 555008, 841728, 555008,
  555008, 555008, 899072, 555008, 555008, 555008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 0, 0, 753664, 0,
  772096, 780288, 0, 0, 798720, 804864, 811008, 0, 825344, 841728, 899072, 0, 0, 0, 0, 1495, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 79872, 79872, 79872, 79872, 79872, 0, 0, 841728, 0, 804864, 841728, 0, 0, 0, 788480, 0, 0, 557056, 557056,
  557056, 557056, 0, 710656, 0, 0, 0, 0, 0, 0, 0, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 753664, 557056, 557056, 557056, 557056, 772096, 557056, 780288, 557056, 784384,
  557056, 557056, 798720, 557056, 780288, 557056, 784384, 557056, 557056, 798720, 557056, 804864, 811008, 557056,
  557056, 557056, 825344, 557056, 557056, 841728, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 899072, 557056, 557056, 557056, 557056,
  557056, 557056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 994, 0, 557056, 626, 0, 0, 629, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 0, 557056, 677888, 557056, 557056, 557056,
  0, 0, 532480, 802816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 768000, 0, 808960, 768000, 555008, 555008, 555008, 555008, 808960,
  817152, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 677888, 0, 735232, 0, 0, 0, 0, 817152, 0, 0,
  817152, 0, 0, 0, 557056, 557056, 677888, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 735232, 557056, 557056, 557056, 557056, 751616, 557056, 557056, 751616, 557056, 557056, 557056,
  768000, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 808960, 813056, 817152, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 903168,
  557056, 557056, 557056, 0, 0, 0, 0, 0, 0, 702464, 0, 0, 0, 0, 0, 0, 0, 544, 0, 544, 0, 0, 0, 427, 0, 0, 0, 696320, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 800768, 0, 0, 0, 0, 0, 1496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 741, 814, 369, 817, 369, 369, 0, 0,
  0, 897024, 921600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 827392, 0, 0, 0, 244, 244, 244, 0, 0, 0, 0, 456, 0, 0, 0, 0, 461, 0,
  743424, 837632, 0, 0, 555008, 696320, 698368, 555008, 555008, 555008, 555008, 743424, 555008, 555008, 555008, 0, 0, 0,
  131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 992, 0, 484, 0, 0, 0, 0, 782336, 555008, 555008, 837632, 555008, 555008, 555008,
  555008, 555008, 555008, 555008, 555008, 698368, 0, 782336, 0, 0, 0, 244, 244, 244, 0, 0, 0, 455, 0, 0, 0, 0, 0, 0,
  731, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1170, 0, 0, 0, 0, 0, 557056, 557056, 557056, 743424, 557056, 557056, 557056,
  557056, 557056, 557056, 782336, 557056, 557056, 557056, 800768, 557056, 557056, 833536, 837632, 557056, 557056,
  833536, 837632, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 878592, 882688, 557056, 557056, 557056,
  894976, 557056, 557056, 557056, 557056, 0, 745472, 0, 0, 0, 843776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 806912, 716800, 776192,
  0, 923648, 0, 0, 733184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 0, 0, 0,
  886784, 555008, 555008, 555008, 716800, 555008, 555008, 745472, 555008, 776192, 555008, 555008, 843776, 555008,
  555008, 555008, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 545, 0, 0, 0, 545, 0, 555008, 555008, 886784, 901120,
  911360, 923648, 0, 0, 0, 0, 901120, 911360, 557056, 679936, 557056, 557056, 557056, 557056, 557056, 557056, 1096, 0,
  0, 1101, 0, 557056, 677888, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0,
  683, 683, 0, 5, 0, 0, 557056, 679936, 557056, 557056, 557056, 704512, 557056, 557056, 716800, 557056, 557056, 557056,
  557056, 557056, 745472, 755712, 557056, 557056, 557056, 776192, 745472, 755712, 557056, 557056, 557056, 776192,
  557056, 557056, 557056, 557056, 557056, 843776, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 886784,
  557056, 901120, 557056, 557056, 557056, 886784, 557056, 901120, 557056, 911360, 557056, 557056, 923648, 557056, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 411988, 0, 0, 411988, 411988, 884736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555008,
  555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 555008, 753664,
  555008, 555008, 772096, 555008, 780288, 555008, 555008, 555008, 555008, 555008, 757760, 555008, 555008, 868352,
  555008, 884736, 0, 757760, 0, 0, 557056, 557056, 557056, 211, 0, 0, 0, 211, 0, 212, 0, 0, 0, 212, 0, 0, 0, 0, 0, 0, 0,
  0, 22528, 67866, 0, 0, 0, 0, 20480, 557056, 786432, 557056, 557056, 819200, 557056, 557056, 849920, 557056, 557056,
  868352, 557056, 557056, 884736, 892928, 557056, 557056, 557056, 927744, 0, 0, 557056, 557056, 927744, 0, 0, 0, 0,
  712704, 0, 0, 724992, 741376, 0, 0, 0, 0, 0, 1592, 1593, 0, 1594, 0, 0, 0, 1596, 1597, 0, 0, 0, 919552, 0, 792576, 0,
  0, 0, 845824, 0, 880640, 0, 722944, 0, 0, 0, 0, 0, 1605, 0, 0, 0, 0, 0, 1610, 0, 307, 307, 307, 724992, 555008,
  555008, 555008, 555008, 0, 0, 0, 557056, 557056, 557056, 557056, 557056, 708608, 722944, 724992, 555008, 555008,
  555008, 555008, 0, 0, 0, 557628, 557628, 557628, 557628, 557628, 709180, 723516, 725564, 557056, 557056, 557056,
  557056, 557056, 557056, 708608, 722944, 724992, 557056, 557056, 741376, 557056, 557056, 557056, 557056, 557056,
  557056, 845824, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 690176, 0, 0, 0, 0, 0, 0, 847872, 770048,
  761856, 749568, 774144, 0, 0, 862208, 0, 905216, 917504, 0, 671744, 864256, 0, 0, 0, 244, 244, 244, 0, 0, 454, 0, 0,
  0, 0, 0, 0, 0, 322, 322, 322, 322, 339, 322, 322, 339, 339, 0, 0, 0, 790528, 0, 0, 0, 0, 0, 0, 0, 555008, 700416,
  555008, 555008, 794624, 555008, 555008, 700416, 794624, 0, 673792, 557056, 557056, 700416, 557056, 557056, 557056,
  737280, 557056, 557056, 770048, 794624, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  915456, 673792, 557056, 557056, 700416, 557056, 915456, 0, 706560, 0, 0, 0, 821248, 0, 0, 913408, 0, 0, 0, 0, 0, 0, 0,
  692, 0, 0, 694, 0, 0, 0, 0, 0, 854016, 0, 684032, 0, 870400, 684032, 706560, 555008, 796672, 870400, 796672, 557056,
  684032, 688128, 706560, 557056, 557056, 557056, 557056, 763904, 796672, 821248, 858112, 557056, 870400, 557056,
  557056, 557056, 913408, 0, 557056, 557056, 557056, 763904, 796672, 821248, 858112, 557056, 870400, 557056, 557056,
  557056, 913408, 557056, 684032, 688128, 0, 0, 0, 829440, 0, 0, 0, 0, 0, 815104, 0, 929792, 731136, 731136, 557056,
  727040, 731136, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 909312, 557056, 727040, 731136,
  557056, 557056, 557056, 211, 0, 212, 0, 0, 0, 702464, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1674, 0, 0, 0,
  0, 0, 0, 557056, 557056, 557056, 557056, 557056, 909312, 0, 0, 0, 0, 831488, 0, 0, 0, 0, 0, 212, 681984, 0, 0, 694272,
  0, 0, 0, 0, 0, 0, 0, 1167, 0, 0, 0, 0, 0, 0, 0, 0, 569, 0, 0, 0, 0, 0, 0, 0, 557056, 0, 0, 0, 0, 0, 0, 0, 0, 557056,
  557056, 739328, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 43008, 557056, 677888, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 739328, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  692224, 0, 718848, 876544, 0, 0, 0, 0, 557056, 557056, 747520, 557056, 823296, 557056, 557056, 557056, 876544, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 120832, 120832, 0, 5, 747520,
  557056, 823296, 557056, 557056, 557056, 876544, 714752, 0, 0, 0, 0, 557056, 557056, 557056, 557056, 696320, 698368,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 743424, 557056, 874496, 675840, 557056,
  557056, 557056, 557056, 874496, 720896, 0, 0, 851968, 557056, 765952, 860160, 557056, 759808, 778240, 729088, 557056,
  729088, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 536576, 0, 0, 0, 0, 866304, 866304, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1599, 0, 53572, 53572, 324, 324, 324, 324, 324, 324, 53572, 324, 53572, 53572,
  53572, 324, 53572, 53572, 53572, 53572, 53572, 53572, 53572, 53572, 53572, 0, 0, 0, 0, 0, 0, 0, 224, 222, 22528,
  24576, 0, 284, 284, 285, 20480, 0, 53572, 53572, 53572, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 0,
  0, 0, 0, 0, 0, 493, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1008, 0, 0, 211, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1173, 0, 211, 0, 0, 0, 0, 0, 0, 0, 0, 57622, 24576, 0, 0, 0, 0, 20480, 211, 0, 0, 211, 0, 0, 2, 45059, 4, 5,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 57344, 0, 528384, 10659, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 369, 369, 369, 369,
  528384, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 215, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 681984, 0, 0,
  694272, 0, 0, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 0, 0, 0, 747, 0, 0, 0, 0, 0, 0, 0, 0, 565447, 45059, 4, 5, 203, 0, 0,
  0, 0, 0, 203, 0, 0, 0, 0, 0, 1772, 0, 0, 0, 0, 0, 0, 0, 307, 369, 369, 0, 59392, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 59392,
  0, 0, 0, 59392, 59392, 0, 0, 0, 565447, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 750, 0, 0, 0, 0, 0, 0, 0, 0, 767, 0, 0, 0,
  0, 0, 0, 307, 59392, 0, 59392, 59392, 59392, 0, 59392, 59392, 59392, 0, 0, 0, 0, 0, 0, 0, 236, 237, 22528, 24576, 0,
  238, 238, 237, 20480, 528384, 0, 0, 0, 0, 0, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 212, 212, 212, 212, 212, 212, 212, 0,
  63488, 0, 0, 0, 0, 63488, 0, 0, 22528, 24576, 63488, 0, 0, 0, 20480, 0, 0, 63488, 0, 0, 0, 0, 63488, 0, 0, 0, 0, 0, 0,
  0, 0, 216, 0, 216, 270, 216, 0, 0, 0, 0, 0, 63488, 0, 0, 63488, 0, 0, 0, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1375, 0, 63488, 0, 0, 63488, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 67584, 0, 0, 65536, 0, 0, 0, 0, 65536, 0, 22528, 24576, 0, 0, 0, 0, 20480, 0, 65536, 65536, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1387, 1388, 0, 0, 0, 65536, 0, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536,
  65536, 65536, 65536, 0, 0, 65536, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 35023, 35023, 35023, 35023, 0, 0, 528384,
  420, 421, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 0, 557056, 871, 0, 0, 874, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 5, 0, 212, 67584, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1504, 0, 212, 0, 0, 212, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1000, 0, 0, 0, 0, 0,
  1007, 0, 0, 0, 528384, 211, 10662, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 474, 0, 0, 0, 528384, 0, 0, 0, 0, 0, 0, 0, 0,
  18432, 0, 0, 0, 0, 0, 0, 0, 1042, 0, 0, 0, 0, 0, 814, 369, 369, 209, 209, 0, 0, 209, 209, 69841, 209, 209, 209, 209,
  209, 209, 209, 209, 209, 248, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 245,
  209, 209, 69841, 209, 209, 209, 209, 209, 69841, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 69841, 69841,
  69841, 69841, 69841, 209, 209, 69841, 209, 209, 209, 209, 209, 209, 22528, 24576, 209, 209, 209, 209, 20480, 69841,
  69841, 69841, 209, 209, 209, 209, 209, 209, 209, 209, 209, 69841, 209, 69841, 69841, 69841, 69841, 69841, 69841,
  69841, 69841, 0, 0, 0, 209, 0, 209, 209, 209, 209, 69841, 69841, 209, 69841, 69841, 69841, 69841, 69841, 69841, 69880,
  69880, 69880, 69880, 69880, 69841, 69841, 69841, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1208, 0, 1210, 0, 0, 0, 0,
  0, 1216, 0, 0, 0, 563651, 563651, 563651, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 229, 230, 0, 0, 0, 0, 0, 563651, 563651,
  0, 0, 686080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 249, 0, 249, 0, 0, 0, 75776, 0, 0, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 0, 45059,
  4, 5, 61440, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 712, 0, 0, 0, 244, 0, 0, 0, 686080, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 273, 273, 273, 273, 273, 273, 273, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824,
  77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 0, 0, 0, 0, 43398, 77824, 43398, 77824, 77824, 43398, 0, 0, 2,
  45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1498, 0, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0, 443, 0, 0, 0, 0, 557056, 626, 0, 43008,
  629, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 1098144, 0,
  79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 0, 0, 0, 0,
  0, 0, 0, 79872, 79872, 79872, 79872, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1607, 0, 0, 0, 0, 0, 307, 307, 307,
  307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 81920, 81920, 81920, 81920, 81920, 0, 81920, 0, 0, 0, 0, 81920,
  0, 0, 81920, 81920, 81920, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1673, 0, 0, 0, 0, 0, 0, 0, 0, 964, 965, 0, 0, 0,
  0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920,
  81920, 0, 0, 0, 0, 0, 0, 0, 0, 2, 200, 4, 5, 0, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 279, 279, 0, 0, 0, 0, 279, 0, 83968,
  83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 0, 0, 0, 0, 0, 0, 0,
  83968, 83968, 83968, 83968, 26821, 26821, 2, 0, 4, 5, 0, 417, 0, 0, 0, 0, 0, 1885, 369, 369, 369, 369, 369, 369, 369,
  369, 1891, 391, 0, 0, 244, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0, 723, 0, 725, 369, 626, 0, 0, 629, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 0, 0, 0, 26821, 5, 0, 0, 532480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 0, 0, 0, 0,
  110592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1005, 0, 0, 0, 0, 558, 494, 494, 0, 0, 0, 0, 0, 558, 0, 0, 558, 1454, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 1601, 0, 0, 0, 0, 1606, 0, 0, 0, 0, 0, 0,
  307, 307, 307, 307, 307, 0, 1743, 369, 369, 369, 369, 0, 1677, 1678, 0, 0, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307, 307,
  0, 369, 369, 369, 369, 369, 307, 307, 0, 0, 0, 1692, 369, 369, 369, 369, 369, 369, 1698, 369, 369, 369, 369, 369, 369,
  1097, 1100, 43881, 1102, 1100, 391, 391, 1106, 391, 391, 391, 391, 1716, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 903, 391, 391, 369, 369, 369, 1748, 369, 1749, 1750, 369, 369, 369, 369, 369, 369, 391, 391, 391,
  391, 1874, 391, 1876, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1345, 0, 0, 0, 391, 391, 1794, 391, 391, 391, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1738, 0, 1806, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1816, 391, 391, 391, 391,
  391, 391, 391, 1719, 391, 391, 391, 391, 1724, 391, 391, 391, 369, 369, 369, 391, 1872, 391, 391, 391, 391, 391, 391,
  391, 391, 0, 0, 0, 0, 0, 369, 369, 1903, 1904, 272, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 20480, 88476, 0,
  0, 88476, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 0, 0, 59392, 59392, 528861, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 244, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 477, 739, 0, 0, 0, 92485,
  92485, 0, 0, 0, 0, 0, 0, 92485, 0, 92485, 92485, 92485, 0, 92485, 92485, 92485, 0, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0,
  0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 444, 445, 0, 0, 92485, 92485, 92485, 92485, 92485, 92485, 92485,
  92485, 92485, 0, 0, 0, 0, 213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 0, 0, 0, 0, 0, 114688, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 231, 0, 231, 555008, 555008, 555008, 0, 94208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 211, 211, 0, 0,
  210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 273, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 20480,
  273, 0, 0, 273, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 226, 227, 0, 0, 0,
  0, 0, 0, 0, 210, 211, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 505, 0, 0, 0, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 271, 0, 743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 411648, 0, 739, 739, 0, 0, 0, 743, 991, 0, 0, 0, 0,
  0, 0, 0, 0, 228, 22528, 24576, 0, 0, 0, 0, 20480, 391, 391, 391, 932, 1156, 0, 0, 0, 0, 938, 1158, 0, 0, 0, 0, 0, 239,
  0, 0, 0, 0, 0, 244, 0, 0, 0, 0, 391, 391, 391, 1156, 0, 1158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 425, 486, 487, 488, 0, 0,
  1441, 0, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1135, 391, 0, 0, 0, 98304, 98304,
  98304, 98304, 98304, 98304, 98304, 98519, 98304, 98304, 98518, 98519, 98304, 98518, 98304, 98518, 98304, 98304, 98304,
  98304, 98304, 0, 0, 0, 0, 0, 0, 0, 241, 0, 0, 0, 244, 0, 0, 0, 0, 0, 98304, 98518, 98304, 0, 0, 2, 45059, 4, 5, 0, 0,
  0, 0, 0, 0, 0, 106496, 106496, 0, 0, 106496, 106496, 0, 0, 0, 73728, 528384, 211, 212, 0, 102400, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 563652, 73728, 563652, 0, 73728, 0, 0, 0, 0, 0, 0, 0, 0, 233, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 563652, 0, 0, 686080, 0, 0, 0, 0, 0, 0, 0, 0, 0, 694, 768, 769, 0, 0, 0, 307, 0, 0, 841728, 0, 804864,
  841728, 0, 0, 0, 788480, 0, 0, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 0, 0, 0, 0, 536576, 0, 0, 0, 0,
  0, 63488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 780860, 557628, 784956, 557628, 557628, 799292, 557628,
  805436, 811580, 557628, 557628, 557628, 825916, 557628, 557628, 842300, 805492, 811636, 557684, 557684, 557684,
  825972, 557684, 557684, 842356, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 782964, 557684, 557684,
  557684, 801396, 557684, 557684, 834164, 838260, 557684, 0, 735232, 0, 0, 0, 0, 817152, 0, 0, 817152, 0, 0, 0, 557056,
  557628, 678460, 752188, 557628, 557628, 557628, 768572, 557628, 557628, 557628, 557628, 557628, 557628, 557628,
  809532, 813628, 817724, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 754236, 557628,
  557628, 557628, 557628, 772668, 557628, 626, 0, 0, 629, 557684, 557684, 557684, 557684, 557684, 557684, 557684,
  557684, 557684, 557684, 557684, 0, 0, 0, 0, 5, 557684, 768628, 557684, 557684, 557684, 557684, 557684, 557684, 557684,
  809588, 813684, 817780, 557684, 557684, 557684, 557684, 0, 710656, 0, 0, 0, 0, 0, 0, 0, 557628, 557628, 557628,
  557628, 557628, 557628, 743996, 557628, 557628, 557628, 557628, 557628, 557628, 782908, 557628, 557628, 557628,
  801340, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 758332, 557628, 557628, 787004,
  557628, 557628, 819772, 557628, 834108, 838204, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 879164,
  883260, 557628, 557628, 557628, 895548, 555008, 555008, 886784, 901120, 911360, 923648, 0, 0, 0, 0, 901120, 911360,
  557628, 680508, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 899644, 557628,
  557628, 557628, 557628, 557628, 627, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684,
  557684, 557684, 903796, 557684, 557684, 557684, 557628, 705084, 557628, 557628, 717372, 557628, 557628, 557628,
  557628, 557628, 746044, 756284, 557628, 557628, 557628, 776764, 557628, 911932, 557628, 557628, 924220, 557628, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 557684, 680564, 557684, 557684, 557684, 705140, 557684, 557684,
  717428, 557684, 557684, 557684, 557684, 557684, 557684, 879220, 883316, 557684, 557684, 557684, 895604, 557684,
  557684, 557684, 557684, 746100, 756340, 557684, 557684, 557684, 776820, 557684, 557684, 557684, 557684, 557684,
  844404, 557684, 557684, 557684, 557684, 557684, 909940, 0, 0, 0, 0, 831488, 0, 0, 0, 0, 0, 293, 0, 307, 307, 307, 307,
  0, 307, 307, 0, 0, 555008, 555008, 555008, 757760, 555008, 555008, 868352, 555008, 884736, 0, 757760, 0, 0, 557628,
  557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 735804, 557628, 557628, 557628,
  557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 903740,
  557628, 557628, 850492, 557628, 557628, 868924, 557628, 557628, 885308, 893500, 557628, 557628, 557628, 928316, 0, 0,
  0, 0, 1591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1501, 0, 0, 0, 0, 0, 0, 557684, 557684, 557684, 557684, 557684, 557684,
  557684, 557684, 557684, 557684, 557684, 557684, 758388, 557684, 557684, 737908, 557684, 557684, 770676, 795252,
  557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 735860, 557684, 557684, 557684, 557684,
  752244, 557684, 557684, 557684, 787060, 557684, 557684, 819828, 557684, 557684, 850548, 557684, 557684, 868980,
  557684, 557684, 885364, 893556, 557684, 557684, 754292, 557684, 557684, 557684, 557684, 772724, 557684, 780916,
  557684, 785012, 557684, 557684, 799348, 557684, 557684, 557684, 899700, 557684, 557684, 557684, 557684, 557684,
  557684, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 232, 0, 557684, 557684, 928372, 0, 0, 0, 0, 712704, 0, 0, 724992,
  741376, 0, 0, 0, 0, 0, 63488, 63488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 216, 0, 250, 0, 216, 216, 250, 557628, 557628, 741948,
  557628, 557628, 557628, 557628, 557628, 557628, 846396, 557628, 557628, 557628, 557628, 557628, 557628, 0, 0, 0, 0, 0,
  557684, 678516, 557684, 557684, 557684, 555008, 555008, 700416, 794624, 0, 674364, 557628, 557628, 700988, 557628,
  557628, 557628, 737852, 557628, 557628, 770620, 795196, 557628, 557628, 557628, 557628, 557628, 557628, 557628,
  557628, 557628, 916028, 674420, 557684, 557684, 701044, 557684, 557684, 846452, 557684, 557684, 557684, 557684,
  557684, 557684, 557684, 690176, 0, 0, 0, 0, 0, 275, 0, 0, 0, 22528, 24576, 0, 0, 0, 288, 20480, 916084, 0, 706560, 0,
  0, 0, 821248, 0, 0, 913408, 0, 0, 0, 0, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0, 803,
  0, 0, 814, 815, 369, 818, 369, 854016, 0, 684032, 0, 870400, 684032, 706560, 555008, 796672, 870400, 796672, 557628,
  684604, 688700, 707132, 557628, 557628, 557628, 557628, 557628, 844348, 557628, 557628, 557628, 557628, 557628,
  557628, 557628, 887356, 557628, 901692, 557628, 557628, 557628, 764476, 797244, 821820, 858684, 557628, 870972,
  557628, 557628, 557628, 913980, 557684, 684660, 688756, 707188, 557684, 557684, 557684, 557684, 764532, 797300,
  821876, 858740, 557684, 871028, 557684, 557684, 557684, 914036, 0, 0, 0, 244, 244, 244, 0, 71680, 0, 0, 0, 0, 0, 0, 0,
  0, 215, 215, 215, 0, 0, 0, 0, 0, 0, 0, 0, 829440, 0, 0, 0, 0, 0, 815104, 0, 929792, 731136, 731136, 557628, 727612,
  731708, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 909884, 557684, 727668, 731764, 557684,
  557684, 557684, 0, 0, 0, 0, 0, 0, 702464, 0, 0, 0, 0, 0, 0, 0, 133120, 0, 0, 133120, 0, 0, 0, 133120, 0, 876544, 0, 0,
  0, 0, 557628, 557628, 748092, 557628, 823868, 557628, 557628, 557628, 877116, 557684, 557684, 557684, 887412, 557684,
  901748, 557684, 911988, 557684, 557684, 924276, 557684, 0, 0, 0, 0, 0, 0, 0, 0, 557628, 557628, 739900, 557628,
  557628, 557628, 557628, 748148, 557684, 823924, 557684, 557684, 557684, 877172, 714752, 0, 0, 0, 0, 557628, 557628,
  557628, 557628, 696892, 698940, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557684, 557684,
  557684, 557684, 557684, 557684, 0, 0, 0, 0, 676412, 557628, 557628, 557628, 557628, 557628, 557628, 557628, 557628,
  557628, 557628, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557628, 875068, 676468,
  557684, 557684, 557684, 557684, 875124, 720896, 0, 0, 851968, 557628, 766524, 860732, 557628, 557628, 557628, 557684,
  557684, 739956, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 692224, 0, 718848, 557684, 766580, 860788,
  557684, 759808, 778240, 729660, 557628, 729716, 557684, 557628, 557684, 557628, 557684, 557628, 557684, 557684,
  557684, 557684, 557684, 709236, 723572, 725620, 557684, 557684, 742004, 557684, 557684, 557684, 557684, 696948,
  698996, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 557684, 744052, 866876, 866932, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555008, 0, 0, 0, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496, 106496,
  106496, 106496, 106496, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 106496, 106496, 106496, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0,
  0, 240, 0, 0, 0, 0, 244, 0, 0, 0, 0, 0, 0, 532480, 802816, 0, 0, 28672, 0, 0, 0, 14336, 0, 0, 768000, 0, 808960,
  557056, 911360, 557056, 557056, 923648, 557056, 626, 0, 0, 0, 626, 0, 629, 0, 0, 0, 0, 704, 0, 0, 706, 0, 0, 0, 709,
  710, 0, 0, 0, 0, 730, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 952, 0, 0, 0, 0, 629, 0, 557056, 679936, 557056, 557056,
  557056, 704512, 557056, 557056, 716800, 557056, 557056, 557056, 557056, 557056, 0, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 0, 0, 118784, 0, 5, 557056, 557056, 849920, 557056, 557056,
  868352, 557056, 557056, 884736, 892928, 557056, 557056, 557056, 927744, 626, 0, 0, 0, 244, 244, 244, 453, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1181, 0, 0, 0, 0, 0, 0, 0, 629, 0, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 757760, 557056, 557056, 786432, 557056, 557056, 819200, 0, 108870, 108870, 108870,
  108870, 108870, 108870, 108870, 108870, 108870, 108870, 108870, 108870, 108870, 108870, 108870, 0, 0, 0, 0, 0, 0, 0,
  108957, 108870, 108870, 108958, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576,
  0, 0, 0, 239, 20480, 0, 2, 45059, 4, 5, 0, 0, 122880, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 748, 0, 749, 0, 0, 0, 0, 0, 0,
  749, 0, 0, 0, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880,
  122880, 122880, 123243, 122880, 122880, 122880, 0, 0, 0, 0, 0, 0, 0, 247, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  122880, 122880, 122880, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 307, 0, 0, 386, 386, 386, 386, 386, 409, 386, 0,
  528384, 211, 212, 0, 0, 104448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 957, 0, 0, 0, 814, 369, 369, 555008, 555008, 555008, 55296,
  0, 118784, 129024, 0, 0, 0, 0, 0, 0, 0, 0, 0, 981, 0, 0, 0, 0, 0, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 126976, 0, 0, 0, 0,
  126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 755, 0, 0, 0, 0, 127303, 127303, 127303, 127303, 127303, 127303, 127303,
  127303, 127303, 127303, 127303, 127303, 127303, 127303, 127303, 0, 0, 0, 0, 126976, 0, 0, 0, 127303, 127303, 127303,
  0, 0, 2, 45059, 0, 5, 0, 0, 135168, 0, 0, 0, 0, 763, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0, 369, 369, 369, 369, 369,
  391, 369, 0, 528384, 211, 212, 96256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 212, 212, 0, 0, 86016, 145408, 0, 0, 0, 0,
  681984, 0, 0, 694272, 0, 0, 0, 0, 0, 0, 307, 0, 0, 388, 388, 388, 388, 388, 411, 388, 0, 2, 45059, 571593, 5, 0, 0, 0,
  0, 205, 0, 0, 0, 0, 205, 0, 0, 0, 244, 244, 100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 251, 0, 0, 0, 133120, 0, 0,
  133120, 0, 0, 2, 45059, 571593, 5, 0, 0, 0, 0, 0, 0, 468, 0, 0, 0, 0, 0, 0, 455, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 137216, 0, 0, 137216, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1684, 0, 307, 307, 1687, 1688, 307, 0, 0, 211, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 756, 0, 0, 0, 369,
  626, 43881, 814, 629, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 477, 0, 0, 26821, 5, 1600, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307, 307, 0, 0, 0, 997, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 770, 0, 0, 307, 389,
  389, 389, 389, 389, 389, 389, 389, 389, 392, 392, 392, 392, 392, 392, 392, 389, 389, 392, 26821, 26821, 2, 45059, 4,
  5, 0, 0, 0, 0, 0, 0, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1197, 0, 0, 0, 0, 0, 0, 0, 1505, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1227, 1228, 26822, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  473, 0, 0, 0, 0, 0, 141312, 141312, 0, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 0, 141312, 141312, 141312,
  141312, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 765, 766, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0, 381, 381, 381, 381, 381,
  404, 381, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 0, 0, 0, 256, 0, 0, 0,
  0, 0, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 437, 0, 847872, 770048, 761856, 749568, 774144, 0, 0, 862208, 0, 905216, 917504,
  0, 671744, 864256, 112640, 0, 2, 45059, 4, 202, 0, 0, 0, 0, 0, 206, 0, 0, 0, 0, 0, 297, 0, 314, 314, 314, 314, 333,
  314, 314, 333, 333, 0, 0, 0, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360,
  143360, 143360, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 143360, 143360, 0, 0, 2, 45059, 4, 1098144, 0, 0, 0, 418, 0, 0, 0, 0,
  1604, 0, 0, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307, 0, 307, 307, 253, 0, 349, 349, 349, 349, 349, 349, 308, 349, 349,
  370, 370, 370, 370, 370, 393, 370, 370, 393, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 805, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 108957, 108957, 108957, 108957, 108957, 108957, 108957, 370, 370, 370, 370, 370, 370, 370, 370, 370, 393, 393,
  393, 393, 393, 393, 393, 0, 0, 211, 212, 0, 0, 0, 0, 424, 0, 0, 427, 428, 0, 0, 0, 0, 945, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1004, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 483, 0, 0, 0, 424, 0, 0, 0, 0, 0, 298, 0, 316, 316, 316, 316, 335, 316,
  316, 335, 343, 0, 510, 307, 307, 514, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 537, 307, 307, 307, 0, 0, 0,
  0, 0, 544, 0, 0, 0, 0, 0, 0, 441, 369, 369, 577, 369, 369, 369, 369, 369, 369, 602, 604, 369, 609, 369, 612, 369, 369,
  369, 369, 369, 1537, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1552, 369, 369, 0, 0, 369, 623, 369, 369,
  369, 0, 391, 391, 391, 634, 391, 391, 391, 391, 391, 391, 391, 1117, 391, 391, 391, 391, 391, 391, 391, 391, 900, 391,
  391, 391, 391, 391, 391, 391, 659, 661, 391, 666, 391, 669, 391, 391, 680, 391, 391, 0, 0, 0, 26821, 5, 0, 0, 244,
  244, 0, 0, 0, 0, 0, 0, 0, 721, 0, 0, 0, 0, 0, 81920, 0, 81920, 0, 0, 0, 0, 0, 0, 0, 0, 226, 22528, 24576, 0, 252, 252,
  0, 20480, 921, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1160, 1046, 369, 369,
  369, 369, 369, 369, 369, 369, 1056, 369, 369, 369, 369, 369, 369, 0, 0, 0, 1440, 0, 1098, 0, 0, 0, 1442, 0, 0, 0,
  1163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 953, 0, 0, 0, 307, 1229, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
  1239, 0, 0, 1241, 0, 0, 0, 1239, 369, 369, 369, 369, 369, 1249, 369, 1251, 369, 369, 1254, 369, 369, 369, 369, 369,
  1705, 369, 369, 369, 369, 369, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 369, 369, 1918, 1919, 391, 391, 391, 1156, 0,
  1158, 0, 0, 1342, 0, 0, 0, 0, 0, 1347, 0, 0, 0, 253, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530432, 738, 0, 0, 369, 369,
  369, 1437, 369, 369, 0, 1439, 0, 0, 0, 0, 0, 1441, 0, 0, 0, 0, 1679, 0, 0, 0, 1683, 0, 0, 1686, 307, 307, 307, 307,
  780, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1033, 307, 307, 1036, 0, 391, 1469, 391, 391, 391, 391,
  391, 391, 391, 1474, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 369, 369, 369, 369, 1865, 369, 1867, 0, 1481, 0, 0, 0, 0, 1485,
  0, 0, 0, 0, 0, 0, 1488, 0, 0, 0, 0, 1771, 0, 0, 1774, 1775, 0, 0, 0, 0, 307, 369, 369, 369, 369, 369, 369, 1784, 369,
  369, 369, 391, 1788, 391, 391, 391, 391, 0, 0, 369, 369, 391, 391, 369, 391, 369, 391, 369, 391, 1545, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1439, 0, 0, 0, 267, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 22528,
  24576, 0, 0, 0, 0, 20480, 1627, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1639, 369, 369, 369, 369,
  369, 590, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1754, 369, 391, 391, 391, 0, 0, 1882, 1883, 0, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 391, 391, 1846, 391, 391, 391, 391, 391, 391, 218, 219, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 447, 995, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 477, 0, 0, 0, 995, 307, 307, 307, 307,
  307, 307, 307, 307, 307, 307, 307, 307, 0, 1240, 0, 0, 1409, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 621, 0, 0, 391, 391, 391, 1445, 1446, 391, 391, 391, 391, 391, 391, 391, 391, 391, 913, 391,
  391, 391, 391, 391, 391, 369, 1838, 369, 1840, 369, 1842, 369, 391, 391, 391, 391, 1848, 391, 1850, 391, 1852, 0, 0,
  220, 221, 222, 223, 224, 225, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 263, 0, 285, 292, 292, 292, 292, 0, 302,
  309, 309, 309, 309, 329, 309, 309, 329, 329, 309, 344, 346, 350, 350, 350, 358, 358, 359, 359, 350, 359, 359, 359,
  350, 359, 359, 359, 359, 359, 359, 309, 359, 359, 371, 371, 371, 371, 371, 394, 371, 371, 394, 26821, 26821, 2, 45059,
  4, 5, 0, 0, 0, 0, 0, 0, 806, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 371,
  371, 371, 371, 371, 371, 371, 371, 371, 394, 394, 394, 394, 394, 394, 394, 0, 0, 244, 244, 0, 0, 0, 718, 700, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 481, 774, 307, 307, 307, 307, 307, 307, 307, 307, 784, 307, 307, 307, 307, 307,
  307, 782, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1237, 307, 0, 0, 0, 0, 0, 0, 803, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 307, 369, 1778, 369, 369, 369, 825, 369, 829, 369, 369, 369, 369, 369, 835, 369, 369, 369, 369, 369, 0,
  391, 391, 391, 391, 391, 645, 391, 391, 391, 391, 0, 0, 369, 369, 391, 391, 369, 391, 369, 391, 1937, 1938, 369, 626,
  43881, 814, 629, 876, 391, 879, 391, 391, 391, 391, 886, 391, 890, 391, 0, 0, 0, 0, 0, 0, 0, 1733, 0, 0, 0, 0, 0, 0,
  0, 321, 321, 321, 321, 338, 321, 321, 338, 338, 369, 369, 369, 369, 1078, 1079, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 1542, 369, 369, 369, 369, 391, 391, 1125, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 904, 391, 391, 391, 1138, 1139, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 918, 391,
  391, 307, 307, 307, 307, 1523, 307, 307, 307, 307, 0, 0, 1527, 0, 369, 369, 369, 369, 369, 369, 1098, 1100, 43881,
  1103, 1100, 391, 391, 391, 391, 391, 391, 1116, 391, 391, 391, 391, 391, 391, 391, 391, 391, 681, 391, 0, 0, 0, 26821,
  5, 391, 391, 1568, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1311, 391, 391, 307, 307, 307,
  1617, 307, 0, 0, 1621, 369, 369, 369, 369, 369, 369, 369, 369, 833, 369, 369, 369, 369, 369, 369, 369, 1656, 1657,
  391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 1803, 1804, 0, 391, 391, 391, 391, 1826, 0, 1827, 0, 0,
  0, 0, 0, 0, 369, 369, 369, 1887, 369, 1888, 369, 369, 369, 391, 391, 1837, 369, 369, 369, 369, 369, 369, 391, 391,
  391, 1847, 391, 391, 391, 391, 391, 391, 899, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1307, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 1930, 0, 0, 369, 369, 391, 391, 369, 391, 369, 391, 369, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 233, 0, 252, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 751616, 0, 0, 227, 266, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 226, 0, 0, 0, 0, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 1379, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 708, 0, 0,
  711, 0, 0, 310, 330, 347, 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 310, 351, 351, 372, 372,
  372, 372, 372, 395, 372, 372, 372, 372, 372, 372, 372, 372, 372, 372, 395, 395, 395, 395, 395, 395, 395, 372, 372,
  395, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 812, 813, 0, 805, 0, 814, 369, 369, 369, 369, 0, 0, 307, 307,
  307, 307, 307, 307, 307, 527, 307, 307, 307, 307, 307, 307, 1233, 307, 307, 307, 307, 307, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  550, 0, 0, 0, 0, 550, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0, 0, 0, 0, 0, 947, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1356, 0, 0, 0, 0, 0,
  0, 0, 727, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 216, 0, 307, 307, 307, 791, 307, 307, 793, 307, 307, 307, 307,
  307, 307, 307, 800, 0, 0, 0, 274, 250, 0, 250, 0, 0, 22528, 24576, 250, 0, 0, 0, 20480, 810, 0, 710, 0, 0, 709, 0, 0,
  0, 0, 0, 814, 816, 369, 369, 369, 369, 369, 369, 1099, 1100, 43881, 1104, 1100, 391, 391, 391, 391, 391, 391, 1797, 0,
  1799, 0, 0, 0, 1802, 0, 0, 1805, 369, 626, 43881, 814, 629, 877, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  682, 0, 0, 0, 26821, 5, 391, 894, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1151, 391,
  391, 391, 391, 908, 391, 391, 910, 391, 912, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 369, 1902, 369, 369,
  1161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 508, 0, 0, 1190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 0, 0, 0, 0,
  0, 0, 0, 0, 369, 369, 369, 1283, 1284, 369, 369, 0, 0, 0, 0, 1100, 0, 0, 0, 0, 0, 106496, 106496, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 735, 0, 0, 0, 0, 0, 0, 1338, 391, 391, 1156, 0, 1158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 736, 0, 0, 0, 0, 0, 0, 0, 0,
  1391, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 787, 307, 0, 0, 391, 391, 1444, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 1309, 391, 391, 391, 391, 307, 307, 1522, 307, 307, 307, 307, 307, 307,
  0, 0, 0, 0, 369, 369, 369, 1248, 369, 369, 369, 369, 369, 369, 369, 369, 1708, 369, 369, 391, 391, 391, 391, 391, 369,
  1546, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1439, 0, 0, 0, 307, 307, 1393, 307, 307, 307, 307,
  1396, 307, 307, 307, 307, 307, 792, 307, 307, 307, 307, 307, 307, 307, 307, 0, 0, 0, 0, 0, 0, 369, 369, 1407, 369,
  1441, 0, 391, 391, 391, 391, 391, 391, 391, 391, 1562, 391, 391, 391, 391, 391, 391, 928, 391, 391, 391, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1346, 0, 0, 369, 369, 1808, 369, 369, 369, 369, 369, 369, 369, 391, 391, 1818, 391, 391, 391, 0, 0,
  0, 0, 0, 0, 1584, 0, 0, 0, 0, 0, 0, 0, 1682, 0, 0, 0, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1398, 307,
  307, 369, 369, 1839, 369, 369, 369, 369, 391, 391, 391, 391, 391, 1849, 391, 391, 391, 0, 0, 0, 0, 0, 1583, 0, 0, 0,
  0, 0, 0, 0, 257, 0, 258, 259, 0, 0, 0, 0, 0, 0, 0, 228, 251, 230, 249, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 753, 0, 0, 0, 0,
  0, 0, 0, 229, 0, 229, 295, 304, 311, 311, 311, 311, 331, 311, 311, 341, 331, 311, 331, 331, 352, 352, 352, 352, 352,
  352, 352, 361, 352, 352, 352, 361, 352, 352, 352, 352, 352, 352, 311, 352, 352, 373, 373, 373, 373, 373, 396, 373,
  373, 396, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 1166, 0, 0, 0, 0, 0, 0, 0, 0, 0, 281, 281, 0, 0, 0, 0, 281,
  373, 373, 373, 373, 373, 373, 373, 373, 373, 396, 396, 396, 396, 396, 396, 396, 0, 433, 434, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 446, 0, 0, 0, 307, 1392, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 797, 307, 799, 0, 0, 0, 463,
  0, 0, 0, 0, 0, 0, 0, 471, 0, 0, 0, 0, 0, 0, 1179, 0, 0, 0, 1183, 1184, 0, 0, 0, 0, 478, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 490, 0, 0, 307, 307, 307, 516, 307, 307, 524, 307, 530, 307, 533, 307, 536, 307, 0, 283, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 307, 307, 307, 0, 0, 0, 0, 0, 0, 0, 0, 548, 0, 553, 0, 556, 548, 0, 565, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 565, 0, 0, 0, 0, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108835, 369, 369, 369, 580,
  369, 369, 591, 369, 600, 369, 605, 369, 369, 611, 614, 618, 391, 662, 391, 391, 668, 671, 675, 391, 391, 391, 391, 0,
  0, 0, 26821, 5, 0, 0, 702, 0, 0, 0, 705, 0, 0, 0, 0, 0, 0, 0, 0, 713, 714, 0, 244, 244, 0, 0, 0, 0, 0, 0, 720, 0, 0,
  0, 0, 0, 299, 0, 307, 307, 307, 307, 0, 307, 307, 0, 0, 726, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 478, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 436, 369, 853, 369, 369, 369, 369, 369, 369, 369, 369, 369, 863, 369, 369, 369, 869, 369,
  626, 43881, 814, 629, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 891, 391, 391, 391, 895, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 905, 391, 391, 391, 391, 924, 391, 391, 391, 930, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1734, 1735, 0, 0, 0, 1739, 0, 0, 0, 944, 0, 946, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 772, 814, 369, 369, 369, 369, 0, 0,
  958, 0, 960, 961, 0, 963, 0, 0, 0, 0, 968, 0, 0, 0, 0, 989, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 967, 0, 0, 0, 0, 0, 973,
  0, 0, 0, 0, 978, 0, 0, 0, 0, 0, 0, 0, 986, 0, 0, 0, 435, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1171, 0, 0, 0, 1010, 0,
  0, 0, 307, 1014, 1015, 307, 307, 307, 307, 307, 1021, 307, 307, 1023, 0, 0, 1038, 0, 0, 1041, 0, 0, 0, 0, 0, 946, 946,
  814, 1045, 369, 369, 369, 369, 583, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1058, 369, 369, 369,
  369, 1047, 369, 1049, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1060, 369, 369, 369, 369, 584, 369, 369, 596,
  369, 369, 369, 369, 369, 369, 369, 369, 1786, 369, 391, 391, 391, 391, 391, 391, 369, 369, 1063, 369, 369, 369, 369,
  369, 369, 369, 1070, 369, 369, 369, 369, 1073, 1074, 369, 1076, 1077, 369, 369, 369, 369, 1082, 369, 1084, 369, 369,
  369, 369, 369, 0, 391, 391, 391, 391, 391, 391, 391, 391, 652, 391, 1090, 369, 369, 369, 369, 1095, 0, 1100, 43881, 0,
  1100, 1105, 391, 391, 1107, 391, 0, 0, 0, 0, 0, 0, 1732, 0, 0, 0, 0, 0, 0, 0, 0, 1168, 0, 0, 0, 0, 0, 0, 0, 1109, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 1120, 391, 391, 391, 1123, 1137, 391, 391, 391, 391, 1142, 391, 1144,
  391, 391, 391, 391, 391, 1150, 391, 391, 391, 391, 391, 1128, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1333,
  391, 391, 391, 391, 391, 391, 391, 1155, 0, 1156, 0, 0, 0, 0, 0, 1158, 0, 0, 0, 0, 0, 300, 0, 307, 307, 307, 307, 0,
  307, 307, 0, 0, 1188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 991, 0, 0, 0, 465, 466, 0, 0, 0, 0, 0, 0, 0, 0, 0, 476,
  0, 0, 0, 684, 688, 0, 681984, 0, 0, 694272, 0, 0, 0, 0, 0, 0, 0, 948, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 546, 0, 0, 0, 1204, 0, 0, 0, 0, 0, 0, 0, 1212, 0, 1214, 0, 0, 0, 0, 75776, 0, 75776, 0, 75776, 0, 0, 0, 0,
  75776, 0, 0, 0, 0, 75776, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 0, 0, 0, 0, 0, 1217, 0, 0, 0, 0, 307, 307, 307,
  307, 307, 307, 1225, 307, 307, 307, 307, 307, 1524, 307, 307, 307, 0, 0, 0, 1528, 369, 369, 369, 1256, 369, 1258, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1279, 369, 391, 1326, 1327, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 1465, 391, 391, 391, 1339, 391, 1156, 0, 1158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  807, 0, 0, 0, 0, 0, 0, 0, 1350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1361, 0, 0, 0, 685, 689, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 695, 0, 0, 0, 0, 0, 0, 1364, 0, 1366, 1367, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 949, 0, 0, 814, 369, 369, 0, 0, 1377,
  0, 0, 0, 0, 1380, 0, 0, 0, 0, 0, 0, 0, 0, 436, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 1401, 307, 307, 307, 307, 0, 0,
  0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 1250, 369, 369, 369, 369, 369, 369, 369, 369, 1424, 369, 1426, 369, 369,
  369, 369, 369, 369, 1433, 369, 369, 369, 369, 369, 369, 1261, 369, 369, 1264, 369, 369, 369, 369, 369, 369, 369, 1428,
  369, 369, 369, 369, 369, 369, 369, 369, 1068, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1436, 369, 369, 369, 0,
  1439, 0, 0, 0, 0, 0, 1441, 0, 0, 0, 0, 77824, 0, 0, 77824, 77824, 43398, 43398, 43398, 43398, 43398, 43398, 43398, 0,
  0, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1452, 391, 0, 0, 0, 0, 0, 1859, 1860, 0, 369, 369, 369,
  369, 369, 369, 369, 860, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1815, 391, 391, 391, 391, 391, 391, 391, 391,
  1470, 391, 391, 391, 391, 391, 1473, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1586, 0, 0, 0, 0, 1493, 0, 0, 0, 0,
  0, 0, 1500, 0, 0, 0, 0, 0, 0, 1353, 0, 0, 0, 1357, 0, 1359, 0, 0, 0, 369, 369, 369, 1535, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 1544, 369, 369, 369, 369, 586, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  1277, 369, 369, 369, 1441, 0, 391, 391, 391, 391, 391, 391, 1560, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0,
  1901, 369, 369, 369, 391, 391, 391, 1569, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0,
  0, 307, 307, 1616, 307, 1618, 1619, 1620, 0, 369, 369, 369, 1625, 369, 369, 369, 369, 369, 0, 391, 391, 391, 391, 637,
  391, 391, 648, 391, 657, 369, 369, 369, 1630, 369, 369, 1633, 369, 369, 369, 369, 369, 1638, 1640, 369, 1642, 1643,
  391, 391, 391, 1647, 391, 391, 391, 391, 391, 391, 391, 1652, 391, 391, 1655, 1671, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 699, 369, 369, 1702, 369, 369, 369, 369, 369, 369, 369, 369, 391, 391, 1712, 391, 391, 391, 391, 391,
  1303, 391, 1305, 391, 391, 1308, 391, 391, 391, 391, 391, 391, 678, 391, 391, 391, 391, 0, 0, 0, 26821, 5, 369, 369,
  1780, 369, 369, 369, 369, 369, 369, 369, 391, 391, 391, 391, 1790, 391, 0, 0, 0, 0, 1731, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1514, 1515, 0, 1517, 1518, 307, 391, 391, 391, 1825, 0, 0, 0, 0, 0, 0, 0, 0, 0, 369, 369, 1836, 391, 1854, 1855, 0,
  0, 0, 0, 0, 0, 1862, 369, 369, 1864, 369, 1866, 369, 369, 369, 369, 587, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 1085, 369, 369, 369, 369, 369, 369, 369, 1871, 391, 391, 1873, 391, 1875, 391, 391, 391, 391, 0, 0, 0, 0,
  1829, 0, 0, 0, 0, 369, 369, 369, 369, 1906, 391, 1908, 391, 391, 391, 1912, 0, 0, 0, 0, 369, 369, 369, 369, 369, 0,
  391, 391, 391, 391, 638, 391, 391, 391, 391, 391, 391, 1129, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1145, 391,
  391, 391, 391, 391, 391, 391, 0, 0, 247, 0, 0, 0, 0, 247, 247, 22528, 24576, 0, 0, 0, 286, 20480, 286, 286, 286, 286,
  286, 0, 286, 312, 312, 312, 312, 0, 312, 312, 0, 0, 0, 0, 663552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 237, 261, 0,
  0, 312, 247, 247, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 312, 286, 286, 374, 374, 374, 374,
  374, 397, 374, 374, 374, 374, 374, 374, 374, 374, 374, 374, 397, 397, 397, 397, 397, 397, 397, 374, 374, 397, 26821,
  26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 1497, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88476, 88476, 88476, 88476, 88476, 88476,
  88476, 0, 0, 244, 244, 0, 0, 0, 0, 701, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 762, 0, 0, 0, 0, 0,
  0, 701, 0, 0, 0, 0, 307, 307, 307, 307, 1018, 307, 307, 307, 307, 307, 307, 307, 1402, 0, 0, 0, 0, 0, 369, 369, 369,
  1408, 307, 307, 307, 778, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1035, 307, 0, 369, 369,
  369, 826, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1278, 369, 369, 369, 626, 43881, 814, 629,
  391, 391, 391, 391, 391, 391, 391, 887, 391, 391, 391, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 0, 0, 0, 0, 1381, 1382, 0, 0,
  1385, 0, 0, 0, 0, 1390, 0, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 0, 801, 1400, 307,
  307, 307, 307, 307, 0, 0, 0, 0, 0, 0, 369, 369, 369, 369, 369, 0, 391, 391, 391, 636, 639, 391, 646, 391, 391, 391,
  1468, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 1670, 369, 369, 1907, 391, 391, 391, 391,
  391, 0, 0, 0, 0, 369, 369, 369, 369, 369, 0, 391, 391, 631, 391, 391, 391, 391, 649, 391, 391, 1929, 391, 391, 391, 0,
  0, 369, 369, 391, 391, 369, 391, 369, 391, 369, 391, 391, 391, 391, 391, 391, 391, 391, 1649, 391, 391, 391, 391, 391,
  391, 391, 1130, 391, 391, 391, 391, 1133, 1134, 391, 1136, 287, 287, 287, 287, 287, 296, 287, 313, 313, 313, 313, 332,
  313, 313, 332, 332, 353, 353, 353, 353, 353, 353, 353, 353, 353, 353, 353, 353, 353, 313, 353, 353, 375, 375, 375,
  375, 375, 398, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 398, 398, 398, 398, 398, 398, 398, 375, 375, 398,
  26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 1510, 0, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307, 307, 1224, 307, 307,
  307, 307, 307, 759, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 307, 1614, 1589, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1595,
  0, 0, 0, 1598, 0, 0, 0, 686, 690, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 754, 0, 0, 0, 0, 0, 0, 0, 1603, 0, 0, 0, 0, 0,
  1608, 0, 0, 0, 307, 307, 307, 307, 1394, 307, 307, 307, 307, 307, 307, 307, 307, 1234, 307, 307, 307, 307, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307, 307, 0, 0, 0, 369, 1693, 369, 369, 369, 369, 369, 369, 369, 1700,
  369, 369, 369, 369, 588, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1265, 369, 1267, 369, 369, 369, 369,
  369, 1703, 369, 369, 369, 369, 369, 369, 369, 391, 1711, 391, 391, 391, 0, 0, 0, 1157, 0, 686, 0, 0, 0, 1159, 0, 690,
  0, 391, 391, 391, 391, 1718, 391, 391, 391, 391, 1721, 391, 391, 391, 391, 391, 391, 391, 1319, 391, 1321, 391, 391,
  391, 391, 391, 1324, 0, 0, 0, 1741, 0, 307, 307, 1742, 307, 307, 0, 369, 369, 369, 369, 369, 0, 391, 391, 391, 391,
  391, 391, 647, 391, 391, 391, 1745, 369, 369, 369, 369, 369, 369, 1751, 369, 369, 369, 369, 369, 391, 391, 391, 391,
  391, 391, 0, 0, 0, 0, 1927, 369, 369, 369, 391, 391, 1757, 391, 391, 391, 391, 391, 391, 1763, 391, 391, 391, 391,
  391, 0, 0, 0, 1828, 0, 0, 1831, 1832, 0, 369, 369, 369, 369, 369, 391, 391, 1922, 1923, 391, 391, 0, 0, 0, 0, 369,
  369, 369, 369, 369, 0, 391, 391, 632, 391, 391, 391, 391, 391, 655, 391, 448, 449, 0, 244, 244, 244, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 951, 0, 0, 0, 0, 0, 0, 492, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 307, 307, 542, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 696, 0, 0, 369, 369, 578, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 1420, 369, 369, 369, 624, 369, 369, 0, 391, 391, 391, 635, 391, 391, 391, 391, 391, 391, 391, 1459, 391, 391,
  391, 391, 391, 391, 391, 1467, 0, 0, 244, 244, 0, 0, 0, 0, 0, 0, 0, 0, 722, 0, 0, 0, 0, 1164, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 53572, 0, 0, 53572, 53572, 0, 0, 1162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 697, 698, 0, 0, 1363, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 489, 0, 391, 391, 391, 391, 1471, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0,
  369, 369, 369, 369, 314, 333, 333, 354, 333, 333, 333, 333, 333, 333, 362, 333, 333, 333, 362, 333, 333, 333, 333,
  333, 333, 314, 333, 333, 376, 376, 376, 376, 376, 399, 376, 376, 399, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0,
  1672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 0, 20480, 376, 376, 376, 376, 376, 376, 376, 376, 376, 399,
  399, 399, 399, 399, 399, 399, 0, 0, 450, 244, 244, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 966, 0, 0, 0, 0, 0, 0, 0, 307,
  307, 307, 517, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1238, 0, 0, 0, 0, 307, 307, 307, 0, 0, 0, 0, 0,
  0, 545, 0, 0, 0, 0, 0, 0, 51200, 0, 0, 0, 0, 51200, 0, 0, 51200, 51200, 369, 369, 369, 581, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 1419, 369, 369, 369, 821, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 0, 0, 369, 840, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 613, 369,
  369, 626, 43881, 814, 629, 391, 391, 391, 391, 391, 882, 391, 391, 391, 391, 391, 391, 1143, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 1147, 1148, 391, 391, 391, 391, 391, 391, 922, 391, 391, 391, 391, 927, 391, 391, 391, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1587, 0, 0, 0, 0, 959, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 984, 0, 0, 987, 0, 0, 974, 0, 0, 0, 0,
  0, 980, 0, 0, 0, 0, 985, 0, 0, 0, 0, 677888, 555008, 555008, 555008, 555008, 555008, 555008, 735232, 555008, 555008,
  751616, 555008, 0, 0, 1012, 0, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 786, 307, 307, 307, 369,
  369, 369, 1093, 369, 369, 0, 1100, 43881, 0, 1100, 391, 391, 391, 391, 391, 391, 1304, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 931, 0, 0, 0, 0, 937, 0, 391, 391, 391, 391, 1141, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 1322, 391, 391, 391, 391, 1153, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814, 369, 369, 369, 369, 391,
  391, 391, 1302, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 1479, 1362, 0, 0, 0, 0, 0, 0, 0,
  1369, 0, 0, 0, 0, 1374, 0, 0, 0, 215, 0, 0, 98304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 391, 391, 391,
  391, 1457, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1475, 0, 0, 0, 0, 1520, 307, 307, 307, 307, 307,
  307, 1525, 307, 0, 0, 0, 0, 369, 1530, 369, 369, 369, 369, 828, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  1086, 369, 369, 369, 369, 369, 1533, 369, 369, 369, 369, 369, 369, 369, 369, 1541, 369, 369, 369, 369, 369, 0, 391,
  391, 391, 391, 391, 640, 391, 391, 391, 391, 369, 369, 369, 1547, 369, 369, 1549, 369, 369, 369, 1551, 369, 369, 369,
  0, 0, 0, 216, 0, 0, 301, 308, 308, 308, 308, 328, 308, 308, 328, 328, 349, 349, 349, 349, 349, 349, 349, 360, 349,
  349, 349, 360, 349, 0, 0, 391, 1555, 391, 391, 1558, 391, 391, 391, 391, 391, 391, 391, 391, 1566, 391, 391, 391,
  1579, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 993, 0, 0, 0, 307, 1615, 307, 307, 307, 0, 0, 0, 369, 369, 369, 369, 369,
  369, 369, 369, 1699, 369, 369, 1628, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1637, 369, 369, 369, 369, 369,
  0, 391, 391, 633, 391, 391, 391, 391, 650, 656, 658, 369, 391, 391, 391, 391, 391, 391, 391, 391, 1650, 391, 391, 391,
  391, 391, 391, 391, 1663, 391, 391, 0, 0, 0, 1668, 0, 0, 391, 391, 391, 391, 1659, 391, 391, 391, 391, 391, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 1810, 369, 1812, 1813, 1814, 369, 391, 391, 391, 391, 1820, 391,
  0, 0, 0, 0, 1858, 0, 0, 1861, 369, 369, 369, 369, 369, 369, 369, 0, 0, 0, 0, 1100, 0, 0, 0, 0, 1822, 1823, 1824, 391,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 1286, 0, 0, 0, 0, 1100, 0, 0, 0, 0, 369, 1246, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 847, 369, 369, 849, 369, 851, 391, 1893, 391, 1894, 391, 391, 391, 0, 0, 0, 0, 0,
  369, 369, 369, 369, 369, 369, 369, 1550, 369, 369, 369, 369, 369, 369, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 0, 0, 0,
  260, 0, 288, 288, 288, 288, 288, 0, 288, 315, 315, 315, 315, 334, 315, 315, 334, 334, 355, 355, 355, 355, 355, 355,
  355, 355, 355, 355, 355, 355, 355, 315, 355, 366, 377, 377, 377, 377, 377, 400, 377, 377, 377, 377, 377, 377, 377,
  377, 377, 377, 400, 400, 400, 400, 400, 400, 400, 377, 377, 400, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0,
  133120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 24576, 0, 0, 0, 287,
  20480, 0, 0, 307, 307, 307, 307, 518, 307, 307, 307, 307, 307, 307, 307, 307, 307, 0, 0, 0, 0, 1529, 369, 369, 307,
  307, 776, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 0, 0, 369, 369, 822, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 836, 369, 369, 369, 369, 369, 369, 1287, 1439, 0, 0, 0, 0, 1293, 1441, 0, 0,
  369, 626, 43881, 814, 629, 391, 391, 391, 391, 391, 391, 883, 391, 391, 391, 391, 0, 0, 369, 369, 391, 391, 369, 391,
  1935, 1936, 369, 391, 369, 369, 369, 369, 1051, 1052, 369, 369, 1055, 369, 369, 369, 369, 369, 369, 369, 0, 1289, 0,
  0, 1100, 0, 1295, 0, 0, 369, 369, 369, 1064, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1543,
  369, 369, 391, 1111, 1112, 391, 391, 1115, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 901, 391, 391, 391, 391,
  391, 1124, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1727, 0, 0, 1203, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 969, 0, 0, 0, 0, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1450, 391, 391, 391, 0, 0,
  0, 1582, 0, 0, 0, 0, 0, 1585, 0, 0, 0, 0, 976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1372, 0, 0, 0, 0, 0, 0, 1482, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1172, 0, 0, 0, 0, 1506, 0, 0, 0, 0, 0, 1512, 0, 0, 0, 0, 0, 307, 1519, 1532, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 839, 0, 0, 391, 391, 391, 1557, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 914, 391, 391, 391, 391, 391, 369, 369, 391, 1921, 391, 391, 391, 391, 0, 0, 0, 0, 369,
  369, 369, 369, 369, 369, 369, 1634, 1635, 369, 369, 369, 369, 369, 369, 369, 0, 0, 0, 1292, 1100, 0, 0, 0, 1298, 316,
  335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 316, 335, 335, 378, 378, 378, 378, 378,
  401, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 401, 401, 401, 401, 401, 401, 401, 378, 378, 401, 26821, 27039,
  2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 143360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1182, 0, 0, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307,
  519, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1031, 307, 307, 307, 307, 0, 0, 0, 745, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1186, 0, 0, 369, 369, 823, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1434,
  369, 369, 626, 43881, 814, 629, 391, 391, 391, 391, 391, 391, 884, 391, 391, 391, 391, 0, 0, 369, 369, 391, 391, 1933,
  1934, 369, 391, 369, 391, 391, 391, 391, 391, 909, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 920, 940, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 954, 0, 0, 0, 244, 244, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 141312,
  141312, 956, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 747, 391, 391, 391, 1113, 391, 391, 391, 391, 391, 391,
  1119, 391, 391, 391, 391, 391, 391, 1472, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 1830, 0, 0, 1833, 369, 1835, 369, 0,
  0, 1177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1360, 0, 0, 369, 1257, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 617, 369, 391, 391, 391, 391, 1796, 391, 0, 0, 0, 1800, 0, 0, 0, 0, 0, 0, 415744, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 77824, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 234, 0, 0, 0, 0, 1205, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 443, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 0, 258, 0, 0, 22528, 24576,
  258, 0, 234, 0, 20480, 317, 342, 336, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342, 317, 342, 342,
  379, 379, 379, 379, 379, 402, 379, 379, 379, 379, 379, 379, 379, 379, 379, 379, 402, 402, 402, 402, 402, 402, 402,
  379, 379, 402, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 681984, 0, 0, 694272, 0, 0, 0, 0, 0, 0, 0, 475, 508, 0,
  0, 469, 0, 0, 0, 0, 509, 0, 307, 512, 307, 307, 520, 307, 307, 528, 307, 307, 307, 534, 307, 307, 0, 0, 0, 369, 369,
  369, 369, 1695, 1696, 1697, 369, 369, 369, 369, 369, 369, 369, 1844, 391, 391, 391, 391, 391, 391, 391, 391, 1131,
  391, 391, 391, 391, 391, 391, 391, 307, 541, 307, 0, 0, 0, 0, 543, 0, 0, 0, 0, 551, 0, 0, 0, 0, 1219, 307, 307, 307,
  307, 1223, 307, 307, 307, 307, 307, 307, 0, 0, 0, 1622, 369, 369, 369, 369, 369, 369, 369, 832, 369, 369, 369, 369,
  369, 369, 369, 369, 594, 369, 369, 369, 369, 369, 369, 369, 369, 861, 369, 369, 369, 369, 866, 369, 369, 0, 0, 560, 0,
  456, 0, 0, 0, 0, 0, 0, 0, 543, 0, 0, 437, 0, 564, 0, 509, 0, 0, 0, 543, 437, 570, 0, 0, 0, 0, 0, 0, 686080, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 856064, 0, 0, 0, 0, 555008, 555008, 555008, 369, 573, 369, 369, 585, 369, 369, 597, 369, 369, 369,
  607, 369, 369, 369, 369, 369, 369, 369, 1707, 369, 369, 369, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 369, 369, 369,
  1928, 622, 369, 369, 369, 369, 0, 391, 391, 630, 391, 391, 642, 391, 391, 654, 391, 0, 0, 1729, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1006, 0, 0, 1009, 391, 391, 664, 391, 391, 391, 391, 679, 391, 391, 391, 0, 0, 0, 26821, 5, 0, 715,
  244, 244, 716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 983, 0, 0, 0, 0, 0, 811, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814, 369, 369,
  369, 369, 369, 369, 369, 1785, 369, 369, 1787, 391, 391, 391, 391, 391, 670, 391, 391, 391, 391, 391, 0, 0, 0, 26821,
  5, 391, 391, 391, 391, 1114, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1723, 391, 391, 391, 391, 0, 0,
  1244, 0, 369, 369, 1247, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1069, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 1271, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1087, 1088, 369, 369, 369, 369, 1282, 369,
  369, 369, 369, 0, 0, 0, 0, 1100, 0, 0, 0, 0, 242, 0, 242, 0, 0, 22528, 24576, 242, 0, 0, 290, 20480, 391, 391, 1301,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1725, 391, 391, 1325, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 1336, 391, 0, 0, 1856, 1857, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 1255, 1349, 0, 0, 0, 1352, 0, 0, 1354, 0, 0, 0, 1358, 0, 0, 0, 0, 271, 0, 271, 0, 0, 22528, 24576, 271,
  0, 0, 0, 20480, 1389, 0, 0, 307, 307, 307, 307, 307, 1395, 307, 307, 307, 1397, 307, 307, 1399, 369, 369, 369, 1411,
  369, 369, 369, 1414, 369, 1416, 369, 369, 369, 369, 369, 369, 0, 0, 1291, 0, 0, 0, 0, 0, 1297, 0, 369, 1422, 369, 369,
  369, 369, 369, 369, 369, 1430, 369, 369, 369, 369, 369, 369, 0, 0, 43881, 0, 0, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 1122, 391, 0, 0, 391, 391, 391, 391, 391, 391, 391, 1448, 391, 391, 391, 1451, 391,
  1453, 0, 0, 0, 1507, 1508, 0, 0, 1511, 0, 0, 0, 0, 0, 0, 307, 307, 307, 307, 307, 307, 307, 307, 1226, 307, 307, 0, 0,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 1563, 391, 391, 391, 391, 0, 0, 369, 1931, 391, 1932, 369, 391, 369, 391,
  369, 391, 369, 369, 369, 369, 1631, 1632, 369, 369, 369, 369, 1636, 369, 369, 369, 369, 369, 0, 391, 391, 391, 391,
  391, 641, 391, 391, 653, 391, 369, 391, 1645, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1653, 1654, 391, 369,
  369, 391, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 485, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 0, 0, 0, 0, 0, 0, 0,
  391, 391, 391, 1658, 391, 391, 391, 391, 391, 391, 0, 0, 1667, 0, 0, 0, 0, 1245, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 848, 369, 369, 369, 369, 369, 369, 369, 369, 1704, 369, 369, 369, 369, 369, 369, 391, 391, 391,
  391, 1713, 1714, 1715, 391, 391, 391, 391, 391, 391, 391, 391, 1722, 391, 391, 391, 391, 391, 391, 1571, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 1118, 391, 391, 391, 391, 391, 391, 369, 1746, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 936, 0, 0, 391, 391, 391, 1758, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 0, 0, 197, 5, 369, 369, 369, 369, 1782, 369, 369, 369, 369, 369,
  391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 1252, 369, 369, 369, 1792, 391, 391,
  391, 391, 391, 0, 1798, 0, 0, 0, 0, 0, 0, 0, 0, 707, 0, 0, 0, 0, 0, 0, 0, 369, 369, 369, 1809, 369, 369, 369, 369,
  369, 369, 391, 391, 391, 1819, 391, 391, 391, 391, 391, 1330, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 915,
  391, 391, 391, 391, 391, 369, 369, 369, 369, 1841, 369, 1843, 391, 391, 391, 391, 391, 391, 391, 1851, 391, 369, 369,
  391, 26821, 27039, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1499, 0, 0, 0, 0, 1503, 0, 0,
  1853, 0, 0, 0, 0, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 838, 369, 369, 369,
  369, 391, 391, 1909, 1910, 391, 391, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 830, 369, 369, 369, 834, 369, 369, 369,
  369, 369, 0, 391, 391, 391, 391, 391, 391, 391, 391, 651, 391, 0, 235, 236, 237, 238, 0, 0, 0, 0, 0, 0, 244, 0, 0, 0,
  0, 307, 307, 307, 1017, 307, 307, 307, 307, 307, 307, 307, 307, 1028, 307, 307, 307, 307, 307, 307, 307, 0, 0, 1404,
  0, 0, 0, 369, 369, 369, 369, 237, 237, 237, 237, 237, 0, 305, 318, 318, 318, 318, 337, 318, 318, 337, 337, 318, 345,
  348, 356, 356, 356, 356, 356, 356, 356, 356, 356, 356, 356, 356, 356, 318, 356, 356, 380, 380, 380, 380, 380, 403,
  380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 403, 403, 403, 403, 403, 403, 403, 380, 380, 403, 26821, 26821, 2,
  45059, 4, 5, 0, 0, 0, 0, 0, 0, 890880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 211, 211, 211, 211, 211, 211, 0, 0, 211, 212,
  0, 0, 0, 0, 0, 425, 0, 0, 0, 429, 430, 431, 432, 0, 0, 0, 0, 0, 0, 0, 440, 0, 0, 0, 0, 0, 0, 0, 268, 0, 0, 0, 0, 0, 0,
  0, 0, 1486, 0, 0, 0, 0, 0, 1489, 1490, 462, 0, 464, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1386, 0, 0, 0, 0, 307, 307,
  515, 307, 307, 523, 307, 307, 307, 532, 307, 307, 307, 307, 1027, 307, 307, 307, 1029, 307, 307, 307, 307, 307, 307,
  0, 0, 0, 1405, 0, 0, 369, 369, 369, 369, 539, 307, 307, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555, 0, 0, 0, 686, 690, 0, 0,
  0, 0, 0, 0, 0, 696, 0, 0, 0, 0, 1192, 0, 0, 0, 0, 0, 0, 1199, 0, 0, 0, 0, 0, 819200, 0, 839680, 0, 868352, 872448,
  925696, 0, 0, 0, 0, 0, 1509, 0, 0, 0, 1513, 0, 0, 0, 0, 307, 307, 307, 307, 307, 1019, 307, 307, 307, 307, 307, 307,
  0, 1403, 0, 0, 0, 0, 1406, 369, 369, 369, 0, 558, 0, 0, 0, 0, 561, 431, 0, 562, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 494, 0, 0, 369, 369, 579, 582, 369, 589, 369, 369, 369, 603, 606, 369, 369, 369, 615, 619, 660, 663, 391, 391, 391,
  672, 676, 391, 391, 391, 391, 0, 0, 0, 26821, 5, 0, 0, 728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0,
  122880, 122880, 0, 0, 761, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0, 369, 389, 389, 389, 369, 392, 389, 369, 854,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 867, 369, 369, 369, 369, 369, 858, 369, 369, 369, 369, 369,
  369, 369, 369, 868, 369, 369, 1091, 369, 369, 369, 369, 0, 1100, 43881, 0, 1100, 391, 391, 391, 391, 391, 391, 1661,
  391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1588, 391, 391, 391, 1316, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 0, 0, 1478, 0, 0, 1103, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  1726, 391, 0, 0, 1554, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1766, 391, 0, 1567, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1767, 369, 391, 391, 391, 391, 1648, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 1462, 391, 391, 391, 391, 391, 1768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 369,
  369, 369, 369, 369, 1065, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1432, 369, 369, 369, 369, 369, 1779,
  369, 369, 369, 369, 369, 369, 369, 369, 391, 391, 391, 1789, 391, 391, 391, 391, 391, 1570, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 0, 1666, 0, 0, 0, 0, 369, 1807, 369, 369, 369, 1811, 369, 369, 369, 369, 391, 1817, 391, 391,
  391, 1821, 381, 381, 381, 381, 381, 381, 381, 381, 381, 404, 404, 404, 404, 404, 404, 404, 381, 381, 404, 26821,
  26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 307, 307, 1221, 1222, 307, 307, 307, 307, 307, 307, 307, 783, 307, 307, 307,
  307, 307, 307, 307, 307, 1235, 1236, 307, 307, 0, 0, 0, 0, 742, 0, 746, 0, 0, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1609,
  0, 0, 1612, 307, 307, 0, 760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 369, 369, 0, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  814, 369, 369, 369, 369, 369, 369, 844, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1417, 369, 369, 369, 369,
  369, 369, 369, 369, 841, 369, 369, 369, 369, 369, 846, 369, 369, 369, 369, 369, 369, 0, 1439, 0, 0, 0, 0, 0, 1441, 0,
  0, 893, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 902, 391, 391, 391, 0, 0, 936, 0, 0, 0, 0, 0, 942, 0,
  0, 0, 0, 0, 0, 0, 950, 0, 0, 0, 0, 955, 0, 391, 391, 907, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 1323, 391, 391, 391, 941, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 758, 0, 0, 0, 1191, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1373, 0, 0, 0, 0, 1202, 0, 0, 0, 0, 0, 0, 1209, 0, 0, 0, 0, 0, 0, 0, 317, 317, 317, 317, 336, 317, 317,
  342, 342, 391, 391, 1315, 391, 391, 1318, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1332, 391, 391, 1334, 391,
  391, 391, 0, 0, 0, 1351, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1487, 0, 0, 0, 369, 369, 369, 369, 1425, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 1266, 369, 369, 369, 0, 1769, 0, 0, 0, 0, 1773, 0, 0, 0, 1776, 0, 0, 307,
  369, 369, 369, 369, 369, 1272, 1273, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1431, 369, 369, 369, 369, 369,
  0, 0, 307, 307, 307, 307, 521, 307, 307, 307, 307, 307, 307, 307, 307, 307, 796, 307, 307, 307, 307, 0, 0, 307, 307,
  307, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0, 0, 0, 369, 1886, 369, 369, 369, 369, 369, 369, 369, 391, 1892, 369, 369, 369,
  625, 369, 0, 391, 391, 391, 391, 391, 643, 391, 391, 391, 391, 391, 674, 391, 391, 391, 391, 391, 0, 0, 0, 26821, 5,
  391, 391, 391, 1717, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1476, 1477, 0, 0, 239, 239, 239, 239,
  239, 0, 239, 319, 319, 319, 319, 0, 319, 319, 0, 0, 239, 239, 239, 239, 239, 239, 239, 239, 239, 239, 239, 239, 239,
  319, 239, 239, 382, 382, 382, 382, 382, 405, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 405, 405, 405, 405,
  405, 405, 405, 382, 382, 405, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 437, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  22528, 24576, 0, 283, 283, 0, 20480, 444, 0, 307, 307, 307, 307, 307, 307, 525, 307, 307, 307, 307, 535, 307, 307, 0,
  0, 0, 369, 369, 1694, 369, 369, 369, 369, 369, 369, 369, 369, 1263, 369, 369, 369, 369, 369, 369, 369, 540, 307, 307,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 907264, 0, 0, 557, 559, 0, 0, 0, 0, 0, 0, 557, 0, 0, 563, 0, 0, 0, 0, 307, 307,
  1016, 307, 307, 307, 307, 307, 307, 1022, 307, 307, 489, 0, 0, 566, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 559, 369, 574,
  369, 369, 369, 369, 592, 369, 369, 369, 369, 608, 610, 369, 369, 620, 391, 391, 665, 667, 391, 391, 677, 391, 391,
  391, 391, 0, 0, 0, 26821, 5, 0, 0, 244, 244, 0, 0, 0, 0, 0, 719, 0, 0, 0, 0, 0, 0, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1198, 0, 0, 0, 0, 0, 852, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1268, 369, 626,
  43881, 814, 629, 391, 878, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1461, 391, 1463, 391, 391, 391, 391, 0, 996,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 740, 0, 0, 0, 0, 1013, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
  307, 307, 798, 307, 0, 0, 369, 369, 1048, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1439,
  0, 369, 1062, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 850, 369, 369, 369, 1092, 369,
  1094, 369, 0, 1100, 43881, 0, 1100, 391, 391, 391, 391, 1108, 391, 1154, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  907264, 28672, 0, 1175, 1176, 0, 0, 0, 0, 0, 1180, 0, 0, 0, 0, 1185, 0, 0, 1187, 0, 1189, 0, 0, 0, 0, 0, 1195, 0, 0,
  0, 0, 0, 0, 0, 0, 949, 0, 0, 0, 0, 0, 0, 0, 307, 307, 1230, 307, 1231, 1232, 307, 307, 307, 307, 307, 307, 0, 0, 0, 0,
  0, 0, 369, 369, 369, 369, 1242, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1755, 391,
  391, 369, 369, 369, 1270, 369, 369, 369, 1274, 369, 369, 369, 369, 369, 369, 369, 369, 595, 369, 369, 369, 369, 369,
  369, 369, 369, 1415, 369, 369, 369, 369, 369, 369, 369, 391, 391, 391, 1328, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 1575, 391, 391, 391, 391, 391, 1340, 0, 0, 0, 0, 0, 0, 0, 0, 1344, 0, 0, 0, 0, 481, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 83968, 0, 0, 83968, 83968, 0, 0, 0, 1365, 0, 0, 0, 0, 0, 1370, 0, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0,
  503, 504, 0, 0, 507, 0, 0, 0, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1449, 391, 391, 391, 391, 391, 897, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 755, 0, 0, 0, 0, 0, 1577, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1502, 0, 0, 0, 369, 1644, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1765, 391, 391, 0,
  0, 0, 1770, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 1777, 369, 369, 369, 369, 842, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 1553, 369, 0, 0, 391, 391, 391, 1795, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59392, 59392, 0,
  59392, 59392, 59392, 1905, 369, 391, 391, 391, 391, 1911, 391, 1913, 0, 0, 1916, 369, 369, 369, 369, 369, 369, 859,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 862, 369, 369, 369, 369, 369, 369, 369, 369, 391, 391, 391, 391, 391,
  391, 0, 1925, 1926, 0, 369, 369, 369, 369, 369, 369, 1053, 369, 369, 369, 369, 369, 369, 1059, 369, 369, 264, 0, 0, 0,
  0, 0, 264, 0, 0, 269, 0, 0, 0, 0, 0, 0, 497, 0, 0, 0, 501, 0, 0, 0, 0, 0, 0, 1681, 0, 0, 0, 0, 307, 307, 307, 307,
  307, 307, 1020, 307, 307, 307, 307, 307, 0, 264, 0, 0, 0, 276, 0, 0, 0, 22528, 24576, 0, 0, 0, 289, 20480, 289, 289,
  289, 289, 289, 0, 306, 320, 320, 320, 320, 0, 320, 320, 0, 240, 320, 0, 0, 306, 306, 306, 306, 306, 306, 306, 306,
  306, 306, 306, 306, 306, 320, 364, 367, 383, 383, 383, 383, 383, 406, 383, 383, 383, 383, 383, 383, 383, 383, 383,
  383, 406, 406, 406, 406, 406, 406, 406, 383, 383, 406, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 556, 0, 0, 0,
  0, 457, 0, 0, 0, 507, 0, 0, 0, 211, 212, 0, 0, 0, 423, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 757, 0, 0, 0, 307,
  513, 307, 307, 307, 307, 307, 529, 307, 307, 307, 307, 307, 307, 0, 0, 0, 369, 369, 1624, 369, 369, 369, 369, 369, 0,
  391, 391, 391, 391, 391, 644, 391, 391, 391, 391, 307, 307, 307, 0, 0, 0, 0, 0, 0, 0, 0, 0, 552, 0, 0, 0, 0, 0, 505,
  0, 552, 0, 0, 0, 0, 0, 0, 567, 568, 0, 0, 0, 0, 510, 0, 479, 510, 0, 369, 575, 369, 369, 369, 369, 369, 598, 369, 369,
  369, 369, 369, 369, 369, 369, 1054, 369, 369, 369, 369, 369, 369, 369, 369, 0, 1290, 0, 0, 1100, 0, 1296, 0, 0, 307,
  775, 307, 779, 307, 781, 307, 307, 307, 307, 307, 307, 307, 307, 307, 788, 820, 369, 369, 827, 369, 369, 831, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 1276, 369, 369, 369, 369, 369, 369, 369, 626, 43881, 814, 629, 391, 391, 391,
  391, 881, 391, 391, 888, 391, 391, 892, 972, 0, 0, 0, 0, 977, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92485, 92485, 92485,
  92485, 92485, 92485, 0, 0, 0, 1218, 0, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1032, 307, 307, 307, 0,
  1269, 369, 369, 369, 369, 369, 369, 369, 1275, 369, 369, 369, 369, 369, 369, 369, 1067, 369, 369, 369, 369, 369, 369,
  369, 369, 1081, 369, 369, 369, 369, 369, 369, 369, 369, 1540, 369, 369, 369, 369, 369, 369, 369, 369, 1281, 369, 369,
  369, 369, 369, 0, 0, 0, 0, 1100, 0, 0, 0, 0, 495, 0, 0, 0, 0, 0, 502, 0, 0, 506, 0, 0, 1299, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 90112, 0, 0, 26821, 5, 391, 391, 391, 391, 1329, 391, 391, 391, 391,
  391, 391, 391, 391, 1335, 391, 391, 391, 391, 391, 1660, 1662, 391, 1664, 1665, 0, 0, 0, 0, 1669, 0, 369, 369, 1423,
  369, 369, 369, 369, 369, 1429, 369, 369, 369, 369, 369, 369, 369, 1262, 369, 369, 369, 369, 369, 369, 369, 369, 391,
  1845, 391, 391, 391, 391, 391, 391, 391, 0, 1897, 0, 0, 1900, 369, 369, 369, 369, 1491, 0, 0, 1494, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1516, 0, 307, 307, 369, 369, 369, 369, 1548, 369, 369, 369, 369, 369, 369, 369, 369, 369, 0, 1291,
  0, 1297, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1565, 391, 391, 391, 391, 391, 1760, 391, 1761, 1762,
  391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 1801, 0, 0, 0, 0, 1676, 0, 0, 0, 0, 1680, 0, 0, 0, 0, 1685, 307, 307,
  307, 307, 307, 0, 0, 0, 369, 1623, 369, 369, 369, 369, 369, 369, 0, 1100, 43881, 0, 1100, 391, 391, 391, 391, 391,
  307, 1690, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 864, 369, 369, 369, 369, 391, 1728, 0, 0,
  1730, 0, 0, 0, 0, 0, 0, 0, 1736, 1737, 0, 0, 0, 244, 244, 244, 0, 0, 0, 0, 0, 0, 0, 459, 0, 0, 0, 244, 244, 244, 0, 0,
  0, 0, 0, 457, 458, 0, 460, 0, 369, 369, 369, 1781, 369, 1783, 369, 369, 369, 369, 391, 391, 391, 391, 391, 1791, 391,
  1793, 391, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1348, 1868, 369, 369, 391, 391, 391, 391, 391, 391, 391,
  1877, 391, 391, 0, 1880, 0, 0, 0, 687, 691, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1384, 0, 0, 0, 0, 265, 0, 0, 0, 0, 0,
  265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137216, 137216, 137216, 137216, 137216, 137216, 137216, 0, 265, 0, 0, 0, 277, 0, 0, 0,
  22528, 24576, 0, 0, 0, 0, 20480, 321, 338, 338, 357, 357, 338, 338, 338, 338, 338, 357, 338, 338, 338, 357, 338, 338,
  338, 338, 338, 338, 321, 365, 368, 384, 384, 384, 384, 384, 407, 384, 384, 407, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0,
  0, 0, 0, 697, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1211, 0, 0, 0, 0, 0, 384, 384, 384, 384, 384, 384, 384, 384, 384, 407,
  407, 407, 407, 407, 407, 407, 0, 455, 0, 480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1611, 307, 1613, 307, 491, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 773, 0, 511, 307, 307, 307, 307, 307, 307, 526, 307, 531, 307, 307, 307, 307, 538,
  307, 307, 307, 0, 0, 0, 0, 0, 0, 0, 0, 549, 0, 554, 0, 0, 0, 0, 455, 0, 0, 0, 511, 0, 554, 571, 0, 369, 576, 369, 369,
  369, 369, 593, 599, 601, 369, 369, 369, 369, 369, 616, 369, 369, 369, 369, 843, 369, 369, 845, 369, 369, 369, 369,
  369, 369, 369, 369, 1287, 0, 0, 0, 1100, 1293, 0, 0, 0, 0, 0, 244, 244, 0, 717, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928,
  0, 0, 0, 0, 0, 0, 0, 0, 747, 0, 0, 0, 0, 0, 752, 0, 0, 0, 0, 0, 0, 764, 0, 0, 0, 695, 0, 0, 0, 771, 0, 307, 307, 790,
  307, 307, 307, 307, 307, 794, 795, 307, 307, 307, 307, 307, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 0, 0, 0, 806, 752, 0, 0, 0, 717, 806, 0, 814, 369, 369, 369, 819, 369, 369, 855, 856, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 837, 369, 369, 369, 369, 626, 43881, 814, 629, 391, 391, 391, 880, 391, 391, 391,
  391, 391, 391, 391, 911, 391, 391, 391, 391, 391, 391, 919, 391, 906, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 916, 917, 391, 391, 391, 0, 0, 1581, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1383, 0, 0, 0, 0, 0, 0, 0, 0, 975, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1675, 0, 0, 0, 307, 307, 307, 1026, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 0,
  0, 0, 0, 369, 369, 1531, 1037, 0, 0, 0, 1040, 0, 0, 0, 0, 0, 950, 1044, 1037, 814, 369, 369, 369, 369, 369, 1285, 369,
  0, 0, 0, 0, 1100, 0, 0, 0, 0, 0, 788480, 0, 0, 0, 835584, 0, 0, 0, 0, 0, 0, 0, 499, 0, 0, 0, 0, 0, 0, 0, 0, 751, 0, 0,
  0, 0, 0, 0, 0, 369, 369, 369, 1050, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1061, 1110, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 1121, 391, 391, 391, 0, 936, 0, 942, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120,
  133120, 133120, 133120, 133120, 133120, 133120, 1201, 0, 0, 0, 0, 0, 1207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1043, 0, 0, 0,
  0, 814, 369, 369, 0, 1243, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1253, 369, 369, 369, 369, 369, 1412,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1710, 391, 391, 391, 391, 1280, 369, 369, 369, 369, 369, 369,
  0, 0, 1291, 0, 1100, 0, 0, 1297, 0, 0, 0, 703, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1200, 0, 991, 0, 391, 391, 391,
  391, 1317, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1146, 391, 391, 391, 391, 391, 391, 1152, 369, 369,
  1410, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1418, 369, 369, 369, 369, 369, 369, 1413, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 1753, 369, 369, 391, 391, 391, 1421, 369, 369, 369, 369, 369, 1427, 369, 369, 369, 369, 369,
  369, 369, 369, 369, 1709, 369, 391, 391, 391, 391, 391, 0, 0, 1443, 391, 391, 391, 391, 391, 1447, 391, 391, 391, 391,
  391, 391, 391, 929, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 369, 369, 369, 391, 391, 391, 391,
  1455, 391, 391, 391, 1458, 391, 391, 391, 391, 391, 1464, 391, 391, 391, 0, 1156, 0, 0, 0, 0, 0, 1158, 0, 0, 0, 0, 0,
  294, 303, 310, 310, 310, 310, 330, 310, 310, 330, 330, 1480, 0, 0, 1483, 1484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77824,
  77824, 0, 77824, 77824, 0, 1492, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 772, 307, 307, 1521, 307, 307, 307, 307,
  307, 307, 307, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 1538, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1083, 369,
  369, 369, 369, 369, 369, 369, 369, 1534, 369, 1536, 369, 369, 1539, 369, 369, 369, 369, 369, 369, 369, 369, 1288, 0,
  0, 0, 1100, 1294, 0, 0, 0, 0, 0, 391, 391, 391, 391, 391, 1559, 391, 1561, 391, 391, 1564, 391, 391, 391, 0, 1580, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83968, 83968, 83968, 83968, 83968, 391, 1578, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 51200, 0, 0, 0, 0, 0, 1590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 1602, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 307, 307, 307, 307, 0, 307, 307, 0, 0, 369, 1629, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 1641, 369, 369, 369, 369, 857, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 865, 369, 369, 369,
  369, 391, 391, 1646, 391, 391, 391, 391, 391, 391, 1651, 391, 391, 391, 391, 391, 673, 391, 391, 391, 391, 391, 0, 0,
  0, 26821, 5, 1689, 307, 0, 0, 1691, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1071, 369, 369, 369, 369,
  369, 1701, 369, 369, 369, 369, 1706, 369, 369, 369, 369, 391, 391, 391, 391, 391, 391, 0, 0, 0, 0, 369, 1917, 369,
  369, 0, 1740, 0, 0, 0, 307, 307, 307, 307, 307, 0, 369, 369, 369, 369, 1744, 391, 1756, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 1764, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 1343, 0, 0, 0, 0, 0, 804, 0, 0, 0, 0, 0, 0, 0, 0, 0, 809,
  369, 369, 1870, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1879, 0, 0, 0, 0, 1378, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  246, 0, 0, 0, 0, 0, 1881, 0, 0, 1884, 369, 369, 369, 369, 369, 369, 1889, 1890, 369, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 391, 1337, 391, 391, 391, 391, 1895, 1896, 391, 0, 0, 1898, 1899, 0, 369, 369,
  369, 369, 369, 369, 1066, 369, 369, 369, 369, 369, 369, 369, 1072, 369, 322, 339, 339, 339, 339, 339, 339, 339, 339,
  339, 339, 339, 339, 339, 339, 339, 322, 339, 339, 385, 385, 385, 385, 385, 408, 385, 385, 385, 385, 385, 385, 385,
  385, 385, 385, 408, 408, 408, 408, 408, 408, 408, 385, 385, 408, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 990,
  0, 991, 0, 0, 0, 0, 0, 0, 0, 0, 242, 243, 0, 244, 0, 0, 0, 0, 307, 307, 777, 307, 307, 307, 307, 307, 307, 307, 307,
  307, 307, 307, 307, 307, 307, 307, 789, 369, 369, 824, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369,
  369, 391, 391, 391, 391, 391, 391, 391, 870, 626, 43881, 814, 629, 391, 391, 391, 391, 391, 391, 885, 391, 391, 391,
  391, 391, 898, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1573, 391, 391, 391, 391, 391, 391, 0, 0, 943, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530432, 0, 0, 0, 0, 957, 0, 0, 0, 0, 962, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1355, 0, 0, 0,
  0, 0, 0, 0, 307, 1024, 307, 307, 307, 307, 307, 307, 307, 1030, 307, 307, 307, 307, 307, 0, 0, 0, 369, 369, 369, 369,
  1626, 369, 369, 369, 391, 391, 391, 1126, 391, 391, 391, 391, 391, 391, 391, 1132, 391, 391, 391, 391, 391, 926, 391,
  391, 391, 391, 0, 0, 935, 0, 0, 0, 391, 391, 391, 1140, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  1306, 391, 391, 391, 1310, 391, 1312, 391, 0, 0, 391, 391, 1556, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 1320, 391, 391, 391, 391, 391, 391, 391, 369, 369, 1747, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 391,
  391, 391, 391, 391, 391, 0, 1914, 1915, 0, 369, 369, 369, 369, 391, 391, 391, 391, 1759, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 0, 0, 934, 0, 0, 0, 369, 1869, 369, 391, 391, 391, 391, 391, 391, 391, 391, 1878, 391, 0, 0, 0, 0,
  0, 0, 0, 0, 369, 1863, 369, 369, 369, 369, 369, 0, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 0, 932, 0, 0, 0,
  938, 1920, 369, 391, 391, 391, 391, 1924, 391, 0, 0, 0, 0, 369, 369, 369, 369, 369, 369, 1080, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 1752, 369, 369, 369, 391, 391, 391, 0, 0, 268, 0, 0, 0, 0, 268, 0, 22528, 24576, 0, 0, 0, 0,
  20480, 307, 268, 268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0, 79872, 79872, 386, 386, 386, 386, 386, 386,
  386, 386, 386, 409, 409, 409, 409, 409, 409, 409, 386, 386, 409, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 998,
  999, 0, 0, 1002, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 75776, 0, 0, 0, 0, 0, 0, 0, 1368, 0, 0, 0, 0, 0, 0, 0, 0, 693, 0, 0,
  0, 0, 0, 0, 0, 802, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 369, 626, 43881, 814, 629, 391, 391, 391, 391,
  391, 391, 391, 391, 889, 391, 391, 391, 391, 896, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1149, 391,
  391, 391, 391, 988, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1174, 307, 307, 1025, 307, 307, 307, 307, 307, 307,
  307, 307, 307, 307, 307, 307, 0, 0, 0, 0, 369, 369, 369, 0, 0, 0, 1039, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814, 369, 369, 369,
  369, 369, 1438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 786432, 0, 0, 0, 0, 888832, 391, 391, 391, 391, 1127, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 391, 1331, 391, 391, 391, 391, 391, 391, 391, 290, 290, 290, 290, 290, 0, 290, 323,
  323, 323, 323, 0, 323, 323, 0, 0, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 323, 290, 290, 387,
  387, 387, 387, 387, 410, 387, 387, 387, 387, 387, 387, 387, 387, 387, 387, 410, 410, 410, 410, 410, 410, 410, 387,
  387, 410, 26821, 26821, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 1165, 0, 0, 0, 1169, 0, 0, 0, 0, 0, 0, 1194, 0, 1196, 0, 0,
  0, 0, 0, 991, 0, 1435, 369, 369, 369, 369, 369, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 407552, 244, 0, 407552, 0, 407552, 391,
  391, 391, 1456, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 1460, 391, 391, 391, 391, 391, 1466, 391,
  388, 388, 388, 388, 388, 388, 388, 388, 388, 411, 411, 411, 411, 411, 411, 411, 388, 388, 411, 26821, 26821, 2, 45059,
  4, 5, 0, 0, 0, 0, 0, 0, 1178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1371, 0, 0, 0, 0, 1376, 0, 0, 307, 307, 307, 307, 522,
  307, 307, 307, 307, 307, 307, 307, 307, 307, 1526, 0, 0, 0, 369, 369, 369, 307, 307, 307, 0, 0, 0, 0, 0, 0, 0, 547, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 547, 0, 0, 244, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724, 0, 0, 0, 729, 0, 0, 0, 0, 734, 0,
  0, 0, 0, 0, 0, 741, 0, 744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 808, 0, 391, 391, 923, 391, 391, 391, 391, 391,
  391, 391, 0, 933, 0, 0, 0, 939, 0, 0, 211, 212, 0, 0, 0, 0, 0, 0, 426, 0, 0, 0, 0, 0, 1193, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 982, 0, 0, 0, 0, 0, 391, 391, 391, 391, 925, 391, 391, 391, 391, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1834, 369, 369, 0,
  1011, 0, 0, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 1034, 307, 307, 0, 369, 1075, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 1089, 369, 369, 369, 369, 369, 1259, 1260, 369, 369, 369, 369,
  369, 369, 369, 369, 369, 369, 1057, 369, 369, 369, 369, 369, 391, 1300, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 1572, 391, 391, 1574, 391, 391, 391, 1576, 1313, 1314, 391, 391, 391, 391, 391, 391, 391,
  391, 391, 391, 391, 391, 391, 391, 1720, 391, 391, 391, 391, 391, 391, 391, 407552, 0, 0, 0, 407552, 407552, 0, 0, 0,
  0, 0, 407552, 407552, 0, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 0, 407552, 0, 0, 407552, 407552, 0, 0, 0, 0, 0, 0,
  407552, 0, 407552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 407552, 0, 0, 0, 407552, 0, 407552, 0, 0, 407552, 0, 0, 0, 407552, 0, 0,
  0, 407552, 0, 0, 0, 407832, 407832, 407552, 0, 0, 0, 407832, 407552, 0, 0, 0, 407552, 0, 407552, 0, 407552, 0, 0, 0,
  0, 0, 0, 0, 439, 0, 0, 0, 0, 0, 0, 0, 0, 1001, 0, 1003, 0, 0, 0, 0, 0, 407552, 407552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 407552, 0, 0, 0, 407552, 0, 528384, 0, 0, 0, 0, 0, 0, 409600, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 0, 0, 0,
  0, 0, 0, 557056, 557056, 557056, 557056, 557682, 0, 557056, 557685, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 0, 0, 0, 0, 675840, 557056, 557056, 557056, 557056, 0, 0, 0, 0, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 557056, 557056, 557056, 757760, 557056, 0, 411648, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 970, 0, 0, 411988, 411988, 411988, 411988, 411988, 411988, 411988, 411988, 411988, 411988, 411988,
  411988, 411988, 411988, 411988, 0, 0, 0, 0, 0, 0, 0, 0, 411988, 411988, 411988, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0,
  0, 1206, 0, 0, 0, 0, 0, 0, 1213, 0, 0, 0, 0, 0, 0, 413696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92485, 0, 0, 92485,
  92485, 0, 0, 0, 415744, 415744, 415744, 415744, 415744, 415744, 415744, 415744, 415744, 415744, 415744, 415744,
  415744, 0, 0, 0, 0, 0, 0, 0, 415744, 415744, 415744, 415744, 0, 0, 2, 45059, 4, 5, 0, 0, 0, 0, 0, 0, 1220, 307, 307,
  307, 307, 307, 307, 307, 307, 307, 307, 785, 307, 307, 307, 307, 307, 528384, 0, 0, 0, 0, 0, 0, 0, 417792, 0, 0, 0, 0,
  0, 0, 0, 469, 0, 0, 0, 0, 0, 475, 0, 0, 557056, 872, 0, 0, 875, 557056, 557056, 557056, 557056, 557056, 557056,
  557056, 557056, 557056, 557056, 557056, 0, 0, 116736, 0, 5, 0, 0, 0, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  108870, 0, 0, 108870, 108870, 0, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200,
  51200, 51200, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 51200, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127303, 0, 0,
  127303, 127303, 0, 528384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 217
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  27, 59, 91, 123, 155, 666, 685, 179, 211, 257, 289, 321, 353, 479, 385, 417, 449, 511, 637, 543, 575, 717, 749, 781,
  606, 813, 241, 845, 849, 856, 851, 855, 856, 860, 867, 863, 871, 875, 879, 883, 887, 961, 1705, 1343, 893, 961, 902,
  907, 961, 961, 975, 2173, 2175, 913, 961, 919, 1111, 924, 1934, 1177, 968, 961, 1784, 975, 975, 975, 930, 985, 985,
  937, 960, 961, 961, 941, 961, 1176, 1178, 1143, 975, 975, 975, 1036, 985, 985, 985, 951, 961, 961, 915, 961, 1433,
  903, 974, 975, 975, 955, 985, 985, 985, 959, 961, 961, 961, 967, 972, 975, 975, 980, 984, 985, 986, 961, 961, 1377,
  1435, 975, 1034, 984, 985, 990, 961, 1473, 995, 975, 1003, 932, 961, 1935, 1008, 997, 985, 1016, 2170, 976, 1004,
  1337, 1010, 933, 1010, 1022, 998, 1026, 999, 1027, 1031, 1012, 1012, 1040, 1044, 1048, 1052, 1053, 1057, 1052, 1061,
  1065, 1069, 1073, 1077, 1081, 1085, 1093, 961, 1724, 961, 961, 2197, 961, 1255, 961, 1199, 961, 961, 1117, 1367, 961,
  961, 961, 1985, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 1357, 1110,
  1221, 961, 1485, 1115, 1997, 1121, 1125, 1129, 1133, 1137, 1141, 1147, 1151, 1245, 961, 1157, 1206, 1161, 1633, 1545,
  1173, 1670, 1795, 961, 1219, 1223, 1616, 1330, 1698, 1182, 1186, 961, 1192, 1686, 1197, 961, 961, 1273, 961, 961, 961,
  2124, 961, 961, 961, 1689, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 920, 1933, 1233, 1203, 961, 1635,
  1213, 961, 961, 2039, 1231, 961, 961, 961, 2125, 961, 1330, 944, 1292, 961, 1237, 1244, 961, 961, 1241, 961, 961,
  1849, 1284, 961, 1249, 1266, 2142, 1277, 961, 961, 1759, 961, 961, 1283, 961, 1289, 1296, 2217, 961, 2194, 961, 2149,
  961, 1300, 1306, 1310, 2216, 1455, 1315, 1321, 1325, 2039, 1329, 1791, 1302, 1336, 1341, 1349, 1364, 1565, 1361, 898,
  1088, 1815, 1089, 1816, 1373, 1381, 1381, 961, 961, 961, 1017, 1996, 1717, 1388, 1752, 1395, 1399, 1403, 1407, 1411,
  1413, 961, 2009, 2054, 1417, 1376, 1422, 1828, 1101, 1430, 1439, 1663, 961, 1443, 961, 1994, 947, 1391, 2136, 2065,
  1449, 1453, 2167, 1902, 1885, 1459, 961, 961, 1468, 1472, 961, 961, 1477, 1483, 1489, 1495, 1992, 1499, 1216, 1225,
  1506, 1589, 1572, 1596, 1605, 1609, 1225, 1614, 961, 1620, 1169, 1651, 1864, 2180, 1625, 2274, 2030, 1462, 1631, 1639,
  961, 1648, 1658, 1667, 1808, 1676, 1677, 1683, 1696, 1425, 1678, 1426, 1679, 2028, 1702, 1702, 1711, 961, 961, 961,
  1269, 1715, 1840, 1721, 1592, 1733, 1737, 1741, 1745, 1746, 961, 1285, 1750, 2187, 1331, 1661, 1756, 1763, 2156, 1769,
  1778, 1782, 1352, 961, 1311, 1271, 1788, 1332, 1799, 1772, 1502, 1539, 1803, 1807, 1610, 1812, 961, 961, 1513, 1820,
  961, 2075, 2015, 1317, 1661, 1825, 1369, 2067, 1832, 961, 1837, 961, 961, 1691, 1844, 961, 961, 1479, 1510, 961, 961,
  1821, 1517, 1391, 1521, 1978, 1525, 1532, 1856, 1538, 961, 961, 1857, 961, 961, 1543, 1621, 1549, 2117, 1553, 1418,
  1563, 961, 961, 1569, 961, 1464, 1853, 1788, 961, 1861, 2021, 1261, 961, 1892, 961, 961, 961, 1893, 961, 2316, 2201,
  961, 1873, 2272, 1878, 1096, 961, 961, 1368, 1883, 1188, 1279, 1153, 1193, 1262, 1889, 961, 1765, 1316, 1931, 961,
  1939, 1950, 1954, 1958, 1962, 1966, 1967, 961, 961, 2207, 1707, 1971, 1774, 1575, 2227, 1729, 1833, 1975, 1252, 1106,
  1984, 961, 1654, 1491, 1989, 2073, 2001, 961, 2013, 1578, 2019, 961, 1534, 2025, 961, 961, 2034, 2038, 961, 2209,
  2043, 1774, 1559, 961, 2047, 2053, 961, 2111, 2058, 961, 961, 1344, 2062, 961, 1653, 1491, 2071, 1227, 1316, 2079,
  961, 1642, 961, 2004, 961, 908, 1584, 961, 963, 961, 961, 961, 961, 1643, 961, 961, 1879, 961, 961, 2314, 888, 1527,
  961, 896, 961, 961, 961, 1868, 961, 961, 1879, 961, 1897, 1672, 1692, 1691, 1901, 1164, 2049, 1018, 1209, 2102, 1691,
  1906, 1910, 1916, 1869, 1912, 1920, 1921, 1927, 1847, 1383, 1922, 1384, 1923, 1556, 1794, 1794, 1794, 961, 961, 961,
  926, 961, 961, 961, 961, 1355, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 1581, 961, 961,
  961, 961, 961, 961, 961, 961, 961, 961, 1100, 961, 961, 961, 961, 961, 961, 961, 1582, 961, 961, 961, 961, 961, 1105,
  961, 961, 1343, 2083, 961, 961, 1344, 2084, 961, 2088, 2092, 2096, 1601, 2100, 961, 2106, 961, 961, 1345, 2110, 2115,
  2121, 2129, 2135, 2131, 2140, 961, 2146, 961, 2153, 2160, 961, 2164, 1445, 2179, 2184, 2191, 1445, 2205, 2213, 2221,
  2130, 2225, 2231, 1368, 2235, 2007, 2239, 2243, 2248, 2244, 2249, 2253, 2257, 2261, 2265, 2269, 961, 961, 961, 2278,
  2282, 2286, 2290, 2294, 2298, 2302, 2306, 2310, 961, 961, 1644, 1980, 961, 1942, 1689, 962, 2199, 961, 961, 1874, 961,
  1867, 961, 1946, 1727, 961, 896, 1690, 961, 909, 961, 961, 961, 961, 889, 961, 961, 1167, 888, 1527, 961, 1945, 961,
  961, 1643, 961, 961, 1599, 1258, 961, 1528, 961, 961, 1627, 961, 1490, 991, 961, 1585, 961, 961, 961, 961, 961, 1690,
  961, 961, 961, 1583, 2438, 2443, 2630, 2323, 2320, 2342, 2344, 2344, 2360, 2339, 2378, 2344, 2344, 2344, 2344, 2349,
  2353, 2344, 2344, 2382, 2385, 2392, 2357, 2371, 2375, 2345, 2399, 2402, 2405, 2412, 2408, 2395, 2388, 2416, 2429,
  2419, 2422, 2433, 2425, 2437, 2442, 3801, 2726, 2449, 2449, 2449, 2365, 2744, 2460, 2467, 3740, 2449, 2365, 2449,
  2449, 3682, 2447, 2736, 2480, 2480, 2480, 2449, 2481, 2449, 2449, 2449, 2367, 2449, 3134, 3138, 2449, 2449, 2449,
  3468, 3690, 2449, 2449, 2449, 2446, 3469, 2500, 2449, 2449, 2449, 3527, 3353, 2475, 2489, 2489, 2491, 2449, 2449,
  2489, 2489, 3356, 3136, 3726, 3479, 2513, 2449, 2444, 2447, 2449, 2449, 3758, 3116, 2710, 3136, 3136, 3137, 3612,
  3613, 2521, 2530, 2710, 3137, 2449, 2449, 2449, 2449, 2366, 2449, 2665, 2480, 2480, 2480, 2739, 2480, 2739, 2449,
  3612, 3612, 3612, 3612, 2709, 3612, 3614, 2521, 2530, 2474, 2489, 2489, 2489, 2489, 2449, 2490, 2449, 2449, 2449,
  2452, 2480, 2740, 3612, 3612, 2707, 2489, 2489, 2492, 2709, 2489, 2489, 2489, 2490, 2739, 3611, 3612, 3612, 2708,
  2489, 2449, 3612, 2492, 2449, 2449, 2449, 2454, 2965, 2489, 2449, 2449, 3611, 2492, 2449, 3611, 3612, 2708, 2489,
  2490, 2449, 3612, 3612, 3612, 3614, 2473, 2489, 2489, 3610, 2537, 2534, 2539, 2449, 2549, 2976, 3212, 2554, 2583,
  2564, 2609, 2609, 2609, 2609, 2568, 2574, 2560, 2605, 2590, 2609, 2556, 2570, 2608, 2609, 2558, 3214, 3213, 2598,
  2586, 2602, 2577, 2613, 2616, 2617, 2621, 2625, 2634, 2658, 3058, 2638, 2580, 2647, 2651, 2655, 2628, 2449, 3530,
  2449, 3528, 2449, 2449, 2462, 3574, 2364, 2449, 2449, 3811, 3815, 2814, 2449, 2449, 2449, 2497, 2816, 2449, 2449,
  2449, 2503, 2455, 2449, 2449, 2449, 2507, 2714, 2723, 2449, 2449, 2449, 3549, 2734, 2991, 2643, 2735, 2752, 3083,
  2760, 2770, 2771, 2763, 2766, 2775, 2782, 2780, 2778, 2786, 2787, 2787, 2787, 2791, 2793, 2797, 2449, 2449, 2449,
  3611, 3540, 2449, 3296, 3803, 2944, 2948, 2449, 2449, 2449, 3664, 2801, 2809, 2449, 2880, 2820, 3112, 2828, 2449,
  2461, 3174, 2449, 2463, 2452, 2449, 3370, 2449, 2856, 2449, 2862, 2449, 2480, 2480, 2480, 2480, 2738, 2675, 2449,
  2449, 2884, 2829, 2894, 2449, 2449, 2449, 3714, 2830, 2449, 2449, 2449, 2593, 2909, 2915, 2449, 2449, 2449, 3737,
  3069, 2449, 2852, 2444, 2673, 2677, 2449, 2461, 3139, 2744, 2849, 2910, 2927, 2449, 2497, 3170, 2449, 2499, 3297,
  3804, 2945, 2949, 2449, 2449, 2449, 3542, 2449, 3686, 3197, 2926, 2444, 2449, 2677, 2449, 3291, 3524, 3836, 2935,
  2449, 3836, 2935, 2929, 2449, 2449, 2449, 2667, 2693, 2444, 2447, 2449, 2502, 3618, 2449, 2526, 2690, 2449, 2461,
  2450, 2449, 2461, 2744, 2449, 2449, 2962, 2962, 2955, 2449, 2680, 3696, 2444, 2449, 2449, 2908, 2914, 3836, 3770,
  2444, 2449, 3703, 3707, 3237, 2947, 2449, 2449, 2449, 2679, 2693, 2446, 2449, 2962, 2449, 2933, 2956, 3516, 2961,
  2449, 3526, 2692, 2447, 2449, 3069, 2973, 3528, 3517, 2449, 3526, 3445, 3202, 2449, 2449, 2449, 2680, 2938, 2449,
  2449, 2449, 2691, 2449, 2693, 2448, 2449, 3068, 2960, 3525, 3444, 2960, 3199, 2449, 2449, 2449, 2692, 2449, 2449,
  3838, 2449, 2449, 2449, 2705, 3014, 2961, 2449, 2449, 2449, 3742, 3669, 3732, 3108, 2939, 2446, 2449, 2686, 3415,
  2449, 2697, 2449, 2449, 2449, 3539, 2448, 3531, 2449, 3529, 2449, 2449, 3529, 2449, 2449, 2449, 2461, 3473, 3529,
  2449, 2517, 2448, 2449, 2449, 2449, 2736, 3531, 3529, 2449, 2448, 3109, 2449, 2449, 3066, 2454, 2995, 3244, 2449,
  2449, 3093, 3064, 3244, 2990, 3018, 2699, 3025, 3029, 3033, 3050, 3038, 3042, 3043, 3047, 3047, 3043, 3034, 3054,
  3054, 3054, 3054, 3056, 2449, 3117, 2449, 2449, 2450, 3126, 2814, 2664, 2493, 3370, 2888, 2449, 2886, 2890, 3087,
  2449, 2877, 2449, 2737, 2480, 2480, 2740, 3611, 3822, 3097, 2449, 2840, 3102, 3107, 2449, 2449, 2449, 3774, 3132,
  2449, 3146, 3427, 2921, 2444, 2449, 2449, 2449, 3801, 2719, 2922, 3784, 2449, 2744, 2449, 2449, 2804, 2449, 3283,
  3159, 2718, 2937, 3783, 2449, 2449, 2449, 2737, 2803, 3604, 2449, 2449, 2450, 3179, 3759, 3243, 2449, 2449, 2451,
  2703, 3092, 2449, 2449, 2449, 2742, 2544, 2814, 2664, 2449, 3369, 3164, 3576, 2444, 2449, 2745, 3425, 3434, 3180,
  3185, 3222, 3190, 3184, 3221, 3189, 2449, 2747, 3456, 3461, 3295, 2449, 2449, 3760, 2449, 3638, 2449, 3369, 3195,
  3209, 2449, 2449, 2494, 2449, 2449, 3108, 2444, 2449, 2449, 2501, 3643, 3191, 2449, 2449, 2449, 2746, 2449, 3601,
  2449, 2449, 2509, 2834, 2448, 3638, 2449, 3369, 2663, 2449, 2449, 3110, 2449, 3109, 2449, 2811, 2449, 3626, 3220,
  3228, 2449, 2449, 2661, 2948, 3124, 3234, 3226, 2448, 2449, 2756, 2449, 2813, 3823, 2449, 2814, 3633, 2449, 2815,
  2449, 2449, 2449, 2495, 2449, 2449, 3758, 3242, 2449, 2450, 3306, 2450, 2329, 2742, 2454, 3250, 2449, 2822, 2449,
  2449, 3718, 3723, 3111, 2449, 3124, 3128, 3257, 2449, 2449, 2449, 2748, 3127, 3256, 2449, 2449, 2666, 2949, 2805,
  3760, 3244, 2449, 2450, 3261, 2990, 2449, 2449, 2743, 2449, 3277, 3281, 2449, 2449, 2829, 3291, 2449, 3021, 2449,
  3743, 3279, 2449, 2824, 2449, 2449, 2449, 3272, 2755, 2449, 2743, 2743, 2725, 2449, 2449, 2691, 3590, 2449, 2449,
  3744, 3290, 2449, 2829, 2449, 2449, 3101, 3106, 2449, 3742, 3288, 2449, 2866, 2449, 2449, 2449, 3665, 3134, 3744,
  2890, 2449, 2449, 3370, 3302, 3689, 3499, 2889, 2449, 2902, 2846, 2449, 2493, 2449, 2449, 2449, 3140, 3140, 2887,
  3527, 2449, 2449, 2871, 2449, 3499, 3527, 3002, 3689, 2363, 2449, 2449, 2449, 3360, 3001, 3008, 2755, 3728, 2449,
  3688, 2449, 2449, 2989, 2449, 3768, 3736, 3373, 2449, 2904, 2671, 2449, 2452, 2449, 2449, 3628, 3737, 2326, 2843,
  3314, 3317, 3325, 3332, 3320, 3324, 3329, 3329, 3324, 3324, 3336, 3337, 3337, 3337, 2449, 3695, 2550, 2449, 2449,
  3006, 3012, 3665, 2449, 3341, 2449, 2951, 3446, 2928, 3347, 3365, 2449, 2449, 3140, 3509, 3387, 2449, 3391, 2449,
  2961, 2449, 2449, 3246, 2449, 3395, 3404, 2449, 2685, 3414, 2949, 2449, 2449, 3245, 3612, 3528, 3409, 3707, 2449,
  2969, 2948, 2445, 2449, 2449, 2449, 2867, 3419, 2449, 2454, 2965, 3431, 2664, 3383, 3441, 3450, 2449, 2449, 2449,
  2756, 3457, 3462, 2949, 2449, 2985, 2447, 3530, 2449, 3466, 2449, 2449, 2449, 2803, 3664, 2449, 2898, 2449, 3073,
  3532, 3080, 3477, 2449, 2449, 2449, 2815, 3141, 3484, 3489, 2449, 3090, 2449, 3421, 3483, 3488, 2949, 2449, 3108,
  2449, 2449, 3372, 2943, 2497, 3400, 2444, 2449, 3125, 3218, 3226, 3191, 3664, 2449, 2897, 2449, 3125, 3262, 2449,
  2823, 2449, 2449, 2449, 3172, 3664, 2449, 2449, 2449, 2822, 2593, 2449, 2449, 2449, 2823, 3813, 2949, 2449, 2449,
  3284, 3160, 2449, 3811, 3510, 2449, 3142, 3488, 2949, 2449, 2449, 3514, 2365, 3705, 3175, 2449, 2449, 2449, 2837,
  3523, 2449, 2449, 2470, 3527, 2963, 2449, 2449, 3342, 3527, 3359, 2449, 2449, 3522, 2964, 2449, 2449, 3111, 2449,
  2449, 2448, 3525, 2445, 2449, 3110, 3590, 2449, 2691, 2449, 2449, 2449, 2665, 2480, 3529, 2594, 3536, 2691, 3295,
  2449, 2367, 2449, 2449, 2449, 3273, 3547, 2449, 2335, 3230, 2524, 2495, 3553, 3555, 3559, 3564, 3580, 3583, 3560,
  3585, 3585, 3560, 3567, 3570, 3570, 3570, 3572, 2545, 3205, 2496, 2662, 2449, 3598, 3608, 2449, 3150, 2449, 2449,
  2453, 2449, 3619, 2449, 2449, 2449, 2874, 3204, 2495, 2662, 2449, 3151, 2449, 2454, 3603, 2449, 2449, 2449, 2730,
  2813, 3738, 3627, 2449, 3272, 2451, 2449, 3294, 2449, 2449, 3602, 2449, 3624, 3632, 2449, 2449, 3408, 3706, 2449,
  3637, 2449, 2449, 3493, 3371, 3648, 3653, 2949, 2449, 3301, 2449, 3689, 3371, 2741, 2449, 3642, 3647, 3652, 3620,
  2449, 2449, 2449, 2950, 2543, 3203, 2334, 2661, 2691, 3657, 2449, 2449, 3514, 3343, 3661, 2449, 2449, 2449, 3062,
  3643, 3648, 3676, 3750, 3647, 3675, 3749, 2449, 3367, 3371, 2449, 2449, 2641, 3204, 3680, 2449, 3756, 2449, 2449,
  3399, 2550, 3694, 3737, 3757, 3737, 3669, 2716, 2998, 3749, 2449, 3700, 2449, 2449, 3360, 2545, 3205, 3711, 3756,
  2449, 3542, 3738, 3688, 2449, 3633, 2449, 2449, 3521, 2449, 3076, 3671, 3734, 3750, 3748, 2449, 2449, 2449, 3075,
  2691, 3531, 2449, 2742, 2449, 3437, 2979, 3205, 3754, 2449, 3372, 2919, 2946, 2449, 3542, 3738, 2449, 2449, 2449,
  3076, 3719, 2449, 2449, 2449, 3121, 3766, 3310, 2449, 2449, 3525, 2449, 3075, 3670, 3309, 2449, 3372, 3238, 2948,
  3361, 2981, 2495, 2449, 3377, 2664, 3381, 3543, 3739, 2449, 3739, 2449, 3764, 3310, 2449, 3397, 3155, 2449, 2737,
  3350, 3612, 2485, 2489, 2489, 2476, 3452, 3781, 2449, 2449, 2449, 3124, 3252, 2332, 2496, 2449, 3406, 3410, 3737,
  2453, 3741, 3738, 2449, 3443, 3200, 2449, 2684, 2449, 2449, 2449, 3528, 3704, 3737, 3504, 2949, 2449, 2449, 3589,
  2449, 2449, 2741, 3742, 3776, 3310, 2449, 3444, 3201, 2449, 2449, 2541, 3295, 2451, 3739, 3775, 3505, 2449, 2449,
  3594, 2449, 3075, 3777, 2444, 3292, 3503, 2449, 2461, 3503, 3502, 2449, 3500, 3166, 3293, 2449, 2449, 3501, 3295,
  3295, 2461, 3165, 3293, 2449, 2449, 3502, 2449, 3501, 3295, 2449, 3501, 2461, 3148, 2449, 3501, 2461, 3148, 2449,
  3794, 3794, 3788, 2513, 2513, 2449, 3497, 2449, 2449, 3266, 2449, 2449, 3793, 3788, 2498, 2500, 2449, 2498, 3541,
  2515, 2456, 3795, 3799, 2515, 2449, 3789, 2499, 3808, 3819, 2858, 3830, 3827, 3842, 3833, 3846, 3852, 3849, 3849,
  3851, 3856, 3860, 3861, 3866, 3861, 3861, 3862, 3870, 3273, 2452, 2449, 2449, 3713, 3269, 131074, 131088, 134283264,
  65536, 65536, 65536, 134217728, 0, 0, 524288, 128, 524288, 33554432, -2147483648, 2048, 0, 32, 0, 33562624, 131088,
  131088, 268566528, 268566528, 1073872896, 131072, 131072, 131072, 131072, 8768, 131072, 131072, 131088, 16908288,
  268566528, 1073872896, 1073872896, -2147352576, 131102, 1073872896, -2147352576, 131072, 131072, 131072, 262144,
  262144, 0, 0, 0, 4, 0, 0, 131072, 131072, 1073872896, -2147352576, 131072, 134227136, 10560, 1073872896, 1073872896,
  1073872896, -2147352576, 131072, 131072, 16908288, 147456, 147472, 268582912, 386007040, 32768, 32800, 98336, 147458,
  268582912, 386007040, 386007040, 117571584, 386023424, 1459748864, 147458, -1761476608, -1761476608, 84017152,
  84017152, 84017152, 84017152, 117571584, 84017152, 386007040, 117571584, 1459748864, 386007040, 117571584, 117571584,
  84017152, 386007040, 163872, 98304, 1212448, 163872, -1073577952, -2147319776, -2147319776, -1072529346, -1072529346,
  -1072529346, 386039840, 386039840, -955088834, 163872, 268599328, 1073905696, -2147319776, -1055752130, -1072529346,
  -1072529346, -1072529346, 4096, 4096, 524288, 2097152, 4194304, 4194304, 8388608, 536870912, 0, 0, 0, -2147483648, 0,
  0, 0, 0, 1, 0, 0, 0, 2, 0, 64, 14, 0, 0, 0, 8, 0, 0, 0, 128, 8256, 0, 0, 65536, 1048576, 1048608, 1048608, 1081344,
  1081344, 1081344, 12, 16384, 16384, 16384, 16384, 67108864, 32800, 1048576, 1081344, 1081376, 1081344, 1081344,
  1081344, 1081344, 0, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 76, 128, 646400, 12, 8, 0, 0, 0, 137363456, 64, 64, 64, 64, 0, 0,
  0, 268435456, 32, 32, 32, 32, -2147483648, 0, 0, 8192, 50331648, 1048608, 1048608, 1048608, 1048608, 32768, 1081344,
  32768, 1081344, 1081344, 32768, 1081344, 0, 0, 0, 536870912, 262144, 8192, 33554432, 0, 512, 134217728, 536870912, 0,
  0, 1, 536887296, 8, 8, 10, 8, 8, 8, 12, 152, 131080, 262152, 524296, 134217736, 8, 65544, 8, 8, 152, 24, 10, 8, 24, 8,
  -351260182, 42, 10, 10, 56, 10, 24, 40, 136, 262280, 136, 524296, 262152, 524296, 524296, 8, 16, 0, 0, 536870912, 8,
  82837504, 136, 136, 557208, 8, 8, 24, 524424, 786440, 262152, 8, 8, 8, 8, -351260182, -351260182, 186, -351260182,
  -350715400, -350715400, -350715400, -350703112, -350453256, -350703112, -350703110, -350572040, -350453254,
  -350703110, -350703112, -350572038, -281506342, 0, 0, 0, 536936448, -350703110, -350572038, -350703110, -82267654, 8,
  40, 8, 8, 16, 16384, 0, 16384, 134217728, 26, 42, 58, 70257674, 70269962, 70270286, 70270286, 70270302, 70270286,
  70270286, 70270286, -350703110, -350703110, -350703110, 0, 0, 131072, 67108864, 0, 0, 0, 16384, 0, 1073741824, 0, 12,
  0, 0, 0, 553648128, 8, -2147483648, 0, 0, 1, 64, 32768, 81788928, 0, 0, 0, 120, 3328, -1073741824, 0, 0, 0, 128, 0, 0,
  2097152, 4194304, 0, 0, 2, 2, 0, 4096, 0, 16384, 32768, 32768, 32768, 1081344, 1081344, 1081344, 16, 0, 4096, 4096,
  16384, 32768, 65536, 131072, 7340032, 8388608, 262144, 1073741824, 0, 0, 2, 16, 16, 4096, 0, 4096, 16512, 4096,
  1090519040, 0, 0, 16384, 16384, 16384, 0, 0, 0, 16, 0, 0, 0, 24, 32, 64, 1280, 1409482752, 1409482752, 536870912, 0,
  0, 262144, 134217728, 0, 553648128, -2147483640, 558374944, 557327360, 137364496, 1546847248, 554181664, 554181664,
  556278816, 556278817, 557327360, 557327360, 557327360, 3146768, 3146768, 557327392, 557327408, 554198177, 557327408,
  557327409, 557327408, 557327408, 557327408, 557327408, 554198177, 557327408, 557327408, 599305984, 599305984,
  599305984, 599305984, 599305984, 599306005, 599306005, 599306005, 599306037, 599306005, 599306005, 599306032,
  599306032, 599306037, 0, 16512, 0, 0, 2, 512, 0, 0, 0, 20608, 0, 0, 3, 0, 0, 0, 4194304, 0, 0, 8192, 558366720, 0, 0,
  4, 16, 0, 0, 557318144, 0, 0, 0, 1024, 3145728, 0, 472907776, 1073741824, 0, 0, 655360, 0, 0, 707584, 536870912,
  536936448, 134218752, 0, 0, 2621440, 3670016, 0, 768, 1024, 8192, 3670016, 16777216, 9216, 554172416, 0, 0, 4, 2240,
  0, 556269568, 557318144, 25728, 0, 44800, 599261184, 0, 0, 0, 335544320, 536870912, 0, 0, 6291456, 0, 0, 172032, 0, 0,
  196608, 335544320, 8192, 4718592, 0, 0, 8, 256, 4096, 2097152, 0, 0, 8192, 3670016, 553648128, 0, 0, 16777216, 0, 0,
  0, 469762048, 0, 0, 8, 65536, 0, 1792, 2048, 8192, 32768, 3670016, 32768, 3670016, 8388608, 587202560, 0, 131072,
  524288, 4194304, 16777216, 67108864, 268435456, 536870912, 3670016, 8388608, 16777216, 33554432, 536870912, 0, 0, 0,
  8192, 524288, 3145728, 8388608, 16777216, 67108864, 268435456, 1073741824, 0, 131072, 4194304, 16777216, 67108864,
  134217728, 268435456, 1073741824, 0, 0, 0, 768, 2048, 2097152, 16777216, 536870912, 0, 0, 2097152, 16777216, 0, 0, 0,
  8192, -2147483648, 0, 0, 0, 131072, 16777216, 67108864, 0, 8192, 16777216, 0, 0, 134217728, 536870912, 8192, 33554432,
  0, -2147483648, 2048, 0, 131072, 268435456, 1073741824, 0, 8388608, 0, 0, 0, 20608, 8389120, 8192, 16384, 524288,
  1048576, 8388608, 134217728, 0, 8, 2097152, 0, 2, -2147483647, 0, 0, 8, 2097152, 0, 8388608, 0, 512, 8192, 32768, 0,
  8388608, 8389120, 0, 0, 201326592, 2621440, 71303168, 0, 71303168, 71303168, 71305216, 71303168, 71305216, 134479904,
  71322642, 893570130, 893570130, 893570130, -168566817, 822255680, 822247488, 893570130, 830636096, 830636098,
  893570130, 893570130, 893570130, 893570130, 894094418, 893570130, 893570130, 893570130, 822247488, 893570130,
  893570130, -168566817, -168566817, -168566817, -168566817, 0, 0, 8, 536887296, 8388608, 0, 524288, 0, 524288, 0, 8192,
  0, 0, 8192, 0, 18, 19456, 0, 0, 12, 64, 128, 183296, 4194304, 352321536, 536870912, 553648128, 553648128, 553652224,
  163840, 285212672, 536870912, 0, 1, 0, 1, -2147483648, 0, 0, 82, 183296, 352321536, 536870912, 0, 479, 253440,
  15728640, 352321536, 352321536, -536870912, 0, 0, 0, 131072, 0, 0, 0, 9216, 0, 8192, 2, 0, 33554432, 0, 4194304,
  67108864, 0, 1, 2, 28, 384, 512, 4096, 131072, 18, 1024, 0, 0, 16, 16, 16, 16, 0, 0, 8, 16, 64, 32768, 0, 18, 64,
  1024, 0, 0, 16, 1024, 0, 131072, 16777216, 268435456, 536870912, 384, 1536, 6144, 16384, 32768, 16, 64, 1024, 2048, 0,
  0, 131072, 536870912, 0, 0, 16, 196608, 268435456, 0, 0, 2, 28, 64, 384, 512, 512, 1024, 6144, 16384, 65536, 8388608,
  67108864, 536870912, -2147483648, 0, 0, 2, 16, 1024, 2048, 8192, 32768, 2097152, 16777216, 33554432, 0, 0,
  -2147483648, 2048, 0, 131072, 67108864, 536870912, 0, 1, 8, 8, 8, 0, 512, 1024, 6144, 65536, 131072, 3145728, 4194304,
  8388608, 131072, 3145728, 8388608, 67108864, -2147483648, 0, 32, 67239936, 384, 512, 6144, 65536, 131072, 16777216,
  67108864, 134217728, 8192, 0, 33554432, 0, 0, 0, 32768, 0, 16, 131072, 0, 0, 16, 536870912, 131072, 3145728, 8388608,
  -2147483648, 0, 384, 512, 4096, 3145728, 8388608, 8388608, 524288, 8192, 33554432, 134217728, 536870912, 0, 2, 8, 0,
  0, 12, 16, 384, 4096, 3145728, 8388608, 0, 0, 31, 64, 384, 16, 256, 4096, 3145728, 0, 0, 0, 2048, 0, 0, 0, 4096,
  65536, 0, 8, 4096, 2097152, 0, 0, 134217728, 512, 524288, 134217728, 536870912, 1073741824, 0, 134218752, 134218752,
  134218752, 134218752, -2147475454, 150995968, 218385720, 100944184, 637880632, 218385712, 218385720, 218385720,
  218385720, 218385720, 67455288, 218385720, 218385720, 218385721, 218385720, 218385720, 67389752, 67422520, 218385848,
  1564990840, 1564990840, 1564990840, 1564990840, 150994944, 0, 0, 0, 1048576, 2097152, 0, 56, 3328, 16384, 16384, 0,
  32768, 32, 1048576, 1081344, 1081344, 0, 16, 0, 16, 0, 536870912, 8192, 262144, 218103808, 0, 0, 32, 262144,
  134217728, 0, 0, 0, 65536, 0, 56, 2304, 16384, 327680, 0, 262144, 49152, 0, 603979776, 16, 100663296, 0, 0, 637534208,
  0, 48, 3328, 218103808, 0, 57, 0, 0, 64, 32768, 65536, 33554432, 134217728, 0, 3456, 0, 0, 512, 4, 1048576, 524288,
  2097152, 0, 3328, 53248, 4653056, 486539264, 1073741824, 0, 1024, 0, 0, 512, 1048580, 32, 1280, 2048, 16384, 32768,
  131072, 256, 2048, 16384, 262144, 16777216, 201326592, 0, 2, 16, 2048, 1280, 201326592, 0, 0, 768, 8192, 32768,
  2097152, 8388608, 0, 25, 0, 0, 4096, 8388608, 1280, 2048, 4096, 49152, 196608, 196608, 262144, 4194304, 16777216,
  469762048, 469762048, 1073741824, 0, 0, 8192, 64, 64, 16, 1024, 16384, 16777216, 0, 49152, 0, 0, 8192, 8192, 64, 1024,
  4096, 49152, 196608, 196608, 4194304, 16777216, 402653184, 1073741824, 0, 8, 16, 16777216, 8, 16, 134217728, 0, 0, 8,
  64, 1024, 2048, 134217728, 536870912, 0, 32768, 196608, 268435456, 1073741824, 0, 65536, 536870912, 0, 0, 8192,
  2097152, 16777216, 8, 16, 196608, 0, 0, 0, 2097152, 0, 0, 0, 512, 0, 0, 0, 82, 262160, 128, 33562624, 0, 2, 64, 0, 0,
  1, 2, 0, 33562624, -2147483648, 0, 2048, 69206016, 119537664, 32896, 0, 32896, 32896, 32896, 3, 98688, 281117056,
  281117056, 281117056, 281117056, 281117056, 281018368, 281117056, 281117056, 314679680, 348356992, 2044321228,
  2044321228, 2044321228, 2044321228, 0, 0, 16384, 131072, 4194304, 67108864, 281018368, 281018880, 281117056,
  -1866465280, 272728448, 272728448, 281117056, 281117056, 281117056, 128, 512, 2097152, 0, 0, 128, 98560, 12582912,
  268435456, 0, 106752, 46137344, 0, 2, 512, 2048, 16384, 0, 0, 229632, 79691776, 0, 0, 32768, 32768, 32768, 32768, 32,
  32, 646400, 164626432, 805306368, 1073741824, 0, 0, 0, 128, 256, 98304, 0, 0, 0, 12582912, 4194304, 8388608,
  268435456, 0, 0, 229376, 0, 0, 0, 67108864, 76, 128, 256, 3072, 4096, 4096, 16384, 98304, 524288, 1048576, 1048576,
  4194304, 25165824, 134217728, 805306368, 256, 98304, 8388608, 268435456, 0, 8388608, 268435456, 0, 2, 8192,
  -2147483648, 0, 64, 128, 256, 3072, 32768, 65536, 1048576, 8388608, 16777216, 134217728, 268435456, 0, 32, 131072,
  67108864, 268435456, 1073741824, 0, 256, 65536, 0, 0, 0, 262144, 262144, 256, 32768, 65536, 8388608, 33554432,
  134217728, 0, 128, 512, 0, 4, 1048576, 2097152, 0, 268435456, 0, 0, 32, 131072, 0, 0, 32768, 65536, 33554432, 0, 128,
  256, 32768, 0, 65536, 8388608, 268435456, 0, 8, 8, 0, 8, 0, 32768, 65536, 524288, 8388608, 134217728, 268435456, 0, 0,
  0, 256, 0, 0, 0, 12, 16, 256, 134217728, 268435456, 536870912, 1073741824, 0, 0, 32, 131072, 32768, 0, 0, 0, 8388608,
  524288, 8192, 0, 12, 64, 256, 3072, 32768, 524288, 2097152, 8388608, 16777216, 33554432, 0, 12, 64, 256, 1024, 2048,
  134217728, 3072, 134217728, 536870912, 1073741824, -2147483648, 0, 0, 0, 64, 0, 64, 2, 2, 8, 64, 0, 0, 256, 0, 320, 0,
  0, 65536, 131072, 262144, 524288, 4194304, 2, 64, 2, 0, 8, 16, 32768, 196608, 402653184, 1073741824, 0, 0, 2240, 2240,
  66, 0, 0, 0, 98560, 68, 32, 1028, 4, 4, 4, 4, 68, 769, 768, 2048, 8192, 32768, 16777216, 0, 68, 4, 68, 768, 4, 768,
  768, 1796, 1796, 1860, 1796, 1796, 1796, 1796, 1860, 1796, 1860, 1796, 1860, 20, 20, 20, 20, 84, 84, 84, 20, 20, 1044,
  1876, 1876, 1812
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "(0)",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "URIQualifiedName",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "S",
  "S",
  "CommentContents",
  "PragmaContents",
  "Wildcard",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "EOF",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'=>'",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'array'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'exponent-separator'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'map'",
  "'minus-sign'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state eq 0) then
    let $result := $result idiv 2048
    let $end := $end - $result idiv 256
    let $end := if ($end gt string-length($input)) then string-length($input) + 1 else $end
    return
      if ($result ne 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer)
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1938 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 32
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 32 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer)
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : Try parsing the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(59, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 48) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 18) then                 (: CommentContents :)
            let $state := p:consumeT(18, $input, $state)    (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:try-Comment($input, $state)
            return $state
        return p:try-Comment-1($input, $state)
};

(:~
 : Try parsing Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Comment($input as xs:string, $state as item()+) as item()+
{
  let $state := p:consumeT(35, $input, $state)              (: ('(' ':') :)
  let $state := p:try-Comment-1($input, $state)
  let $state := p:consumeT(48, $input, $state)              (: (':' ')') :)
  return $state
};

(:~
 : Try parsing Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:try-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 17) then                       (: S^WS :)
      let $state := p:consumeT(17, $input, $state)          (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:try-Comment($input, $state)
      return $state
  return $state
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QueryBody", $count, $begin, $end)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-QueryBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MainModule", $count, $begin, $end)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:consume(153, $input, $state)              (: 'option' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OptionDecl", $count, $begin, $end)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(119, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(179, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: '{' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(115, $input, $state)          (: 'external' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionDecl", $count, $begin, $end)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(191, $input, $state)              (: 'variable' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: ':=' :)
      let $state := p:consume(50, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(115, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 50) then                   (: ':=' :)
          let $state := p:consume(50, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(187, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(103, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'variable' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 191) then                      (: 'variable' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AnnotatedDecl", $count, $begin, $end)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarDefaultValue", $count, $begin, $end)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:consume(133, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '<<' :)
      let $state := p:consume(56, $input, $state)           (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(63, $input, $state)           (: '>>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeComp", $count, $begin, $end)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 59) then                       (: '=' :)
      let $state := p:consume(59, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:consume(26, $input, $state)           (: '!=' :)
      return $state
    else if ($state[$p:l1] = 52) then                       (: '<' :)
      let $state := p:consume(52, $input, $state)           (: '<' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<=' :)
      let $state := p:consume(57, $input, $state)           (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:consume(61, $input, $state)           (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(62, $input, $state)           (: '>=' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GeneralComp", $count, $begin, $end)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:consume(111, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'ne' :)
      let $state := p:consume(146, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:consume(139, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:consume(136, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:consume(124, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(120, $input, $state)          (: 'ge' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueComp", $count, $begin, $end)
};

(:~
 : Parse SimpleTypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleTypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TypeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleTypeName", $count, $begin, $end)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SimpleTypeName($input, $state)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'and' | 'ascending' | 'case' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:consume(64, $input, $state)           (: '?' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SingleType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(153, $input, $state)        (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PredicateList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PredicateList", $count, $begin, $end)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:consume(66, $input, $state)           (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NodeTest($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevForwardStep", $count, $begin, $end)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 87) then                       (: 'child' :)
      let $state := p:consume(87, $input, $state)           (: 'child' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'descendant' :)
      let $state := p:consume(98, $input, $state)           (: 'descendant' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'attribute' :)
      let $state := p:consume(79, $input, $state)           (: 'attribute' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'self' :)
      let $state := p:consume(172, $input, $state)          (: 'self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant-or-self' :)
      let $state := p:consume(99, $input, $state)           (: 'descendant-or-self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'following-sibling' :)
      let $state := p:consume(117, $input, $state)          (: 'following-sibling' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(116, $input, $state)          (: 'following' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardAxis", $count, $begin, $end)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 79) then                           (: 'attribute' :)
      let $state := p:lookahead2W(161, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (87,                           (: 'child' :)
                              98,                           (: 'descendant' :)
                              99,                           (: 'descendant-or-self' :)
                              116,                          (: 'following' :)
                              117,                          (: 'following-sibling' :)
                              172)) then                    (: 'self' :)
      let $state := p:lookahead2W(157, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 12623                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12631                          (: 'child' '::' :)
          or $state[$p:lk] = 12642                          (: 'descendant' '::' :)
          or $state[$p:lk] = 12643                          (: 'descendant-or-self' '::' :)
          or $state[$p:lk] = 12660                          (: 'following' '::' :)
          or $state[$p:lk] = 12661                          (: 'following-sibling' '::' :)
          or $state[$p:lk] = 12716) then                    (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ForwardStep", $count, $begin, $end)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(43, $input, $state)               (: '..' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AbbrevReverseStep", $count, $begin, $end)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (79,                                (: 'attribute' :)
                         89,                                (: 'comment' :)
                         104,                               (: 'document-node' :)
                         105,                               (: 'element' :)
                         145,                               (: 'namespace-node' :)
                         150,                               (: 'node' :)
                         166,                               (: 'processing-instruction' :)
                         170,                               (: 'schema-attribute' :)
                         171,                               (: 'schema-element' :)
                         180)) then                         (: 'text' :)
      let $state := p:lookahead2W(156, $input, $state)      (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8527                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8537                           (: 'comment' '(' :)
          or $state[$p:lk] = 8552                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8553                           (: 'element' '(' :)
          or $state[$p:lk] = 8593                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 8598                           (: 'node' '(' :)
          or $state[$p:lk] = 8614                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8618                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8619                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8628) then                     (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeTest", $count, $begin, $end)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'parent' :)
      let $state := p:consume(158, $input, $state)          (: 'parent' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor' :)
      let $state := p:consume(72, $input, $state)           (: 'ancestor' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'preceding-sibling' :)
      let $state := p:consume(163, $input, $state)          (: 'preceding-sibling' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding' :)
      let $state := p:consume(162, $input, $state)          (: 'preceding' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(73, $input, $state)           (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(26, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:consume(49, $input, $state)           (: '::' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseAxis", $count, $begin, $end)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 43) then                       (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(174, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ReverseStep", $count, $begin, $end)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (72,                                (: 'ancestor' :)
                         73,                                (: 'ancestor-or-self' :)
                         158,                               (: 'parent' :)
                         162,                               (: 'preceding' :)
                         163)) then                         (: 'preceding-sibling' :)
      let $state := p:lookahead2W(157, $input, $state)      (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 43                             (: '..' :)
          or $state[$p:lk] = 12616                          (: 'ancestor' '::' :)
          or $state[$p:lk] = 12617                          (: 'ancestor-or-self' '::' :)
          or $state[$p:lk] = 12702                          (: 'parent' '::' :)
          or $state[$p:lk] = 12706                          (: 'preceding' '::' :)
          or $state[$p:lk] = 12707) then                    (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | EOF | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PredicateList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AxisStep", $count, $begin, $end)
};

(:~
 : Parse ArrowFunctionSpecifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrowFunctionSpecifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:l1] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrowFunctionSpecifier", $count, $begin, $end)
};

(:~
 : Parse ArrowPostfix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrowPostfix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(60, $input, $state)               (: '=>' :)
  let $state := p:lookahead1W(178, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArrowFunctionSpecifier($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArgumentList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrowPostfix", $count, $begin, $end)
};

(:~
 : Parse Lookup.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Lookup($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(64, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(140, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-KeySpecifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Lookup", $count, $begin, $end)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(68, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(69, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Predicate", $count, $begin, $end)
};

(:~
 : Parse KeySpecifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeySpecifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KeySpecifier", $count, $begin, $end)
};

(:~
 : Parse UnaryLookup.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryLookup($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(64, $input, $state)               (: '?' :)
  let $state := p:lookahead1W(140, $input, $state)          (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               '*' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-KeySpecifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryLookup", $count, $begin, $end)
};

(:~
 : Parse CurlyArrayConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurlyArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(75, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurlyArrayConstructor", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SquareArrayConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-SquareArrayConstructor-1($input, $state)
};

(:~
 : Parse SquareArrayConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SquareArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(68, $input, $state)               (: '[' :)
  let $state := p:lookahead1W(190, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | ']' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 69) then                      (: ']' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-SquareArrayConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(69, $input, $state)               (: ']' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SquareArrayConstructor", $count, $begin, $end)
};

(:~
 : Parse ArrayConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: '[' :)
      let $state := p:parse-SquareArrayConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CurlyArrayConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayConstructor", $count, $begin, $end)
};

(:~
 : Parse MapValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapValueExpr", $count, $begin, $end)
};

(:~
 : Parse MapKeyExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapKeyExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapKeyExpr", $count, $begin, $end)
};

(:~
 : Parse MapConstructorEntry.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapConstructorEntry($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MapKeyExpr($input, $state)
  let $state := p:consume(47, $input, $state)               (: ':' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-MapValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapConstructorEntry", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MapConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MapConstructorEntry($input, $state)
      return p:parse-MapConstructor-1($input, $state)
};

(:~
 : Parse MapConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(140, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MapConstructorEntry($input, $state)
      let $state := p:parse-MapConstructor-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "MapConstructor", $count, $begin, $end)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EnclosedExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionBody", $count, $begin, $end)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Param", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParamList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production InlineFunctionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(67, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-InlineFunctionExpr-1($input, $state)
};

(:~
 : Parse InlineFunctionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunctionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InlineFunctionExpr-1($input, $state)
  let $state := p:consume(119, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(179, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-FunctionBody($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "InlineFunctionExpr", $count, $begin, $end)
};

(:~
 : Parse NamedFunctionRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamedFunctionRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:consume(28, $input, $state)               (: '#' :)
  let $state := p:lookahead1W(16, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:consume(1, $input, $state)                (: IntegerLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamedFunctionRef", $count, $begin, $end)
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'function' :)
      let $state := p:lookahead2W(62, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 8567) then                     (: 'function' '(' :)
      let $state := p:parse-InlineFunctionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NamedFunctionRef($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionItemExpr", $count, $begin, $end)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(166, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(136, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: '{' :)
      let $state := p:consume(198, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:consume(202, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompPIConstructor", $count, $begin, $end)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(180, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompTextConstructor", $count, $begin, $end)
};

(:~
 : Parse URIExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URIExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "URIExpr", $count, $begin, $end)
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PrefixExpr", $count, $begin, $end)
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NCName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prefix", $count, $begin, $end)
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(144, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(136, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: '{' :)
      let $state := p:consume(198, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PrefixExpr($input, $state)
      let $state := p:consume(202, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URIExpr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompNamespaceConstructor", $count, $begin, $end)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(176, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: '{' :)
      let $state := p:consume(198, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:consume(202, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompAttrConstructor", $count, $begin, $end)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContentExpr", $count, $begin, $end)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(176, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 198) then                      (: '{' :)
      let $state := p:consume(198, $input, $state)          (: '{' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      let $state := p:consume(202, $input, $state)          (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompElemConstructor", $count, $begin, $end)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(103, $input, $state)              (: 'document' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CompDocConstructor", $count, $begin, $end)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 103) then                      (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace' :)
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComputedConstructor", $count, $begin, $end)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(58, $input, $state)               (: '<?' :)
  let $state := p:lookahead1(0, $input, $state)             (: PITarget :)
  let $state := p:consume(12, $input, $state)               (: PITarget :)
  let $state := p:lookahead1(14, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:consume(16, $input, $state)           (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:consume(22, $input, $state)           (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(9, $input, $state)             (: '?>' :)
  let $state := p:consume(65, $input, $state)               (: '?>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirPIConstructor", $count, $begin, $end)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(53, $input, $state)               (: '<!--' :)
  let $state := p:lookahead1(2, $input, $state)             (: DirCommentContents :)
  let $state := p:consume(21, $input, $state)               (: DirCommentContents :)
  let $state := p:lookahead1(6, $input, $state)             (: '-->' :)
  let $state := p:consume(41, $input, $state)               (: '-->' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirCommentConstructor", $count, $begin, $end)
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(54, $input, $state)               (: '<![CDATA[' :)
  let $state := p:lookahead1(4, $input, $state)             (: CDataSectionContents :)
  let $state := p:consume(23, $input, $state)               (: CDataSectionContents :)
  let $state := p:lookahead1(10, $input, $state)            (: ']]>' :)
  let $state := p:consume(70, $input, $state)               (: ']]>' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CDataSection", $count, $begin, $end)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52                             (: '<' :)
          or $state[$p:l1] = 53                             (: '<!--' :)
          or $state[$p:l1] = 58) then                       (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: ElementContentChar :)
      let $state := p:consume(9, $input, $state)            (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemContent", $count, $begin, $end)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 11) then                       (: AposAttrContentChar :)
      let $state := p:consume(11, $input, $state)           (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AposAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "EnclosedExpr", $count, $begin, $end)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 6) then                        (: PredefinedEntityRef :)
      let $state := p:consume(6, $input, $state)            (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 13) then                       (: CharRef :)
      let $state := p:consume(13, $input, $state)           (: CharRef :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: '{{' :)
      let $state := p:consume(199, $input, $state)          (: '{{' :)
      return $state
    else if ($state[$p:l1] = 203) then                      (: '}}' :)
      let $state := p:consume(203, $input, $state)          (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CommonContent", $count, $begin, $end)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 10) then                       (: QuotAttrContentChar :)
      let $state := p:consume(10, $input, $state)           (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QuotAttrValueContent", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(121, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 7) then                  (: EscapeQuot :)
            let $state := p:consume(7, $input, $state)      (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(122, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 8) then                  (: EscapeApos :)
            let $state := p:consume(8, $input, $state)      (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(15, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27) then                       (: '"' :)
      let $state := p:consume(27, $input, $state)           (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:consume(27, $input, $state)           (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(32, $input, $state)           (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:consume(32, $input, $state)           (: "'" :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeValue", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(19, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 16) then                         (: S :)
        $state
      else
        let $state := p:consume(16, $input, $state)         (: S :)
        let $state := p:lookahead1(173, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 16                      (: S :)
               and $state[$p:l1] != 46                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(12, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 16) then             (: S :)
                let $state := p:consume(16, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(7, $input, $state)   (: '=' :)
            let $state := p:consume(59, $input, $state)     (: '=' :)
            let $state := p:lookahead1(18, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 16) then             (: S :)
                let $state := p:consume(16, $input, $state) (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-DirAttributeList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DirAttributeList", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(127, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 55) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(52, $input, $state)               (: '<' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46) then                       (: '/>' :)
      let $state := p:consume(46, $input, $state)           (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(61, $input, $state)           (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:consume(55, $input, $state)           (: '</' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(13, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 16) then                   (: S :)
          let $state := p:consume(16, $input, $state)       (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(8, $input, $state)         (: '>' :)
      let $state := p:consume(61, $input, $state)           (: '>' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirElemConstructor", $count, $begin, $end)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DirectConstructor", $count, $begin, $end)
};

(:~
 : Parse NodeConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52                             (: '<' :)
          or $state[$p:l1] = 53                             (: '<!--' :)
          or $state[$p:l1] = 58) then                       (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NodeConstructor", $count, $begin, $end)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(189, $input, $state)              (: 'unordered' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnorderedExpr", $count, $begin, $end)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(156, $input, $state)              (: 'ordered' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderedExpr", $count, $begin, $end)
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(64, $input, $state)               (: '?' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentPlaceholder", $count, $begin, $end)
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 64) then                           (: '?' :)
      let $state := p:lookahead2W(144, $input, $state)      (: IntegerLiteral | NCName^Token | S^WS | '(' | ('(' ':') |
                                                               ')' | '*' | ',' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 9280                           (: '?' ')' :)
          or $state[$p:lk] = 10048) then                    (: '?' ',' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Argument", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(187, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ArgumentList", $count, $begin, $end)
};

(:~
 : Parse FunctionEQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionEQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionEQName", $count, $begin, $end)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionEQName($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ArgumentList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionCall", $count, $begin, $end)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(42, $input, $state)               (: '.' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemExpr", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(189, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedExpr", $count, $begin, $end)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarRef", $count, $begin, $end)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 144) then                          (: 'namespace' :)
      let $state := p:lookahead2W(141, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] eq 166) then                     (: 'processing-instruction' :)
      let $state := p:lookahead2W(138, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = (79,                           (: 'attribute' :)
                              105)) then                    (: 'element' :)
      let $state := p:lookahead2W(177, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = (103,                          (: 'document' :)
                              156,                          (: 'ordered' :)
                              189)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(100, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (75,                           (: 'array' :)
                              89,                           (: 'comment' :)
                              140,                          (: 'map' :)
                              180)) then                    (: 'text' :)
      let $state := p:lookahead2W(63, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              72,                           (: 'ancestor' :)
                              73,                           (: 'ancestor-or-self' :)
                              74,                           (: 'and' :)
                              77,                           (: 'ascending' :)
                              83,                           (: 'case' :)
                              84,                           (: 'cast' :)
                              85,                           (: 'castable' :)
                              87,                           (: 'child' :)
                              88,                           (: 'collation' :)
                              93,                           (: 'count' :)
                              96,                           (: 'declare' :)
                              97,                           (: 'default' :)
                              98,                           (: 'descendant' :)
                              99,                           (: 'descendant-or-self' :)
                              100,                          (: 'descending' :)
                              102,                          (: 'div' :)
                              106,                          (: 'else' :)
                              107,                          (: 'empty' :)
                              110,                          (: 'end' :)
                              111,                          (: 'eq' :)
                              112,                          (: 'every' :)
                              113,                          (: 'except' :)
                              116,                          (: 'following' :)
                              117,                          (: 'following-sibling' :)
                              118,                          (: 'for' :)
                              120,                          (: 'ge' :)
                              122,                          (: 'group' :)
                              124,                          (: 'gt' :)
                              125,                          (: 'idiv' :)
                              127,                          (: 'import' :)
                              131,                          (: 'instance' :)
                              132,                          (: 'intersect' :)
                              133,                          (: 'is' :)
                              136,                          (: 'le' :)
                              138,                          (: 'let' :)
                              139,                          (: 'lt' :)
                              142,                          (: 'mod' :)
                              143,                          (: 'module' :)
                              146,                          (: 'ne' :)
                              152,                          (: 'only' :)
                              154,                          (: 'or' :)
                              155,                          (: 'order' :)
                              158,                          (: 'parent' :)
                              162,                          (: 'preceding' :)
                              163,                          (: 'preceding-sibling' :)
                              167,                          (: 'return' :)
                              168,                          (: 'satisfies' :)
                              172,                          (: 'self' :)
                              174,                          (: 'some' :)
                              175,                          (: 'stable' :)
                              176,                          (: 'start' :)
                              182,                          (: 'to' :)
                              183,                          (: 'treat' :)
                              184,                          (: 'try' :)
                              188,                          (: 'union' :)
                              190,                          (: 'validate' :)
                              194,                          (: 'where' :)
                              196)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(62, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4) then                        (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 42) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8453                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8463                           (: QName^Token '(' :)
          or $state[$p:lk] = 8520                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8521                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8522                           (: 'and' '(' :)
          or $state[$p:lk] = 8525                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8531                           (: 'case' '(' :)
          or $state[$p:lk] = 8532                           (: 'cast' '(' :)
          or $state[$p:lk] = 8533                           (: 'castable' '(' :)
          or $state[$p:lk] = 8535                           (: 'child' '(' :)
          or $state[$p:lk] = 8536                           (: 'collation' '(' :)
          or $state[$p:lk] = 8541                           (: 'count' '(' :)
          or $state[$p:lk] = 8544                           (: 'declare' '(' :)
          or $state[$p:lk] = 8545                           (: 'default' '(' :)
          or $state[$p:lk] = 8546                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8547                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8548                           (: 'descending' '(' :)
          or $state[$p:lk] = 8550                           (: 'div' '(' :)
          or $state[$p:lk] = 8551                           (: 'document' '(' :)
          or $state[$p:lk] = 8554                           (: 'else' '(' :)
          or $state[$p:lk] = 8555                           (: 'empty' '(' :)
          or $state[$p:lk] = 8558                           (: 'end' '(' :)
          or $state[$p:lk] = 8559                           (: 'eq' '(' :)
          or $state[$p:lk] = 8560                           (: 'every' '(' :)
          or $state[$p:lk] = 8561                           (: 'except' '(' :)
          or $state[$p:lk] = 8564                           (: 'following' '(' :)
          or $state[$p:lk] = 8565                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8566                           (: 'for' '(' :)
          or $state[$p:lk] = 8568                           (: 'ge' '(' :)
          or $state[$p:lk] = 8570                           (: 'group' '(' :)
          or $state[$p:lk] = 8572                           (: 'gt' '(' :)
          or $state[$p:lk] = 8573                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8575                           (: 'import' '(' :)
          or $state[$p:lk] = 8579                           (: 'instance' '(' :)
          or $state[$p:lk] = 8580                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8581                           (: 'is' '(' :)
          or $state[$p:lk] = 8584                           (: 'le' '(' :)
          or $state[$p:lk] = 8586                           (: 'let' '(' :)
          or $state[$p:lk] = 8587                           (: 'lt' '(' :)
          or $state[$p:lk] = 8590                           (: 'mod' '(' :)
          or $state[$p:lk] = 8591                           (: 'module' '(' :)
          or $state[$p:lk] = 8592                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8594                           (: 'ne' '(' :)
          or $state[$p:lk] = 8600                           (: 'only' '(' :)
          or $state[$p:lk] = 8602                           (: 'or' '(' :)
          or $state[$p:lk] = 8603                           (: 'order' '(' :)
          or $state[$p:lk] = 8604                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8606                           (: 'parent' '(' :)
          or $state[$p:lk] = 8610                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8611                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8615                           (: 'return' '(' :)
          or $state[$p:lk] = 8616                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8620                           (: 'self' '(' :)
          or $state[$p:lk] = 8622                           (: 'some' '(' :)
          or $state[$p:lk] = 8623                           (: 'stable' '(' :)
          or $state[$p:lk] = 8624                           (: 'start' '(' :)
          or $state[$p:lk] = 8630                           (: 'to' '(' :)
          or $state[$p:lk] = 8631                           (: 'treat' '(' :)
          or $state[$p:lk] = 8632                           (: 'try' '(' :)
          or $state[$p:lk] = 8636                           (: 'union' '(' :)
          or $state[$p:lk] = 8637                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8638                           (: 'validate' '(' :)
          or $state[$p:lk] = 8642                           (: 'where' '(' :)
          or $state[$p:lk] = 8644) then                     (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 50844) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50877) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 104                            (: 'document-node' :)
          or $state[$p:lk] = 108                            (: 'empty-sequence' :)
          or $state[$p:lk] = 119                            (: 'function' :)
          or $state[$p:lk] = 126                            (: 'if' :)
          or $state[$p:lk] = 134                            (: 'item' :)
          or $state[$p:lk] = 145                            (: 'namespace-node' :)
          or $state[$p:lk] = 150                            (: 'node' :)
          or $state[$p:lk] = 170                            (: 'schema-attribute' :)
          or $state[$p:lk] = 171                            (: 'schema-element' :)
          or $state[$p:lk] = 179                            (: 'switch' :)
          or $state[$p:lk] = 187                            (: 'typeswitch' :)
          or $state[$p:lk] = 7173                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7183                           (: QName^Token '#' :)
          or $state[$p:lk] = 7240                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7241                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7242                           (: 'and' '#' :)
          or $state[$p:lk] = 7243                           (: 'array' '#' :)
          or $state[$p:lk] = 7245                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7247                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7251                           (: 'case' '#' :)
          or $state[$p:lk] = 7252                           (: 'cast' '#' :)
          or $state[$p:lk] = 7253                           (: 'castable' '#' :)
          or $state[$p:lk] = 7255                           (: 'child' '#' :)
          or $state[$p:lk] = 7256                           (: 'collation' '#' :)
          or $state[$p:lk] = 7257                           (: 'comment' '#' :)
          or $state[$p:lk] = 7261                           (: 'count' '#' :)
          or $state[$p:lk] = 7264                           (: 'declare' '#' :)
          or $state[$p:lk] = 7265                           (: 'default' '#' :)
          or $state[$p:lk] = 7266                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7267                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7268                           (: 'descending' '#' :)
          or $state[$p:lk] = 7270                           (: 'div' '#' :)
          or $state[$p:lk] = 7271                           (: 'document' '#' :)
          or $state[$p:lk] = 7273                           (: 'element' '#' :)
          or $state[$p:lk] = 7274                           (: 'else' '#' :)
          or $state[$p:lk] = 7275                           (: 'empty' '#' :)
          or $state[$p:lk] = 7278                           (: 'end' '#' :)
          or $state[$p:lk] = 7279                           (: 'eq' '#' :)
          or $state[$p:lk] = 7280                           (: 'every' '#' :)
          or $state[$p:lk] = 7281                           (: 'except' '#' :)
          or $state[$p:lk] = 7284                           (: 'following' '#' :)
          or $state[$p:lk] = 7285                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7286                           (: 'for' '#' :)
          or $state[$p:lk] = 7288                           (: 'ge' '#' :)
          or $state[$p:lk] = 7290                           (: 'group' '#' :)
          or $state[$p:lk] = 7292                           (: 'gt' '#' :)
          or $state[$p:lk] = 7293                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7295                           (: 'import' '#' :)
          or $state[$p:lk] = 7299                           (: 'instance' '#' :)
          or $state[$p:lk] = 7300                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7301                           (: 'is' '#' :)
          or $state[$p:lk] = 7304                           (: 'le' '#' :)
          or $state[$p:lk] = 7306                           (: 'let' '#' :)
          or $state[$p:lk] = 7307                           (: 'lt' '#' :)
          or $state[$p:lk] = 7308                           (: 'map' '#' :)
          or $state[$p:lk] = 7310                           (: 'mod' '#' :)
          or $state[$p:lk] = 7311                           (: 'module' '#' :)
          or $state[$p:lk] = 7312                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7314                           (: 'ne' '#' :)
          or $state[$p:lk] = 7320                           (: 'only' '#' :)
          or $state[$p:lk] = 7322                           (: 'or' '#' :)
          or $state[$p:lk] = 7323                           (: 'order' '#' :)
          or $state[$p:lk] = 7324                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7326                           (: 'parent' '#' :)
          or $state[$p:lk] = 7330                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7331                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7334                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7335                           (: 'return' '#' :)
          or $state[$p:lk] = 7336                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7340                           (: 'self' '#' :)
          or $state[$p:lk] = 7342                           (: 'some' '#' :)
          or $state[$p:lk] = 7343                           (: 'stable' '#' :)
          or $state[$p:lk] = 7344                           (: 'start' '#' :)
          or $state[$p:lk] = 7348                           (: 'text' '#' :)
          or $state[$p:lk] = 7350                           (: 'to' '#' :)
          or $state[$p:lk] = 7351                           (: 'treat' '#' :)
          or $state[$p:lk] = 7352                           (: 'try' '#' :)
          or $state[$p:lk] = 7356                           (: 'union' '#' :)
          or $state[$p:lk] = 7357                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7358                           (: 'validate' '#' :)
          or $state[$p:lk] = 7362                           (: 'where' '#' :)
          or $state[$p:lk] = 7364) then                     (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50828) then                    (: 'map' '{' :)
      let $state := p:parse-MapConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 68                             (: '[' :)
          or $state[$p:lk] = 50763) then                    (: 'array' '{' :)
      let $state := p:parse-ArrayConstructor($input, $state)
      return $state
    else if ($state[$p:lk] = 64) then                       (: '?' :)
      let $state := p:parse-UnaryLookup($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NodeConstructor($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PrimaryExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: S^WS | EOF | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 33                               (: '(' :)
      and $state[$p:l1] != 60                               (: '=>' :)
      and $state[$p:l1] != 64                               (: '?' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: '[' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:l1] = 33) then                 (: '(' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ArgumentList($input, $state)
            return $state
          else if ($state[$p:l1] = 64) then                 (: '?' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Lookup($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ArrowPostfix($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PostfixExpr", $count, $begin, $end)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 79) then                           (: 'attribute' :)
      let $state := p:lookahead2W(194, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 22607) then                    (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(61, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 24911) then               (: 'attribute' 'default' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 27471) then               (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 30287) then               (: 'attribute' 'for' :)
          let $state := p:lookahead3W(113, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 33615) then               (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 38991) then               (: 'attribute' 'only' :)
          let $state := p:lookahead3W(84, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 44879) then               (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(92, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (19791,                    (: 'attribute' 'ascending' :)
                                  25679)) then              (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(132, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (23887,                    (: 'attribute' 'count' :)
                                  35407)) then              (: 'attribute' 'let' :)
          let $state := p:lookahead3W(66, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (28239,                    (: 'attribute' 'end' :)
                                  45135)) then              (: 'attribute' 'start' :)
          let $state := p:lookahead3W(123, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (31311,                    (: 'attribute' 'group' :)
                                  39759)) then              (: 'attribute' 'order' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (21583,                    (: 'attribute' 'cast' :)
                                  21839,                    (: 'attribute' 'castable' :)
                                  46927)) then              (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(78, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (19023,                    (: 'attribute' 'and' :)
                                  21327,                    (: 'attribute' 'case' :)
                                  26191,                    (: 'attribute' 'div' :)
                                  27215,                    (: 'attribute' 'else' :)
                                  28495,                    (: 'attribute' 'eq' :)
                                  29007,                    (: 'attribute' 'except' :)
                                  30799,                    (: 'attribute' 'ge' :)
                                  31823,                    (: 'attribute' 'gt' :)
                                  32079,                    (: 'attribute' 'idiv' :)
                                  33871,                    (: 'attribute' 'intersect' :)
                                  34127,                    (: 'attribute' 'is' :)
                                  34895,                    (: 'attribute' 'le' :)
                                  35663,                    (: 'attribute' 'lt' :)
                                  36431,                    (: 'attribute' 'mod' :)
                                  37455,                    (: 'attribute' 'ne' :)
                                  39503,                    (: 'attribute' 'or' :)
                                  42831,                    (: 'attribute' 'return' :)
                                  43087,                    (: 'attribute' 'satisfies' :)
                                  46671,                    (: 'attribute' 'to' :)
                                  48207,                    (: 'attribute' 'union' :)
                                  49743)) then              (: 'attribute' 'where' :)
          let $state := p:lookahead3W(191, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] eq 105) then                     (: 'element' :)
      let $state := p:lookahead2W(193, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | EOF | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ':' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] eq 22633) then                    (: 'element' 'collation' :)
          let $state := p:lookahead3W(61, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] eq 24937) then               (: 'element' 'default' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] eq 27497) then               (: 'element' 'empty' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] eq 30313) then               (: 'element' 'for' :)
          let $state := p:lookahead3W(113, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] eq 33641) then               (: 'element' 'instance' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] eq 39017) then               (: 'element' 'only' :)
          let $state := p:lookahead3W(84, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] eq 44905) then               (: 'element' 'stable' :)
          let $state := p:lookahead3W(92, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (19817,                    (: 'element' 'ascending' :)
                                  25705)) then              (: 'element' 'descending' :)
          let $state := p:lookahead3W(132, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (23913,                    (: 'element' 'count' :)
                                  35433)) then              (: 'element' 'let' :)
          let $state := p:lookahead3W(66, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (28265,                    (: 'element' 'end' :)
                                  45161)) then              (: 'element' 'start' :)
          let $state := p:lookahead3W(123, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (31337,                    (: 'element' 'group' :)
                                  39785)) then              (: 'element' 'order' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (21609,                    (: 'element' 'cast' :)
                                  21865,                    (: 'element' 'castable' :)
                                  46953)) then              (: 'element' 'treat' :)
          let $state := p:lookahead3W(78, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (19049,                    (: 'element' 'and' :)
                                  21353,                    (: 'element' 'case' :)
                                  26217,                    (: 'element' 'div' :)
                                  27241,                    (: 'element' 'else' :)
                                  28521,                    (: 'element' 'eq' :)
                                  29033,                    (: 'element' 'except' :)
                                  30825,                    (: 'element' 'ge' :)
                                  31849,                    (: 'element' 'gt' :)
                                  32105,                    (: 'element' 'idiv' :)
                                  33897,                    (: 'element' 'intersect' :)
                                  34153,                    (: 'element' 'is' :)
                                  34921,                    (: 'element' 'le' :)
                                  35689,                    (: 'element' 'lt' :)
                                  36457,                    (: 'element' 'mod' :)
                                  37481,                    (: 'element' 'ne' :)
                                  39529,                    (: 'element' 'or' :)
                                  42857,                    (: 'element' 'return' :)
                                  43113,                    (: 'element' 'satisfies' :)
                                  46697,                    (: 'element' 'to' :)
                                  48233,                    (: 'element' 'union' :)
                                  49769)) then              (: 'element' 'where' :)
          let $state := p:lookahead3W(191, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (75,                           (: 'array' :)
                              140)) then                    (: 'map' :)
      let $state := p:lookahead2W(160, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (144,                          (: 'namespace' :)
                              166)) then                    (: 'processing-instruction' :)
      let $state := p:lookahead2W(166, $input, $state)      (: NCName^Token | S^WS | EOF | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '[' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = (22672,                         (: 'namespace' 'collation' :)
                             22694)) then                   (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(61, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (24976,                    (: 'namespace' 'default' :)
                                  24998)) then              (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = (27536,                    (: 'namespace' 'empty' :)
                                  27558)) then              (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = (30352,                    (: 'namespace' 'for' :)
                                  30374)) then              (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(113, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = (33680,                    (: 'namespace' 'instance' :)
                                  33702)) then              (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = (39056,                    (: 'namespace' 'only' :)
                                  39078)) then              (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(84, $input, $state)   (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = (44944,                    (: 'namespace' 'stable' :)
                                  44966)) then              (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(92, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = (19856,                    (: 'namespace' 'ascending' :)
                                  25744,                    (: 'namespace' 'descending' :)
                                  19878,                    (: 'processing-instruction' 'ascending' :)
                                  25766)) then              (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(132, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = (23952,                    (: 'namespace' 'count' :)
                                  35472,                    (: 'namespace' 'let' :)
                                  23974,                    (: 'processing-instruction' 'count' :)
                                  35494)) then              (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(66, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = (28304,                    (: 'namespace' 'end' :)
                                  45200,                    (: 'namespace' 'start' :)
                                  28326,                    (: 'processing-instruction' 'end' :)
                                  45222)) then              (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(123, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = (31376,                    (: 'namespace' 'group' :)
                                  39824,                    (: 'namespace' 'order' :)
                                  31398,                    (: 'processing-instruction' 'group' :)
                                  39846)) then              (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = (21648,                    (: 'namespace' 'cast' :)
                                  21904,                    (: 'namespace' 'castable' :)
                                  46992,                    (: 'namespace' 'treat' :)
                                  21670,                    (: 'processing-instruction' 'cast' :)
                                  21926,                    (: 'processing-instruction' 'castable' :)
                                  47014)) then              (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(78, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = (19088,                    (: 'namespace' 'and' :)
                                  21392,                    (: 'namespace' 'case' :)
                                  26256,                    (: 'namespace' 'div' :)
                                  27280,                    (: 'namespace' 'else' :)
                                  28560,                    (: 'namespace' 'eq' :)
                                  29072,                    (: 'namespace' 'except' :)
                                  30864,                    (: 'namespace' 'ge' :)
                                  31888,                    (: 'namespace' 'gt' :)
                                  32144,                    (: 'namespace' 'idiv' :)
                                  33936,                    (: 'namespace' 'intersect' :)
                                  34192,                    (: 'namespace' 'is' :)
                                  34960,                    (: 'namespace' 'le' :)
                                  35728,                    (: 'namespace' 'lt' :)
                                  36496,                    (: 'namespace' 'mod' :)
                                  37520,                    (: 'namespace' 'ne' :)
                                  39568,                    (: 'namespace' 'or' :)
                                  42896,                    (: 'namespace' 'return' :)
                                  43152,                    (: 'namespace' 'satisfies' :)
                                  46736,                    (: 'namespace' 'to' :)
                                  48272,                    (: 'namespace' 'union' :)
                                  49808,                    (: 'namespace' 'where' :)
                                  19110,                    (: 'processing-instruction' 'and' :)
                                  21414,                    (: 'processing-instruction' 'case' :)
                                  26278,                    (: 'processing-instruction' 'div' :)
                                  27302,                    (: 'processing-instruction' 'else' :)
                                  28582,                    (: 'processing-instruction' 'eq' :)
                                  29094,                    (: 'processing-instruction' 'except' :)
                                  30886,                    (: 'processing-instruction' 'ge' :)
                                  31910,                    (: 'processing-instruction' 'gt' :)
                                  32166,                    (: 'processing-instruction' 'idiv' :)
                                  33958,                    (: 'processing-instruction' 'intersect' :)
                                  34214,                    (: 'processing-instruction' 'is' :)
                                  34982,                    (: 'processing-instruction' 'le' :)
                                  35750,                    (: 'processing-instruction' 'lt' :)
                                  36518,                    (: 'processing-instruction' 'mod' :)
                                  37542,                    (: 'processing-instruction' 'ne' :)
                                  39590,                    (: 'processing-instruction' 'or' :)
                                  42918,                    (: 'processing-instruction' 'return' :)
                                  43174,                    (: 'processing-instruction' 'satisfies' :)
                                  46758,                    (: 'processing-instruction' 'to' :)
                                  48294,                    (: 'processing-instruction' 'union' :)
                                  49830)) then              (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(191, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = (89,                           (: 'comment' :)
                              103,                          (: 'document' :)
                              156,                          (: 'ordered' :)
                              180,                          (: 'text' :)
                              189)) then                    (: 'unordered' :)
      let $state := p:lookahead2W(164, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (108,                          (: 'empty-sequence' :)
                              126,                          (: 'if' :)
                              134,                          (: 'item' :)
                              179,                          (: 'switch' :)
                              187)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (72,                           (: 'ancestor' :)
                              73,                           (: 'ancestor-or-self' :)
                              87,                           (: 'child' :)
                              98,                           (: 'descendant' :)
                              99,                           (: 'descendant-or-self' :)
                              116,                          (: 'following' :)
                              117,                          (: 'following-sibling' :)
                              158,                          (: 'parent' :)
                              162,                          (: 'preceding' :)
                              163,                          (: 'preceding-sibling' :)
                              172)) then                    (: 'self' :)
      let $state := p:lookahead2W(163, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | '::' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (5,                            (: URIQualifiedName :)
                              15,                           (: QName^Token :)
                              74,                           (: 'and' :)
                              77,                           (: 'ascending' :)
                              83,                           (: 'case' :)
                              84,                           (: 'cast' :)
                              85,                           (: 'castable' :)
                              88,                           (: 'collation' :)
                              93,                           (: 'count' :)
                              96,                           (: 'declare' :)
                              97,                           (: 'default' :)
                              100,                          (: 'descending' :)
                              102,                          (: 'div' :)
                              104,                          (: 'document-node' :)
                              106,                          (: 'else' :)
                              107,                          (: 'empty' :)
                              110,                          (: 'end' :)
                              111,                          (: 'eq' :)
                              112,                          (: 'every' :)
                              113,                          (: 'except' :)
                              118,                          (: 'for' :)
                              119,                          (: 'function' :)
                              120,                          (: 'ge' :)
                              122,                          (: 'group' :)
                              124,                          (: 'gt' :)
                              125,                          (: 'idiv' :)
                              127,                          (: 'import' :)
                              131,                          (: 'instance' :)
                              132,                          (: 'intersect' :)
                              133,                          (: 'is' :)
                              136,                          (: 'le' :)
                              138,                          (: 'let' :)
                              139,                          (: 'lt' :)
                              142,                          (: 'mod' :)
                              143,                          (: 'module' :)
                              145,                          (: 'namespace-node' :)
                              146,                          (: 'ne' :)
                              150,                          (: 'node' :)
                              152,                          (: 'only' :)
                              154,                          (: 'or' :)
                              155,                          (: 'order' :)
                              167,                          (: 'return' :)
                              168,                          (: 'satisfies' :)
                              170,                          (: 'schema-attribute' :)
                              171,                          (: 'schema-element' :)
                              174,                          (: 'some' :)
                              175,                          (: 'stable' :)
                              176,                          (: 'start' :)
                              182,                          (: 'to' :)
                              183,                          (: 'treat' :)
                              184,                          (: 'try' :)
                              188,                          (: 'union' :)
                              190,                          (: 'validate' :)
                              194,                          (: 'where' :)
                              196)) then                    (: 'xquery' :)
      let $state := p:lookahead2W(159, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 1                              (: IntegerLiteral :)
          or $state[$p:lk] = 2                              (: DecimalLiteral :)
          or $state[$p:lk] = 3                              (: DoubleLiteral :)
          or $state[$p:lk] = 4                              (: StringLiteral :)
          or $state[$p:lk] = 30                             (: '$' :)
          or $state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 33                             (: '(' :)
          or $state[$p:lk] = 42                             (: '.' :)
          or $state[$p:lk] = 52                             (: '<' :)
          or $state[$p:lk] = 53                             (: '<!--' :)
          or $state[$p:lk] = 58                             (: '<?' :)
          or $state[$p:lk] = 64                             (: '?' :)
          or $state[$p:lk] = 68                             (: '[' :)
          or $state[$p:lk] = 1359                           (: 'attribute' URIQualifiedName :)
          or $state[$p:lk] = 1385                           (: 'element' URIQualifiedName :)
          or $state[$p:lk] = 3728                           (: 'namespace' NCName^Token :)
          or $state[$p:lk] = 3750                           (: 'processing-instruction' NCName^Token :)
          or $state[$p:lk] = 3919                           (: 'attribute' QName^Token :)
          or $state[$p:lk] = 3945                           (: 'element' QName^Token :)
          or $state[$p:lk] = 7173                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7183                           (: QName^Token '#' :)
          or $state[$p:lk] = 7240                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7241                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7242                           (: 'and' '#' :)
          or $state[$p:lk] = 7243                           (: 'array' '#' :)
          or $state[$p:lk] = 7245                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7247                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7251                           (: 'case' '#' :)
          or $state[$p:lk] = 7252                           (: 'cast' '#' :)
          or $state[$p:lk] = 7253                           (: 'castable' '#' :)
          or $state[$p:lk] = 7255                           (: 'child' '#' :)
          or $state[$p:lk] = 7256                           (: 'collation' '#' :)
          or $state[$p:lk] = 7257                           (: 'comment' '#' :)
          or $state[$p:lk] = 7261                           (: 'count' '#' :)
          or $state[$p:lk] = 7264                           (: 'declare' '#' :)
          or $state[$p:lk] = 7265                           (: 'default' '#' :)
          or $state[$p:lk] = 7266                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7267                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7268                           (: 'descending' '#' :)
          or $state[$p:lk] = 7270                           (: 'div' '#' :)
          or $state[$p:lk] = 7271                           (: 'document' '#' :)
          or $state[$p:lk] = 7272                           (: 'document-node' '#' :)
          or $state[$p:lk] = 7273                           (: 'element' '#' :)
          or $state[$p:lk] = 7274                           (: 'else' '#' :)
          or $state[$p:lk] = 7275                           (: 'empty' '#' :)
          or $state[$p:lk] = 7276                           (: 'empty-sequence' '#' :)
          or $state[$p:lk] = 7278                           (: 'end' '#' :)
          or $state[$p:lk] = 7279                           (: 'eq' '#' :)
          or $state[$p:lk] = 7280                           (: 'every' '#' :)
          or $state[$p:lk] = 7281                           (: 'except' '#' :)
          or $state[$p:lk] = 7284                           (: 'following' '#' :)
          or $state[$p:lk] = 7285                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7286                           (: 'for' '#' :)
          or $state[$p:lk] = 7287                           (: 'function' '#' :)
          or $state[$p:lk] = 7288                           (: 'ge' '#' :)
          or $state[$p:lk] = 7290                           (: 'group' '#' :)
          or $state[$p:lk] = 7292                           (: 'gt' '#' :)
          or $state[$p:lk] = 7293                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7294                           (: 'if' '#' :)
          or $state[$p:lk] = 7295                           (: 'import' '#' :)
          or $state[$p:lk] = 7299                           (: 'instance' '#' :)
          or $state[$p:lk] = 7300                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7301                           (: 'is' '#' :)
          or $state[$p:lk] = 7302                           (: 'item' '#' :)
          or $state[$p:lk] = 7304                           (: 'le' '#' :)
          or $state[$p:lk] = 7306                           (: 'let' '#' :)
          or $state[$p:lk] = 7307                           (: 'lt' '#' :)
          or $state[$p:lk] = 7308                           (: 'map' '#' :)
          or $state[$p:lk] = 7310                           (: 'mod' '#' :)
          or $state[$p:lk] = 7311                           (: 'module' '#' :)
          or $state[$p:lk] = 7312                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7313                           (: 'namespace-node' '#' :)
          or $state[$p:lk] = 7314                           (: 'ne' '#' :)
          or $state[$p:lk] = 7318                           (: 'node' '#' :)
          or $state[$p:lk] = 7320                           (: 'only' '#' :)
          or $state[$p:lk] = 7322                           (: 'or' '#' :)
          or $state[$p:lk] = 7323                           (: 'order' '#' :)
          or $state[$p:lk] = 7324                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7326                           (: 'parent' '#' :)
          or $state[$p:lk] = 7330                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7331                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7334                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7335                           (: 'return' '#' :)
          or $state[$p:lk] = 7336                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7338                           (: 'schema-attribute' '#' :)
          or $state[$p:lk] = 7339                           (: 'schema-element' '#' :)
          or $state[$p:lk] = 7340                           (: 'self' '#' :)
          or $state[$p:lk] = 7342                           (: 'some' '#' :)
          or $state[$p:lk] = 7343                           (: 'stable' '#' :)
          or $state[$p:lk] = 7344                           (: 'start' '#' :)
          or $state[$p:lk] = 7347                           (: 'switch' '#' :)
          or $state[$p:lk] = 7348                           (: 'text' '#' :)
          or $state[$p:lk] = 7350                           (: 'to' '#' :)
          or $state[$p:lk] = 7351                           (: 'treat' '#' :)
          or $state[$p:lk] = 7352                           (: 'try' '#' :)
          or $state[$p:lk] = 7355                           (: 'typeswitch' '#' :)
          or $state[$p:lk] = 7356                           (: 'union' '#' :)
          or $state[$p:lk] = 7357                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7358                           (: 'validate' '#' :)
          or $state[$p:lk] = 7362                           (: 'where' '#' :)
          or $state[$p:lk] = 7364                           (: 'xquery' '#' :)
          or $state[$p:lk] = 8453                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8463                           (: QName^Token '(' :)
          or $state[$p:lk] = 8520                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8521                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8522                           (: 'and' '(' :)
          or $state[$p:lk] = 8525                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8531                           (: 'case' '(' :)
          or $state[$p:lk] = 8532                           (: 'cast' '(' :)
          or $state[$p:lk] = 8533                           (: 'castable' '(' :)
          or $state[$p:lk] = 8535                           (: 'child' '(' :)
          or $state[$p:lk] = 8536                           (: 'collation' '(' :)
          or $state[$p:lk] = 8541                           (: 'count' '(' :)
          or $state[$p:lk] = 8544                           (: 'declare' '(' :)
          or $state[$p:lk] = 8545                           (: 'default' '(' :)
          or $state[$p:lk] = 8546                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8547                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8548                           (: 'descending' '(' :)
          or $state[$p:lk] = 8550                           (: 'div' '(' :)
          or $state[$p:lk] = 8551                           (: 'document' '(' :)
          or $state[$p:lk] = 8554                           (: 'else' '(' :)
          or $state[$p:lk] = 8555                           (: 'empty' '(' :)
          or $state[$p:lk] = 8558                           (: 'end' '(' :)
          or $state[$p:lk] = 8559                           (: 'eq' '(' :)
          or $state[$p:lk] = 8560                           (: 'every' '(' :)
          or $state[$p:lk] = 8561                           (: 'except' '(' :)
          or $state[$p:lk] = 8564                           (: 'following' '(' :)
          or $state[$p:lk] = 8565                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8566                           (: 'for' '(' :)
          or $state[$p:lk] = 8567                           (: 'function' '(' :)
          or $state[$p:lk] = 8568                           (: 'ge' '(' :)
          or $state[$p:lk] = 8570                           (: 'group' '(' :)
          or $state[$p:lk] = 8572                           (: 'gt' '(' :)
          or $state[$p:lk] = 8573                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8575                           (: 'import' '(' :)
          or $state[$p:lk] = 8579                           (: 'instance' '(' :)
          or $state[$p:lk] = 8580                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8581                           (: 'is' '(' :)
          or $state[$p:lk] = 8584                           (: 'le' '(' :)
          or $state[$p:lk] = 8586                           (: 'let' '(' :)
          or $state[$p:lk] = 8587                           (: 'lt' '(' :)
          or $state[$p:lk] = 8590                           (: 'mod' '(' :)
          or $state[$p:lk] = 8591                           (: 'module' '(' :)
          or $state[$p:lk] = 8592                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8594                           (: 'ne' '(' :)
          or $state[$p:lk] = 8600                           (: 'only' '(' :)
          or $state[$p:lk] = 8602                           (: 'or' '(' :)
          or $state[$p:lk] = 8603                           (: 'order' '(' :)
          or $state[$p:lk] = 8604                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8606                           (: 'parent' '(' :)
          or $state[$p:lk] = 8610                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8611                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8615                           (: 'return' '(' :)
          or $state[$p:lk] = 8616                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8620                           (: 'self' '(' :)
          or $state[$p:lk] = 8622                           (: 'some' '(' :)
          or $state[$p:lk] = 8623                           (: 'stable' '(' :)
          or $state[$p:lk] = 8624                           (: 'start' '(' :)
          or $state[$p:lk] = 8630                           (: 'to' '(' :)
          or $state[$p:lk] = 8631                           (: 'treat' '(' :)
          or $state[$p:lk] = 8632                           (: 'try' '(' :)
          or $state[$p:lk] = 8636                           (: 'union' '(' :)
          or $state[$p:lk] = 8637                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8638                           (: 'validate' '(' :)
          or $state[$p:lk] = 8642                           (: 'where' '(' :)
          or $state[$p:lk] = 8644                           (: 'xquery' '(' :)
          or $state[$p:lk] = 18511                          (: 'attribute' 'ancestor' :)
          or $state[$p:lk] = 18537                          (: 'element' 'ancestor' :)
          or $state[$p:lk] = 18767                          (: 'attribute' 'ancestor-or-self' :)
          or $state[$p:lk] = 18793                          (: 'element' 'ancestor-or-self' :)
          or $state[$p:lk] = 19279                          (: 'attribute' 'array' :)
          or $state[$p:lk] = 19305                          (: 'element' 'array' :)
          or $state[$p:lk] = 20303                          (: 'attribute' 'attribute' :)
          or $state[$p:lk] = 20329                          (: 'element' 'attribute' :)
          or $state[$p:lk] = 22351                          (: 'attribute' 'child' :)
          or $state[$p:lk] = 22377                          (: 'element' 'child' :)
          or $state[$p:lk] = 22863                          (: 'attribute' 'comment' :)
          or $state[$p:lk] = 22889                          (: 'element' 'comment' :)
          or $state[$p:lk] = 24655                          (: 'attribute' 'declare' :)
          or $state[$p:lk] = 24681                          (: 'element' 'declare' :)
          or $state[$p:lk] = 25167                          (: 'attribute' 'descendant' :)
          or $state[$p:lk] = 25193                          (: 'element' 'descendant' :)
          or $state[$p:lk] = 25423                          (: 'attribute' 'descendant-or-self' :)
          or $state[$p:lk] = 25449                          (: 'element' 'descendant-or-self' :)
          or $state[$p:lk] = 26447                          (: 'attribute' 'document' :)
          or $state[$p:lk] = 26473                          (: 'element' 'document' :)
          or $state[$p:lk] = 26703                          (: 'attribute' 'document-node' :)
          or $state[$p:lk] = 26729                          (: 'element' 'document-node' :)
          or $state[$p:lk] = 26959                          (: 'attribute' 'element' :)
          or $state[$p:lk] = 26985                          (: 'element' 'element' :)
          or $state[$p:lk] = 27727                          (: 'attribute' 'empty-sequence' :)
          or $state[$p:lk] = 27753                          (: 'element' 'empty-sequence' :)
          or $state[$p:lk] = 28751                          (: 'attribute' 'every' :)
          or $state[$p:lk] = 28777                          (: 'element' 'every' :)
          or $state[$p:lk] = 29775                          (: 'attribute' 'following' :)
          or $state[$p:lk] = 29801                          (: 'element' 'following' :)
          or $state[$p:lk] = 30031                          (: 'attribute' 'following-sibling' :)
          or $state[$p:lk] = 30057                          (: 'element' 'following-sibling' :)
          or $state[$p:lk] = 30543                          (: 'attribute' 'function' :)
          or $state[$p:lk] = 30569                          (: 'element' 'function' :)
          or $state[$p:lk] = 32335                          (: 'attribute' 'if' :)
          or $state[$p:lk] = 32361                          (: 'element' 'if' :)
          or $state[$p:lk] = 32591                          (: 'attribute' 'import' :)
          or $state[$p:lk] = 32617                          (: 'element' 'import' :)
          or $state[$p:lk] = 34383                          (: 'attribute' 'item' :)
          or $state[$p:lk] = 34409                          (: 'element' 'item' :)
          or $state[$p:lk] = 35919                          (: 'attribute' 'map' :)
          or $state[$p:lk] = 35945                          (: 'element' 'map' :)
          or $state[$p:lk] = 36687                          (: 'attribute' 'module' :)
          or $state[$p:lk] = 36713                          (: 'element' 'module' :)
          or $state[$p:lk] = 36943                          (: 'attribute' 'namespace' :)
          or $state[$p:lk] = 36969                          (: 'element' 'namespace' :)
          or $state[$p:lk] = 37199                          (: 'attribute' 'namespace-node' :)
          or $state[$p:lk] = 37225                          (: 'element' 'namespace-node' :)
          or $state[$p:lk] = 38479                          (: 'attribute' 'node' :)
          or $state[$p:lk] = 38505                          (: 'element' 'node' :)
          or $state[$p:lk] = 40015                          (: 'attribute' 'ordered' :)
          or $state[$p:lk] = 40041                          (: 'element' 'ordered' :)
          or $state[$p:lk] = 40527                          (: 'attribute' 'parent' :)
          or $state[$p:lk] = 40553                          (: 'element' 'parent' :)
          or $state[$p:lk] = 41551                          (: 'attribute' 'preceding' :)
          or $state[$p:lk] = 41577                          (: 'element' 'preceding' :)
          or $state[$p:lk] = 41807                          (: 'attribute' 'preceding-sibling' :)
          or $state[$p:lk] = 41833                          (: 'element' 'preceding-sibling' :)
          or $state[$p:lk] = 42575                          (: 'attribute' 'processing-instruction' :)
          or $state[$p:lk] = 42601                          (: 'element' 'processing-instruction' :)
          or $state[$p:lk] = 43599                          (: 'attribute' 'schema-attribute' :)
          or $state[$p:lk] = 43625                          (: 'element' 'schema-attribute' :)
          or $state[$p:lk] = 43855                          (: 'attribute' 'schema-element' :)
          or $state[$p:lk] = 43881                          (: 'element' 'schema-element' :)
          or $state[$p:lk] = 44111                          (: 'attribute' 'self' :)
          or $state[$p:lk] = 44137                          (: 'element' 'self' :)
          or $state[$p:lk] = 44623                          (: 'attribute' 'some' :)
          or $state[$p:lk] = 44649                          (: 'element' 'some' :)
          or $state[$p:lk] = 45903                          (: 'attribute' 'switch' :)
          or $state[$p:lk] = 45929                          (: 'element' 'switch' :)
          or $state[$p:lk] = 46159                          (: 'attribute' 'text' :)
          or $state[$p:lk] = 46185                          (: 'element' 'text' :)
          or $state[$p:lk] = 47183                          (: 'attribute' 'try' :)
          or $state[$p:lk] = 47209                          (: 'element' 'try' :)
          or $state[$p:lk] = 47951                          (: 'attribute' 'typeswitch' :)
          or $state[$p:lk] = 47977                          (: 'element' 'typeswitch' :)
          or $state[$p:lk] = 48463                          (: 'attribute' 'unordered' :)
          or $state[$p:lk] = 48489                          (: 'element' 'unordered' :)
          or $state[$p:lk] = 48719                          (: 'attribute' 'validate' :)
          or $state[$p:lk] = 48745                          (: 'element' 'validate' :)
          or $state[$p:lk] = 50255                          (: 'attribute' 'xquery' :)
          or $state[$p:lk] = 50281                          (: 'element' 'xquery' :)
          or $state[$p:lk] = 50763                          (: 'array' '{' :)
          or $state[$p:lk] = 50767                          (: 'attribute' '{' :)
          or $state[$p:lk] = 50777                          (: 'comment' '{' :)
          or $state[$p:lk] = 50791                          (: 'document' '{' :)
          or $state[$p:lk] = 50793                          (: 'element' '{' :)
          or $state[$p:lk] = 50828                          (: 'map' '{' :)
          or $state[$p:lk] = 50832                          (: 'namespace' '{' :)
          or $state[$p:lk] = 50844                          (: 'ordered' '{' :)
          or $state[$p:lk] = 50854                          (: 'processing-instruction' '{' :)
          or $state[$p:lk] = 50868                          (: 'text' '{' :)
          or $state[$p:lk] = 50877                          (: 'unordered' '{' :)
          or $state[$p:lk] = 12995151                       (: 'attribute' 'and' '{' :)
          or $state[$p:lk] = 12995177                       (: 'element' 'and' '{' :)
          or $state[$p:lk] = 12995216                       (: 'namespace' 'and' '{' :)
          or $state[$p:lk] = 12995238                       (: 'processing-instruction' 'and' '{' :)
          or $state[$p:lk] = 12995919                       (: 'attribute' 'ascending' '{' :)
          or $state[$p:lk] = 12995945                       (: 'element' 'ascending' '{' :)
          or $state[$p:lk] = 12995984                       (: 'namespace' 'ascending' '{' :)
          or $state[$p:lk] = 12996006                       (: 'processing-instruction' 'ascending' '{' :)
          or $state[$p:lk] = 12997455                       (: 'attribute' 'case' '{' :)
          or $state[$p:lk] = 12997481                       (: 'element' 'case' '{' :)
          or $state[$p:lk] = 12997520                       (: 'namespace' 'case' '{' :)
          or $state[$p:lk] = 12997542                       (: 'processing-instruction' 'case' '{' :)
          or $state[$p:lk] = 12997711                       (: 'attribute' 'cast' '{' :)
          or $state[$p:lk] = 12997737                       (: 'element' 'cast' '{' :)
          or $state[$p:lk] = 12997776                       (: 'namespace' 'cast' '{' :)
          or $state[$p:lk] = 12997798                       (: 'processing-instruction' 'cast' '{' :)
          or $state[$p:lk] = 12997967                       (: 'attribute' 'castable' '{' :)
          or $state[$p:lk] = 12997993                       (: 'element' 'castable' '{' :)
          or $state[$p:lk] = 12998032                       (: 'namespace' 'castable' '{' :)
          or $state[$p:lk] = 12998054                       (: 'processing-instruction' 'castable' '{' :)
          or $state[$p:lk] = 12998735                       (: 'attribute' 'collation' '{' :)
          or $state[$p:lk] = 12998761                       (: 'element' 'collation' '{' :)
          or $state[$p:lk] = 12998800                       (: 'namespace' 'collation' '{' :)
          or $state[$p:lk] = 12998822                       (: 'processing-instruction' 'collation' '{' :)
          or $state[$p:lk] = 13000015                       (: 'attribute' 'count' '{' :)
          or $state[$p:lk] = 13000041                       (: 'element' 'count' '{' :)
          or $state[$p:lk] = 13000080                       (: 'namespace' 'count' '{' :)
          or $state[$p:lk] = 13000102                       (: 'processing-instruction' 'count' '{' :)
          or $state[$p:lk] = 13001039                       (: 'attribute' 'default' '{' :)
          or $state[$p:lk] = 13001065                       (: 'element' 'default' '{' :)
          or $state[$p:lk] = 13001104                       (: 'namespace' 'default' '{' :)
          or $state[$p:lk] = 13001126                       (: 'processing-instruction' 'default' '{' :)
          or $state[$p:lk] = 13001807                       (: 'attribute' 'descending' '{' :)
          or $state[$p:lk] = 13001833                       (: 'element' 'descending' '{' :)
          or $state[$p:lk] = 13001872                       (: 'namespace' 'descending' '{' :)
          or $state[$p:lk] = 13001894                       (: 'processing-instruction' 'descending' '{' :)
          or $state[$p:lk] = 13002319                       (: 'attribute' 'div' '{' :)
          or $state[$p:lk] = 13002345                       (: 'element' 'div' '{' :)
          or $state[$p:lk] = 13002384                       (: 'namespace' 'div' '{' :)
          or $state[$p:lk] = 13002406                       (: 'processing-instruction' 'div' '{' :)
          or $state[$p:lk] = 13003343                       (: 'attribute' 'else' '{' :)
          or $state[$p:lk] = 13003369                       (: 'element' 'else' '{' :)
          or $state[$p:lk] = 13003408                       (: 'namespace' 'else' '{' :)
          or $state[$p:lk] = 13003430                       (: 'processing-instruction' 'else' '{' :)
          or $state[$p:lk] = 13003599                       (: 'attribute' 'empty' '{' :)
          or $state[$p:lk] = 13003625                       (: 'element' 'empty' '{' :)
          or $state[$p:lk] = 13003664                       (: 'namespace' 'empty' '{' :)
          or $state[$p:lk] = 13003686                       (: 'processing-instruction' 'empty' '{' :)
          or $state[$p:lk] = 13004367                       (: 'attribute' 'end' '{' :)
          or $state[$p:lk] = 13004393                       (: 'element' 'end' '{' :)
          or $state[$p:lk] = 13004432                       (: 'namespace' 'end' '{' :)
          or $state[$p:lk] = 13004454                       (: 'processing-instruction' 'end' '{' :)
          or $state[$p:lk] = 13004623                       (: 'attribute' 'eq' '{' :)
          or $state[$p:lk] = 13004649                       (: 'element' 'eq' '{' :)
          or $state[$p:lk] = 13004688                       (: 'namespace' 'eq' '{' :)
          or $state[$p:lk] = 13004710                       (: 'processing-instruction' 'eq' '{' :)
          or $state[$p:lk] = 13005135                       (: 'attribute' 'except' '{' :)
          or $state[$p:lk] = 13005161                       (: 'element' 'except' '{' :)
          or $state[$p:lk] = 13005200                       (: 'namespace' 'except' '{' :)
          or $state[$p:lk] = 13005222                       (: 'processing-instruction' 'except' '{' :)
          or $state[$p:lk] = 13006415                       (: 'attribute' 'for' '{' :)
          or $state[$p:lk] = 13006441                       (: 'element' 'for' '{' :)
          or $state[$p:lk] = 13006480                       (: 'namespace' 'for' '{' :)
          or $state[$p:lk] = 13006502                       (: 'processing-instruction' 'for' '{' :)
          or $state[$p:lk] = 13006927                       (: 'attribute' 'ge' '{' :)
          or $state[$p:lk] = 13006953                       (: 'element' 'ge' '{' :)
          or $state[$p:lk] = 13006992                       (: 'namespace' 'ge' '{' :)
          or $state[$p:lk] = 13007014                       (: 'processing-instruction' 'ge' '{' :)
          or $state[$p:lk] = 13007439                       (: 'attribute' 'group' '{' :)
          or $state[$p:lk] = 13007465                       (: 'element' 'group' '{' :)
          or $state[$p:lk] = 13007504                       (: 'namespace' 'group' '{' :)
          or $state[$p:lk] = 13007526                       (: 'processing-instruction' 'group' '{' :)
          or $state[$p:lk] = 13007951                       (: 'attribute' 'gt' '{' :)
          or $state[$p:lk] = 13007977                       (: 'element' 'gt' '{' :)
          or $state[$p:lk] = 13008016                       (: 'namespace' 'gt' '{' :)
          or $state[$p:lk] = 13008038                       (: 'processing-instruction' 'gt' '{' :)
          or $state[$p:lk] = 13008207                       (: 'attribute' 'idiv' '{' :)
          or $state[$p:lk] = 13008233                       (: 'element' 'idiv' '{' :)
          or $state[$p:lk] = 13008272                       (: 'namespace' 'idiv' '{' :)
          or $state[$p:lk] = 13008294                       (: 'processing-instruction' 'idiv' '{' :)
          or $state[$p:lk] = 13009743                       (: 'attribute' 'instance' '{' :)
          or $state[$p:lk] = 13009769                       (: 'element' 'instance' '{' :)
          or $state[$p:lk] = 13009808                       (: 'namespace' 'instance' '{' :)
          or $state[$p:lk] = 13009830                       (: 'processing-instruction' 'instance' '{' :)
          or $state[$p:lk] = 13009999                       (: 'attribute' 'intersect' '{' :)
          or $state[$p:lk] = 13010025                       (: 'element' 'intersect' '{' :)
          or $state[$p:lk] = 13010064                       (: 'namespace' 'intersect' '{' :)
          or $state[$p:lk] = 13010086                       (: 'processing-instruction' 'intersect' '{' :)
          or $state[$p:lk] = 13010255                       (: 'attribute' 'is' '{' :)
          or $state[$p:lk] = 13010281                       (: 'element' 'is' '{' :)
          or $state[$p:lk] = 13010320                       (: 'namespace' 'is' '{' :)
          or $state[$p:lk] = 13010342                       (: 'processing-instruction' 'is' '{' :)
          or $state[$p:lk] = 13011023                       (: 'attribute' 'le' '{' :)
          or $state[$p:lk] = 13011049                       (: 'element' 'le' '{' :)
          or $state[$p:lk] = 13011088                       (: 'namespace' 'le' '{' :)
          or $state[$p:lk] = 13011110                       (: 'processing-instruction' 'le' '{' :)
          or $state[$p:lk] = 13011535                       (: 'attribute' 'let' '{' :)
          or $state[$p:lk] = 13011561                       (: 'element' 'let' '{' :)
          or $state[$p:lk] = 13011600                       (: 'namespace' 'let' '{' :)
          or $state[$p:lk] = 13011622                       (: 'processing-instruction' 'let' '{' :)
          or $state[$p:lk] = 13011791                       (: 'attribute' 'lt' '{' :)
          or $state[$p:lk] = 13011817                       (: 'element' 'lt' '{' :)
          or $state[$p:lk] = 13011856                       (: 'namespace' 'lt' '{' :)
          or $state[$p:lk] = 13011878                       (: 'processing-instruction' 'lt' '{' :)
          or $state[$p:lk] = 13012559                       (: 'attribute' 'mod' '{' :)
          or $state[$p:lk] = 13012585                       (: 'element' 'mod' '{' :)
          or $state[$p:lk] = 13012624                       (: 'namespace' 'mod' '{' :)
          or $state[$p:lk] = 13012646                       (: 'processing-instruction' 'mod' '{' :)
          or $state[$p:lk] = 13013583                       (: 'attribute' 'ne' '{' :)
          or $state[$p:lk] = 13013609                       (: 'element' 'ne' '{' :)
          or $state[$p:lk] = 13013648                       (: 'namespace' 'ne' '{' :)
          or $state[$p:lk] = 13013670                       (: 'processing-instruction' 'ne' '{' :)
          or $state[$p:lk] = 13015119                       (: 'attribute' 'only' '{' :)
          or $state[$p:lk] = 13015145                       (: 'element' 'only' '{' :)
          or $state[$p:lk] = 13015184                       (: 'namespace' 'only' '{' :)
          or $state[$p:lk] = 13015206                       (: 'processing-instruction' 'only' '{' :)
          or $state[$p:lk] = 13015631                       (: 'attribute' 'or' '{' :)
          or $state[$p:lk] = 13015657                       (: 'element' 'or' '{' :)
          or $state[$p:lk] = 13015696                       (: 'namespace' 'or' '{' :)
          or $state[$p:lk] = 13015718                       (: 'processing-instruction' 'or' '{' :)
          or $state[$p:lk] = 13015887                       (: 'attribute' 'order' '{' :)
          or $state[$p:lk] = 13015913                       (: 'element' 'order' '{' :)
          or $state[$p:lk] = 13015952                       (: 'namespace' 'order' '{' :)
          or $state[$p:lk] = 13015974                       (: 'processing-instruction' 'order' '{' :)
          or $state[$p:lk] = 13018959                       (: 'attribute' 'return' '{' :)
          or $state[$p:lk] = 13018985                       (: 'element' 'return' '{' :)
          or $state[$p:lk] = 13019024                       (: 'namespace' 'return' '{' :)
          or $state[$p:lk] = 13019046                       (: 'processing-instruction' 'return' '{' :)
          or $state[$p:lk] = 13019215                       (: 'attribute' 'satisfies' '{' :)
          or $state[$p:lk] = 13019241                       (: 'element' 'satisfies' '{' :)
          or $state[$p:lk] = 13019280                       (: 'namespace' 'satisfies' '{' :)
          or $state[$p:lk] = 13019302                       (: 'processing-instruction' 'satisfies' '{' :)
          or $state[$p:lk] = 13021007                       (: 'attribute' 'stable' '{' :)
          or $state[$p:lk] = 13021033                       (: 'element' 'stable' '{' :)
          or $state[$p:lk] = 13021072                       (: 'namespace' 'stable' '{' :)
          or $state[$p:lk] = 13021094                       (: 'processing-instruction' 'stable' '{' :)
          or $state[$p:lk] = 13021263                       (: 'attribute' 'start' '{' :)
          or $state[$p:lk] = 13021289                       (: 'element' 'start' '{' :)
          or $state[$p:lk] = 13021328                       (: 'namespace' 'start' '{' :)
          or $state[$p:lk] = 13021350                       (: 'processing-instruction' 'start' '{' :)
          or $state[$p:lk] = 13022799                       (: 'attribute' 'to' '{' :)
          or $state[$p:lk] = 13022825                       (: 'element' 'to' '{' :)
          or $state[$p:lk] = 13022864                       (: 'namespace' 'to' '{' :)
          or $state[$p:lk] = 13022886                       (: 'processing-instruction' 'to' '{' :)
          or $state[$p:lk] = 13023055                       (: 'attribute' 'treat' '{' :)
          or $state[$p:lk] = 13023081                       (: 'element' 'treat' '{' :)
          or $state[$p:lk] = 13023120                       (: 'namespace' 'treat' '{' :)
          or $state[$p:lk] = 13023142                       (: 'processing-instruction' 'treat' '{' :)
          or $state[$p:lk] = 13024335                       (: 'attribute' 'union' '{' :)
          or $state[$p:lk] = 13024361                       (: 'element' 'union' '{' :)
          or $state[$p:lk] = 13024400                       (: 'namespace' 'union' '{' :)
          or $state[$p:lk] = 13024422                       (: 'processing-instruction' 'union' '{' :)
          or $state[$p:lk] = 13025871                       (: 'attribute' 'where' '{' :)
          or $state[$p:lk] = 13025897                       (: 'element' 'where' '{' :)
          or $state[$p:lk] = 13025936                       (: 'namespace' 'where' '{' :)
          or $state[$p:lk] = 13025958) then                 (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "StepExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 44                                 (: '/' :)
    and $state[$p:l1] != 45) then                           (: '//' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 44) then                   (: '/' :)
          let $state := p:consume(44, $input, $state)       (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(45, $input, $state)       (: '//' :)
          return $state
      let $state := p:lookahead1W(185, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StepExpr($input, $state)
      return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "RelativePathExpr", $count, $begin, $end)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 44) then                       (: '/' :)
      let $state := p:consume(44, $input, $state)           (: '/' :)
      let $state := p:lookahead1W(195, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '!' | '!=' | '$' | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' |
                                                               ':' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' | '=' |
                                                               '>' | '>=' | '>>' | '?' | '@' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 24                         (: EOF :)
              or $state[$p:l1] = 25                         (: '!' :)
              or $state[$p:l1] = 26                         (: '!=' :)
              or $state[$p:l1] = 36                         (: ')' :)
              or $state[$p:l1] = 37                         (: '*' :)
              or $state[$p:l1] = 38                         (: '+' :)
              or $state[$p:l1] = 39                         (: ',' :)
              or $state[$p:l1] = 40                         (: '-' :)
              or $state[$p:l1] = 47                         (: ':' :)
              or $state[$p:l1] = 51                         (: ';' :)
              or $state[$p:l1] = 56                         (: '<<' :)
              or $state[$p:l1] = 57                         (: '<=' :)
              or $state[$p:l1] = 59                         (: '=' :)
              or $state[$p:l1] = 61                         (: '>' :)
              or $state[$p:l1] = 62                         (: '>=' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 69                         (: ']' :)
              or $state[$p:l1] = 200                        (: '|' :)
              or $state[$p:l1] = 201                        (: '||' :)
              or $state[$p:l1] = 202) then                  (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 45) then                       (: '//' :)
      let $state := p:consume(45, $input, $state)           (: '//' :)
      let $state := p:lookahead1W(185, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '?' | '@' | '[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PathExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SimpleMapExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 25) then                           (: '!' :)
      $state
    else
      let $state := p:consume(25, $input, $state)           (: '!' :)
      let $state := p:lookahead1W(186, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | ('(' ':') | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' | '[' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PathExpr($input, $state)
      return p:parse-SimpleMapExpr-1($input, $state)
};

(:~
 : Parse SimpleMapExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SimpleMapExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-PathExpr($input, $state)
  let $state := p:parse-SimpleMapExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SimpleMapExpr", $count, $begin, $end)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(34, $input, $state)               (: '(#' :)
  let $state := p:lookahead1(171, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:consume(16, $input, $state)           (: S :)
      return $state
    else
      $state
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(11, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 16) then                       (: S :)
      let $state := p:consume(16, $input, $state)           (: S :)
      let $state := p:lookahead1(1, $input, $state)         (: PragmaContents :)
      let $state := p:consume(19, $input, $state)           (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:consume(29, $input, $state)               (: '#)' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Pragma", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:whitespace($input, $state)
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(68, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(192, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 202) then                     (: '}' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ExtensionExpr", $count, $begin, $end)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 135) then                      (: 'lax' :)
      let $state := p:consume(135, $input, $state)          (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(177, $input, $state)          (: 'strict' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidationMode", $count, $begin, $end)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(190, $input, $state)              (: 'validate' :)
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'lax' | 'strict' | 'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 198) then                     (: '{' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 186) then                  (: 'type' :)
          let $state := p:consume(186, $input, $state)      (: 'type' :)
          let $state := p:lookahead1W(172, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ValidateExpr", $count, $begin, $end)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 190) then                          (: 'validate' :)
      let $state := p:lookahead2W(168, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'strict' | 'to' |
                                                               'treat' | 'type' | 'union' | 'where' | '{' | '|' | '||' |
                                                               '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 34750                          (: 'validate' 'lax' :)
          or $state[$p:lk] = 45502                          (: 'validate' 'strict' :)
          or $state[$p:lk] = 47806                          (: 'validate' 'type' :)
          or $state[$p:lk] = 50878) then                    (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-SimpleMapExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ValueExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(187, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 38                               (: '+' :)
      and $state[$p:l1] != 40) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 40) then                 (: '-' :)
            let $state := p:consume(40, $input, $state)     (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(38, $input, $state)     (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnaryExpr", $count, $begin, $end)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(152, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:consume(84, $input, $state)           (: 'cast' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastExpr", $count, $begin, $end)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(150, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:consume(85, $input, $state)           (: 'castable' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "CastableExpr", $count, $begin, $end)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 183) then                      (: 'treat' :)
      let $state := p:consume(183, $input, $state)          (: 'treat' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(179, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TreatExpr", $count, $begin, $end)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:consume(131, $input, $state)          (: 'instance' :)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:consume(151, $input, $state)          (: 'of' :)
      let $state := p:lookahead1W(179, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InstanceofExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(147, $input, $state)        (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 113                              (: 'except' :)
      and $state[$p:l1] != 132) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 132) then                (: 'intersect' :)
            let $state := p:consume(132, $input, $state)    (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:consume(113, $input, $state)    (: 'except' :)
            return $state
        let $state := p:lookahead1W(187, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IntersectExceptExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 188                                (: 'union' :)
    and $state[$p:l1] != 200) then                          (: '|' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 188) then                  (: 'union' :)
          let $state := p:consume(188, $input, $state)      (: 'union' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(200, $input, $state)      (: '|' :)
          return $state
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-IntersectExceptExpr($input, $state)
      return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "UnionExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 37                                 (: '*' :)
    and $state[$p:l1] != 102                                (: 'div' :)
    and $state[$p:l1] != 125                                (: 'idiv' :)
    and $state[$p:l1] != 142) then                          (: 'mod' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37) then                   (: '*' :)
          let $state := p:consume(37, $input, $state)       (: '*' :)
          return $state
        else if ($state[$p:l1] = 102) then                  (: 'div' :)
          let $state := p:consume(102, $input, $state)      (: 'div' :)
          return $state
        else if ($state[$p:l1] = 125) then                  (: 'idiv' :)
          let $state := p:consume(125, $input, $state)      (: 'idiv' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(142, $input, $state)      (: 'mod' :)
          return $state
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-UnionExpr($input, $state)
      return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "MultiplicativeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 38                                 (: '+' :)
    and $state[$p:l1] != 40) then                           (: '-' :)
      $state
    else
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: '+' :)
          let $state := p:consume(38, $input, $state)       (: '+' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(40, $input, $state)       (: '-' :)
          return $state
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MultiplicativeExpr($input, $state)
      return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AdditiveExpr", $count, $begin, $end)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 182) then                      (: 'to' :)
      let $state := p:consume(182, $input, $state)          (: 'to' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "RangeExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 201) then                          (: '||' :)
      $state
    else
      let $state := p:consume(201, $input, $state)          (: '||' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-RangeExpr($input, $state)
      return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "StringConcatExpr", $count, $begin, $end)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 52                             (: '<' :)
          or $state[$p:l1] = 56                             (: '<<' :)
          or $state[$p:l1] = 57                             (: '<=' :)
          or $state[$p:l1] = 59                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 111                            (: 'eq' :)
          or $state[$p:l1] = 120                            (: 'ge' :)
          or $state[$p:l1] = 124                            (: 'gt' :)
          or $state[$p:l1] = 133                            (: 'is' :)
          or $state[$p:l1] = 136                            (: 'le' :)
          or $state[$p:l1] = 139                            (: 'lt' :)
          or $state[$p:l1] = 146) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 111                        (: 'eq' :)
              or $state[$p:l1] = 120                        (: 'ge' :)
              or $state[$p:l1] = 124                        (: 'gt' :)
              or $state[$p:l1] = 136                        (: 'le' :)
              or $state[$p:l1] = 139                        (: 'lt' :)
              or $state[$p:l1] = 146) then                  (: 'ne' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 56                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 133) then                  (: 'is' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ComparisonExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 74) then                           (: 'and' :)
      $state
    else
      let $state := p:consume(74, $input, $state)           (: 'and' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ComparisonExpr($input, $state)
      return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AndExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 154) then                          (: 'or' :)
      $state
    else
      let $state := p:consume(154, $input, $state)          (: 'or' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AndExpr($input, $state)
      return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrExpr", $count, $begin, $end)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 20) then                       (: Wildcard :)
      let $state := p:consume(20, $input, $state)           (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NameTest", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 200) then                        (: '|' :)
        $state
      else
        let $state := p:consume(200, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(174, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchErrorList", $count, $begin, $end)
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(86, $input, $state)               (: 'catch' :)
  let $state := p:lookahead1W(174, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | Wildcard |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-CatchErrorList($input, $state)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CatchClause", $count, $begin, $end)
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Expr($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryTargetExpr", $count, $begin, $end)
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(184, $input, $state)              (: 'try' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:consume(198, $input, $state)              (: '{' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-TryTargetExpr($input, $state)
  let $state := p:consume(202, $input, $state)              (: '}' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(35, $input, $state)         (: S^WS | ('(' ':') | 'catch' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(134, $input, $state)        (: S^WS | EOF | ('(' ':') | ')' | ',' | ':' | ';' | ']' |
                                                               'ascending' | 'case' | 'catch' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 86) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-TryClause($input, $state)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TryCatchExpr", $count, $begin, $end)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(126, $input, $state)              (: 'if' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:consume(181, $input, $state)              (: 'then' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:consume(106, $input, $state)              (: 'else' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "IfExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 200) then                        (: '|' :)
        $state
      else
        let $state := p:consume(200, $input, $state)        (: '|' :)
        let $state := p:lookahead1W(179, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceTypeUnion", $count, $begin, $end)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(83, $input, $state)               (: 'case' :)
  let $state := p:lookahead1W(181, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(179, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:consume(167, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-CaseClause($input, $state)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(187, $input, $state)              (: 'typeswitch' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(167, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeswitchExpr", $count, $begin, $end)
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseOperand", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:consume(83, $input, $state)             (: 'case' :)
    let $state := p:lookahead1W(187, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:consume(167, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchCaseClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Expr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:whitespace($input, $state)
    let $state := p:parse-SwitchCaseClause($input, $state)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(179, $input, $state)              (: 'switch' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Expr($input, $state)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:consume(167, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SwitchExpr", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(77, $input, $state)       (: S^WS | ('(' ':') | 'as' | 'in' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 76) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | 'in' :)
      let $state := p:consume(128, $input, $state)          (: 'in' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 174) then                      (: 'some' :)
      let $state := p:consume(174, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(112, $input, $state)          (: 'every' :)
      return $state
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(128, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:consume(168, $input, $state)              (: 'satisfies' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "QuantifiedExpr", $count, $begin, $end)
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(167, $input, $state)              (: 'return' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ReturnClause", $count, $begin, $end)
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(93, $input, $state)               (: 'count' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CountClause", $count, $begin, $end)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77                             (: 'ascending' :)
          or $state[$p:l1] = 100) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 77) then                   (: 'ascending' :)
          let $state := p:consume(77, $input, $state)       (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(100, $input, $state)      (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:consume(107, $input, $state)          (: 'empty' :)
      let $state := p:lookahead1W(86, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 121) then                  (: 'greatest' :)
          let $state := p:consume(121, $input, $state)      (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:consume(137, $input, $state)      (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:consume(88, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderModifier", $count, $begin, $end)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderModifier($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(187, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderSpecList", $count, $begin, $end)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 155) then                      (: 'order' :)
      let $state := p:consume(155, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(82, $input, $state)           (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(175, $input, $state)          (: 'stable' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:consume(155, $input, $state)          (: 'order' :)
      let $state := p:lookahead1W(33, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:consume(82, $input, $state)           (: 'by' :)
      return $state
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-OrderSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderByClause", $count, $begin, $end)
};

(:~
 : Parse GroupingVariable.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingVariable($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingVariable", $count, $begin, $end)
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-GroupingVariable($input, $state)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | ('(' ':') | ',' | ':=' | 'as' | 'collation' |
                                                               'count' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50                             (: ':=' :)
          or $state[$p:l1] = 76) then                       (: 'as' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 76) then                   (: 'as' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeDeclaration($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | ('(' ':') | ':=' :)
      let $state := p:consume(50, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:consume(88, $input, $state)           (: 'collation' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpec", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(21, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupingSpecList", $count, $begin, $end)
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(122, $input, $state)              (: 'group' :)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:consume(82, $input, $state)               (: 'by' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-GroupingSpecList($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "GroupByClause", $count, $begin, $end)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(194, $input, $state)              (: 'where' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WhereClause", $count, $begin, $end)
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118                            (: 'for' :)
          or $state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "IntermediateClause", $count, $begin, $end)
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(173, $input, $state)              (: 'sliding' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(195, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(128, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowEndCondition($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "SlidingWindowClause", $count, $begin, $end)
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'only' :)
      let $state := p:consume(152, $input, $state)          (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:consume(110, $input, $state)              (: 'end' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(193, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowEndCondition", $count, $begin, $end)
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NextItem", $count, $begin, $end)
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PreviousItem", $count, $begin, $end)
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CurrentItem", $count, $begin, $end)
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 30) then                       (: '$' :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 165) then                      (: 'previous' :)
      let $state := p:consume(165, $input, $state)          (: 'previous' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 147) then                      (: 'next' :)
      let $state := p:consume(147, $input, $state)          (: 'next' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:consume(30, $input, $state)           (: '$' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowVars", $count, $begin, $end)
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(176, $input, $state)              (: 'start' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:consume(193, $input, $state)              (: 'when' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowStartCondition", $count, $begin, $end)
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(185, $input, $state)              (: 'tumbling' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:consume(195, $input, $state)              (: 'window' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(128, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 110                            (: 'end' :)
          or $state[$p:l1] = 152) then                      (: 'only' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "TumblingWindowClause", $count, $begin, $end)
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(118, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 185) then                      (: 'tumbling' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "WindowClause", $count, $begin, $end)
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:consume(50, $input, $state)               (: ':=' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LetBinding($input, $state)
      return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(138, $input, $state)              (: 'let' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LetClause", $count, $begin, $end)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(78, $input, $state)               (: 'at' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "PositionalVar", $count, $begin, $end)
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(71, $input, $state)               (: 'allowing' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(107, $input, $state)              (: 'empty' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AllowingEmpty", $count, $begin, $end)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(76, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(179, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeDeclaration", $count, $begin, $end)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarName", $count, $begin, $end)
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(30, $input, $state)               (: '$' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'allowing' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'at' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:consume(128, $input, $state)              (: 'in' :)
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForBinding", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 39) then                           (: ',' :)
      $state
    else
      let $state := p:consume(39, $input, $state)           (: ',' :)
      let $state := p:lookahead1W(21, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ForBinding($input, $state)
      return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(118, $input, $state)              (: 'for' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ForClause", $count, $begin, $end)
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 118) then                          (: 'for' :)
      let $state := p:lookahead2W(102, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7798) then                     (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 138) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InitialClause", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 167) then                         (: 'return' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "FLWORExpr", $count, $begin, $end)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 118) then                          (: 'for' :)
      let $state := p:lookahead2W(167, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] eq 184) then                     (: 'try' :)
      let $state := p:lookahead2W(164, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (112,                          (: 'every' :)
                              138,                          (: 'let' :)
                              174)) then                    (: 'some' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = (126,                          (: 'if' :)
                              179,                          (: 'switch' :)
                              187)) then                    (: 'typeswitch' :)
      let $state := p:lookahead2W(159, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ':' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 7798                           (: 'for' '$' :)
          or $state[$p:lk] = 7818                           (: 'let' '$' :)
          or $state[$p:lk] = 44406                          (: 'for' 'sliding' :)
          or $state[$p:lk] = 47478) then                    (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7792                           (: 'every' '$' :)
          or $state[$p:lk] = 7854) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8627) then                     (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8635) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8574) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50872) then                    (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ExprSingle", $count, $begin, $end)
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ExprSingle($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VarValue", $count, $begin, $end)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(179, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ParenthesizedItemType", $count, $begin, $end)
};

(:~
 : Parse TypedArrayTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(75, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(179, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedArrayTest", $count, $begin, $end)
};

(:~
 : Parse AnyArrayTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(75, $input, $state)               (: 'array' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(37, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyArrayTest", $count, $begin, $end)
};

(:~
 : Parse ArrayTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArrayTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 75) then                           (: 'array' :)
      let $state := p:lookahead2W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8523) then                     (: 'array' '(' :)
          let $state := p:lookahead3W(183, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | '*' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2433355) then                  (: 'array' '(' '*' :)
      let $state := p:parse-AnyArrayTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedArrayTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ArrayTest", $count, $begin, $end)
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AtomicOrUnionType", $count, $begin, $end)
};

(:~
 : Parse TypedMapTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedMapTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(140, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(39, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(179, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedMapTest", $count, $begin, $end)
};

(:~
 : Parse AnyMapTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyMapTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(140, $input, $state)              (: 'map' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(37, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyMapTest", $count, $begin, $end)
};

(:~
 : Parse MapTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MapTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 140) then                          (: 'map' :)
      let $state := p:lookahead2W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8588) then                     (: 'map' '(' :)
          let $state := p:lookahead3W(175, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | '*' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2433420) then                  (: 'map' '(' '*' :)
      let $state := p:parse-AnyMapTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedMapTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "MapTest", $count, $begin, $end)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:consume(64, $input, $state)           (: '?' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(38, $input, $state)           (: '+' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OccurrenceIndicator", $count, $begin, $end)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 108) then                          (: 'empty-sequence' :)
      let $state := p:lookahead2W(158, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8556) then                     (: 'empty-sequence' '(' :)
      let $state := p:consume(108, $input, $state)          (: 'empty-sequence' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(33, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(36, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(154, $input, $state)      (: S^WS | EOF | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 37                         (: '*' :)
              or $state[$p:l1] = 38                         (: '+' :)
              or $state[$p:l1] = 64) then                   (: '?' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SequenceType", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(179, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(119, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(182, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:consume(76, $input, $state)               (: 'as' :)
  let $state := p:lookahead1W(179, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-SequenceType($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypedFunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(119, $input, $state)              (: 'function' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:consume(37, $input, $state)               (: '*' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyFunctionTest", $count, $begin, $end)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 1) then                        (: IntegerLiteral :)
      let $state := p:consume(1, $input, $state)            (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 2) then                        (: DecimalLiteral :)
      let $state := p:consume(2, $input, $state)            (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(3, $input, $state)            (: DoubleLiteral :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NumericLiteral", $count, $begin, $end)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 4) then                        (: StringLiteral :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Literal", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(112, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(31, $input, $state)               (: '%' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 33) then                       (: '(' :)
      let $state := p:consume(33, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(112, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-Literal($input, $state)
      let $state := p:parse-Annotation-1($input, $state)
      let $state := p:consume(36, $input, $state)           (: ')' :)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Annotation", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(67, $input, $state)         (: S^WS | '%' | ('(' ':') | 'function' :)
    return
      if ($state[$p:l1] != 31) then                         (: '%' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] eq 119) then                          (: 'function' :)
      let $state := p:lookahead2W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] eq 8567) then                     (: 'function' '(' :)
          let $state := p:lookahead3W(184, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 2433399) then                  (: 'function' '(' '*' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionTest", $count, $begin, $end)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(150, $input, $state)              (: 'node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AnyKindTest", $count, $begin, $end)
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(145, $input, $state)              (: 'namespace-node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceNodeTest", $count, $begin, $end)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(180, $input, $state)              (: 'text' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "TextTest", $count, $begin, $end)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(89, $input, $state)               (: 'comment' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "CommentTest", $count, $begin, $end)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(166, $input, $state)              (: 'processing-instruction' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 4) then                    (: StringLiteral :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "PITest", $count, $begin, $end)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-AttributeName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(170, $input, $state)              (: 'schema-attribute' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaAttributeTest", $count, $begin, $end)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeName", $count, $begin, $end)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "AttribNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(79, $input, $state)               (: 'attribute' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(180, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(172, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "AttributeTest", $count, $begin, $end)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ElementName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementDeclaration", $count, $begin, $end)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(171, $input, $state)              (: 'schema-element' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(172, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaElementTest", $count, $begin, $end)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "TypeName", $count, $begin, $end)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-EQName($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementName", $count, $begin, $end)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 37) then                       (: '*' :)
      let $state := p:consume(37, $input, $state)           (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementNameOrWildcard", $count, $begin, $end)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(105, $input, $state)              (: 'element' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(180, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 39) then                   (: ',' :)
          let $state := p:consume(39, $input, $state)       (: ',' :)
          let $state := p:lookahead1W(172, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(70, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:consume(64, $input, $state)   (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "ElementTest", $count, $begin, $end)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(104, $input, $state)              (: 'document-node' :)
  let $state := p:lookahead1W(22, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:consume(33, $input, $state)               (: '(' :)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 105) then                  (: 'element' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:whitespace($input, $state)
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:consume(36, $input, $state)               (: ')' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "DocumentTest", $count, $begin, $end)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 104) then                      (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "KindTest", $count, $begin, $end)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] = (75,                                (: 'array' :)
                         79,                                (: 'attribute' :)
                         89,                                (: 'comment' :)
                         104,                               (: 'document-node' :)
                         105,                               (: 'element' :)
                         119,                               (: 'function' :)
                         134,                               (: 'item' :)
                         140,                               (: 'map' :)
                         145,                               (: 'namespace-node' :)
                         150,                               (: 'node' :)
                         166,                               (: 'processing-instruction' :)
                         170,                               (: 'schema-attribute' :)
                         171,                               (: 'schema-element' :)
                         180)) then                         (: 'text' :)
      let $state := p:lookahead2W(158, $input, $state)      (: S^WS | EOF | '!=' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | ':' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 8527                           (: 'attribute' '(' :)
          or $state[$p:lk] = 8537                           (: 'comment' '(' :)
          or $state[$p:lk] = 8552                           (: 'document-node' '(' :)
          or $state[$p:lk] = 8553                           (: 'element' '(' :)
          or $state[$p:lk] = 8593                           (: 'namespace-node' '(' :)
          or $state[$p:lk] = 8598                           (: 'node' '(' :)
          or $state[$p:lk] = 8614                           (: 'processing-instruction' '(' :)
          or $state[$p:lk] = 8618                           (: 'schema-attribute' '(' :)
          or $state[$p:lk] = 8619                           (: 'schema-element' '(' :)
          or $state[$p:lk] = 8628) then                     (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8582) then                     (: 'item' '(' :)
      let $state := p:consume(134, $input, $state)          (: 'item' :)
      let $state := p:lookahead1W(22, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:consume(33, $input, $state)           (: '(' :)
      let $state := p:lookahead1W(23, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:consume(36, $input, $state)           (: ')' :)
      return $state
    else if ($state[$p:lk] = 31                             (: '%' :)
          or $state[$p:lk] = 8567) then                     (: 'function' '(' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8588) then                     (: 'map' '(' :)
      let $state := p:parse-MapTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8523) then                     (: 'array' '(' :)
      let $state := p:parse-ArrayTest($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ItemType", $count, $begin, $end)
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:consume(91, $input, $state)               (: 'context' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:consume(134, $input, $state)              (: 'item' :)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'as' :)
      let $state := p:consume(76, $input, $state)           (: 'as' :)
      let $state := p:lookahead1W(179, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 50) then                       (: ':=' :)
      let $state := p:consume(50, $input, $state)           (: ':=' :)
      let $state := p:lookahead1W(187, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(115, $input, $state)          (: 'external' :)
      let $state := p:lookahead1W(72, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 50) then                   (: ':=' :)
          let $state := p:consume(50, $input, $state)       (: ':=' :)
          let $state := p:lookahead1W(187, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:whitespace($input, $state)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ContextItemDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(127, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:consume(143, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(60, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace' :)
      let $state := p:consume(144, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(135, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(59, $input, $state)           (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'at' :)
      let $state := p:consume(78, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleImport", $count, $begin, $end)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace' :)
      let $state := p:consume(144, $input, $state)          (: 'namespace' :)
      let $state := p:lookahead1W(135, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:consume(59, $input, $state)           (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(42, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:consume(105, $input, $state)          (: 'element' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:consume(144, $input, $state)          (: 'namespace' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaPrefix", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(71, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 39) then                         (: ',' :)
        $state
      else
        let $state := p:consume(39, $input, $state)         (: ',' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(127, $input, $state)              (: 'import' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:consume(169, $input, $state)              (: 'schema' :)
  let $state := p:lookahead1W(98, $input, $state)           (: StringLiteral | S^WS | ('(' ':') | 'default' |
                                                               'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 4) then                       (: StringLiteral :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'at' :)
      let $state := p:consume(78, $input, $state)           (: 'at' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  let $end := $state[$p:e0]
  return p:reduce($state, "SchemaImport", $count, $begin, $end)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 127) then                          (: 'import' :)
      let $state := p:lookahead2W(88, $input, $state)       (: S^WS | ('(' ':') | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 43391) then                    (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ModuleImport($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Import", $count, $begin, $end)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(144, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(135, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(59, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "NamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'decimal-separator' :)
      let $state := p:consume(95, $input, $state)           (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'grouping-separator' :)
      let $state := p:consume(123, $input, $state)          (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'infinity' :)
      let $state := p:consume(129, $input, $state)          (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'minus-sign' :)
      let $state := p:consume(141, $input, $state)          (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'NaN' :)
      let $state := p:consume(67, $input, $state)           (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'percent' :)
      let $state := p:consume(161, $input, $state)          (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'per-mille' :)
      let $state := p:consume(160, $input, $state)          (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 197) then                      (: 'zero-digit' :)
      let $state := p:consume(197, $input, $state)          (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'digit' :)
      let $state := p:consume(101, $input, $state)          (: 'digit' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'pattern-separator' :)
      let $state := p:consume(159, $input, $state)          (: 'pattern-separator' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(114, $input, $state)          (: 'exponent-separator' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "DFPropertyName", $count, $begin, $end)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 15) then                       (: QName^Token :)
      let $state := p:consume(15, $input, $state)           (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor' :)
      let $state := p:consume(72, $input, $state)           (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ancestor-or-self' :)
      let $state := p:consume(73, $input, $state)           (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'and' :)
      let $state := p:consume(74, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'ascending' :)
      let $state := p:consume(77, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'case' :)
      let $state := p:consume(83, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:consume(84, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:consume(85, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'child' :)
      let $state := p:consume(87, $input, $state)           (: 'child' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:consume(88, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:consume(93, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'declare' :)
      let $state := p:consume(96, $input, $state)           (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'descendant' :)
      let $state := p:consume(98, $input, $state)           (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant-or-self' :)
      let $state := p:consume(99, $input, $state)           (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descending' :)
      let $state := p:consume(100, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'div' :)
      let $state := p:consume(102, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'document' :)
      let $state := p:consume(103, $input, $state)          (: 'document' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'else' :)
      let $state := p:consume(106, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:consume(107, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'end' :)
      let $state := p:consume(110, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:consume(111, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'every' :)
      let $state := p:consume(112, $input, $state)          (: 'every' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'except' :)
      let $state := p:consume(113, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'following' :)
      let $state := p:consume(116, $input, $state)          (: 'following' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'following-sibling' :)
      let $state := p:consume(117, $input, $state)          (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'for' :)
      let $state := p:consume(118, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'ge' :)
      let $state := p:consume(120, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:consume(122, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:consume(124, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'idiv' :)
      let $state := p:consume(125, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'import' :)
      let $state := p:consume(127, $input, $state)          (: 'import' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:consume(131, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'intersect' :)
      let $state := p:consume(132, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:consume(133, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:consume(136, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:consume(138, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:consume(139, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'mod' :)
      let $state := p:consume(142, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'module' :)
      let $state := p:consume(143, $input, $state)          (: 'module' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace' :)
      let $state := p:consume(144, $input, $state)          (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'ne' :)
      let $state := p:consume(146, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'only' :)
      let $state := p:consume(152, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'or' :)
      let $state := p:consume(154, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'order' :)
      let $state := p:consume(155, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'ordered' :)
      let $state := p:consume(156, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'parent' :)
      let $state := p:consume(158, $input, $state)          (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding' :)
      let $state := p:consume(162, $input, $state)          (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'preceding-sibling' :)
      let $state := p:consume(163, $input, $state)          (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'return' :)
      let $state := p:consume(167, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'satisfies' :)
      let $state := p:consume(168, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'self' :)
      let $state := p:consume(172, $input, $state)          (: 'self' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: 'some' :)
      let $state := p:consume(174, $input, $state)          (: 'some' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'stable' :)
      let $state := p:consume(175, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'start' :)
      let $state := p:consume(176, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'to' :)
      let $state := p:consume(182, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'treat' :)
      let $state := p:consume(183, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'try' :)
      let $state := p:consume(184, $input, $state)          (: 'try' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'union' :)
      let $state := p:consume(188, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'unordered' :)
      let $state := p:consume(189, $input, $state)          (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'validate' :)
      let $state := p:consume(190, $input, $state)          (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 194) then                      (: 'where' :)
      let $state := p:consume(194, $input, $state)          (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(196, $input, $state)          (: 'xquery' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "FunctionName", $count, $begin, $end)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(169, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'array' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'array' :)
      let $state := p:consume(75, $input, $state)           (: 'array' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'attribute' :)
      let $state := p:consume(79, $input, $state)           (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:consume(89, $input, $state)           (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'document-node' :)
      let $state := p:consume(104, $input, $state)          (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:consume(105, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty-sequence' :)
      let $state := p:consume(108, $input, $state)          (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'function' :)
      let $state := p:consume(119, $input, $state)          (: 'function' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'if' :)
      let $state := p:consume(126, $input, $state)          (: 'if' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'item' :)
      let $state := p:consume(134, $input, $state)          (: 'item' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'map' :)
      let $state := p:consume(140, $input, $state)          (: 'map' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'namespace-node' :)
      let $state := p:consume(145, $input, $state)          (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'node' :)
      let $state := p:consume(150, $input, $state)          (: 'node' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:consume(166, $input, $state)          (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'schema-attribute' :)
      let $state := p:consume(170, $input, $state)          (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-element' :)
      let $state := p:consume(171, $input, $state)          (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 179) then                      (: 'switch' :)
      let $state := p:consume(179, $input, $state)          (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 180) then                      (: 'text' :)
      let $state := p:consume(180, $input, $state)          (: 'text' :)
      return $state
    else if ($state[$p:l1] = 187) then                      (: 'typeswitch' :)
      let $state := p:consume(187, $input, $state)          (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "QName", $count, $begin, $end)
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1(170, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 5) then                        (: URIQualifiedName :)
      let $state := p:consume(5, $input, $state)            (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EQName", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(133, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'exponent-separator' | 'grouping-separator' |
                                                               'infinity' | 'minus-sign' | 'pattern-separator' |
                                                               'per-mille' | 'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 51) then                          (: ';' :)
        $state
      else
        let $state := p:whitespace($input, $state)
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(29, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:consume(59, $input, $state)         (: '=' :)
        let $state := p:lookahead1W(17, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:consume(4, $input, $state)          (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: 'decimal-format' :)
      let $state := p:consume(94, $input, $state)           (: 'decimal-format' :)
      let $state := p:lookahead1W(172, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:consume(94, $input, $state)           (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DecimalFormatDecl", $count, $begin, $end)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 130) then                      (: 'inherit' :)
      let $state := p:consume(130, $input, $state)          (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(148, $input, $state)          (: 'no-inherit' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "InheritMode", $count, $begin, $end)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'preserve' :)
      let $state := p:consume(164, $input, $state)          (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(149, $input, $state)          (: 'no-preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "PreserveMode", $count, $begin, $end)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:consume(92, $input, $state)               (: 'copy-namespaces' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:consume(39, $input, $state)               (: ',' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-InheritMode($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "CopyNamespacesDecl", $count, $begin, $end)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:consume(155, $input, $state)              (: 'order' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:consume(107, $input, $state)              (: 'empty' :)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 121) then                      (: 'greatest' :)
      let $state := p:consume(121, $input, $state)          (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(137, $input, $state)          (: 'least' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "EmptyOrderDecl", $count, $begin, $end)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:consume(157, $input, $state)              (: 'ordering' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 156) then                      (: 'ordered' :)
      let $state := p:consume(156, $input, $state)          (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(189, $input, $state)          (: 'unordered' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "OrderingModeDecl", $count, $begin, $end)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:consume(90, $input, $state)               (: 'construction' :)
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 178) then                      (: 'strip' :)
      let $state := p:consume(178, $input, $state)          (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(164, $input, $state)          (: 'preserve' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "ConstructionDecl", $count, $begin, $end)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:consume(80, $input, $state)               (: 'base-uri' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "BaseURIDecl", $count, $begin, $end)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:consume(88, $input, $state)               (: 'collation' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultCollationDecl", $count, $begin, $end)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(32, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:consume(81, $input, $state)               (: 'boundary-space' :)
  let $state := p:lookahead1W(94, $input, $state)           (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'preserve' :)
      let $state := p:consume(164, $input, $state)          (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(178, $input, $state)          (: 'strip' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "BoundarySpaceDecl", $count, $begin, $end)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 96) then                           (: 'declare' :)
      let $state := p:lookahead2W(124, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' :)
      let $state :=
        if ($state[$p:lk] eq 24928) then                    (: 'declare' 'default' :)
          let $state := p:lookahead3W(109, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 20832) then                    (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5792096) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 20576) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23136) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 40288) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10183008) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23648) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Setter", $count, $begin, $end)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(96, $input, $state)               (: 'declare' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:consume(97, $input, $state)               (: 'default' :)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:consume(105, $input, $state)          (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(119, $input, $state)          (: 'function' :)
      return $state
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(144, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "DefaultNamespaceDecl", $count, $begin, $end)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(188, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 96) then                         (: 'declare' :)
        let $state := p:lookahead2W(146, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'base-uri' |
                                                               'boundary-space' | 'cast' | 'castable' | 'construction' |
                                                               'context' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'div' | 'eq' | 'except' | 'function' | 'ge' |
                                                               'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'lt' | 'mod' | 'namespace' | 'ne' | 'option' | 'or' |
                                                               'ordering' | 'to' | 'treat' | 'union' | 'variable' |
                                                               '|' | '||' :)
        return $state
      else if ($state[$p:l1] eq 127) then                   (: 'import' :)
        let $state := p:lookahead2W(143, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'schema' | 'to' | 'treat' |
                                                               'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 20576                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 20832                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 23136                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 23648                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 24160                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 24928                            (: 'declare' 'default' :)
      and $state[$p:lk] != 36735                            (: 'import' 'module' :)
      and $state[$p:lk] != 36960                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 40288                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 43391) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 96) then                     (: 'declare' :)
            let $state := p:lookahead2W(125, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] eq 24928) then              (: 'declare' 'default' :)
                let $state := p:lookahead3W(120, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 6906208                  (: 'declare' 'default' 'element' :)
                or $state[$p:lk] = 7823712) then            (: 'declare' 'default' 'function' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 36960) then              (: 'declare' 'namespace' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 127) then                (: 'import' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+)
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(188, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | EOF | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | '[' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'array' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'map' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] eq 96) then                         (: 'declare' :)
        let $state := p:lookahead2W(145, $input, $state)    (: S^WS | EOF | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'context' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                               'option' | 'or' | 'to' | 'treat' | 'union' | 'variable' |
                                                               '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 8032                             (: 'declare' '%' :)
      and $state[$p:lk] != 23392                            (: 'declare' 'context' :)
      and $state[$p:lk] != 30560                            (: 'declare' 'function' :)
      and $state[$p:lk] != 39264                            (: 'declare' 'option' :)
      and $state[$p:lk] != 48992) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] eq 96) then                     (: 'declare' :)
            let $state := p:lookahead2W(119, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 23392) then              (: 'declare' 'context' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 39264) then              (: 'declare' 'option' :)
            let $state := p:whitespace($input, $state)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:whitespace($input, $state)
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:whitespace($input, $state)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "Prolog", $count, $begin, $end)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(4, $input, $state)                (: StringLiteral :)
  let $end := $state[$p:e0]
  return p:reduce($state, "URILiteral", $count, $begin, $end)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: NCName^Token :)
      let $state := p:consume(14, $input, $state)           (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'and' :)
      let $state := p:consume(74, $input, $state)           (: 'and' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'ascending' :)
      let $state := p:consume(77, $input, $state)           (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'case' :)
      let $state := p:consume(83, $input, $state)           (: 'case' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:consume(84, $input, $state)           (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:consume(85, $input, $state)           (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:consume(88, $input, $state)           (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:consume(93, $input, $state)           (: 'count' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:consume(97, $input, $state)           (: 'default' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descending' :)
      let $state := p:consume(100, $input, $state)          (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'div' :)
      let $state := p:consume(102, $input, $state)          (: 'div' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'else' :)
      let $state := p:consume(106, $input, $state)          (: 'else' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:consume(107, $input, $state)          (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'end' :)
      let $state := p:consume(110, $input, $state)          (: 'end' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:consume(111, $input, $state)          (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'except' :)
      let $state := p:consume(113, $input, $state)          (: 'except' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'for' :)
      let $state := p:consume(118, $input, $state)          (: 'for' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'ge' :)
      let $state := p:consume(120, $input, $state)          (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:consume(122, $input, $state)          (: 'group' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:consume(124, $input, $state)          (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'idiv' :)
      let $state := p:consume(125, $input, $state)          (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:consume(131, $input, $state)          (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'intersect' :)
      let $state := p:consume(132, $input, $state)          (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:consume(133, $input, $state)          (: 'is' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:consume(136, $input, $state)          (: 'le' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:consume(138, $input, $state)          (: 'let' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:consume(139, $input, $state)          (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'mod' :)
      let $state := p:consume(142, $input, $state)          (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'ne' :)
      let $state := p:consume(146, $input, $state)          (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'only' :)
      let $state := p:consume(152, $input, $state)          (: 'only' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'or' :)
      let $state := p:consume(154, $input, $state)          (: 'or' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'order' :)
      let $state := p:consume(155, $input, $state)          (: 'order' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'return' :)
      let $state := p:consume(167, $input, $state)          (: 'return' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'satisfies' :)
      let $state := p:consume(168, $input, $state)          (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'stable' :)
      let $state := p:consume(175, $input, $state)          (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'start' :)
      let $state := p:consume(176, $input, $state)          (: 'start' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'to' :)
      let $state := p:consume(182, $input, $state)          (: 'to' :)
      return $state
    else if ($state[$p:l1] = 183) then                      (: 'treat' :)
      let $state := p:consume(183, $input, $state)          (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 188) then                      (: 'union' :)
      let $state := p:consume(188, $input, $state)          (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(194, $input, $state)          (: 'where' :)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "NCName", $count, $begin, $end)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(143, $input, $state)              (: 'module' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:consume(144, $input, $state)              (: 'namespace' :)
  let $state := p:lookahead1W(135, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:consume(59, $input, $state)               (: '=' :)
  let $state := p:lookahead1W(17, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "ModuleDecl", $count, $begin, $end)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | EOF | ('(' ':') | 'declare' | 'import' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Prolog($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "LibraryModule", $count, $begin, $end)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(51, $input, $state)               (: ';' :)
  let $end := $state[$p:e0]
  return p:reduce($state, "Separator", $count, $begin, $end)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:consume(196, $input, $state)              (: 'xquery' :)
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 109) then                      (: 'encoding' :)
      let $state := p:consume(109, $input, $state)          (: 'encoding' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:consume(192, $input, $state)          (: 'version' :)
      let $state := p:lookahead1W(17, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:consume(4, $input, $state)            (: StringLiteral :)
      let $state := p:lookahead1W(76, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 109) then                  (: 'encoding' :)
          let $state := p:consume(109, $input, $state)      (: 'encoding' :)
          let $state := p:lookahead1W(17, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:consume(4, $input, $state)        (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Separator($input, $state)
  let $end := $state[$p:e0]
  return p:reduce($state, "VersionDecl", $count, $begin, $end)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state :=
    if ($state[$p:l1] eq 196) then                          (: 'xquery' :)
      let $state := p:lookahead2W(142, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'encoding' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'to' | 'treat' | 'union' |
                                                               'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 28100                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 49348) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] eq 143) then                          (: 'module' :)
      let $state := p:lookahead2W(139, $input, $state)      (: S^WS | EOF | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                               'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'namespace' | 'ne' | 'or' | 'to' | 'treat' | 'union' |
                                                               '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 37007) then                    (: 'module' 'namespace' :)
      let $state := p:whitespace($input, $state)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:whitespace($input, $state)
      let $state := p:parse-MainModule($input, $state)
      return $state
  let $end := $state[$p:e0]
  return p:reduce($state, "Module", $count, $begin, $end)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $begin := $state[$p:e0]
  let $state := p:lookahead1W(187, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | URIQualifiedName | QName^Token | S^WS |
                                                               Wildcard | '$' | '%' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | '[' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'array' | 'ascending' | 'attribute' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'comment' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'map' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'start' |
                                                               'switch' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:whitespace($input, $state)
  let $state := p:parse-Module($input, $state)
  let $state := p:consume(24, $input, $state)               (: EOF :)
  let $end := $state[$p:e0]
  return p:reduce($state, "XQuery", $count, $begin, $end)
};

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:consume($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    where $begin ne $end
    return
      text
      {
        substring($input, $begin, $end - $begin)
      },
    let $token := $p:TOKEN[1 + $state[$p:l1]]
    let $name := if (starts-with($token, "'")) then "TOKEN" else $token
    let $begin := $state[$p:b1]
    let $end := $state[$p:e1]
    return
      element {$name}
      {
        substring($input, $begin, $end - $begin)
      }
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state. In contrast to p:consume, do not create any output.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:consumeT($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3)
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Consume whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:whitespace($input as xs:string,
                              $state as item()+) as item()+
{
  if ($state[$p:e0] = $state[$p:b1]) then
    $state
  else
    let $begin := $state[$p:e0]
    let $end := $state[$p:b1]
    return
    (
      0,
      $state[$p:b0],
      $end,
      subsequence($state, $p:e0 + 1),
      text
      {
        substring($input, $begin, $end - $begin)
      }
    )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer)
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 17) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: ('(' ':') :)
      let $state := p:try-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack, creating a nonterminal element. Pop
 : $count elements off the stack, wrap them in a new element
 : named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @param $begin the input index where the nonterminal begins.
 : @param $end the input index where the nonterminal ends.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer, $begin as xs:integer, $end as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
